/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct sqlite3 ;
typedef struct sqlite3 sqlite3;
typedef long long sqlite_int64;
typedef unsigned long long sqlite_uint64;
struct sqlite3_file ;
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_io_methods ;
struct sqlite3_file {
   struct sqlite3_io_methods  const  *pMethods ;
};
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
   int iVersion ;
   int (*xClose)(sqlite3_file * ) ;
   int (*xRead)(sqlite3_file * , void * , int iAmt , sqlite_int64 iOfst ) ;
   int (*xWrite)(sqlite3_file * , void const   * , int iAmt , sqlite_int64 iOfst ) ;
   int (*xTruncate)(sqlite3_file * , sqlite_int64 size ) ;
   int (*xSync)(sqlite3_file * , int flags ) ;
   int (*xFileSize)(sqlite3_file * , sqlite_int64 *pSize ) ;
   int (*xLock)(sqlite3_file * , int  ) ;
   int (*xUnlock)(sqlite3_file * , int  ) ;
   int (*xCheckReservedLock)(sqlite3_file * , int *pResOut ) ;
   int (*xFileControl)(sqlite3_file * , int op , void *pArg ) ;
   int (*xSectorSize)(sqlite3_file * ) ;
   int (*xDeviceCharacteristics)(sqlite3_file * ) ;
   int (*xShmMap)(sqlite3_file * , int iPg , int pgsz , int  , void volatile   ** ) ;
   int (*xShmLock)(sqlite3_file * , int offset , int n , int flags ) ;
   void (*xShmBarrier)(sqlite3_file * ) ;
   int (*xShmUnmap)(sqlite3_file * , int deleteFlag ) ;
   int (*xFetch)(sqlite3_file * , sqlite_int64 iOfst , int iAmt , void **pp ) ;
   int (*xUnfetch)(sqlite3_file * , sqlite_int64 iOfst , void *p ) ;
};
struct sqlite3_mutex ;
typedef struct sqlite3_mutex sqlite3_mutex;
struct sqlite3_api_routines ;
typedef struct sqlite3_api_routines sqlite3_api_routines;
struct sqlite3_vfs ;
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs {
   int iVersion ;
   int szOsFile ;
   int mxPathname ;
   sqlite3_vfs *pNext ;
   char const   *zName ;
   void *pAppData ;
   int (*xOpen)(sqlite3_vfs * , char const   *zName , sqlite3_file * , int flags ,
                int *pOutFlags ) ;
   int (*xDelete)(sqlite3_vfs * , char const   *zName , int syncDir ) ;
   int (*xAccess)(sqlite3_vfs * , char const   *zName , int flags , int *pResOut ) ;
   int (*xFullPathname)(sqlite3_vfs * , char const   *zName , int nOut , char *zOut ) ;
   void *(*xDlOpen)(sqlite3_vfs * , char const   *zFilename ) ;
   void (*xDlError)(sqlite3_vfs * , int nByte , char *zErrMsg ) ;
   void (*(*xDlSym)(sqlite3_vfs * , void * , char const   *zSymbol ))(void) ;
   void (*xDlClose)(sqlite3_vfs * , void * ) ;
   int (*xRandomness)(sqlite3_vfs * , int nByte , char *zOut ) ;
   int (*xSleep)(sqlite3_vfs * , int microseconds ) ;
   int (*xCurrentTime)(sqlite3_vfs * , double * ) ;
   int (*xGetLastError)(sqlite3_vfs * , int  , char * ) ;
   int (*xCurrentTimeInt64)(sqlite3_vfs * , sqlite_int64 * ) ;
   int (*xSetSystemCall)(sqlite3_vfs * , char const   *zName , void (*)(void) ) ;
   sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs * , char const   *zName ) ;
   char const   *(*xNextSystemCall)(sqlite3_vfs * , char const   *zName ) ;
};
struct sqlite3_mem_methods ;
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
   void *(*xMalloc)(int  ) ;
   void (*xFree)(void * ) ;
   void *(*xRealloc)(void * , int  ) ;
   int (*xSize)(void * ) ;
   int (*xRoundup)(int  ) ;
   int (*xInit)(void * ) ;
   void (*xShutdown)(void * ) ;
   void *pAppData ;
};
struct sqlite3_stmt ;
typedef struct sqlite3_stmt sqlite3_stmt;
struct sqlite3_value ;
typedef struct sqlite3_value sqlite3_value;
struct sqlite3_context ;
typedef struct sqlite3_context sqlite3_context;
struct sqlite3_vtab ;
typedef struct sqlite3_vtab sqlite3_vtab;
struct sqlite3_index_info ;
typedef struct sqlite3_index_info sqlite3_index_info;
struct sqlite3_vtab_cursor ;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
struct sqlite3_module ;
typedef struct sqlite3_module sqlite3_module;
struct sqlite3_module {
   int iVersion ;
   int (*xCreate)(sqlite3 * , void *pAux , int argc , char const   * const  *argv ,
                  sqlite3_vtab **ppVTab , char ** ) ;
   int (*xConnect)(sqlite3 * , void *pAux , int argc , char const   * const  *argv ,
                   sqlite3_vtab **ppVTab , char ** ) ;
   int (*xBestIndex)(sqlite3_vtab *pVTab , sqlite3_index_info * ) ;
   int (*xDisconnect)(sqlite3_vtab *pVTab ) ;
   int (*xDestroy)(sqlite3_vtab *pVTab ) ;
   int (*xOpen)(sqlite3_vtab *pVTab , sqlite3_vtab_cursor **ppCursor ) ;
   int (*xClose)(sqlite3_vtab_cursor * ) ;
   int (*xFilter)(sqlite3_vtab_cursor * , int idxNum , char const   *idxStr , int argc ,
                  sqlite3_value **argv ) ;
   int (*xNext)(sqlite3_vtab_cursor * ) ;
   int (*xEof)(sqlite3_vtab_cursor * ) ;
   int (*xColumn)(sqlite3_vtab_cursor * , sqlite3_context * , int  ) ;
   int (*xRowid)(sqlite3_vtab_cursor * , sqlite_int64 *pRowid ) ;
   int (*xUpdate)(sqlite3_vtab * , int  , sqlite3_value ** , sqlite_int64 * ) ;
   int (*xBegin)(sqlite3_vtab *pVTab ) ;
   int (*xSync)(sqlite3_vtab *pVTab ) ;
   int (*xCommit)(sqlite3_vtab *pVTab ) ;
   int (*xRollback)(sqlite3_vtab *pVTab ) ;
   int (*xFindFunction)(sqlite3_vtab *pVtab , int nArg , char const   *zName , void (**pxFunc)(sqlite3_context * ,
                                                                                               int  ,
                                                                                               sqlite3_value ** ) ,
                        void **ppArg ) ;
   int (*xRename)(sqlite3_vtab *pVtab , char const   *zNew ) ;
   int (*xSavepoint)(sqlite3_vtab *pVTab , int  ) ;
   int (*xRelease)(sqlite3_vtab *pVTab , int  ) ;
   int (*xRollbackTo)(sqlite3_vtab *pVTab , int  ) ;
   int (*xShadowName)(char const   * ) ;
};
struct sqlite3_index_constraint {
   int iColumn ;
   unsigned char op ;
   unsigned char usable ;
   int iTermOffset ;
};
struct sqlite3_index_orderby {
   int iColumn ;
   unsigned char desc ;
};
struct sqlite3_index_constraint_usage {
   int argvIndex ;
   unsigned char omit ;
};
struct sqlite3_index_info {
   int nConstraint ;
   struct sqlite3_index_constraint *aConstraint ;
   int nOrderBy ;
   struct sqlite3_index_orderby *aOrderBy ;
   struct sqlite3_index_constraint_usage *aConstraintUsage ;
   int idxNum ;
   char *idxStr ;
   int needToFreeIdxStr ;
   int orderByConsumed ;
   double estimatedCost ;
   sqlite_int64 estimatedRows ;
   int idxFlags ;
   sqlite_uint64 colUsed ;
};
struct sqlite3_vtab {
   sqlite3_module const   *pModule ;
   int nRef ;
   char *zErrMsg ;
};
struct sqlite3_vtab_cursor {
   sqlite3_vtab *pVtab ;
};
struct sqlite3_blob ;
typedef struct sqlite3_blob sqlite3_blob;
struct sqlite3_mutex_methods ;
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
   int (*xMutexInit)(void) ;
   int (*xMutexEnd)(void) ;
   sqlite3_mutex *(*xMutexAlloc)(int  ) ;
   void (*xMutexFree)(sqlite3_mutex * ) ;
   void (*xMutexEnter)(sqlite3_mutex * ) ;
   int (*xMutexTry)(sqlite3_mutex * ) ;
   void (*xMutexLeave)(sqlite3_mutex * ) ;
   int (*xMutexHeld)(sqlite3_mutex * ) ;
   int (*xMutexNotheld)(sqlite3_mutex * ) ;
};
struct sqlite3_str ;
typedef struct sqlite3_str sqlite3_str;
struct sqlite3_pcache ;
typedef struct sqlite3_pcache sqlite3_pcache;
struct sqlite3_pcache_page ;
typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
   void *pBuf ;
   void *pExtra ;
};
struct sqlite3_pcache_methods2 ;
typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
   int iVersion ;
   void *pArg ;
   int (*xInit)(void * ) ;
   void (*xShutdown)(void * ) ;
   sqlite3_pcache *(*xCreate)(int szPage , int szExtra , int bPurgeable ) ;
   void (*xCachesize)(sqlite3_pcache * , int nCachesize ) ;
   int (*xPagecount)(sqlite3_pcache * ) ;
   sqlite3_pcache_page *(*xFetch)(sqlite3_pcache * , unsigned int key , int createFlag ) ;
   void (*xUnpin)(sqlite3_pcache * , sqlite3_pcache_page * , int discard ) ;
   void (*xRekey)(sqlite3_pcache * , sqlite3_pcache_page * , unsigned int oldKey ,
                  unsigned int newKey ) ;
   void (*xTruncate)(sqlite3_pcache * , unsigned int iLimit ) ;
   void (*xDestroy)(sqlite3_pcache * ) ;
   void (*xShrink)(sqlite3_pcache * ) ;
};
struct sqlite3_backup ;
typedef struct sqlite3_backup sqlite3_backup;
struct Hash ;
typedef struct Hash Hash;
struct HashElem ;
typedef struct HashElem HashElem;
struct _ht {
   unsigned int count ;
   HashElem *chain ;
};
struct Hash {
   unsigned int htsize ;
   unsigned int count ;
   HashElem *first ;
   struct _ht *ht ;
};
struct HashElem {
   HashElem *next ;
   HashElem *prev ;
   void *data ;
   char const   *pKey ;
};
typedef unsigned long size_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __off64_t off_t;
typedef __ssize_t ssize_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __uid_t uid_t;
typedef __pid_t pid_t;
typedef __time_t time_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef sqlite_int64 i64;
typedef sqlite_uint64 u64;
typedef unsigned int u32;
typedef unsigned short u16;
typedef short i16;
typedef unsigned char u8;
typedef signed char i8;
typedef u32 tRowcnt;
typedef short LogEst;
typedef u64 uptr;
struct BusyHandler ;
typedef struct BusyHandler BusyHandler;
struct BusyHandler {
   int (*xBusyHandler)(void * , int  ) ;
   void *pBusyArg ;
   int nBusy ;
   u8 bExtraFileArg ;
};
struct AggInfo ;
typedef struct AggInfo AggInfo;
struct AuthContext ;
typedef struct AuthContext AuthContext;
struct AutoincInfo ;
typedef struct AutoincInfo AutoincInfo;
struct Bitvec ;
typedef struct Bitvec Bitvec;
struct CollSeq ;
typedef struct CollSeq CollSeq;
struct Column ;
typedef struct Column Column;
struct Db ;
typedef struct Db Db;
struct Schema ;
typedef struct Schema Schema;
struct Expr ;
typedef struct Expr Expr;
struct ExprList ;
typedef struct ExprList ExprList;
struct FKey ;
typedef struct FKey FKey;
struct FuncDestructor ;
typedef struct FuncDestructor FuncDestructor;
struct FuncDef ;
typedef struct FuncDef FuncDef;
struct FuncDefHash ;
typedef struct FuncDefHash FuncDefHash;
struct IdList ;
typedef struct IdList IdList;
struct Index ;
typedef struct Index Index;
struct KeyInfo ;
typedef struct KeyInfo KeyInfo;
struct Lookaside ;
typedef struct Lookaside Lookaside;
struct LookasideSlot ;
typedef struct LookasideSlot LookasideSlot;
struct Module ;
typedef struct Module Module;
struct NameContext ;
typedef struct NameContext NameContext;
struct Parse ;
typedef struct Parse Parse;
struct PrintfArguments ;
typedef struct PrintfArguments PrintfArguments;
struct RenameToken ;
typedef struct RenameToken RenameToken;
struct RowSet ;
typedef struct RowSet RowSet;
struct Savepoint ;
typedef struct Savepoint Savepoint;
struct Select ;
typedef struct Select Select;
struct SQLiteThread ;
typedef struct SQLiteThread SQLiteThread;
struct SelectDest ;
typedef struct SelectDest SelectDest;
struct SrcList ;
typedef struct SrcList SrcList;
typedef struct sqlite3_str StrAccum;
struct Table ;
typedef struct Table Table;
struct TableLock ;
typedef struct TableLock TableLock;
struct Token ;
typedef struct Token Token;
struct Trigger ;
typedef struct Trigger Trigger;
struct TriggerPrg ;
typedef struct TriggerPrg TriggerPrg;
struct TriggerStep ;
typedef struct TriggerStep TriggerStep;
struct UnpackedRecord ;
typedef struct UnpackedRecord UnpackedRecord;
struct Upsert ;
typedef struct Upsert Upsert;
struct VTable ;
typedef struct VTable VTable;
struct VtabCtx ;
typedef struct VtabCtx VtabCtx;
struct Walker ;
typedef struct Walker Walker;
struct WhereInfo ;
typedef struct WhereInfo WhereInfo;
struct Window ;
typedef struct Window Window;
struct With ;
typedef struct With With;
typedef u64 Bitmask;
typedef int VList;
struct Btree ;
typedef struct Btree Btree;
struct BtCursor ;
typedef struct BtCursor BtCursor;
struct BtShared ;
typedef struct BtShared BtShared;
struct BtreePayload ;
typedef struct BtreePayload BtreePayload;
struct BtreePayload {
   void const   *pKey ;
   sqlite_int64 nKey ;
   void const   *pData ;
   sqlite3_value *aMem ;
   u16 nMem ;
   int nData ;
   int nZero ;
};
struct Pager ;
struct Vdbe ;
typedef struct Vdbe Vdbe;
typedef struct sqlite3_value Mem;
struct SubProgram ;
typedef struct SubProgram SubProgram;
union p4union {
   int i ;
   void *p ;
   char *z ;
   i64 *pI64 ;
   double *pReal ;
   FuncDef *pFunc ;
   sqlite3_context *pCtx ;
   CollSeq *pColl ;
   Mem *pMem ;
   VTable *pVtab ;
   KeyInfo *pKeyInfo ;
   int *ai ;
   SubProgram *pProgram ;
   Table *pTab ;
   int (*xAdvance)(BtCursor * , int  ) ;
};
struct VdbeOp {
   u8 opcode ;
   signed char p4type ;
   u16 p5 ;
   int p1 ;
   int p2 ;
   int p3 ;
   union p4union p4 ;
};
typedef struct VdbeOp VdbeOp;
struct SubProgram {
   VdbeOp *aOp ;
   int nOp ;
   int nMem ;
   int nCsr ;
   u8 *aOnce ;
   void *token ;
   SubProgram *pNext ;
};
struct VdbeOpList {
   u8 opcode ;
   signed char p1 ;
   signed char p2 ;
   signed char p3 ;
};
typedef struct VdbeOpList VdbeOpList;
typedef int (*RecordCompare)(int  , void const   * , UnpackedRecord * );
typedef u32 Pgno;
typedef struct Pager Pager;
struct PgHdr ;
typedef struct PgHdr DbPage;
typedef struct PgHdr PgHdr;
struct PCache ;
typedef struct PCache PCache;
struct PgHdr {
   sqlite3_pcache_page *pPage ;
   void *pData ;
   void *pExtra ;
   PCache *pCache ;
   PgHdr *pDirty ;
   Pager *pPager ;
   Pgno pgno ;
   u16 flags ;
   i16 nRef ;
   PgHdr *pDirtyNext ;
   PgHdr *pDirtyPrev ;
};
struct Db {
   char *zDbSName ;
   Btree *pBt ;
   u8 safety_level ;
   u8 bSyncSet ;
   Schema *pSchema ;
};
struct Schema {
   int schema_cookie ;
   int iGeneration ;
   Hash tblHash ;
   Hash idxHash ;
   Hash trigHash ;
   Hash fkeyHash ;
   Table *pSeqTab ;
   u8 file_format ;
   u8 enc ;
   u16 schemaFlags ;
   int cache_size ;
};
struct Lookaside {
   u32 bDisable ;
   u16 sz ;
   u8 bMalloced ;
   u32 nSlot ;
   u32 anStat[3] ;
   LookasideSlot *pInit ;
   LookasideSlot *pFree ;
   void *pStart ;
   void *pEnd ;
};
struct LookasideSlot {
   LookasideSlot *pNext ;
};
struct FuncDefHash {
   FuncDef *a[23] ;
};
struct sqlite3InitInfo {
   int newTnum ;
   u8 iDb ;
   u8 busy ;
   unsigned int orphanTrigger : 1 ;
   unsigned int imposterTable : 1 ;
   unsigned int reopenMemdb : 1 ;
   char **azInit ;
};
union __anonunion_u1_209251945 {
   int volatile   isInterrupted ;
   double notUsed1 ;
};
struct sqlite3 {
   sqlite3_vfs *pVfs ;
   struct Vdbe *pVdbe ;
   CollSeq *pDfltColl ;
   sqlite3_mutex *mutex ;
   Db *aDb ;
   int nDb ;
   u32 mDbFlags ;
   u64 flags ;
   i64 lastRowid ;
   i64 szMmap ;
   u32 nSchemaLock ;
   unsigned int openFlags ;
   int errCode ;
   int errMask ;
   int iSysErrno ;
   u16 dbOptFlags ;
   u8 enc ;
   u8 autoCommit ;
   u8 temp_store ;
   u8 mallocFailed ;
   u8 bBenignMalloc ;
   u8 dfltLockMode ;
   signed char nextAutovac ;
   u8 suppressErr ;
   u8 vtabOnConflict ;
   u8 isTransactionSavepoint ;
   u8 mTrace ;
   u8 noSharedCache ;
   u8 nSqlExec ;
   int nextPagesize ;
   u32 magic ;
   int nChange ;
   int nTotalChange ;
   int aLimit[12] ;
   int nMaxSorterMmap ;
   struct sqlite3InitInfo init ;
   int nVdbeActive ;
   int nVdbeRead ;
   int nVdbeWrite ;
   int nVdbeExec ;
   int nVDestroy ;
   int nExtension ;
   void **aExtension ;
   int (*xTrace)(u32  , void * , void * , void * ) ;
   void *pTraceArg ;
   void (*xProfile)(void * , char const   * , u64  ) ;
   void *pProfileArg ;
   void *pCommitArg ;
   int (*xCommitCallback)(void * ) ;
   void *pRollbackArg ;
   void (*xRollbackCallback)(void * ) ;
   void *pUpdateArg ;
   void (*xUpdateCallback)(void * , int  , char const   * , char const   * , sqlite_int64  ) ;
   Parse *pParse ;
   int (*xWalCallback)(void * , sqlite3 * , char const   * , int  ) ;
   void *pWalArg ;
   void (*xCollNeeded)(void * , sqlite3 * , int eTextRep , char const   * ) ;
   void (*xCollNeeded16)(void * , sqlite3 * , int eTextRep , void const   * ) ;
   void *pCollNeededArg ;
   sqlite3_value *pErr ;
   union __anonunion_u1_209251945 u1 ;
   Lookaside lookaside ;
   int (*xAuth)(void * , int  , char const   * , char const   * , char const   * ,
                char const   * ) ;
   void *pAuthArg ;
   int (*xProgress)(void * ) ;
   void *pProgressArg ;
   unsigned int nProgressOps ;
   int nVTrans ;
   Hash aModule ;
   VtabCtx *pVtabCtx ;
   VTable **aVTrans ;
   VTable *pDisconnect ;
   Hash aFunc ;
   Hash aCollSeq ;
   BusyHandler busyHandler ;
   Db aDbStatic[2] ;
   Savepoint *pSavepoint ;
   int busyTimeout ;
   int nSavepoint ;
   int nStatement ;
   i64 nDeferredCons ;
   i64 nDeferredImmCons ;
   int *pnBytesFreed ;
};
union __anonunion_u_1053798503 {
   FuncDef *pHash ;
   FuncDestructor *pDestructor ;
};
struct FuncDef {
   i8 nArg ;
   u32 funcFlags ;
   void *pUserData ;
   FuncDef *pNext ;
   void (*xSFunc)(sqlite3_context * , int  , sqlite3_value ** ) ;
   void (*xFinalize)(sqlite3_context * ) ;
   void (*xValue)(sqlite3_context * ) ;
   void (*xInverse)(sqlite3_context * , int  , sqlite3_value ** ) ;
   char const   *zName ;
   union __anonunion_u_1053798503 u ;
};
struct FuncDestructor {
   int nRef ;
   void (*xDestroy)(void * ) ;
   void *pUserData ;
};
struct Savepoint {
   char *zName ;
   i64 nDeferredCons ;
   i64 nDeferredImmCons ;
   Savepoint *pNext ;
};
struct Module {
   sqlite3_module const   *pModule ;
   char const   *zName ;
   int nRefModule ;
   void *pAux ;
   void (*xDestroy)(void * ) ;
   Table *pEpoTab ;
};
struct Column {
   char *zName ;
   Expr *pDflt ;
   char *zColl ;
   u8 notNull ;
   char affinity ;
   u8 szEst ;
   u8 colFlags ;
};
struct CollSeq {
   char *zName ;
   u8 enc ;
   void *pUser ;
   int (*xCmp)(void * , int  , void const   * , int  , void const   * ) ;
   void (*xDel)(void * ) ;
};
struct VTable {
   sqlite3 *db ;
   Module *pMod ;
   sqlite3_vtab *pVtab ;
   int nRef ;
   u8 bConstraint ;
   int iSavepoint ;
   VTable *pNext ;
};
struct Table {
   char *zName ;
   Column *aCol ;
   Index *pIndex ;
   Select *pSelect ;
   FKey *pFKey ;
   char *zColAff ;
   ExprList *pCheck ;
   int tnum ;
   u32 nTabRef ;
   u32 tabFlags ;
   i16 iPKey ;
   i16 nCol ;
   LogEst nRowLogEst ;
   LogEst szTabRow ;
   u8 keyConf ;
   int addColOffset ;
   int nModuleArg ;
   char **azModuleArg ;
   VTable *pVTable ;
   Trigger *pTrigger ;
   Schema *pSchema ;
   Table *pNextZombie ;
};
struct sColMap {
   int iFrom ;
   char *zCol ;
};
struct FKey {
   Table *pFrom ;
   FKey *pNextFrom ;
   char *zTo ;
   FKey *pNextTo ;
   FKey *pPrevTo ;
   int nCol ;
   u8 isDeferred ;
   u8 aAction[2] ;
   Trigger *apTrigger[2] ;
   struct sColMap aCol[1] ;
};
struct KeyInfo {
   u32 nRef ;
   u8 enc ;
   u16 nKeyField ;
   u16 nAllField ;
   sqlite3 *db ;
   u8 *aSortFlags ;
   CollSeq *aColl[1] ;
};
struct UnpackedRecord {
   KeyInfo *pKeyInfo ;
   Mem *aMem ;
   u16 nField ;
   i8 default_rc ;
   u8 errCode ;
   i8 r1 ;
   i8 r2 ;
   u8 eqSeen ;
};
struct Index {
   char *zName ;
   i16 *aiColumn ;
   LogEst *aiRowLogEst ;
   Table *pTable ;
   char *zColAff ;
   Index *pNext ;
   Schema *pSchema ;
   u8 *aSortOrder ;
   char const   **azColl ;
   Expr *pPartIdxWhere ;
   ExprList *aColExpr ;
   int tnum ;
   LogEst szIdxRow ;
   u16 nKeyCol ;
   u16 nColumn ;
   u8 onError ;
   unsigned int idxType : 2 ;
   unsigned int bUnordered : 1 ;
   unsigned int uniqNotNull : 1 ;
   unsigned int isResized : 1 ;
   unsigned int isCovering : 1 ;
   unsigned int noSkipScan : 1 ;
   unsigned int hasStat1 : 1 ;
   unsigned int bNoQuery : 1 ;
   unsigned int bAscKeyBug : 1 ;
   Bitmask colNotIdxed ;
};
struct Token {
   char const   *z ;
   unsigned int n ;
};
struct AggInfo_col {
   Table *pTab ;
   int iTable ;
   int iColumn ;
   int iSorterColumn ;
   int iMem ;
   Expr *pExpr ;
};
struct AggInfo_func {
   Expr *pExpr ;
   FuncDef *pFunc ;
   int iMem ;
   int iDistinct ;
};
struct AggInfo {
   u8 directMode ;
   u8 useSortingIdx ;
   int sortingIdx ;
   int sortingIdxPTab ;
   int nSortingColumn ;
   int mnReg ;
   int mxReg ;
   ExprList *pGroupBy ;
   struct AggInfo_col *aCol ;
   int nColumn ;
   int nAccumulator ;
   struct AggInfo_func *aFunc ;
   int nFunc ;
};
typedef i16 ynVar;
union __anonunion_u_1053798504 {
   char *zToken ;
   int iValue ;
};
union __anonunion_x_259970514 {
   ExprList *pList ;
   Select *pSelect ;
};
struct __anonstruct_sub_1053798505 {
   int iAddr ;
   int regReturn ;
};
union __anonunion_y_184733418 {
   Table *pTab ;
   Window *pWin ;
   struct __anonstruct_sub_1053798505 sub ;
};
struct Expr {
   u8 op ;
   char affExpr ;
   u32 flags ;
   union __anonunion_u_1053798504 u ;
   Expr *pLeft ;
   Expr *pRight ;
   union __anonunion_x_259970514 x ;
   int nHeight ;
   int iTable ;
   ynVar iColumn ;
   i16 iAgg ;
   i16 iRightJoinTable ;
   u8 op2 ;
   AggInfo *pAggInfo ;
   union __anonunion_y_184733418 y ;
};
struct __anonstruct_x_470887219 {
   u16 iOrderByCol ;
   u16 iAlias ;
};
union __anonunion_u_993225778 {
   struct __anonstruct_x_470887219 x ;
   int iConstExprReg ;
};
struct ExprList_item {
   Expr *pExpr ;
   char *zName ;
   char *zSpan ;
   u8 sortFlags ;
   unsigned int done : 1 ;
   unsigned int bSpanIsTab : 1 ;
   unsigned int reusable : 1 ;
   unsigned int bSorterRef : 1 ;
   unsigned int bNulls : 1 ;
   union __anonunion_u_993225778 u ;
};
struct ExprList {
   int nExpr ;
   struct ExprList_item a[1] ;
};
struct IdList_item {
   char *zName ;
   int idx ;
};
struct IdList {
   struct IdList_item *a ;
   int nId ;
};
struct __anonstruct_fg_923713511 {
   u8 jointype ;
   unsigned int notIndexed : 1 ;
   unsigned int isIndexedBy : 1 ;
   unsigned int isTabFunc : 1 ;
   unsigned int isCorrelated : 1 ;
   unsigned int viaCoroutine : 1 ;
   unsigned int isRecursive : 1 ;
};
union __anonunion_u1_549475948 {
   char *zIndexedBy ;
   ExprList *pFuncArg ;
};
struct SrcList_item {
   Schema *pSchema ;
   char *zDatabase ;
   char *zName ;
   char *zAlias ;
   Table *pTab ;
   Select *pSelect ;
   int addrFillSub ;
   int regReturn ;
   int regResult ;
   struct __anonstruct_fg_923713511 fg ;
   int iCursor ;
   Expr *pOn ;
   IdList *pUsing ;
   Bitmask colUsed ;
   union __anonunion_u1_549475948 u1 ;
   Index *pIBIndex ;
};
struct SrcList {
   int nSrc ;
   u32 nAlloc ;
   struct SrcList_item a[1] ;
};
union __anonunion_uNC_93670597 {
   ExprList *pEList ;
   AggInfo *pAggInfo ;
   Upsert *pUpsert ;
};
struct NameContext {
   Parse *pParse ;
   SrcList *pSrcList ;
   union __anonunion_uNC_93670597 uNC ;
   NameContext *pNext ;
   int nRef ;
   int nErr ;
   int ncFlags ;
   Select *pWinSelect ;
};
struct Upsert {
   ExprList *pUpsertTarget ;
   Expr *pUpsertTargetWhere ;
   ExprList *pUpsertSet ;
   Expr *pUpsertWhere ;
   Index *pUpsertIdx ;
   SrcList *pUpsertSrc ;
   int regData ;
   int iDataCur ;
   int iIdxCur ;
};
struct Select {
   ExprList *pEList ;
   u8 op ;
   LogEst nSelectRow ;
   u32 selFlags ;
   int iLimit ;
   int iOffset ;
   u32 selId ;
   int addrOpenEphm[2] ;
   SrcList *pSrc ;
   Expr *pWhere ;
   ExprList *pGroupBy ;
   Expr *pHaving ;
   ExprList *pOrderBy ;
   Select *pPrior ;
   Select *pNext ;
   Expr *pLimit ;
   With *pWith ;
   Window *pWin ;
   Window *pWinDefn ;
};
struct SelectDest {
   u8 eDest ;
   int iSDParm ;
   int iSdst ;
   int nSdst ;
   char *zAffSdst ;
   ExprList *pOrderBy ;
};
struct AutoincInfo {
   AutoincInfo *pNext ;
   Table *pTab ;
   int iDb ;
   int regCtr ;
};
struct TriggerPrg {
   Trigger *pTrigger ;
   TriggerPrg *pNext ;
   SubProgram *pProgram ;
   int orconf ;
   u32 aColmask[2] ;
};
typedef unsigned int yDbMask;
struct Parse {
   sqlite3 *db ;
   char *zErrMsg ;
   Vdbe *pVdbe ;
   int rc ;
   u8 colNamesSet ;
   u8 checkSchema ;
   u8 nested ;
   u8 nTempReg ;
   u8 isMultiWrite ;
   u8 mayAbort ;
   u8 hasCompound ;
   u8 okConstFactor ;
   u8 disableLookaside ;
   u8 disableVtab ;
   int nRangeReg ;
   int iRangeReg ;
   int nErr ;
   int nTab ;
   int nMem ;
   int szOpAlloc ;
   int iSelfTab ;
   int nLabel ;
   int nLabelAlloc ;
   int *aLabel ;
   ExprList *pConstExpr ;
   Token constraintName ;
   yDbMask writeMask ;
   yDbMask cookieMask ;
   int regRowid ;
   int regRoot ;
   int nMaxArg ;
   int nSelect ;
   int nTableLock ;
   TableLock *aTableLock ;
   AutoincInfo *pAinc ;
   Parse *pToplevel ;
   Table *pTriggerTab ;
   Parse *pParentParse ;
   int addrCrTab ;
   u32 nQueryLoop ;
   u32 oldmask ;
   u32 newmask ;
   u8 eTriggerOp ;
   u8 eOrconf ;
   u8 disableTriggers ;
   int aTempReg[8] ;
   Token sNameToken ;
   Token sLastToken ;
   ynVar nVar ;
   u8 iPkSortOrder ;
   u8 explain ;
   u8 eParseMode ;
   int nVtabLock ;
   int nHeight ;
   int addrExplain ;
   VList *pVList ;
   Vdbe *pReprepare ;
   char const   *zTail ;
   Table *pNewTable ;
   Index *pNewIndex ;
   Trigger *pNewTrigger ;
   char const   *zAuthContext ;
   Token sArg ;
   Table **apVtabLock ;
   Table *pZombieTab ;
   TriggerPrg *pTriggerPrg ;
   With *pWith ;
   With *pWithToFree ;
   RenameToken *pRename ;
};
struct AuthContext {
   char const   *zAuthContext ;
   Parse *pParse ;
};
struct Trigger {
   char *zName ;
   char *table ;
   u8 op ;
   u8 tr_tm ;
   Expr *pWhen ;
   IdList *pColumns ;
   Schema *pSchema ;
   Schema *pTabSchema ;
   TriggerStep *step_list ;
   Trigger *pNext ;
};
struct TriggerStep {
   u8 op ;
   u8 orconf ;
   Trigger *pTrig ;
   Select *pSelect ;
   char *zTarget ;
   Expr *pWhere ;
   ExprList *pExprList ;
   IdList *pIdList ;
   Upsert *pUpsert ;
   char *zSpan ;
   TriggerStep *pNext ;
   TriggerStep *pLast ;
};
struct DbFixer ;
typedef struct DbFixer DbFixer;
struct DbFixer {
   Parse *pParse ;
   Schema *pSchema ;
   int bVarOnly ;
   char const   *zDb ;
   char const   *zType ;
   Token const   *pName ;
};
struct sqlite3_str {
   sqlite3 *db ;
   char *zText ;
   u32 nAlloc ;
   u32 mxAlloc ;
   u32 nChar ;
   u8 accError ;
   u8 printfFlags ;
};
struct __anonstruct_InitData_869253526 {
   sqlite3 *db ;
   char **pzErrMsg ;
   int iDb ;
   int rc ;
   u32 mInitFlags ;
   u32 nInitRow ;
};
typedef struct __anonstruct_InitData_869253526 InitData;
struct Sqlite3Config {
   int bMemstat ;
   u8 bCoreMutex ;
   u8 bFullMutex ;
   u8 bOpenUri ;
   u8 bUseCis ;
   u8 bSmallMalloc ;
   u8 bExtraSchemaChecks ;
   int mxStrlen ;
   int neverCorrupt ;
   int szLookaside ;
   int nLookaside ;
   int nStmtSpill ;
   sqlite3_mem_methods m ;
   sqlite3_mutex_methods mutex ;
   sqlite3_pcache_methods2 pcache2 ;
   void *pHeap ;
   int nHeap ;
   int mnReq ;
   int mxReq ;
   sqlite_int64 szMmap ;
   sqlite_int64 mxMmap ;
   void *pPage ;
   int szPage ;
   int nPage ;
   int mxParserStack ;
   int sharedCacheEnabled ;
   u32 szPma ;
   int isInit ;
   int inProgress ;
   int isMutexInit ;
   int isMallocInit ;
   int isPCacheInit ;
   int nRefInitMutex ;
   sqlite3_mutex *pInitMutex ;
   void (*xLog)(void * , int  , char const   * ) ;
   void *pLogArg ;
   int (*xTestCallback)(int  ) ;
   int bLocaltimeFault ;
   int bInternalFunctions ;
   int iOnceResetThreshold ;
   u32 szSorterRef ;
   unsigned int iPrngSeed ;
};
struct SrcCount ;
struct CCurHint ;
struct IdxCover ;
struct IdxExprTrans ;
struct WindowRewrite ;
struct WhereConst ;
struct RenameCtx ;
union __anonunion_u_230722102 {
   NameContext *pNC ;
   int n ;
   int iCur ;
   SrcList *pSrcList ;
   struct SrcCount *pSrcCount ;
   struct CCurHint *pCCurHint ;
   int *aiCol ;
   struct IdxCover *pIdxCover ;
   struct IdxExprTrans *pIdxTrans ;
   ExprList *pGroupBy ;
   Select *pSelect ;
   struct WindowRewrite *pRewrite ;
   struct WhereConst *pConst ;
   struct RenameCtx *pRename ;
};
struct Walker {
   Parse *pParse ;
   int (*xExprCallback)(Walker * , Expr * ) ;
   int (*xSelectCallback)(Walker * , Select * ) ;
   void (*xSelectCallback2)(Walker * , Select * ) ;
   int walkerDepth ;
   u8 eCode ;
   union __anonunion_u_230722102 u ;
};
struct Cte {
   char *zName ;
   ExprList *pCols ;
   Select *pSelect ;
   char const   *zCteErr ;
};
struct With {
   int nCte ;
   With *pOuter ;
   struct Cte a[1] ;
};
struct Window {
   char *zName ;
   char *zBase ;
   ExprList *pPartition ;
   ExprList *pOrderBy ;
   u8 eFrmType ;
   u8 eStart ;
   u8 eEnd ;
   u8 bImplicitFrame ;
   u8 eExclude ;
   Expr *pStart ;
   Expr *pEnd ;
   Window **ppThis ;
   Window *pNextWin ;
   Expr *pFilter ;
   FuncDef *pFunc ;
   int iEphCsr ;
   int regAccum ;
   int regResult ;
   int csrApp ;
   int regApp ;
   int regPart ;
   Expr *pOwner ;
   int nBufferCol ;
   int iArgCol ;
   int regOne ;
   int regStartRowid ;
   int regEndRowid ;
   u8 bExprArgs ;
};
struct PrintfArguments {
   int nArg ;
   int nUsed ;
   sqlite3_value **apArg ;
};
typedef struct VdbeOp Op;
typedef unsigned int Bool;
struct VdbeSorter ;
typedef struct VdbeSorter VdbeSorter;
struct AuxData ;
typedef struct AuxData AuxData;
struct VdbeCursor ;
typedef struct VdbeCursor VdbeCursor;
union __anonunion_uc_41284374 {
   BtCursor *pCursor ;
   sqlite3_vtab_cursor *pVCur ;
   VdbeSorter *pSorter ;
};
struct VdbeCursor {
   u8 eCurType ;
   i8 iDb ;
   u8 nullRow ;
   u8 deferredMoveto ;
   u8 isTable ;
   Bool isEphemeral : 1 ;
   Bool useRandomRowid : 1 ;
   Bool isOrdered : 1 ;
   Bool seekHit : 1 ;
   Btree *pBtx ;
   i64 seqCount ;
   int *aAltMap ;
   u32 cacheStatus ;
   int seekResult ;
   VdbeCursor *pAltCursor ;
   union __anonunion_uc_41284374 uc ;
   KeyInfo *pKeyInfo ;
   u32 iHdrOffset ;
   Pgno pgnoRoot ;
   i16 nField ;
   u16 nHdrParsed ;
   i64 movetoTarget ;
   u32 *aOffset ;
   u8 const   *aRow ;
   u32 payloadSize ;
   u32 szRow ;
   u32 aType[1] ;
};
struct VdbeFrame ;
typedef struct VdbeFrame VdbeFrame;
struct VdbeFrame {
   Vdbe *v ;
   VdbeFrame *pParent ;
   Op *aOp ;
   i64 *anExec ;
   Mem *aMem ;
   VdbeCursor **apCsr ;
   u8 *aOnce ;
   void *token ;
   i64 lastRowid ;
   AuxData *pAuxData ;
   int nCursor ;
   int pc ;
   int nOp ;
   int nMem ;
   int nChildMem ;
   int nChildCsr ;
   int nChange ;
   int nDbChange ;
};
union MemValue {
   double r ;
   i64 i ;
   int nZero ;
   char const   *zPType ;
   FuncDef *pDef ;
};
struct sqlite3_value {
   union MemValue u ;
   u16 flags ;
   u8 enc ;
   u8 eSubtype ;
   int n ;
   char *z ;
   char *zMalloc ;
   int szMalloc ;
   u32 uTemp ;
   sqlite3 *db ;
   void (*xDel)(void * ) ;
};
struct AuxData {
   int iAuxOp ;
   int iAuxArg ;
   void *pAux ;
   void (*xDeleteAux)(void * ) ;
   AuxData *pNextAux ;
};
struct sqlite3_context {
   Mem *pOut ;
   FuncDef *pFunc ;
   Mem *pMem ;
   Vdbe *pVdbe ;
   int iOp ;
   int isError ;
   u8 skipFlag ;
   u8 argc ;
   sqlite3_value *argv[1] ;
};
typedef unsigned int bft;
struct Vdbe {
   sqlite3 *db ;
   Vdbe *pPrev ;
   Vdbe *pNext ;
   Parse *pParse ;
   ynVar nVar ;
   u32 magic ;
   int nMem ;
   int nCursor ;
   u32 cacheCtr ;
   int pc ;
   int rc ;
   int nChange ;
   int iStatement ;
   i64 iCurrentTime ;
   i64 nFkConstraint ;
   i64 nStmtDefCons ;
   i64 nStmtDefImmCons ;
   Mem *aMem ;
   Mem **apArg ;
   VdbeCursor **apCsr ;
   Mem *aVar ;
   Op *aOp ;
   int nOp ;
   int nOpAlloc ;
   Mem *aColName ;
   Mem *pResultSet ;
   char *zErrMsg ;
   VList *pVList ;
   i64 startTime ;
   u16 nResColumn ;
   u8 errorAction ;
   u8 minWriteFileFormat ;
   u8 prepFlags ;
   bft expired : 2 ;
   bft explain : 2 ;
   bft doingRerun : 1 ;
   bft changeCntOn : 1 ;
   bft runOnlyOnce : 1 ;
   bft usesStmtJournal : 1 ;
   bft readOnly : 1 ;
   bft bIsReader : 1 ;
   yDbMask btreeMask ;
   yDbMask lockMask ;
   u32 aCounter[7] ;
   char *zSql ;
   void *pFree ;
   VdbeFrame *pFrame ;
   VdbeFrame *pDelFrame ;
   int nFrame ;
   u32 expmask ;
   SubProgram *pProgram ;
   AuxData *pAuxData ;
};
typedef sqlite_int64 sqlite3StatValueType;
struct sqlite3StatType ;
struct sqlite3StatType {
   sqlite3StatValueType nowValue[10] ;
   sqlite3StatValueType mxValue[10] ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct DateTime ;
typedef struct DateTime DateTime;
struct DateTime {
   sqlite_int64 iJD ;
   int Y ;
   int M ;
   int D ;
   int h ;
   int m ;
   int tz ;
   double s ;
   char validJD ;
   char rawS ;
   char validYMD ;
   char validHMS ;
   char validTZ ;
   char tzSet ;
   char isError ;
};
struct __anonstruct_aXformType_301096214 {
   u8 eType ;
   u8 nName ;
   char *zName ;
   double rLimit ;
   double rXform ;
};
struct BenignMallocHooks ;
struct BenignMallocHooks {
   void (*xBenignBegin)(void) ;
   void (*xBenignEnd)(void) ;
};
struct Mem0Global {
   sqlite3_mutex *mutex ;
   sqlite_int64 alarmThreshold ;
   int nearlyFull ;
};
typedef unsigned char etByte;
struct et_info {
   char fmttype ;
   etByte base ;
   etByte flags ;
   etByte type ;
   etByte charset ;
   etByte prefix ;
};
typedef struct et_info et_info;
struct sqlite3PrngType {
   unsigned char isInit ;
   unsigned char i ;
   unsigned char j ;
   unsigned char s[256] ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
struct unixShm ;
typedef struct unixShm unixShm;
struct unixShmNode ;
typedef struct unixShmNode unixShmNode;
struct unixInodeInfo ;
typedef struct unixInodeInfo unixInodeInfo;
struct UnixUnusedFd ;
typedef struct UnixUnusedFd UnixUnusedFd;
struct UnixUnusedFd {
   int fd ;
   int flags ;
   UnixUnusedFd *pNext ;
};
struct unixFile ;
typedef struct unixFile unixFile;
struct unixFile {
   sqlite3_io_methods const   *pMethod ;
   sqlite3_vfs *pVfs ;
   unixInodeInfo *pInode ;
   int h ;
   unsigned char eFileLock ;
   unsigned short ctrlFlags ;
   int lastErrno ;
   void *lockingContext ;
   UnixUnusedFd *pPreallocatedUnused ;
   char const   *zPath ;
   unixShm *pShm ;
   int szChunk ;
   int nFetchOut ;
   sqlite_int64 mmapSize ;
   sqlite_int64 mmapSizeActual ;
   sqlite_int64 mmapSizeMax ;
   void *pMapRegion ;
   int sectorSize ;
   int deviceCharacteristics ;
};
struct unix_syscall {
   char const   *zName ;
   void (*pCurrent)(void) ;
   void (*pDefault)(void) ;
};
struct unixFileId {
   dev_t dev ;
   u64 ino ;
};
struct unixInodeInfo {
   struct unixFileId fileId ;
   sqlite3_mutex *pLockMutex ;
   int nShared ;
   int nLock ;
   unsigned char eFileLock ;
   unsigned char bProcessLock ;
   UnixUnusedFd *pUnused ;
   int nRef ;
   unixShmNode *pShmNode ;
   unixInodeInfo *pNext ;
   unixInodeInfo *pPrev ;
};
struct unixShmNode {
   unixInodeInfo *pInode ;
   sqlite3_mutex *pShmMutex ;
   char *zFilename ;
   int hShm ;
   int szRegion ;
   u16 nRegion ;
   u8 isReadonly ;
   u8 isUnlocked ;
   char **apRegion ;
   int nRef ;
   unixShm *pFirst ;
};
struct unixShm {
   unixShmNode *pShmNode ;
   unixShm *pNext ;
   u8 hasMutex ;
   u8 id ;
   u16 sharedMask ;
   u16 exclMask ;
};
typedef sqlite3_io_methods const   *(*finder_type)(char const   * , unixFile * );
union __anonunion_u_1058979728 {
   u8 aBitmap[(((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )] ;
   u32 aHash[(((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )] ;
   Bitvec *apSub[(((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)] ;
};
struct Bitvec {
   u32 iSize ;
   u32 nSet ;
   u32 iDivisor ;
   union __anonunion_u_1058979728 u ;
};
struct PCache {
   PgHdr *pDirty ;
   PgHdr *pDirtyTail ;
   PgHdr *pSynced ;
   int nRefSum ;
   int szCache ;
   int szSpill ;
   int szPage ;
   int szExtra ;
   u8 bPurgeable ;
   u8 eCreate ;
   int (*xStress)(void * , PgHdr * ) ;
   void *pStress ;
   sqlite3_pcache *pCache ;
};
struct PCache1 ;
typedef struct PCache1 PCache1;
struct PgHdr1 ;
typedef struct PgHdr1 PgHdr1;
struct PgFreeslot ;
typedef struct PgFreeslot PgFreeslot;
struct PGroup ;
typedef struct PGroup PGroup;
struct PgHdr1 {
   sqlite3_pcache_page page ;
   unsigned int iKey ;
   u16 isBulkLocal ;
   u16 isAnchor ;
   PgHdr1 *pNext ;
   PCache1 *pCache ;
   PgHdr1 *pLruNext ;
   PgHdr1 *pLruPrev ;
};
struct PGroup {
   sqlite3_mutex *mutex ;
   unsigned int nMaxPage ;
   unsigned int nMinPage ;
   unsigned int mxPinned ;
   unsigned int nPurgeable ;
   PgHdr1 lru ;
};
struct PCache1 {
   PGroup *pGroup ;
   unsigned int *pnPurgeable ;
   int szPage ;
   int szExtra ;
   int szAlloc ;
   int bPurgeable ;
   unsigned int nMin ;
   unsigned int nMax ;
   unsigned int n90pct ;
   unsigned int iMaxKey ;
   unsigned int nPurgeableDummy ;
   unsigned int nRecyclable ;
   unsigned int nPage ;
   unsigned int nHash ;
   PgHdr1 **apHash ;
   PgHdr1 *pFree ;
   void *pBulk ;
};
struct PgFreeslot {
   PgFreeslot *pNext ;
};
struct PCacheGlobal {
   PGroup grp ;
   int isInit ;
   int separateCache ;
   int nInitPage ;
   int szSlot ;
   int nSlot ;
   int nReserve ;
   void *pStart ;
   void *pEnd ;
   sqlite3_mutex *mutex ;
   PgFreeslot *pFree ;
   int nFreeSlot ;
   int bUnderPressure ;
};
struct RowSetEntry {
   i64 v ;
   struct RowSetEntry *pRight ;
   struct RowSetEntry *pLeft ;
};
struct RowSetChunk {
   struct RowSetChunk *pNextChunk ;
   struct RowSetEntry aEntry[1016UL / sizeof(struct RowSetEntry )] ;
};
struct RowSet {
   struct RowSetChunk *pChunk ;
   sqlite3 *db ;
   struct RowSetEntry *pEntry ;
   struct RowSetEntry *pLast ;
   struct RowSetEntry *pFresh ;
   struct RowSetEntry *pForest ;
   u16 nFresh ;
   u16 rsFlags ;
   int iBatch ;
};
struct Wal ;
typedef struct Wal Wal;
struct PagerSavepoint ;
typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint {
   i64 iOffset ;
   i64 iHdrOffset ;
   Bitvec *pInSavepoint ;
   Pgno nOrig ;
   Pgno iSubRec ;
   u32 aWalData[4] ;
};
struct Pager {
   sqlite3_vfs *pVfs ;
   u8 exclusiveMode ;
   u8 journalMode ;
   u8 useJournal ;
   u8 noSync ;
   u8 fullSync ;
   u8 extraSync ;
   u8 syncFlags ;
   u8 walSyncFlags ;
   u8 tempFile ;
   u8 noLock ;
   u8 readOnly ;
   u8 memDb ;
   u8 eState ;
   u8 eLock ;
   u8 changeCountDone ;
   u8 setMaster ;
   u8 doNotSpill ;
   u8 subjInMemory ;
   u8 bUseFetch ;
   u8 hasHeldSharedLock ;
   Pgno dbSize ;
   Pgno dbOrigSize ;
   Pgno dbFileSize ;
   Pgno dbHintSize ;
   int errCode ;
   int nRec ;
   u32 cksumInit ;
   u32 nSubRec ;
   Bitvec *pInJournal ;
   sqlite3_file *fd ;
   sqlite3_file *jfd ;
   sqlite3_file *sjfd ;
   i64 journalOff ;
   i64 journalHdr ;
   sqlite3_backup *pBackup ;
   PagerSavepoint *aSavepoint ;
   int nSavepoint ;
   u32 iDataVersion ;
   char dbFileVers[16] ;
   int nMmapOut ;
   sqlite_int64 szMmap ;
   PgHdr *pMmapFreelist ;
   u16 nExtra ;
   i16 nReserve ;
   u32 vfsFlags ;
   u32 sectorSize ;
   int pageSize ;
   Pgno mxPgno ;
   i64 journalSizeLimit ;
   char *zFilename ;
   char *zJournal ;
   int (*xBusyHandler)(void * ) ;
   void *pBusyHandlerArg ;
   int aStat[4] ;
   void (*xReiniter)(DbPage * ) ;
   int (*xGet)(Pager * , Pgno  , DbPage ** , int  ) ;
   char *pTmpSpace ;
   PCache *pPCache ;
   Wal *pWal ;
   char *zWal ;
};
struct WalIndexHdr ;
typedef struct WalIndexHdr WalIndexHdr;
struct WalIterator ;
typedef struct WalIterator WalIterator;
struct WalCkptInfo ;
typedef struct WalCkptInfo WalCkptInfo;
struct WalIndexHdr {
   u32 iVersion ;
   u32 unused ;
   u32 iChange ;
   u8 isInit ;
   u8 bigEndCksum ;
   u16 szPage ;
   u32 mxFrame ;
   u32 nPage ;
   u32 aFrameCksum[2] ;
   u32 aSalt[2] ;
   u32 aCksum[2] ;
};
struct WalCkptInfo {
   u32 nBackfill ;
   u32 aReadMark[5] ;
   u8 aLock[8] ;
   u32 nBackfillAttempted ;
   u32 notUsed0 ;
};
struct Wal {
   sqlite3_vfs *pVfs ;
   sqlite3_file *pDbFd ;
   sqlite3_file *pWalFd ;
   u32 iCallback ;
   i64 mxWalSize ;
   int nWiData ;
   int szFirstBlock ;
   u32 volatile   **apWiData ;
   u32 szPage ;
   i16 readLock ;
   u8 syncFlags ;
   u8 exclusiveMode ;
   u8 writeLock ;
   u8 ckptLock ;
   u8 readOnly ;
   u8 truncateOnCommit ;
   u8 syncHeader ;
   u8 padToSectorBoundary ;
   u8 bShmUnreliable ;
   WalIndexHdr hdr ;
   u32 minFrame ;
   u32 iReCksum ;
   char const   *zWalName ;
   u32 nCkpt ;
};
typedef u16 ht_slot;
struct WalSegment {
   int iNext ;
   ht_slot *aIndex ;
   u32 *aPgno ;
   int nEntry ;
   int iZero ;
};
struct WalIterator {
   int iPrior ;
   int nSegment ;
   struct WalSegment aSegment[1] ;
};
struct WalHashLoc ;
typedef struct WalHashLoc WalHashLoc;
struct WalHashLoc {
   ht_slot volatile   *aHash ;
   u32 volatile   *aPgno ;
   u32 iZero ;
};
struct Sublist {
   int nList ;
   ht_slot *aList ;
};
struct WalWriter {
   Wal *pWal ;
   sqlite3_file *pFd ;
   sqlite_int64 iSyncPoint ;
   int syncFlags ;
   int szPage ;
};
typedef struct WalWriter WalWriter;
struct MemPage ;
typedef struct MemPage MemPage;
struct BtLock ;
typedef struct BtLock BtLock;
struct CellInfo ;
typedef struct CellInfo CellInfo;
struct MemPage {
   u8 isInit ;
   u8 bBusy ;
   u8 intKey ;
   u8 intKeyLeaf ;
   Pgno pgno ;
   u8 leaf ;
   u8 hdrOffset ;
   u8 childPtrSize ;
   u8 max1bytePayload ;
   u8 nOverflow ;
   u16 maxLocal ;
   u16 minLocal ;
   u16 cellOffset ;
   int nFree ;
   u16 nCell ;
   u16 maskPage ;
   u16 aiOvfl[4] ;
   u8 *apOvfl[4] ;
   BtShared *pBt ;
   u8 *aData ;
   u8 *aDataEnd ;
   u8 *aCellIdx ;
   u8 *aDataOfst ;
   DbPage *pDbPage ;
   u16 (*xCellSize)(MemPage * , u8 * ) ;
   void (*xParseCell)(MemPage * , u8 * , CellInfo * ) ;
};
struct BtLock {
   Btree *pBtree ;
   Pgno iTable ;
   u8 eLock ;
   BtLock *pNext ;
};
struct Btree {
   sqlite3 *db ;
   BtShared *pBt ;
   u8 inTrans ;
   u8 sharable ;
   u8 locked ;
   u8 hasIncrblobCur ;
   int wantToLock ;
   int nBackup ;
   u32 iDataVersion ;
   Btree *pNext ;
   Btree *pPrev ;
   BtLock lock ;
};
struct BtShared {
   Pager *pPager ;
   sqlite3 *db ;
   BtCursor *pCursor ;
   MemPage *pPage1 ;
   u8 openFlags ;
   u8 autoVacuum ;
   u8 incrVacuum ;
   u8 bDoTruncate ;
   u8 inTransaction ;
   u8 max1bytePayload ;
   u16 btsFlags ;
   u16 maxLocal ;
   u16 minLocal ;
   u16 maxLeaf ;
   u16 minLeaf ;
   u32 pageSize ;
   u32 usableSize ;
   int nTransaction ;
   u32 nPage ;
   void *pSchema ;
   void (*xFreeSchema)(void * ) ;
   sqlite3_mutex *mutex ;
   Bitvec *pHasContent ;
   int nRef ;
   BtShared *pNext ;
   BtLock *pLock ;
   Btree *pWriter ;
   u8 *pTmpSpace ;
};
struct CellInfo {
   i64 nKey ;
   u8 *pPayload ;
   u32 nPayload ;
   u16 nLocal ;
   u16 nSize ;
};
struct BtCursor {
   u8 eState ;
   u8 curFlags ;
   u8 curPagerFlags ;
   u8 hints ;
   int skipNext ;
   Btree *pBtree ;
   Pgno *aOverflow ;
   void *pKey ;
   BtShared *pBt ;
   BtCursor *pNext ;
   CellInfo info ;
   i64 nKey ;
   Pgno pgnoRoot ;
   i8 iPage ;
   u8 curIntKey ;
   u16 ix ;
   u16 aiIdx[19] ;
   struct KeyInfo *pKeyInfo ;
   MemPage *pPage ;
   MemPage *apPage[19] ;
};
struct IntegrityCk ;
typedef struct IntegrityCk IntegrityCk;
struct IntegrityCk {
   BtShared *pBt ;
   Pager *pPager ;
   u8 *aPgRef ;
   Pgno nPage ;
   int mxErr ;
   int nErr ;
   int mallocFailed ;
   char const   *zPfx ;
   int v1 ;
   int v2 ;
   StrAccum errMsg ;
   u32 *heap ;
};
struct CellArray ;
typedef struct CellArray CellArray;
struct CellArray {
   int nCell ;
   MemPage *pRef ;
   u8 **apCell ;
   u16 *szCell ;
   u8 *apEnd[6] ;
   int ixNx[6] ;
};
struct sqlite3_backup {
   sqlite3 *pDestDb ;
   Btree *pDest ;
   u32 iDestSchema ;
   int bDestLocked ;
   Pgno iNext ;
   sqlite3 *pSrcDb ;
   Btree *pSrc ;
   int rc ;
   Pgno nRemaining ;
   Pgno nPagecount ;
   int isAttached ;
   sqlite3_backup *pNext ;
};
struct ValueNewStat4Ctx {
   Parse *pParse ;
   Index *pIdx ;
   UnpackedRecord **ppRec ;
   int iVal ;
};
struct ReusableSpace {
   u8 *pSpace ;
   sqlite_int64 nFree ;
   sqlite_int64 nNeeded ;
};
struct Incrblob ;
typedef struct Incrblob Incrblob;
struct Incrblob {
   int nByte ;
   int iOffset ;
   u16 iCol ;
   BtCursor *pCsr ;
   sqlite3_stmt *pStmt ;
   sqlite3 *db ;
   char *zDb ;
   Table *pTab ;
};
struct MergeEngine ;
typedef struct MergeEngine MergeEngine;
struct PmaReader ;
typedef struct PmaReader PmaReader;
struct PmaWriter ;
typedef struct PmaWriter PmaWriter;
struct SorterRecord ;
typedef struct SorterRecord SorterRecord;
struct SortSubtask ;
typedef struct SortSubtask SortSubtask;
struct SorterFile ;
typedef struct SorterFile SorterFile;
struct SorterList ;
typedef struct SorterList SorterList;
struct IncrMerger ;
typedef struct IncrMerger IncrMerger;
struct SorterFile {
   sqlite3_file *pFd ;
   i64 iEof ;
};
struct SorterList {
   SorterRecord *pList ;
   u8 *aMemory ;
   int szPMA ;
};
struct MergeEngine {
   int nTree ;
   SortSubtask *pTask ;
   int *aTree ;
   PmaReader *aReadr ;
};
typedef int (*SorterCompare)(SortSubtask * , int * , void const   * , int  , void const   * ,
                             int  );
struct SortSubtask {
   SQLiteThread *pThread ;
   int bDone ;
   VdbeSorter *pSorter ;
   UnpackedRecord *pUnpacked ;
   SorterList list ;
   int nPMA ;
   int (*xCompare)(SortSubtask * , int * , void const   * , int  , void const   * ,
                   int  ) ;
   SorterFile file ;
   SorterFile file2 ;
};
struct VdbeSorter {
   int mnPmaSize ;
   int mxPmaSize ;
   int mxKeysize ;
   int pgsz ;
   PmaReader *pReader ;
   MergeEngine *pMerger ;
   sqlite3 *db ;
   KeyInfo *pKeyInfo ;
   UnpackedRecord *pUnpacked ;
   SorterList list ;
   int iMemory ;
   int nMemory ;
   u8 bUsePMA ;
   u8 bUseThreads ;
   u8 iPrev ;
   u8 nTask ;
   u8 typeMask ;
   SortSubtask aTask[1] ;
};
struct PmaReader {
   i64 iReadOff ;
   i64 iEof ;
   int nAlloc ;
   int nKey ;
   sqlite3_file *pFd ;
   u8 *aAlloc ;
   u8 *aKey ;
   u8 *aBuffer ;
   int nBuffer ;
   u8 *aMap ;
   IncrMerger *pIncr ;
};
struct IncrMerger {
   SortSubtask *pTask ;
   MergeEngine *pMerger ;
   i64 iStartOff ;
   int mxSz ;
   int bEof ;
   int bUseThread ;
   SorterFile aFile[2] ;
};
struct PmaWriter {
   int eFWErr ;
   u8 *aBuffer ;
   int nBuffer ;
   int iBufStart ;
   int iBufEnd ;
   i64 iWriteOff ;
   sqlite3_file *pFd ;
};
union __anonunion_u_228470091 {
   SorterRecord *pNext ;
   int iNext ;
};
struct SorterRecord {
   int nVal ;
   union __anonunion_u_228470091 u ;
};
struct MemJournal ;
typedef struct MemJournal MemJournal;
struct FilePoint ;
typedef struct FilePoint FilePoint;
struct FileChunk ;
typedef struct FileChunk FileChunk;
struct FileChunk {
   FileChunk *pNext ;
   u8 zChunk[8] ;
};
struct FilePoint {
   sqlite_int64 iOffset ;
   FileChunk *pChunk ;
};
struct MemJournal {
   sqlite3_io_methods const   *pMethod ;
   int nChunkSize ;
   int nSpill ;
   int nSize ;
   FileChunk *pFirst ;
   FilePoint endpoint ;
   FilePoint readpoint ;
   int flags ;
   sqlite3_vfs *pVfs ;
   char const   *zJournal ;
};
struct IdxCover {
   Index *pIdx ;
   int iCur ;
};
struct SrcCount {
   SrcList *pSrc ;
   int nThis ;
   int nOther ;
};
struct RenameToken {
   void *p ;
   Token t ;
   RenameToken *pNext ;
};
typedef struct RenameCtx RenameCtx;
struct RenameCtx {
   RenameToken *pList ;
   int nList ;
   int iCol ;
   Table *pTab ;
   char const   *zOld ;
};
struct __anonstruct_aTable_527861670 {
   char const   *zName ;
   char const   *zCols ;
};
struct Stat4Accum ;
typedef struct Stat4Accum Stat4Accum;
struct Stat4Sample ;
typedef struct Stat4Sample Stat4Sample;
struct Stat4Sample {
   tRowcnt *anEq ;
   tRowcnt *anDLt ;
};
struct Stat4Accum {
   tRowcnt nRow ;
   tRowcnt nPSample ;
   int nCol ;
   int nKeyCol ;
   int mxSample ;
   Stat4Sample current ;
   u32 iPrn ;
   Stat4Sample *aBest ;
   int iMin ;
   int nSample ;
   int nMaxEqZero ;
   int iGet ;
   Stat4Sample *a ;
   sqlite3 *db ;
};
struct analysisInfo ;
typedef struct analysisInfo analysisInfo;
struct analysisInfo {
   sqlite3 *db ;
   char const   *zDatabase ;
};
struct TableLock {
   int iDb ;
   int iTab ;
   u8 isWriteLock ;
   char const   *zLockName ;
};
struct compareInfo {
   u8 matchAll ;
   u8 matchOne ;
   u8 matchSet ;
   u8 noCase ;
};
struct SumCtx ;
typedef struct SumCtx SumCtx;
struct SumCtx {
   double rSum ;
   i64 iSum ;
   i64 cnt ;
   u8 overflow ;
   u8 approx ;
};
struct CountCtx ;
typedef struct CountCtx CountCtx;
struct CountCtx {
   i64 n ;
};
struct sqlite3_api_routines {
   void *(*aggregate_context)(sqlite3_context * , int nBytes ) ;
   int (*aggregate_count)(sqlite3_context * ) ;
   int (*bind_blob)(sqlite3_stmt * , int  , void const   * , int n , void (*)(void * ) ) ;
   int (*bind_double)(sqlite3_stmt * , int  , double  ) ;
   int (*bind_int)(sqlite3_stmt * , int  , int  ) ;
   int (*bind_int64)(sqlite3_stmt * , int  , sqlite_int64  ) ;
   int (*bind_null)(sqlite3_stmt * , int  ) ;
   int (*bind_parameter_count)(sqlite3_stmt * ) ;
   int (*bind_parameter_index)(sqlite3_stmt * , char const   *zName ) ;
   char const   *(*bind_parameter_name)(sqlite3_stmt * , int  ) ;
   int (*bind_text)(sqlite3_stmt * , int  , char const   * , int n , void (*)(void * ) ) ;
   int (*bind_text16)(sqlite3_stmt * , int  , void const   * , int  , void (*)(void * ) ) ;
   int (*bind_value)(sqlite3_stmt * , int  , sqlite3_value const   * ) ;
   int (*busy_handler)(sqlite3 * , int (*)(void * , int  ) , void * ) ;
   int (*busy_timeout)(sqlite3 * , int ms ) ;
   int (*changes)(sqlite3 * ) ;
   int (*close)(sqlite3 * ) ;
   int (*collation_needed)(sqlite3 * , void * , void (*)(void * , sqlite3 * , int eTextRep ,
                                                         char const   * ) ) ;
   int (*collation_needed16)(sqlite3 * , void * , void (*)(void * , sqlite3 * , int eTextRep ,
                                                           void const   * ) ) ;
   void const   *(*column_blob)(sqlite3_stmt * , int iCol ) ;
   int (*column_bytes)(sqlite3_stmt * , int iCol ) ;
   int (*column_bytes16)(sqlite3_stmt * , int iCol ) ;
   int (*column_count)(sqlite3_stmt *pStmt ) ;
   char const   *(*column_database_name)(sqlite3_stmt * , int  ) ;
   void const   *(*column_database_name16)(sqlite3_stmt * , int  ) ;
   char const   *(*column_decltype)(sqlite3_stmt * , int i ) ;
   void const   *(*column_decltype16)(sqlite3_stmt * , int  ) ;
   double (*column_double)(sqlite3_stmt * , int iCol ) ;
   int (*column_int)(sqlite3_stmt * , int iCol ) ;
   sqlite_int64 (*column_int64)(sqlite3_stmt * , int iCol ) ;
   char const   *(*column_name)(sqlite3_stmt * , int  ) ;
   void const   *(*column_name16)(sqlite3_stmt * , int  ) ;
   char const   *(*column_origin_name)(sqlite3_stmt * , int  ) ;
   void const   *(*column_origin_name16)(sqlite3_stmt * , int  ) ;
   char const   *(*column_table_name)(sqlite3_stmt * , int  ) ;
   void const   *(*column_table_name16)(sqlite3_stmt * , int  ) ;
   unsigned char const   *(*column_text)(sqlite3_stmt * , int iCol ) ;
   void const   *(*column_text16)(sqlite3_stmt * , int iCol ) ;
   int (*column_type)(sqlite3_stmt * , int iCol ) ;
   sqlite3_value *(*column_value)(sqlite3_stmt * , int iCol ) ;
   void *(*commit_hook)(sqlite3 * , int (*)(void * ) , void * ) ;
   int (*complete)(char const   *sql ) ;
   int (*complete16)(void const   *sql ) ;
   int (*create_collation)(sqlite3 * , char const   * , int  , void * , int (*)(void * ,
                                                                                int  ,
                                                                                void const   * ,
                                                                                int  ,
                                                                                void const   * ) ) ;
   int (*create_collation16)(sqlite3 * , void const   * , int  , void * , int (*)(void * ,
                                                                                  int  ,
                                                                                  void const   * ,
                                                                                  int  ,
                                                                                  void const   * ) ) ;
   int (*create_function)(sqlite3 * , char const   * , int  , int  , void * , void (*xFunc)(sqlite3_context * ,
                                                                                            int  ,
                                                                                            sqlite3_value ** ) ,
                          void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                          void (*xFinal)(sqlite3_context * ) ) ;
   int (*create_function16)(sqlite3 * , void const   * , int  , int  , void * , void (*xFunc)(sqlite3_context * ,
                                                                                              int  ,
                                                                                              sqlite3_value ** ) ,
                            void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                            void (*xFinal)(sqlite3_context * ) ) ;
   int (*create_module)(sqlite3 * , char const   * , sqlite3_module const   * , void * ) ;
   int (*data_count)(sqlite3_stmt *pStmt ) ;
   sqlite3 *(*db_handle)(sqlite3_stmt * ) ;
   int (*declare_vtab)(sqlite3 * , char const   * ) ;
   int (*enable_shared_cache)(int  ) ;
   int (*errcode)(sqlite3 *db ) ;
   char const   *(*errmsg)(sqlite3 * ) ;
   void const   *(*errmsg16)(sqlite3 * ) ;
   int (*exec)(sqlite3 * , char const   * , int (*)(void * , int  , char ** , char ** ) ,
               void * , char ** ) ;
   int (*expired)(sqlite3_stmt * ) ;
   int (*finalize)(sqlite3_stmt *pStmt ) ;
   void (*free)(void * ) ;
   void (*free_table)(char **result ) ;
   int (*get_autocommit)(sqlite3 * ) ;
   void *(*get_auxdata)(sqlite3_context * , int  ) ;
   int (*get_table)(sqlite3 * , char const   * , char *** , int * , int * , char ** ) ;
   int (*global_recover)(void) ;
   void (*interruptx)(sqlite3 * ) ;
   sqlite_int64 (*last_insert_rowid)(sqlite3 * ) ;
   char const   *(*libversion)(void) ;
   int (*libversion_number)(void) ;
   void *(*malloc)(int  ) ;
   char *(*mprintf)(char const   *  , ...) ;
   int (*open)(char const   * , sqlite3 ** ) ;
   int (*open16)(void const   * , sqlite3 ** ) ;
   int (*prepare)(sqlite3 * , char const   * , int  , sqlite3_stmt ** , char const   ** ) ;
   int (*prepare16)(sqlite3 * , void const   * , int  , sqlite3_stmt ** , void const   ** ) ;
   void *(*profile)(sqlite3 * , void (*)(void * , char const   * , sqlite_uint64  ) ,
                    void * ) ;
   void (*progress_handler)(sqlite3 * , int  , int (*)(void * ) , void * ) ;
   void *(*realloc)(void * , int  ) ;
   int (*reset)(sqlite3_stmt *pStmt ) ;
   void (*result_blob)(sqlite3_context * , void const   * , int  , void (*)(void * ) ) ;
   void (*result_double)(sqlite3_context * , double  ) ;
   void (*result_error)(sqlite3_context * , char const   * , int  ) ;
   void (*result_error16)(sqlite3_context * , void const   * , int  ) ;
   void (*result_int)(sqlite3_context * , int  ) ;
   void (*result_int64)(sqlite3_context * , sqlite_int64  ) ;
   void (*result_null)(sqlite3_context * ) ;
   void (*result_text)(sqlite3_context * , char const   * , int  , void (*)(void * ) ) ;
   void (*result_text16)(sqlite3_context * , void const   * , int  , void (*)(void * ) ) ;
   void (*result_text16be)(sqlite3_context * , void const   * , int  , void (*)(void * ) ) ;
   void (*result_text16le)(sqlite3_context * , void const   * , int  , void (*)(void * ) ) ;
   void (*result_value)(sqlite3_context * , sqlite3_value * ) ;
   void *(*rollback_hook)(sqlite3 * , void (*)(void * ) , void * ) ;
   int (*set_authorizer)(sqlite3 * , int (*)(void * , int  , char const   * , char const   * ,
                                             char const   * , char const   * ) , void * ) ;
   void (*set_auxdata)(sqlite3_context * , int  , void * , void (*)(void * ) ) ;
   char *(*xsnprintf)(int  , char * , char const   *  , ...) ;
   int (*step)(sqlite3_stmt * ) ;
   int (*table_column_metadata)(sqlite3 * , char const   * , char const   * , char const   * ,
                                char const   ** , char const   ** , int * , int * ,
                                int * ) ;
   void (*thread_cleanup)(void) ;
   int (*total_changes)(sqlite3 * ) ;
   void *(*trace)(sqlite3 * , void (*xTrace)(void * , char const   * ) , void * ) ;
   int (*transfer_bindings)(sqlite3_stmt * , sqlite3_stmt * ) ;
   void *(*update_hook)(sqlite3 * , void (*)(void * , int  , char const   * , char const   * ,
                                             sqlite_int64  ) , void * ) ;
   void *(*user_data)(sqlite3_context * ) ;
   void const   *(*value_blob)(sqlite3_value * ) ;
   int (*value_bytes)(sqlite3_value * ) ;
   int (*value_bytes16)(sqlite3_value * ) ;
   double (*value_double)(sqlite3_value * ) ;
   int (*value_int)(sqlite3_value * ) ;
   sqlite_int64 (*value_int64)(sqlite3_value * ) ;
   int (*value_numeric_type)(sqlite3_value * ) ;
   unsigned char const   *(*value_text)(sqlite3_value * ) ;
   void const   *(*value_text16)(sqlite3_value * ) ;
   void const   *(*value_text16be)(sqlite3_value * ) ;
   void const   *(*value_text16le)(sqlite3_value * ) ;
   int (*value_type)(sqlite3_value * ) ;
   char *(*vmprintf)(char const   * , va_list  ) ;
   int (*overload_function)(sqlite3 * , char const   *zFuncName , int nArg ) ;
   int (*prepare_v2)(sqlite3 * , char const   * , int  , sqlite3_stmt ** , char const   ** ) ;
   int (*prepare16_v2)(sqlite3 * , void const   * , int  , sqlite3_stmt ** , void const   ** ) ;
   int (*clear_bindings)(sqlite3_stmt * ) ;
   int (*create_module_v2)(sqlite3 * , char const   * , sqlite3_module const   * ,
                           void * , void (*xDestroy)(void * ) ) ;
   int (*bind_zeroblob)(sqlite3_stmt * , int  , int  ) ;
   int (*blob_bytes)(sqlite3_blob * ) ;
   int (*blob_close)(sqlite3_blob * ) ;
   int (*blob_open)(sqlite3 * , char const   * , char const   * , char const   * ,
                    sqlite_int64  , int  , sqlite3_blob ** ) ;
   int (*blob_read)(sqlite3_blob * , void * , int  , int  ) ;
   int (*blob_write)(sqlite3_blob * , void const   * , int  , int  ) ;
   int (*create_collation_v2)(sqlite3 * , char const   * , int  , void * , int (*)(void * ,
                                                                                   int  ,
                                                                                   void const   * ,
                                                                                   int  ,
                                                                                   void const   * ) ,
                              void (*)(void * ) ) ;
   int (*file_control)(sqlite3 * , char const   * , int  , void * ) ;
   sqlite_int64 (*memory_highwater)(int  ) ;
   sqlite_int64 (*memory_used)(void) ;
   sqlite3_mutex *(*mutex_alloc)(int  ) ;
   void (*mutex_enter)(sqlite3_mutex * ) ;
   void (*mutex_free)(sqlite3_mutex * ) ;
   void (*mutex_leave)(sqlite3_mutex * ) ;
   int (*mutex_try)(sqlite3_mutex * ) ;
   int (*open_v2)(char const   * , sqlite3 ** , int  , char const   * ) ;
   int (*release_memory)(int  ) ;
   void (*result_error_nomem)(sqlite3_context * ) ;
   void (*result_error_toobig)(sqlite3_context * ) ;
   int (*sleep)(int  ) ;
   void (*soft_heap_limit)(int  ) ;
   sqlite3_vfs *(*vfs_find)(char const   * ) ;
   int (*vfs_register)(sqlite3_vfs * , int  ) ;
   int (*vfs_unregister)(sqlite3_vfs * ) ;
   int (*xthreadsafe)(void) ;
   void (*result_zeroblob)(sqlite3_context * , int  ) ;
   void (*result_error_code)(sqlite3_context * , int  ) ;
   int (*test_control)(int   , ...) ;
   void (*randomness)(int  , void * ) ;
   sqlite3 *(*context_db_handle)(sqlite3_context * ) ;
   int (*extended_result_codes)(sqlite3 * , int  ) ;
   int (*limit)(sqlite3 * , int  , int  ) ;
   sqlite3_stmt *(*next_stmt)(sqlite3 * , sqlite3_stmt * ) ;
   char const   *(*sql)(sqlite3_stmt * ) ;
   int (*status)(int  , int * , int * , int  ) ;
   int (*backup_finish)(sqlite3_backup * ) ;
   sqlite3_backup *(*backup_init)(sqlite3 * , char const   * , sqlite3 * , char const   * ) ;
   int (*backup_pagecount)(sqlite3_backup * ) ;
   int (*backup_remaining)(sqlite3_backup * ) ;
   int (*backup_step)(sqlite3_backup * , int  ) ;
   char const   *(*compileoption_get)(int  ) ;
   int (*compileoption_used)(char const   * ) ;
   int (*create_function_v2)(sqlite3 * , char const   * , int  , int  , void * , void (*xFunc)(sqlite3_context * ,
                                                                                               int  ,
                                                                                               sqlite3_value ** ) ,
                             void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             void (*xFinal)(sqlite3_context * ) , void (*xDestroy)(void * ) ) ;
   int (*db_config)(sqlite3 * , int   , ...) ;
   sqlite3_mutex *(*db_mutex)(sqlite3 * ) ;
   int (*db_status)(sqlite3 * , int  , int * , int * , int  ) ;
   int (*extended_errcode)(sqlite3 * ) ;
   void (*log)(int  , char const   *  , ...) ;
   sqlite_int64 (*soft_heap_limit64)(sqlite_int64  ) ;
   char const   *(*sourceid)(void) ;
   int (*stmt_status)(sqlite3_stmt * , int  , int  ) ;
   int (*strnicmp)(char const   * , char const   * , int  ) ;
   int (*unlock_notify)(sqlite3 * , void (*)(void ** , int  ) , void * ) ;
   int (*wal_autocheckpoint)(sqlite3 * , int  ) ;
   int (*wal_checkpoint)(sqlite3 * , char const   * ) ;
   void *(*wal_hook)(sqlite3 * , int (*)(void * , sqlite3 * , char const   * , int  ) ,
                     void * ) ;
   int (*blob_reopen)(sqlite3_blob * , sqlite_int64  ) ;
   int (*vtab_config)(sqlite3 * , int op  , ...) ;
   int (*vtab_on_conflict)(sqlite3 * ) ;
   int (*close_v2)(sqlite3 * ) ;
   char const   *(*db_filename)(sqlite3 * , char const   * ) ;
   int (*db_readonly)(sqlite3 * , char const   * ) ;
   int (*db_release_memory)(sqlite3 * ) ;
   char const   *(*errstr)(int  ) ;
   int (*stmt_busy)(sqlite3_stmt * ) ;
   int (*stmt_readonly)(sqlite3_stmt * ) ;
   int (*stricmp)(char const   * , char const   * ) ;
   int (*uri_boolean)(char const   * , char const   * , int  ) ;
   sqlite_int64 (*uri_int64)(char const   * , char const   * , sqlite_int64  ) ;
   char const   *(*uri_parameter)(char const   * , char const   * ) ;
   char *(*xvsnprintf)(int  , char * , char const   * , va_list  ) ;
   int (*wal_checkpoint_v2)(sqlite3 * , char const   * , int  , int * , int * ) ;
   int (*auto_extension)(void (*)(void) ) ;
   int (*bind_blob64)(sqlite3_stmt * , int  , void const   * , sqlite_uint64  , void (*)(void * ) ) ;
   int (*bind_text64)(sqlite3_stmt * , int  , char const   * , sqlite_uint64  , void (*)(void * ) ,
                      unsigned char  ) ;
   int (*cancel_auto_extension)(void (*)(void) ) ;
   int (*load_extension)(sqlite3 * , char const   * , char const   * , char ** ) ;
   void *(*malloc64)(sqlite_uint64  ) ;
   sqlite_uint64 (*msize)(void * ) ;
   void *(*realloc64)(void * , sqlite_uint64  ) ;
   void (*reset_auto_extension)(void) ;
   void (*result_blob64)(sqlite3_context * , void const   * , sqlite_uint64  , void (*)(void * ) ) ;
   void (*result_text64)(sqlite3_context * , char const   * , sqlite_uint64  , void (*)(void * ) ,
                         unsigned char  ) ;
   int (*strglob)(char const   * , char const   * ) ;
   sqlite3_value *(*value_dup)(sqlite3_value const   * ) ;
   void (*value_free)(sqlite3_value * ) ;
   int (*result_zeroblob64)(sqlite3_context * , sqlite_uint64  ) ;
   int (*bind_zeroblob64)(sqlite3_stmt * , int  , sqlite_uint64  ) ;
   unsigned int (*value_subtype)(sqlite3_value * ) ;
   void (*result_subtype)(sqlite3_context * , unsigned int  ) ;
   int (*status64)(int  , sqlite_int64 * , sqlite_int64 * , int  ) ;
   int (*strlike)(char const   * , char const   * , unsigned int  ) ;
   int (*db_cacheflush)(sqlite3 * ) ;
   int (*system_errno)(sqlite3 * ) ;
   int (*trace_v2)(sqlite3 * , unsigned int  , int (*)(unsigned int  , void * , void * ,
                                                       void * ) , void * ) ;
   char *(*expanded_sql)(sqlite3_stmt * ) ;
   void (*set_last_insert_rowid)(sqlite3 * , sqlite_int64  ) ;
   int (*prepare_v3)(sqlite3 * , char const   * , int  , unsigned int  , sqlite3_stmt ** ,
                     char const   ** ) ;
   int (*prepare16_v3)(sqlite3 * , void const   * , int  , unsigned int  , sqlite3_stmt ** ,
                       void const   ** ) ;
   int (*bind_pointer)(sqlite3_stmt * , int  , void * , char const   * , void (*)(void * ) ) ;
   void (*result_pointer)(sqlite3_context * , void * , char const   * , void (*)(void * ) ) ;
   void *(*value_pointer)(sqlite3_value * , char const   * ) ;
   int (*vtab_nochange)(sqlite3_context * ) ;
   int (*value_nochange)(sqlite3_value * ) ;
   char const   *(*vtab_collation)(sqlite3_index_info * , int  ) ;
   int (*keyword_count)(void) ;
   int (*keyword_name)(int  , char const   ** , int * ) ;
   int (*keyword_check)(char const   * , int  ) ;
   sqlite3_str *(*str_new)(sqlite3 * ) ;
   char *(*str_finish)(sqlite3_str * ) ;
   void (*str_appendf)(sqlite3_str * , char const   *zFormat  , ...) ;
   void (*str_vappendf)(sqlite3_str * , char const   *zFormat , va_list  ) ;
   void (*str_append)(sqlite3_str * , char const   *zIn , int N ) ;
   void (*str_appendall)(sqlite3_str * , char const   *zIn ) ;
   void (*str_appendchar)(sqlite3_str * , int N , char C ) ;
   void (*str_reset)(sqlite3_str * ) ;
   int (*str_errcode)(sqlite3_str * ) ;
   int (*str_length)(sqlite3_str * ) ;
   char *(*str_value)(sqlite3_str * ) ;
   int (*create_window_function)(sqlite3 * , char const   * , int  , int  , void * ,
                                 void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                                 void (*xFinal)(sqlite3_context * ) , void (*xValue)(sqlite3_context * ) ,
                                 void (*xInv)(sqlite3_context * , int  , sqlite3_value ** ) ,
                                 void (*xDestroy)(void * ) ) ;
   char const   *(*normalized_sql)(sqlite3_stmt * ) ;
   int (*stmt_isexplain)(sqlite3_stmt * ) ;
   int (*value_frombind)(sqlite3_value * ) ;
   int (*drop_modules)(sqlite3 * , char const   ** ) ;
};
struct sqlite3AutoExtList ;
struct sqlite3AutoExtList {
   u32 nExt ;
   void (**aExt)(void) ;
};
struct PragmaName {
   char const   * const  zName ;
   u8 ePragTyp ;
   u8 mPragFlg ;
   u8 iPragCName ;
   u8 nPragCName ;
   u64 iArg ;
};
typedef struct PragmaName PragmaName;
struct EncName {
   char *zName ;
   u8 enc ;
};
struct PragmaVtab ;
typedef struct PragmaVtab PragmaVtab;
struct PragmaVtabCursor ;
typedef struct PragmaVtabCursor PragmaVtabCursor;
struct PragmaVtab {
   sqlite3_vtab base ;
   sqlite3 *db ;
   PragmaName const   *pName ;
   u8 nHidden ;
   u8 iHidden ;
};
struct PragmaVtabCursor {
   sqlite3_vtab_cursor base ;
   sqlite3_stmt *pPragma ;
   sqlite_int64 iRowid ;
   char *azArg[2] ;
};
struct DistinctCtx ;
typedef struct DistinctCtx DistinctCtx;
struct DistinctCtx {
   u8 isTnct ;
   u8 eTnctType ;
   int tabTnct ;
   int addrTnct ;
};
struct SortCtx ;
typedef struct SortCtx SortCtx;
struct RowLoadInfo ;
struct SortCtx {
   ExprList *pOrderBy ;
   int nOBSat ;
   int iECursor ;
   int regReturn ;
   int labelBkOut ;
   int addrSortIndex ;
   int labelDone ;
   int labelOBLopt ;
   u8 sortFlags ;
   struct RowLoadInfo *pDeferredRowLoad ;
};
struct __anonstruct_aKeyword_561017541 {
   u8 i ;
   u8 nChar ;
   u8 code ;
};
typedef struct RowLoadInfo RowLoadInfo;
struct RowLoadInfo {
   int regResult ;
   u8 ecelFlags ;
};
struct SubstContext {
   Parse *pParse ;
   int iTable ;
   int iNewTable ;
   int isLeftJoin ;
   ExprList *pEList ;
};
typedef struct SubstContext SubstContext;
typedef struct WhereConst WhereConst;
struct WhereConst {
   Parse *pParse ;
   int nConst ;
   int nChng ;
   Expr **apExpr ;
};
struct TabResult {
   char **azResult ;
   char *zErrMsg ;
   u32 nAlloc ;
   u32 nRow ;
   u32 nColumn ;
   u32 nData ;
   int rc ;
};
typedef struct TabResult TabResult;
struct VtabCtx {
   VTable *pVTable ;
   Table *pTab ;
   VtabCtx *pPrior ;
   int bDeclared ;
};
struct WhereClause ;
typedef struct WhereClause WhereClause;
struct WhereMaskSet ;
typedef struct WhereMaskSet WhereMaskSet;
struct WhereOrInfo ;
typedef struct WhereOrInfo WhereOrInfo;
struct WhereAndInfo ;
typedef struct WhereAndInfo WhereAndInfo;
struct WhereLevel ;
typedef struct WhereLevel WhereLevel;
struct WhereLoop ;
typedef struct WhereLoop WhereLoop;
struct WherePath ;
typedef struct WherePath WherePath;
struct WhereTerm ;
typedef struct WhereTerm WhereTerm;
struct WhereLoopBuilder ;
typedef struct WhereLoopBuilder WhereLoopBuilder;
struct WhereScan ;
typedef struct WhereScan WhereScan;
struct WhereOrCost ;
typedef struct WhereOrCost WhereOrCost;
struct WhereOrSet ;
typedef struct WhereOrSet WhereOrSet;
struct InLoop {
   int iCur ;
   int addrInTop ;
   int iBase ;
   int nPrefix ;
   u8 eEndLoopOp ;
};
struct __anonstruct_in_162421769 {
   int nIn ;
   struct InLoop *aInLoop ;
};
union __anonunion_u_513636984 {
   struct __anonstruct_in_162421769 in ;
   Index *pCovidx ;
};
struct WhereLevel {
   int iLeftJoin ;
   int iTabCur ;
   int iIdxCur ;
   int addrBrk ;
   int addrNxt ;
   int addrSkip ;
   int addrCont ;
   int addrFirst ;
   int addrBody ;
   int regBignull ;
   int addrBignull ;
   u32 iLikeRepCntr ;
   int addrLikeRep ;
   u8 iFrom ;
   u8 op ;
   u8 p3 ;
   u8 p5 ;
   int p1 ;
   int p2 ;
   union __anonunion_u_513636984 u ;
   struct WhereLoop *pWLoop ;
   Bitmask notReady ;
};
struct __anonstruct_btree_207802691 {
   u16 nEq ;
   u16 nBtm ;
   u16 nTop ;
   u16 nDistinctCol ;
   Index *pIndex ;
};
struct __anonstruct_vtab_487147857 {
   int idxNum ;
   u8 needFree ;
   i8 isOrdered ;
   u16 omitMask ;
   char *idxStr ;
};
union __anonunion_u_1020647947 {
   struct __anonstruct_btree_207802691 btree ;
   struct __anonstruct_vtab_487147857 vtab ;
};
struct WhereLoop {
   Bitmask prereq ;
   Bitmask maskSelf ;
   u8 iTab ;
   u8 iSortIdx ;
   LogEst rSetup ;
   LogEst rRun ;
   LogEst nOut ;
   union __anonunion_u_1020647947 u ;
   u32 wsFlags ;
   u16 nLTerm ;
   u16 nSkip ;
   u16 nLSlot ;
   WhereTerm **aLTerm ;
   WhereLoop *pNextLoop ;
   WhereTerm *aLTermSpace[3] ;
};
struct WhereOrCost {
   Bitmask prereq ;
   LogEst rRun ;
   LogEst nOut ;
};
struct WhereOrSet {
   u16 n ;
   WhereOrCost a[3] ;
};
struct WherePath {
   Bitmask maskLoop ;
   Bitmask revLoop ;
   LogEst nRow ;
   LogEst rCost ;
   LogEst rUnsorted ;
   i8 isOrdered ;
   WhereLoop **aLoop ;
};
union __anonunion_u_973658567 {
   int leftColumn ;
   WhereOrInfo *pOrInfo ;
   WhereAndInfo *pAndInfo ;
};
struct WhereTerm {
   Expr *pExpr ;
   WhereClause *pWC ;
   LogEst truthProb ;
   u16 wtFlags ;
   u16 eOperator ;
   u8 nChild ;
   u8 eMatchOp ;
   int iParent ;
   int leftCursor ;
   int iField ;
   union __anonunion_u_973658567 u ;
   Bitmask prereqRight ;
   Bitmask prereqAll ;
};
struct WhereScan {
   WhereClause *pOrigWC ;
   WhereClause *pWC ;
   char const   *zCollName ;
   Expr *pIdxExpr ;
   char idxaff ;
   unsigned char nEquiv ;
   unsigned char iEquiv ;
   u32 opMask ;
   int k ;
   int aiCur[11] ;
   i16 aiColumn[11] ;
};
struct WhereClause {
   WhereInfo *pWInfo ;
   WhereClause *pOuter ;
   u8 op ;
   u8 hasOr ;
   int nTerm ;
   int nSlot ;
   WhereTerm *a ;
   WhereTerm aStatic[8] ;
};
struct WhereOrInfo {
   WhereClause wc ;
   Bitmask indexable ;
};
struct WhereAndInfo {
   WhereClause wc ;
};
struct WhereMaskSet {
   int bVarSelect ;
   int n ;
   int ix[(int )(sizeof(Bitmask ) * 8UL)] ;
};
struct WhereLoopBuilder {
   WhereInfo *pWInfo ;
   WhereClause *pWC ;
   ExprList *pOrderBy ;
   WhereLoop *pNew ;
   WhereOrSet *pOrSet ;
   unsigned int bldFlags ;
   unsigned int iPlanLimit ;
};
struct WhereInfo {
   Parse *pParse ;
   SrcList *pTabList ;
   ExprList *pOrderBy ;
   ExprList *pResultSet ;
   Expr *pWhere ;
   LogEst iLimit ;
   int aiCurOnePass[2] ;
   int iContinue ;
   int iBreak ;
   int savedNQueryLoop ;
   u16 wctrlFlags ;
   u8 nLevel ;
   i8 nOBSat ;
   u8 sorted ;
   u8 eOnePass ;
   u8 untestedTerms ;
   u8 eDistinct ;
   u8 bOrderedInnerLoop ;
   int iTop ;
   WhereLoop *pLoops ;
   Bitmask revMask ;
   LogEst nRowOut ;
   WhereClause sWC ;
   WhereMaskSet sMaskSet ;
   WhereLevel a[1] ;
};
struct IdxExprTrans {
   Expr *pIdxExpr ;
   int iTabCur ;
   int iIdxCur ;
   int iIdxCol ;
};
typedef struct IdxExprTrans IdxExprTrans;
struct Op2 {
   char const   *zOp ;
   unsigned char eOp2 ;
};
struct HiddenIndexInfo ;
typedef struct HiddenIndexInfo HiddenIndexInfo;
struct HiddenIndexInfo {
   WhereClause *pWC ;
   Parse *pParse ;
};
struct CallCount {
   i64 nValue ;
   i64 nStep ;
   i64 nTotal ;
};
struct NthValueCtx {
   i64 nStep ;
   sqlite3_value *pValue ;
};
struct NtileCtx {
   i64 nTotal ;
   i64 nParam ;
   i64 iRow ;
};
struct LastValueCtx {
   sqlite3_value *pVal ;
   int nVal ;
};
struct WindowUpdate {
   char const   *zFunc ;
   int eFrmType ;
   int eStart ;
   int eEnd ;
};
typedef struct WindowRewrite WindowRewrite;
struct WindowRewrite {
   Window *pWin ;
   SrcList *pSrc ;
   ExprList *pSub ;
   Table *pTab ;
   Select *pSubSelect ;
};
struct WindowCodeArg ;
typedef struct WindowCodeArg WindowCodeArg;
struct WindowCsrAndReg ;
typedef struct WindowCsrAndReg WindowCsrAndReg;
struct WindowCsrAndReg {
   int csr ;
   int reg ;
};
struct WindowCodeArg {
   Parse *pParse ;
   Window *pMWin ;
   Vdbe *pVdbe ;
   int addrGosub ;
   int regGosub ;
   int regArg ;
   int eDelete ;
   WindowCsrAndReg start ;
   WindowCsrAndReg current ;
   WindowCsrAndReg end ;
};
struct TrigEvent {
   int a ;
   IdList *b ;
};
struct FrameBound {
   int eType ;
   Expr *pExpr ;
};
struct __anonstruct_yy495_1058979729 {
   int value ;
   int mask ;
};
union __anonunion_YYMINORTYPE_510395620 {
   int yyinit ;
   Token yy0 ;
   char const   *yy8 ;
   Select *yy25 ;
   int yy32 ;
   Expr *yy46 ;
   struct FrameBound yy57 ;
   u8 yy118 ;
   ExprList *yy138 ;
   Upsert *yy288 ;
   With *yy297 ;
   IdList *yy406 ;
   Window *yy455 ;
   struct __anonstruct_yy495_1058979729 yy495 ;
   TriggerStep *yy527 ;
   struct TrigEvent yy572 ;
   SrcList *yy609 ;
};
typedef union __anonunion_YYMINORTYPE_510395620 YYMINORTYPE;
struct yyStackEntry {
   unsigned short stateno ;
   unsigned short major ;
   YYMINORTYPE minor ;
};
typedef struct yyStackEntry yyStackEntry;
struct yyParser {
   yyStackEntry *yytos ;
   Parse *pParse ;
   yyStackEntry yystack[100] ;
   yyStackEntry *yystackEnd ;
};
typedef struct yyParser yyParser;
struct __anonstruct_aFlagOp_1035562233 {
   int op ;
   u32 mask ;
};
struct OpenMode {
   char const   *z ;
   int mode ;
};
typedef unsigned long __ino64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef void (*__sighandler_t)(int  );
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
union __anonunion____missing_field_name_1036346496 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
union __anonunion____missing_field_name_1036346497 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
union __anonunion____missing_field_name_1036346498 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
union __anonunion____missing_field_name_1036346499 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
union __anonunion____missing_field_name_1036346500 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
union __anonunion____missing_field_name_1036346501 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
union __anonunion____missing_field_name_1036346502 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
union __anonunion____missing_field_name_1036346503 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
union __anonunion____missing_field_name_1036346504 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
union __anonunion____missing_field_name_1036346505 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
union __anonunion____missing_field_name_1036346506 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
union __anonunion____missing_field_name_1036346507 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
union __anonunion____missing_field_name_1036346508 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
union __anonunion____missing_field_name_1036346509 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_1036346496 __annonCompField4 ;
   union __anonunion____missing_field_name_1036346497 __annonCompField5 ;
   union __anonunion____missing_field_name_1036346498 __annonCompField6 ;
   union __anonunion____missing_field_name_1036346499 __annonCompField7 ;
   union __anonunion____missing_field_name_1036346500 __annonCompField8 ;
   union __anonunion____missing_field_name_1036346501 __annonCompField9 ;
   union __anonunion____missing_field_name_1036346502 __annonCompField10 ;
   union __anonunion____missing_field_name_1036346503 __annonCompField11 ;
   union __anonunion____missing_field_name_1036346504 __annonCompField12 ;
   union __anonunion____missing_field_name_1036346505 __annonCompField13 ;
   union __anonunion____missing_field_name_1036346506 __annonCompField14 ;
   union __anonunion____missing_field_name_1036346507 __annonCompField15 ;
   union __anonunion____missing_field_name_1036346508 __annonCompField16 ;
   union __anonunion____missing_field_name_1036346509 __annonCompField17 ;
};
typedef int __rusage_who_t;
struct __anonstruct_aMult_1036346510 {
   char *zSuffix ;
   int iMult ;
};
struct ShellText ;
typedef struct ShellText ShellText;
struct ShellText {
   char *z ;
   int n ;
   int nAlloc ;
};
struct SHA3Context ;
typedef struct SHA3Context SHA3Context;
union __anonunion_u_245620610 {
   u64 s[25] ;
   unsigned char x[1600] ;
};
struct SHA3Context {
   union __anonunion_u_245620610 u ;
   unsigned int nRate ;
   unsigned int nLoaded ;
   unsigned int ixMask ;
};
struct fsdir_cursor ;
typedef struct fsdir_cursor fsdir_cursor;
struct FsdirLevel ;
typedef struct FsdirLevel FsdirLevel;
struct FsdirLevel {
   DIR *pDir ;
   char *zDir ;
};
struct fsdir_cursor {
   sqlite3_vtab_cursor base ;
   int nLvl ;
   int iLvl ;
   FsdirLevel *aLvl ;
   char const   *zBase ;
   int nBase ;
   struct stat sStat ;
   char *zPath ;
   sqlite_int64 iRowid ;
};
struct fsdir_tab ;
typedef struct fsdir_tab fsdir_tab;
struct fsdir_tab {
   sqlite3_vtab base ;
};
struct completion_vtab ;
typedef struct completion_vtab completion_vtab;
struct completion_vtab {
   sqlite3_vtab base ;
   sqlite3 *db ;
};
struct completion_cursor ;
typedef struct completion_cursor completion_cursor;
struct completion_cursor {
   sqlite3_vtab_cursor base ;
   sqlite3 *db ;
   int nPrefix ;
   int nLine ;
   char *zPrefix ;
   char *zLine ;
   char const   *zCurrentRow ;
   int szRow ;
   sqlite3_stmt *pStmt ;
   sqlite_int64 iRowid ;
   int ePhase ;
   int j ;
};
struct ApndFile ;
typedef struct ApndFile ApndFile;
struct ApndFile {
   sqlite3_file base ;
   sqlite_int64 iPgOne ;
   sqlite_int64 iMark ;
};
struct sqlite3expert ;
typedef struct sqlite3expert sqlite3expert;
struct IdxColumn ;
typedef struct IdxColumn IdxColumn;
struct IdxConstraint ;
typedef struct IdxConstraint IdxConstraint;
struct IdxScan ;
typedef struct IdxScan IdxScan;
struct IdxStatement ;
typedef struct IdxStatement IdxStatement;
struct IdxTable ;
typedef struct IdxTable IdxTable;
struct IdxWrite ;
typedef struct IdxWrite IdxWrite;
struct IdxConstraint {
   char *zColl ;
   int bRange ;
   int iCol ;
   int bFlag ;
   int bDesc ;
   IdxConstraint *pNext ;
   IdxConstraint *pLink ;
};
struct IdxScan {
   IdxTable *pTab ;
   int iDb ;
   i64 covering ;
   IdxConstraint *pOrder ;
   IdxConstraint *pEq ;
   IdxConstraint *pRange ;
   IdxScan *pNextScan ;
};
struct IdxColumn {
   char *zName ;
   char *zColl ;
   int iPk ;
};
struct IdxTable {
   int nCol ;
   char *zName ;
   IdxColumn *aCol ;
   IdxTable *pNext ;
};
struct IdxWrite {
   IdxTable *pTab ;
   int eOp ;
   IdxWrite *pNext ;
};
struct IdxStatement {
   int iId ;
   char *zSql ;
   char *zIdx ;
   char *zEQP ;
   IdxStatement *pNext ;
};
struct IdxHashEntry ;
typedef struct IdxHashEntry IdxHashEntry;
struct IdxHash ;
typedef struct IdxHash IdxHash;
struct IdxHashEntry {
   char *zKey ;
   char *zVal ;
   char *zVal2 ;
   IdxHashEntry *pHashNext ;
   IdxHashEntry *pNext ;
};
struct IdxHash {
   IdxHashEntry *pFirst ;
   IdxHashEntry *aHash[1023] ;
};
struct sqlite3expert {
   int iSample ;
   sqlite3 *db ;
   sqlite3 *dbm ;
   sqlite3 *dbv ;
   IdxTable *pTable ;
   IdxScan *pScan ;
   IdxWrite *pWrite ;
   IdxStatement *pStatement ;
   int bRun ;
   char **pzErrmsg ;
   int rc ;
   IdxHash hIdx ;
   char *zCandidates ;
};
struct ExpertVtab ;
typedef struct ExpertVtab ExpertVtab;
struct ExpertVtab {
   sqlite3_vtab base ;
   IdxTable *pTab ;
   sqlite3expert *pExpert ;
};
struct ExpertCsr ;
typedef struct ExpertCsr ExpertCsr;
struct ExpertCsr {
   sqlite3_vtab_cursor base ;
   sqlite3_stmt *pData ;
};
struct IdxSampleCtx {
   int iTarget ;
   double target ;
   double nRow ;
   double nRet ;
};
struct IdxRemSlot {
   int eType ;
   i64 iVal ;
   double rVal ;
   int nByte ;
   int n ;
   char *z ;
};
struct IdxRemCtx {
   int nSlot ;
   struct IdxRemSlot aSlot[1] ;
};
struct ExpertInfo ;
typedef struct ExpertInfo ExpertInfo;
struct ExpertInfo {
   sqlite3expert *pExpert ;
   int bVerbose ;
};
struct EQPGraphRow ;
typedef struct EQPGraphRow EQPGraphRow;
struct EQPGraphRow {
   int iEqpId ;
   int iParentId ;
   EQPGraphRow *pNext ;
   char zText[1] ;
};
struct EQPGraph ;
typedef struct EQPGraph EQPGraph;
struct EQPGraph {
   EQPGraphRow *pRow ;
   EQPGraphRow *pLast ;
   char zPrefix[100] ;
};
struct ShellState ;
typedef struct ShellState ShellState;
struct ShellState {
   sqlite3 *db ;
   u8 autoExplain ;
   u8 autoEQP ;
   u8 autoEQPtest ;
   u8 autoEQPtrace ;
   u8 statsOn ;
   u8 scanstatsOn ;
   u8 openMode ;
   u8 doXdgOpen ;
   u8 nEqpLevel ;
   u8 eTraceType ;
   unsigned int mEqpLines ;
   int outCount ;
   int cnt ;
   int lineno ;
   FILE *in ;
   FILE *out ;
   FILE *traceOut ;
   int nErr ;
   int mode ;
   int modePrior ;
   int cMode ;
   int normalMode ;
   int writableSchema ;
   int showHeader ;
   int nCheck ;
   unsigned int nProgress ;
   unsigned int mxProgress ;
   unsigned int flgProgress ;
   unsigned int shellFlgs ;
   sqlite_int64 szMax ;
   char *zDestTable ;
   char *zTempFile ;
   char zTestcase[30] ;
   char colSeparator[20] ;
   char rowSeparator[20] ;
   char colSepPrior[20] ;
   char rowSepPrior[20] ;
   int colWidth[100] ;
   int actualWidth[100] ;
   char nullValue[20] ;
   char outfile[4096] ;
   char const   *zDbFilename ;
   char *zFreeOnClose ;
   char const   *zVfs ;
   sqlite3_stmt *pStmt ;
   FILE *pLog ;
   int *aiIndent ;
   int nIndent ;
   int iIndent ;
   EQPGraph sGraph ;
   ExpertInfo expert ;
};
struct __anonstruct_aTrans_527861670 {
   char const   *zPattern ;
   char const   *zDesc ;
};
struct ImportCtx ;
typedef struct ImportCtx ImportCtx;
struct ImportCtx {
   char const   *zFile ;
   FILE *in ;
   char *z ;
   int n ;
   int nAlloc ;
   int nLine ;
   int bNotFirst ;
   int cTerm ;
   int cColSep ;
   int cRowSep ;
};
struct __anonstruct_aField_713894858 {
   char const   *zName ;
   int ofst ;
};
struct __anonstruct_aQuery_713894859 {
   char const   *zName ;
   char const   *zSql ;
};
struct DbConfigChoices {
   char const   *zName ;
   int op ;
};
struct __anonstruct_aCtrl_942335853 {
   char const   *zCtrlName ;
   int ctrlCode ;
   char const   *zUsage ;
};
struct __anonstruct_aLimit_942335854 {
   char const   *zLimitName ;
   int limitCode ;
};
struct __anonstruct_aCtrl_942335855 {
   char const   *zCtrlName ;
   int ctrlCode ;
   char const   *zUsage ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   short __builtin_bswap16(short  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
#pragma merger("0","sqlite3.i","")
#pragma merger("0","/tmp/cil-c6Ri1HQn.i","")
static char const   * const  sqlite3azCompileOpt[3]  = {      (char const   * const  )"COMPILER=gcc-8.3.0",      (char const   * const  )"OMIT_LOAD_EXTENSION",      (char const   * const  )"THREADSAFE=0"};
static char const   **sqlite3CompileOptions(int *pnOpt ) 
{ 


  {
  *pnOpt = (int )(sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]));
  return ((char const   **)(sqlite3azCompileOpt));
}
}
char const   sqlite3_version[7]  = {      (char const   )'3',      (char const   )'.',      (char const   )'3',      (char const   )'0', 
        (char const   )'.',      (char const   )'0',      (char const   )'\000'};
char const   *sqlite3_libversion(void) ;
char const   *sqlite3_sourceid(void) ;
int sqlite3_libversion_number(void) ;
int sqlite3_compileoption_used(char const   *zOptName ) ;
char const   *sqlite3_compileoption_get(int N ) ;
int sqlite3_threadsafe(void) ;
int sqlite3_close(sqlite3 *db ) ;
int sqlite3_close_v2(sqlite3 *db ) ;
int sqlite3_exec(sqlite3 *db , char const   *zSql , int (*xCallback)(void * , int  ,
                                                                     char ** , char ** ) ,
                 void *pArg , char **pzErrMsg ) ;
int sqlite3_initialize(void) ;
int sqlite3_shutdown(void) ;
int sqlite3_os_init(void) ;
int sqlite3_os_end(void) ;
int sqlite3_config(int op  , ...) ;
int sqlite3_db_config(sqlite3 *db , int op  , ...) ;
int sqlite3_extended_result_codes(sqlite3 *db , int onoff ) ;
long long sqlite3_last_insert_rowid(sqlite3 *db ) ;
void sqlite3_set_last_insert_rowid(sqlite3 *db , sqlite_int64 iRowid ) ;
int sqlite3_changes(sqlite3 *db ) ;
int sqlite3_total_changes(sqlite3 *db ) ;
void sqlite3_interrupt(sqlite3 *db ) ;
int sqlite3_complete(char const   *zSql ) ;
int sqlite3_complete16(void const   *zSql ) ;
int sqlite3_busy_handler(sqlite3 *db , int (*xBusy)(void * , int  ) , void *pArg ) ;
int sqlite3_busy_timeout(sqlite3 *db , int ms ) ;
int sqlite3_get_table(sqlite3 *db , char const   *zSql , char ***pazResult , int *pnRow ,
                      int *pnColumn , char **pzErrMsg ) ;
void sqlite3_free_table(char **azResult ) ;
char *sqlite3_mprintf(char const   *zFormat  , ...) ;
char *sqlite3_vmprintf(char const   *zFormat , va_list ap ) ;
char *sqlite3_snprintf(int n , char *zBuf , char const   *zFormat  , ...) ;
char *sqlite3_vsnprintf(int n , char *zBuf , char const   *zFormat , va_list ap ) ;
void *sqlite3_malloc(int n ) ;
void *sqlite3_malloc64(sqlite_uint64 n ) ;
void *sqlite3_realloc(void *pOld , int n ) ;
void *sqlite3_realloc64(void *pOld , sqlite_uint64 n ) ;
void sqlite3_free(void *p ) ;
sqlite_uint64 sqlite3_msize(void *p ) ;
sqlite_int64 sqlite3_memory_used(void) ;
sqlite_int64 sqlite3_memory_highwater(int resetFlag ) ;
void sqlite3_randomness(int N , void *pBuf ) ;
int sqlite3_set_authorizer(sqlite3 *db , int (*xAuth)(void * , int  , char const   * ,
                                                      char const   * , char const   * ,
                                                      char const   * ) , void *pArg ) ;
void *sqlite3_trace(sqlite3 *db , void (*xTrace)(void * , char const   * ) , void *pArg ) ;
void *sqlite3_profile(sqlite3 *db , void (*xProfile)(void * , char const   * , unsigned long long  ) ,
                      void *pArg ) ;
int sqlite3_trace_v2(sqlite3 *db , unsigned int mTrace , int (*xTrace)(unsigned int  ,
                                                                       void * , void * ,
                                                                       void * ) ,
                     void *pArg ) ;
void sqlite3_progress_handler(sqlite3 *db , int nOps , int (*xProgress)(void * ) ,
                              void *pArg ) ;
int sqlite3_open(char const   *zFilename , sqlite3 **ppDb ) ;
int sqlite3_open16(void const   *zFilename , sqlite3 **ppDb ) ;
int sqlite3_open_v2(char const   *filename , sqlite3 **ppDb , int flags___0 , char const   *zVfs ) ;
char const   *sqlite3_uri_parameter(char const   *zFilename , char const   *zParam ) ;
int sqlite3_uri_boolean(char const   *zFilename , char const   *zParam , int bDflt ) ;
sqlite_int64 sqlite3_uri_int64(char const   *zFilename , char const   *zParam , sqlite_int64 bDflt ) ;
int sqlite3_errcode(sqlite3 *db ) ;
int sqlite3_extended_errcode(sqlite3 *db ) ;
char const   *sqlite3_errmsg(sqlite3 *db ) ;
void const   *sqlite3_errmsg16(sqlite3 *db ) ;
char const   *sqlite3_errstr(int rc ) ;
int sqlite3_limit(sqlite3 *db , int limitId , int newLimit ) ;
int sqlite3_prepare(sqlite3 *db , char const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                    char const   **pzTail ) ;
int sqlite3_prepare_v2(sqlite3 *db , char const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                       char const   **pzTail ) ;
int sqlite3_prepare_v3(sqlite3 *db , char const   *zSql , int nBytes , unsigned int prepFlags ,
                       sqlite3_stmt **ppStmt , char const   **pzTail ) ;
int sqlite3_prepare16(sqlite3 *db , void const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                      void const   **pzTail ) ;
int sqlite3_prepare16_v2(sqlite3 *db , void const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                         void const   **pzTail ) ;
int sqlite3_prepare16_v3(sqlite3 *db , void const   *zSql , int nBytes , unsigned int prepFlags ,
                         sqlite3_stmt **ppStmt , void const   **pzTail ) ;
char const   *sqlite3_sql(sqlite3_stmt *pStmt ) ;
char *sqlite3_expanded_sql(sqlite3_stmt *pStmt ) ;
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt ) ;
int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt ) ;
int sqlite3_stmt_busy(sqlite3_stmt *pStmt ) ;
int sqlite3_bind_blob(sqlite3_stmt *pStmt , int i , void const   *zData , int nData ,
                      void (*xDel)(void * ) ) ;
int sqlite3_bind_blob64(sqlite3_stmt *pStmt , int i , void const   *zData , sqlite_uint64 nData ,
                        void (*xDel)(void * ) ) ;
int sqlite3_bind_double(sqlite3_stmt *pStmt , int i , double rValue ) ;
int sqlite3_bind_int(sqlite3_stmt *p , int i , int iValue___0 ) ;
int sqlite3_bind_int64(sqlite3_stmt *pStmt , int i , long long iValue___0 ) ;
int sqlite3_bind_null(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_bind_text(sqlite3_stmt *pStmt , int i , char const   *zData , int nData ,
                      void (*xDel)(void * ) ) ;
int sqlite3_bind_text16(sqlite3_stmt *pStmt , int i , void const   *zData , int nData ,
                        void (*xDel)(void * ) ) ;
int sqlite3_bind_text64(sqlite3_stmt *pStmt , int i , char const   *zData , sqlite_uint64 nData ,
                        void (*xDel)(void * ) , unsigned char enc ) ;
int sqlite3_bind_value(sqlite3_stmt *pStmt , int i , sqlite3_value const   *pValue ) ;
int sqlite3_bind_pointer(sqlite3_stmt *pStmt , int i , void *pPtr , char const   *zPTtype ,
                         void (*xDestructor)(void * ) ) ;
int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt , int i , int n ) ;
int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt , int i , sqlite_uint64 n ) ;
int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt ) ;
char const   *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt , char const   *zName ) ;
int sqlite3_clear_bindings(sqlite3_stmt *pStmt ) ;
int sqlite3_column_count(sqlite3_stmt *pStmt ) ;
char const   *sqlite3_column_name(sqlite3_stmt *pStmt , int N ) ;
void const   *sqlite3_column_name16(sqlite3_stmt *pStmt , int N ) ;
char const   *sqlite3_column_decltype(sqlite3_stmt *pStmt , int N ) ;
void const   *sqlite3_column_decltype16(sqlite3_stmt *pStmt , int N ) ;
int sqlite3_step(sqlite3_stmt *pStmt ) ;
int sqlite3_data_count(sqlite3_stmt *pStmt ) ;
void const   *sqlite3_column_blob(sqlite3_stmt *pStmt , int i ) ;
double sqlite3_column_double(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_column_int(sqlite3_stmt *pStmt , int i ) ;
long long sqlite3_column_int64(sqlite3_stmt *pStmt , int i ) ;
unsigned char const   *sqlite3_column_text(sqlite3_stmt *pStmt , int i ) ;
void const   *sqlite3_column_text16(sqlite3_stmt *pStmt , int i ) ;
sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_column_bytes(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_column_bytes16(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_column_type(sqlite3_stmt *pStmt , int i ) ;
int sqlite3_finalize(sqlite3_stmt *pStmt ) ;
int sqlite3_reset(sqlite3_stmt *pStmt ) ;
int sqlite3_create_function(sqlite3 *db , char const   *zFunc , int nArg , int enc ,
                            void *p , void (*xSFunc)(sqlite3_context * , int  , sqlite3_value ** ) ,
                            void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                            void (*xFinal)(sqlite3_context * ) ) ;
int sqlite3_create_function16(sqlite3 *db , void const   *zFunctionName , int nArg ,
                              int eTextRep , void *p , void (*xSFunc)(sqlite3_context * ,
                                                                      int  , sqlite3_value ** ) ,
                              void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                              void (*xFinal)(sqlite3_context * ) ) ;
int sqlite3_create_function_v2(sqlite3 *db , char const   *zFunc , int nArg , int enc ,
                               void *p , void (*xSFunc)(sqlite3_context * , int  ,
                                                        sqlite3_value ** ) , void (*xStep)(sqlite3_context * ,
                                                                                           int  ,
                                                                                           sqlite3_value ** ) ,
                               void (*xFinal)(sqlite3_context * ) , void (*xDestroy)(void * ) ) ;
int sqlite3_create_window_function(sqlite3 *db , char const   *zFunc , int nArg ,
                                   int enc , void *p , void (*xStep)(sqlite3_context * ,
                                                                     int  , sqlite3_value ** ) ,
                                   void (*xFinal)(sqlite3_context * ) , void (*xValue)(sqlite3_context * ) ,
                                   void (*xInverse)(sqlite3_context * , int  , sqlite3_value ** ) ,
                                   void (*xDestroy)(void * ) ) ;
int sqlite3_aggregate_count(sqlite3_context *p ) ;
int sqlite3_expired(sqlite3_stmt *pStmt ) ;
int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt , sqlite3_stmt *pToStmt ) ;
int sqlite3_global_recover(void) ;
void sqlite3_thread_cleanup(void) ;
int sqlite3_memory_alarm(void (*xCallback)(void *pArg , sqlite_int64 used , int N ) ,
                         void *pArg , sqlite_int64 iThreshold ) ;
void const   *sqlite3_value_blob(sqlite3_value *pVal ) ;
double sqlite3_value_double(sqlite3_value *pVal ) ;
int sqlite3_value_int(sqlite3_value *pVal ) ;
long long sqlite3_value_int64(sqlite3_value *pVal ) ;
void *sqlite3_value_pointer(sqlite3_value *pVal , char const   *zPType ) ;
unsigned char const   *sqlite3_value_text(sqlite3_value *pVal ) ;
void const   *sqlite3_value_text16(sqlite3_value *pVal ) ;
void const   *sqlite3_value_text16le(sqlite3_value *pVal ) ;
void const   *sqlite3_value_text16be(sqlite3_value *pVal ) ;
int sqlite3_value_bytes(sqlite3_value *pVal ) ;
int sqlite3_value_bytes16(sqlite3_value *pVal ) ;
int sqlite3_value_type(sqlite3_value *pVal ) ;
int sqlite3_value_numeric_type(sqlite3_value *pVal ) ;
int sqlite3_value_nochange(sqlite3_value *pVal ) ;
int sqlite3_value_frombind(sqlite3_value *pVal ) ;
unsigned int sqlite3_value_subtype(sqlite3_value *pVal ) ;
sqlite3_value *sqlite3_value_dup(sqlite3_value const   *pOrig ) ;
void sqlite3_value_free(sqlite3_value *pOld ) ;
void *sqlite3_aggregate_context(sqlite3_context *p , int nByte ) ;
void *sqlite3_user_data(sqlite3_context *p ) ;
sqlite3 *sqlite3_context_db_handle(sqlite3_context *p ) ;
void *sqlite3_get_auxdata(sqlite3_context *pCtx , int iArg ) ;
void sqlite3_set_auxdata(sqlite3_context *pCtx , int iArg , void *pAux , void (*xDelete)(void * ) ) ;
void sqlite3_result_blob(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) ;
void sqlite3_result_blob64(sqlite3_context *pCtx , void const   *z , sqlite_uint64 n ,
                           void (*xDel)(void * ) ) ;
void sqlite3_result_double(sqlite3_context *pCtx , double rVal ) ;
void sqlite3_result_error(sqlite3_context *pCtx , char const   *z , int n ) ;
void sqlite3_result_error16(sqlite3_context *pCtx , void const   *z , int n ) ;
void sqlite3_result_error_toobig(sqlite3_context *pCtx ) ;
void sqlite3_result_error_nomem(sqlite3_context *pCtx ) ;
void sqlite3_result_error_code(sqlite3_context *pCtx , int errCode ) ;
void sqlite3_result_int(sqlite3_context *pCtx , int iVal ) ;
void sqlite3_result_int64(sqlite3_context *pCtx , long long iVal ) ;
void sqlite3_result_null(sqlite3_context *pCtx ) ;
void sqlite3_result_text(sqlite3_context *pCtx , char const   *z , int n , void (*xDel)(void * ) ) ;
void sqlite3_result_text64(sqlite3_context *pCtx , char const   *z , sqlite_uint64 n ,
                           void (*xDel)(void * ) , unsigned char enc ) ;
void sqlite3_result_text16(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) ;
void sqlite3_result_text16le(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) ;
void sqlite3_result_text16be(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) ;
void sqlite3_result_value(sqlite3_context *pCtx , sqlite3_value *pValue ) ;
void sqlite3_result_pointer(sqlite3_context *pCtx , void *pPtr , char const   *zPType ,
                            void (*xDestructor)(void * ) ) ;
void sqlite3_result_zeroblob(sqlite3_context *pCtx , int n ) ;
int sqlite3_result_zeroblob64(sqlite3_context *pCtx , unsigned long long n ) ;
void sqlite3_result_subtype(sqlite3_context *pCtx , unsigned int eSubtype ) ;
int sqlite3_create_collation(sqlite3 *db , char const   *zName , int enc , void *pCtx ,
                             int (*xCompare)(void * , int  , void const   * , int  ,
                                             void const   * ) ) ;
int sqlite3_create_collation_v2(sqlite3 *db , char const   *zName , int enc , void *pCtx ,
                                int (*xCompare)(void * , int  , void const   * , int  ,
                                                void const   * ) , void (*xDel)(void * ) ) ;
int sqlite3_create_collation16(sqlite3 *db , void const   *zName , int enc , void *pCtx ,
                               int (*xCompare)(void * , int  , void const   * , int  ,
                                               void const   * ) ) ;
int sqlite3_collation_needed(sqlite3 *db , void *pCollNeededArg , void (*xCollNeeded)(void * ,
                                                                                      sqlite3 * ,
                                                                                      int eTextRep ,
                                                                                      char const   * ) ) ;
int sqlite3_collation_needed16(sqlite3 *db , void *pCollNeededArg , void (*xCollNeeded16)(void * ,
                                                                                          sqlite3 * ,
                                                                                          int eTextRep ,
                                                                                          void const   * ) ) ;
int sqlite3_sleep(int ms ) ;
char *sqlite3_temp_directory ;
char *sqlite3_data_directory ;
int sqlite3_get_autocommit(sqlite3 *db ) ;
sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt ) ;
char const   *sqlite3_db_filename(sqlite3 *db , char const   *zDbName ) ;
int sqlite3_db_readonly(sqlite3 *db , char const   *zDbName ) ;
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb , sqlite3_stmt *pStmt ) ;
void *sqlite3_commit_hook(sqlite3 *db , int (*xCallback)(void * ) , void *pArg ) ;
void *sqlite3_rollback_hook(sqlite3 *db , void (*xCallback)(void * ) , void *pArg ) ;
void *sqlite3_update_hook(sqlite3 *db , void (*xCallback)(void * , int  , char const   * ,
                                                          char const   * , long long  ) ,
                          void *pArg ) ;
int sqlite3_enable_shared_cache(int enable ) ;
int sqlite3_release_memory(int n ) ;
int sqlite3_db_release_memory(sqlite3 *db ) ;
sqlite_int64 sqlite3_soft_heap_limit64(sqlite_int64 n ) ;
void sqlite3_soft_heap_limit(int n ) ;
int sqlite3_table_column_metadata(sqlite3 *db , char const   *zDbName , char const   *zTableName ,
                                  char const   *zColumnName , char const   **pzDataType ,
                                  char const   **pzCollSeq , int *pNotNull , int *pPrimaryKey ,
                                  int *pAutoinc ) ;
int sqlite3_auto_extension(void (*xInit)(void) ) ;
int sqlite3_cancel_auto_extension(void (*xInit)(void) ) ;
void sqlite3_reset_auto_extension(void) ;
int sqlite3_create_module(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                          void *pAux ) ;
int sqlite3_create_module_v2(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                             void *pAux , void (*xDestroy)(void * ) ) ;
int sqlite3_drop_modules(sqlite3 *db , char const   **azNames ) ;
int sqlite3_declare_vtab(sqlite3 *db , char const   *zCreateTable ) ;
int sqlite3_overload_function(sqlite3 *db , char const   *zName , int nArg ) ;
int sqlite3_blob_open(sqlite3 *db , char const   *zDb , char const   *zTable , char const   *zColumn ,
                      long long iRow , int wrFlag , sqlite3_blob **ppBlob ) ;
int sqlite3_blob_reopen(sqlite3_blob *pBlob , sqlite_int64 iRow ) ;
int sqlite3_blob_close(sqlite3_blob *pBlob ) ;
int sqlite3_blob_bytes(sqlite3_blob *pBlob ) ;
int sqlite3_blob_read(sqlite3_blob *pBlob , void *z , int n , int iOffset___0 ) ;
int sqlite3_blob_write(sqlite3_blob *pBlob , void const   *z , int n , int iOffset___0 ) ;
sqlite3_vfs *sqlite3_vfs_find(char const   *zVfs ) ;
int sqlite3_vfs_register(sqlite3_vfs *pVfs , int makeDflt ) ;
int sqlite3_vfs_unregister(sqlite3_vfs *pVfs ) ;
sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db ) ;
int sqlite3_file_control(sqlite3 *db , char const   *zDbName , int op , void *pArg ) ;
int sqlite3_test_control(int op  , ...) ;
int sqlite3_keyword_count(void) ;
int sqlite3_keyword_name(int i , char const   **pzName , int *pnName ) ;
int sqlite3_keyword_check(char const   *zName , int nName ) ;
sqlite3_str *sqlite3_str_new(sqlite3 *db ) ;
char *sqlite3_str_finish(sqlite3_str *p ) ;
void sqlite3_str_appendf(struct sqlite3_str *p , char const   *zFormat  , ...) ;
void sqlite3_str_vappendf(sqlite3_str *pAccum , char const   *fmt , va_list ap ) ;
void sqlite3_str_append(sqlite3_str *p , char const   *z , int N ) ;
void sqlite3_str_appendall(sqlite3_str *p , char const   *z ) ;
void sqlite3_str_appendchar(sqlite3_str *p , int N , char c ) ;
void sqlite3_str_reset(struct sqlite3_str *p ) ;
int sqlite3_str_errcode(sqlite3_str *p ) ;
int sqlite3_str_length(sqlite3_str *p ) ;
char *sqlite3_str_value(sqlite3_str *p ) ;
int sqlite3_status(int op , int *pCurrent , int *pHighwater , int resetFlag ) ;
int sqlite3_status64(int op , sqlite_int64 *pCurrent , sqlite_int64 *pHighwater ,
                     int resetFlag ) ;
int sqlite3_db_status(sqlite3 *db , int op , int *pCurrent , int *pHighwater , int resetFlag ) ;
int sqlite3_stmt_status(sqlite3_stmt *pStmt , int op , int resetFlag ) ;
sqlite3_backup *sqlite3_backup_init(sqlite3 *pDestDb , char const   *zDestDb , sqlite3 *pSrcDb ,
                                    char const   *zSrcDb ) ;
int sqlite3_backup_step(sqlite3_backup *p , int nPage ) ;
int sqlite3_backup_finish(sqlite3_backup *p ) ;
int sqlite3_backup_remaining(sqlite3_backup *p ) ;
int sqlite3_backup_pagecount(sqlite3_backup *p ) ;
int sqlite3_stricmp(char const   *zLeft , char const   *zRight ) ;
int sqlite3_strnicmp(char const   *zLeft , char const   *zRight , int N ) ;
int sqlite3_strglob(char const   *zGlobPattern , char const   *zString ) ;
int sqlite3_strlike(char const   *zPattern , char const   *zStr , unsigned int esc ) ;
void sqlite3_log(int iErrCode , char const   *zFormat  , ...) ;
void *sqlite3_wal_hook(sqlite3 *db , int (*xCallback)(void * , sqlite3 * , char const   * ,
                                                      int  ) , void *pArg ) ;
int sqlite3_wal_autocheckpoint(sqlite3 *db , int nFrame ) ;
int sqlite3_wal_checkpoint(sqlite3 *db , char const   *zDb ) ;
int sqlite3_wal_checkpoint_v2(sqlite3 *db , char const   *zDb , int eMode , int *pnLog ,
                              int *pnCkpt ) ;
int sqlite3_vtab_config(sqlite3 *db , int op  , ...) ;
int sqlite3_vtab_on_conflict(sqlite3 *db ) ;
int sqlite3_vtab_nochange(sqlite3_context *p ) ;
char const   *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo , int iCons ) ;
int sqlite3_db_cacheflush(sqlite3 *db ) ;
int sqlite3_system_errno(sqlite3 *db ) ;
static void sqlite3HashInit(Hash *pNew ) ;
static void *sqlite3HashInsert(Hash *pH , char const   *pKey , void *data ) ;
static void *sqlite3HashFind(Hash const   *pH , char const   *pKey ) ;
static void sqlite3HashClear(Hash *pH ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
static int sqlite3BtreeOpen(sqlite3_vfs *pVfs , char const   *zFilename , sqlite3 *db ,
                            Btree **ppBtree , int flags___0 , int vfsFlags___0 ) ;
static int sqlite3BtreeClose(Btree *p ) ;
static int sqlite3BtreeSetCacheSize(Btree *p , int mxPage ) ;
static int sqlite3BtreeSetSpillSize(Btree *p , int mxPage ) ;
static int sqlite3BtreeSetMmapLimit(Btree *p , sqlite_int64 szMmap ) ;
static int sqlite3BtreeSetPagerFlags(Btree *p , unsigned int pgFlags ) ;
static int sqlite3BtreeSetPageSize(Btree *p , int pageSize , int nReserve , int iFix ) ;
static int sqlite3BtreeGetPageSize(Btree *p ) ;
static int sqlite3BtreeMaxPageCount(Btree *p , int mxPage ) ;
static u32 sqlite3BtreeLastPage(Btree *p ) ;
static int sqlite3BtreeSecureDelete(Btree *p , int newFlag ) ;
static int sqlite3BtreeGetOptimalReserve(Btree *p ) ;
static int sqlite3BtreeGetReserveNoMutex(Btree *p ) ;
static int sqlite3BtreeSetAutoVacuum(Btree *p , int autoVacuum ) ;
static int sqlite3BtreeGetAutoVacuum(Btree *p ) ;
static int sqlite3BtreeBeginTrans(Btree *p , int wrflag , int *pSchemaVersion ) ;
static int sqlite3BtreeCommitPhaseOne(Btree *p , char const   *zMaster ) ;
static int sqlite3BtreeCommitPhaseTwo(Btree *p , int bCleanup ) ;
static int sqlite3BtreeCommit(Btree *p ) ;
static int sqlite3BtreeRollback(Btree *p , int tripCode , int writeOnly ) ;
static int sqlite3BtreeBeginStmt(Btree *p , int iStatement ) ;
static int sqlite3BtreeCreateTable(Btree *p , int *piTable , int flags___0 ) ;
static int sqlite3BtreeIsInTrans(Btree *p ) ;
static int sqlite3BtreeIsInReadTrans(Btree *p ) ;
static int sqlite3BtreeIsInBackup(Btree *p ) ;
static void *sqlite3BtreeSchema(Btree *p , int nBytes , void (*xFree)(void * ) ) ;
static int sqlite3BtreeSchemaLocked(Btree *p ) ;
static int sqlite3BtreeLockTable(Btree *p , int iTab , u8 isWriteLock ) ;
static int sqlite3BtreeSavepoint(Btree *p , int op , int iSavepoint ) ;
static char const   *sqlite3BtreeGetFilename(Btree *p ) ;
static char const   *sqlite3BtreeGetJournalname(Btree *p ) ;
static int sqlite3BtreeCopyFile(Btree *pTo , Btree *pFrom ) ;
static int sqlite3BtreeIncrVacuum(Btree *p ) ;
static int sqlite3BtreeDropTable(Btree *p , int iTable , int *piMoved ) ;
static int sqlite3BtreeClearTable(Btree *p , int iTable , int *pnChange ) ;
static int sqlite3BtreeClearTableOfCursor(BtCursor *pCur ) ;
static int sqlite3BtreeTripAllCursors(Btree *pBtree , int errCode , int writeOnly ) ;
static void sqlite3BtreeGetMeta(Btree *p , int idx , u32 *pMeta ) ;
static int sqlite3BtreeUpdateMeta(Btree *p , int idx , u32 iMeta ) ;
static int sqlite3BtreeNewDb(Btree *p ) ;
static int sqlite3BtreeCursor(Btree *p , int iTable , int wrFlag , struct KeyInfo *pKeyInfo ,
                              BtCursor *pCur ) ;
static BtCursor *sqlite3BtreeFakeValidCursor(void) ;
static int sqlite3BtreeCursorSize(void) ;
static void sqlite3BtreeCursorZero(BtCursor *p ) ;
static void sqlite3BtreeCursorHintFlags(BtCursor *pCur , unsigned int x___0 ) ;
static int sqlite3BtreeCloseCursor(BtCursor *pCur ) ;
static int sqlite3BtreeMovetoUnpacked(BtCursor *pCur , UnpackedRecord *pIdxKey , i64 intKey ,
                                      int biasRight , int *pRes ) ;
static int sqlite3BtreeCursorHasMoved(BtCursor *pCur ) ;
static int sqlite3BtreeCursorRestore(BtCursor *pCur , int *pDifferentRow ) ;
static int sqlite3BtreeDelete(BtCursor *pCur , u8 flags___0 ) ;
static int sqlite3BtreeInsert(BtCursor *pCur , BtreePayload const   *pX , int flags___0 ,
                              int seekResult ) ;
static int sqlite3BtreeFirst(BtCursor *pCur , int *pRes ) ;
static int sqlite3BtreeLast(BtCursor *pCur , int *pRes ) ;
static int sqlite3BtreeNext(BtCursor *pCur , int flags___0 ) ;
static int sqlite3BtreeEof(BtCursor *pCur ) ;
static int sqlite3BtreePrevious(BtCursor *pCur , int flags___0 ) ;
static i64 sqlite3BtreeIntegerKey(BtCursor *pCur ) ;
static int sqlite3BtreePayload(BtCursor *pCur , u32 offset , u32 amt , void *pBuf ) ;
static void const   *sqlite3BtreePayloadFetch(BtCursor *pCur , u32 *pAmt ) ;
static u32 sqlite3BtreePayloadSize(BtCursor *pCur ) ;
static sqlite_int64 sqlite3BtreeMaxRecordSize(BtCursor *pCur ) ;
static char *sqlite3BtreeIntegrityCheck(Btree *p , int *aRoot , int nRoot , int mxErr ,
                                        int *pnErr ) ;
static struct Pager *sqlite3BtreePager(Btree *p ) ;
static i64 sqlite3BtreeRowCountEst(BtCursor *pCur ) ;
static int sqlite3BtreePayloadChecked(BtCursor *pCur , u32 offset , u32 amt , void *pBuf ) ;
static int sqlite3BtreePutData(BtCursor *pCsr , u32 offset , u32 amt , void *z ) ;
static void sqlite3BtreeIncrblobCursor(BtCursor *pCur ) ;
static void sqlite3BtreeClearCursor(BtCursor *pCur ) ;
static int sqlite3BtreeSetVersion(Btree *pBtree , int iVersion ) ;
static int sqlite3BtreeCursorHasHint(BtCursor *pCsr , unsigned int mask ) ;
static int sqlite3BtreeIsReadonly(Btree *p ) ;
static int sqlite3HeaderSizeBtree(void) ;
static int sqlite3BtreeCursorIsValidNN(BtCursor *pCur ) ;
static int sqlite3BtreeCount(BtCursor *pCur , i64 *pnEntry ) ;
static int sqlite3BtreeCheckpoint(Btree *p , int eMode , int *pnLog , int *pnCkpt ) ;
static void sqlite3BtreeEnter(Btree *p ) ;
static void sqlite3BtreeEnterAll(sqlite3 *db ) ;
static int sqlite3BtreeSharable(Btree *p ) ;
static void sqlite3BtreeEnterCursor(BtCursor *pCur ) ;
static int sqlite3BtreeConnectionCount(Btree *p ) ;
static Vdbe *sqlite3VdbeCreate(Parse *pParse ) ;
static int sqlite3VdbeAddOp0(Vdbe *p , int op ) ;
static int sqlite3VdbeAddOp1(Vdbe *p , int op , int p1 ) ;
static int sqlite3VdbeAddOp2(Vdbe *p , int op , int p1 , int p2 ) ;
static int sqlite3VdbeGoto(Vdbe *p , int iDest ) ;
static int sqlite3VdbeLoadString(Vdbe *p , int iDest , char const   *zStr ) ;
static void sqlite3VdbeMultiLoad(Vdbe *p , int iDest , char const   *zTypes  , ...) ;
static int sqlite3VdbeAddOp3(Vdbe *p , int op , int p1 , int p2 , int p3 ) ;
static int sqlite3VdbeAddOp4(Vdbe *p , int op , int p1 , int p2 , int p3 , char const   *zP4 ,
                             int p4type ) ;
static int sqlite3VdbeAddOp4Dup8(Vdbe *p , int op , int p1 , int p2 , int p3 , u8 const   *zP4 ,
                                 int p4type ) ;
static int sqlite3VdbeAddOp4Int(Vdbe *p , int op , int p1 , int p2 , int p3 , int p4 ) ;
static void sqlite3VdbeEndCoroutine(Vdbe *v , int regYield ) ;
static VdbeOp *sqlite3VdbeAddOpList(Vdbe *p , int nOp , VdbeOpList const   *aOp___1 ,
                                    int iLineno ) ;
static void sqlite3VdbeExplain(Parse *pParse , u8 bPush , char const   *zFmt  , ...) ;
static void sqlite3VdbeExplainPop(Parse *pParse ) ;
static int sqlite3VdbeExplainParent(Parse *pParse ) ;
static void sqlite3VdbeAddParseSchemaOp(Vdbe *p , int iDb , char *zWhere ) ;
static void sqlite3VdbeChangeOpcode(Vdbe *p , int addr , u8 iNewOpcode ) ;
static void sqlite3VdbeChangeP1(Vdbe *p , int addr , int val ) ;
static void sqlite3VdbeChangeP2(Vdbe *p , int addr , int val ) ;
static void sqlite3VdbeChangeP3(Vdbe *p , int addr , int val ) ;
static void sqlite3VdbeChangeP5(Vdbe *p , u16 p5 ) ;
static void sqlite3VdbeJumpHere(Vdbe *p , int addr ) ;
static int sqlite3VdbeChangeToNoop(Vdbe *p , int addr ) ;
static int sqlite3VdbeDeletePriorOpcode(Vdbe *p , u8 op ) ;
static void sqlite3VdbeChangeP4(Vdbe *p , int addr , char const   *zP4 , int n ) ;
static void sqlite3VdbeAppendP4(Vdbe *p , void *pP4 , int n ) ;
static void sqlite3VdbeSetP4KeyInfo(Parse *pParse , Index *pIdx ) ;
static void sqlite3VdbeUsesBtree(Vdbe *p , int i ) ;
static VdbeOp *sqlite3VdbeGetOp(Vdbe *p , int addr ) ;
static int sqlite3VdbeMakeLabel(Parse *pParse ) ;
static void sqlite3VdbeRunOnlyOnce(Vdbe *p ) ;
static void sqlite3VdbeReusable(Vdbe *p ) ;
static void sqlite3VdbeDelete(Vdbe *p ) ;
static void sqlite3VdbeClearObject(sqlite3 *db , Vdbe *p ) ;
static void sqlite3VdbeMakeReady(Vdbe *p , Parse *pParse ) ;
static int sqlite3VdbeFinalize(Vdbe *p ) ;
static void sqlite3VdbeResolveLabel(Vdbe *v , int x___0 ) ;
static int sqlite3VdbeCurrentAddr(Vdbe *p ) ;
static void sqlite3VdbeResetStepResult(Vdbe *p ) ;
static void sqlite3VdbeRewind(Vdbe *p ) ;
static int sqlite3VdbeReset(Vdbe *p ) ;
static void sqlite3VdbeSetNumCols(Vdbe *p , int nResColumn ) ;
static int sqlite3VdbeSetColName(Vdbe *p , int idx , int var , char const   *zName ,
                                 void (*xDel)(void * ) ) ;
static void sqlite3VdbeCountChanges(Vdbe *v ) ;
static sqlite3 *sqlite3VdbeDb(Vdbe *v ) ;
static u8 sqlite3VdbePrepareFlags(Vdbe *v ) ;
static void sqlite3VdbeSetSql(Vdbe *p , char const   *z , int n , u8 prepFlags ) ;
static void sqlite3VdbeSwap(Vdbe *pA , Vdbe *pB ) ;
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p , int *pnOp , int *pnMaxArg ) ;
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v , int iVar , u8 aff ) ;
static void sqlite3VdbeSetVarmask(Vdbe *v , int iVar ) ;
static char *sqlite3VdbeExpandSql(Vdbe *p , char const   *zRawSql ) ;
static int sqlite3MemCompare(Mem const   *pMem1 , Mem const   *pMem2 , CollSeq const   *pColl ) ;
static int ( __attribute__((__noinline__)) sqlite3BlobCompare)(Mem const   *pB1 ,
                                                               Mem const   *pB2 ) ;
static void sqlite3VdbeRecordUnpack(KeyInfo *pKeyInfo , int nKey , void const   *pKey ,
                                    UnpackedRecord *p ) ;
static int sqlite3VdbeRecordCompare(int nKey1 , void const   *pKey1 , UnpackedRecord *pPKey2 ) ;
static int sqlite3VdbeRecordCompareWithSkip(int nKey1 , void const   *pKey1 , UnpackedRecord *pPKey2 ,
                                            int bSkip ) ;
static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo *pKeyInfo ) ;
static RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p ) ;
static void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe , SubProgram *p ) ;
static int sqlite3NotPureFunc(sqlite3_context *pCtx ) ;
static int sqlite3PagerOpen(sqlite3_vfs *pVfs , Pager **ppPager , char const   *zFilename ,
                            int nExtra , int flags___0 , int vfsFlags___0 , void (*xReinit)(DbPage * ) ) ;
static int sqlite3PagerClose(Pager *pPager , sqlite3 *db ) ;
static int sqlite3PagerReadFileheader(Pager *pPager , int N , unsigned char *pDest ) ;
static void sqlite3PagerSetBusyHandler(Pager *pPager , int (*xBusyHandler)(void * ) ,
                                       void *pBusyHandlerArg ) ;
static int sqlite3PagerSetPagesize(Pager *pPager , u32 *pPageSize , int nReserve ) ;
static int sqlite3PagerMaxPageCount(Pager *pPager , int mxPage ) ;
static void sqlite3PagerSetCachesize(Pager *pPager , int mxPage ) ;
static int sqlite3PagerSetSpillsize(Pager *pPager , int mxPage ) ;
static void sqlite3PagerSetMmapLimit(Pager *pPager , sqlite_int64 szMmap ) ;
static void sqlite3PagerShrink(Pager *pPager ) ;
static void sqlite3PagerSetFlags(Pager *pPager , unsigned int pgFlags ) ;
static int sqlite3PagerLockingMode(Pager *pPager , int eMode ) ;
static int sqlite3PagerSetJournalMode(Pager *pPager , int eMode ) ;
static int sqlite3PagerGetJournalMode(Pager *pPager ) ;
static int sqlite3PagerOkToChangeJournalMode(Pager *pPager ) ;
static i64 sqlite3PagerJournalSizeLimit(Pager *pPager , i64 iLimit ) ;
static sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager ) ;
static int sqlite3PagerFlush(Pager *pPager ) ;
static int sqlite3PagerGet(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) ;
static DbPage *sqlite3PagerLookup(Pager *pPager , Pgno pgno ) ;
static void sqlite3PagerRef(DbPage *pPg ) ;
static void sqlite3PagerUnref(DbPage *pPg ) ;
static void sqlite3PagerUnrefNotNull(DbPage *pPg ) ;
static void sqlite3PagerUnrefPageOne(DbPage *pPg ) ;
static int sqlite3PagerWrite(struct PgHdr *pPg ) ;
static void sqlite3PagerDontWrite(struct PgHdr *pPg ) ;
static int sqlite3PagerMovepage(Pager *pPager , DbPage *pPg , Pgno pgno , int isCommit ) ;
static int sqlite3PagerPageRefcount(DbPage *pPage ) ;
static void *sqlite3PagerGetData(DbPage *pPg ) ;
static void *sqlite3PagerGetExtra(DbPage *pPg ) ;
static void sqlite3PagerPagecount(Pager *pPager , int *pnPage ) ;
static int sqlite3PagerBegin(Pager *pPager , int exFlag , int subjInMemory ) ;
static int sqlite3PagerCommitPhaseOne(Pager *pPager , char const   *zMaster , int noSync ) ;
static int sqlite3PagerExclusiveLock(Pager *pPager ) ;
static int sqlite3PagerSync(Pager *pPager , char const   *zMaster ) ;
static int sqlite3PagerCommitPhaseTwo(Pager *pPager ) ;
static int sqlite3PagerRollback(Pager *pPager ) ;
static int sqlite3PagerOpenSavepoint(Pager *pPager , int nSavepoint ) ;
static int sqlite3PagerSavepoint(Pager *pPager , int op , int iSavepoint ) ;
static int sqlite3PagerSharedLock(Pager *pPager ) ;
static int sqlite3PagerCheckpoint(Pager *pPager , sqlite3 *db , int eMode , int *pnLog ,
                                  int *pnCkpt ) ;
static int sqlite3PagerWalSupported(Pager *pPager ) ;
static int sqlite3PagerWalCallback(Pager *pPager ) ;
static int sqlite3PagerOpenWal(Pager *pPager , int *pbOpen ) ;
static int sqlite3PagerCloseWal(Pager *pPager , sqlite3 *db ) ;
static u8 sqlite3PagerIsreadonly(Pager *pPager ) ;
static u32 sqlite3PagerDataVersion(Pager *pPager ) ;
static int sqlite3PagerMemUsed(Pager *pPager ) ;
static char const   *sqlite3PagerFilename(Pager *pPager , int nullIfMemDb ) ;
static sqlite3_vfs *sqlite3PagerVfs(Pager *pPager ) ;
static sqlite3_file *sqlite3PagerFile(Pager *pPager ) ;
static sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager ) ;
static char const   *sqlite3PagerJournalname(Pager *pPager ) ;
static void *sqlite3PagerTempSpace(Pager *pPager ) ;
static int sqlite3PagerIsMemdb(Pager *pPager ) ;
static void sqlite3PagerCacheStat(Pager *pPager , int eStat , int reset , int *pnVal ) ;
static void sqlite3PagerClearCache(Pager *pPager ) ;
static int sqlite3SectorSize(sqlite3_file *pFile ) ;
static void sqlite3PagerTruncateImage(Pager *pPager , Pgno nPage ) ;
static void sqlite3PagerRekey(DbPage *pPg , Pgno iNew , u16 flags___0 ) ;
static int sqlite3PcacheInitialize(void) ;
static void sqlite3PcacheShutdown(void) ;
static void sqlite3PCacheBufferSetup(void *pBuf , int sz , int n ) ;
static int sqlite3PcacheOpen(int szPage , int szExtra , int bPurgeable , int (*xStress)(void * ,
                                                                                        PgHdr * ) ,
                             void *pStress , PCache *p ) ;
static int sqlite3PcacheSetPageSize(PCache *pCache , int szPage ) ;
static int sqlite3PcacheSize(void) ;
static sqlite3_pcache_page *sqlite3PcacheFetch(PCache *pCache , Pgno pgno , int createFlag ) ;
static int sqlite3PcacheFetchStress(PCache *pCache , Pgno pgno , sqlite3_pcache_page **ppPage ) ;
static PgHdr *sqlite3PcacheFetchFinish(PCache *pCache , Pgno pgno , sqlite3_pcache_page *pPage ) ;
static void ( __attribute__((__noinline__)) sqlite3PcacheRelease)(PgHdr *p ) ;
static void sqlite3PcacheDrop(PgHdr *p ) ;
static void sqlite3PcacheMakeDirty(PgHdr *p ) ;
static void sqlite3PcacheMakeClean(PgHdr *p ) ;
static void sqlite3PcacheCleanAll(PCache *pCache ) ;
static void sqlite3PcacheClearWritable(PCache *pCache ) ;
static void sqlite3PcacheMove(PgHdr *p , Pgno newPgno ) ;
static void sqlite3PcacheTruncate(PCache *pCache , Pgno pgno ) ;
static PgHdr *sqlite3PcacheDirtyList(PCache *pCache ) ;
static void sqlite3PcacheClose(PCache *pCache ) ;
static void sqlite3PcacheClearSyncFlags(PCache *pCache ) ;
static void sqlite3PcacheClear(PCache *pCache ) ;
static int sqlite3PcacheRefCount(PCache *pCache ) ;
static void sqlite3PcacheRef(PgHdr *p ) ;
static int sqlite3PcachePageRefcount(PgHdr *p ) ;
static int sqlite3PcachePagecount(PCache *pCache ) ;
static void sqlite3PcacheSetCachesize(PCache *pCache , int mxPage ) ;
static int sqlite3PcacheSetSpillsize(PCache *p , int mxPage ) ;
static void sqlite3PcacheShrink(PCache *pCache ) ;
static void sqlite3PCacheSetDefault(void) ;
static int sqlite3HeaderSizePcache(void) ;
static int sqlite3HeaderSizePcache1(void) ;
static int sqlite3PCachePercentDirty(PCache *pCache ) ;
static int sqlite3OsInit(void) ;
static void sqlite3OsClose(sqlite3_file *pId ) ;
static int sqlite3OsRead(sqlite3_file *id , void *pBuf , int amt , i64 offset ) ;
static int sqlite3OsWrite(sqlite3_file *id , void const   *pBuf , int amt , i64 offset ) ;
static int sqlite3OsTruncate(sqlite3_file *id , i64 size ) ;
static int sqlite3OsSync(sqlite3_file *id , int flags___0 ) ;
static int sqlite3OsFileSize(sqlite3_file *id , i64 *pSize ) ;
static int sqlite3OsLock(sqlite3_file *id , int lockType ) ;
static int sqlite3OsUnlock(sqlite3_file *id , int lockType ) ;
static int sqlite3OsCheckReservedLock(sqlite3_file *id , int *pResOut ) ;
static int sqlite3OsFileControl(sqlite3_file *id , int op , void *pArg ) ;
static void sqlite3OsFileControlHint(sqlite3_file *id , int op , void *pArg ) ;
static int sqlite3OsSectorSize(sqlite3_file *id ) ;
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id ) ;
static int sqlite3OsShmMap(sqlite3_file *id , int iPage , int pgsz___0 , int bExtend ,
                           void volatile   **pp ) ;
static int sqlite3OsShmLock(sqlite3_file *id , int offset , int n , int flags___0 ) ;
static void sqlite3OsShmBarrier(sqlite3_file *id ) ;
static int sqlite3OsShmUnmap(sqlite3_file *id , int deleteFlag ) ;
static int sqlite3OsFetch(sqlite3_file *id , i64 iOff , int iAmt , void **pp ) ;
static int sqlite3OsUnfetch(sqlite3_file *id , i64 iOff , void *p ) ;
static int sqlite3OsOpen(sqlite3_vfs *pVfs , char const   *zPath , sqlite3_file *pFile ,
                         int flags___0 , int *pFlagsOut ) ;
static int sqlite3OsDelete(sqlite3_vfs *pVfs , char const   *zPath , int dirSync ) ;
static int sqlite3OsAccess(sqlite3_vfs *pVfs , char const   *zPath , int flags___0 ,
                           int *pResOut ) ;
static int sqlite3OsFullPathname(sqlite3_vfs *pVfs , char const   *zPath , int nPathOut ,
                                 char *zPathOut ) ;
static int sqlite3OsRandomness(sqlite3_vfs *pVfs , int nByte , char *zBufOut ) ;
static int sqlite3OsSleep(sqlite3_vfs *pVfs , int nMicro ) ;
static int sqlite3OsGetLastError(sqlite3_vfs *pVfs ) ;
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs , sqlite_int64 *pTimeOut ) ;
static int sqlite3OsOpenMalloc(sqlite3_vfs *pVfs , char const   *zFile , sqlite3_file **ppFile ,
                               int flags___0 , int *pOutFlags ) ;
static void sqlite3OsCloseFree(sqlite3_file *pFile ) ;
static int sqlite3WalkExpr(Walker *pWalker , Expr *pExpr ) ;
static int sqlite3WalkExprList(Walker *pWalker , ExprList *p ) ;
static int sqlite3WalkSelect(Walker *pWalker , Select *p ) ;
static int sqlite3WalkSelectExpr(Walker *pWalker , Select *p ) ;
static int sqlite3WalkSelectFrom(Walker *pWalker , Select *p ) ;
static int sqlite3ExprWalkNoop(Walker *NotUsed , Expr *NotUsed2 ) ;
static int sqlite3SelectWalkNoop(Walker *NotUsed , Select *NotUsed2 ) ;
static int sqlite3SelectWalkFail(Walker *pWalker , Select *NotUsed ) ;
static void sqlite3WindowDelete(sqlite3 *db , Window *p ) ;
static void sqlite3WindowUnlinkFromSelect(Window *p ) ;
static void sqlite3WindowListDelete(sqlite3 *db , Window *p ) ;
static Window *sqlite3WindowAlloc(Parse *pParse , int eType , int eStart , Expr *pStart ,
                                  int eEnd , Expr *pEnd , u8 eExclude ) ;
static void sqlite3WindowAttach(Parse *pParse , Expr *p , Window *pWin ) ;
static void sqlite3WindowLink(Select *pSel , Window *pWin ) ;
static int sqlite3WindowCompare(Parse *pParse , Window *p1 , Window *p2 , int bFilter ) ;
static void sqlite3WindowCodeInit(Parse *pParse , Window *pMWin ) ;
static void sqlite3WindowCodeStep(Parse *pParse , Select *p , WhereInfo *pWInfo ,
                                  int regGosub , int addrGosub ) ;
static int sqlite3WindowRewrite(Parse *pParse , Select *p ) ;
static int sqlite3ExpandSubquery(Parse *pParse , struct SrcList_item *pFrom ) ;
static void sqlite3WindowUpdate(Parse *pParse , Window *pList , Window *pWin , FuncDef *pFunc ) ;
static Window *sqlite3WindowDup(sqlite3 *db , Expr *pOwner , Window *p ) ;
static Window *sqlite3WindowListDup(sqlite3 *db , Window *p ) ;
static void sqlite3WindowFunctions(void) ;
static void sqlite3WindowChain(Parse *pParse , Window *pWin , Window *pList ) ;
static Window *sqlite3WindowAssemble(Parse *pParse , Window *pWin , ExprList *pPartition ,
                                     ExprList *pOrderBy , Token *pBase ) ;
static int sqlite3ReportError(int iErr , int lineno , char const   *zType ) ;
static int sqlite3CorruptError(int lineno ) ;
static int sqlite3MisuseError(int lineno ) ;
static int sqlite3CantopenError(int lineno ) ;
static int sqlite3IsIdChar(u8 c ) ;
static int sqlite3StrICmp(char const   *zLeft , char const   *zRight ) ;
static int sqlite3Strlen30(char const   *z ) ;
static char *sqlite3ColumnType(Column *pCol , char *zDflt ) ;
static int sqlite3MallocInit(void) ;
static void sqlite3MallocEnd(void) ;
static void *sqlite3Malloc(u64 n ) ;
static void *sqlite3MallocZero(u64 n ) ;
static void *sqlite3DbMallocZero(sqlite3 *db , u64 n ) ;
static void *sqlite3DbMallocRaw(sqlite3 *db , u64 n ) ;
static void *sqlite3DbMallocRawNN(sqlite3 *db , u64 n ) ;
static char *sqlite3DbStrDup(sqlite3 *db , char const   *z ) ;
static char *sqlite3DbStrNDup(sqlite3 *db , char const   *z , u64 n ) ;
static char *sqlite3DbSpanDup(sqlite3 *db , char const   *zStart , char const   *zEnd ) ;
static void *sqlite3Realloc(void *pOld , u64 nBytes ) ;
static void *sqlite3DbReallocOrFree(sqlite3 *db , void *p , u64 n ) ;
static void *sqlite3DbRealloc(sqlite3 *db , void *p , u64 n ) ;
static void sqlite3DbFree(sqlite3 *db , void *p ) ;
static void sqlite3DbFreeNN(sqlite3 *db , void *p ) ;
static int sqlite3MallocSize(void *p ) ;
static int sqlite3DbMallocSize(sqlite3 *db , void *p ) ;
static void *sqlite3PageMalloc(int sz ) ;
static void sqlite3PageFree(void *p ) ;
static void sqlite3MemSetDefault(void) ;
static void sqlite3BenignMallocHooks(void (*xBenignBegin)(void) , void (*xBenignEnd)(void) ) ;
static int sqlite3HeapNearlyFull(void) ;
static sqlite_int64 sqlite3StatusValue(int op ) ;
static void sqlite3StatusUp(int op , int N ) ;
static void sqlite3StatusDown(int op , int N ) ;
static void sqlite3StatusHighwater(int op , int X ) ;
static int sqlite3LookasideUsed(sqlite3 *db , int *pHighwater ) ;
static sqlite3_mutex *sqlite3Pcache1Mutex(void) ;
static sqlite3_mutex *sqlite3MallocMutex(void) ;
static int sqlite3IsNaN(double x___0 ) ;
static char *sqlite3MPrintf(sqlite3 *db , char const   *zFormat  , ...) ;
static char *sqlite3VMPrintf(sqlite3 *db , char const   *zFormat , va_list ap ) ;
static void sqlite3SetString(char **pz , sqlite3 *db , char const   *zNew ) ;
static void sqlite3ErrorMsg(Parse *pParse , char const   *zFormat  , ...) ;
static int sqlite3ErrorToParser(sqlite3 *db , int errCode ) ;
static void sqlite3Dequote(char *z ) ;
static void sqlite3DequoteExpr(Expr *p ) ;
static void sqlite3TokenInit(Token *p , char *z ) ;
static int sqlite3KeywordCode(unsigned char const   *z , int n ) ;
static int sqlite3RunParser(Parse *pParse , char const   *zSql , char **pzErrMsg ) ;
static void sqlite3FinishCoding(Parse *pParse ) ;
static int sqlite3GetTempReg(Parse *pParse ) ;
static void sqlite3ReleaseTempReg(Parse *pParse , int iReg ) ;
static int sqlite3GetTempRange(Parse *pParse , int nReg ) ;
static void sqlite3ReleaseTempRange(Parse *pParse , int iReg , int nReg ) ;
static void sqlite3ClearTempRegCache(Parse *pParse ) ;
static Expr *sqlite3ExprAlloc(sqlite3 *db , int op , Token const   *pToken , int dequote ) ;
static Expr *sqlite3Expr(sqlite3 *db , int op , char const   *zToken ) ;
static void sqlite3ExprAttachSubtrees(sqlite3 *db , Expr *pRoot , Expr *pLeft , Expr *pRight ) ;
static Expr *sqlite3PExpr(Parse *pParse , int op , Expr *pLeft , Expr *pRight ) ;
static void sqlite3PExprAddSelect(Parse *pParse , Expr *pExpr , Select *pSelect ) ;
static Expr *sqlite3ExprAnd(Parse *pParse , Expr *pLeft , Expr *pRight ) ;
static Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr ) ;
static Expr *sqlite3ExprFunction(Parse *pParse , ExprList *pList , Token *pToken ,
                                 int eDistinct ) ;
static void sqlite3ExprAssignVarNumber(Parse *pParse , Expr *pExpr , u32 n ) ;
static void sqlite3ExprDelete(sqlite3 *db , Expr *p ) ;
static void sqlite3ExprUnmapAndDelete(Parse *pParse , Expr *p ) ;
static ExprList *sqlite3ExprListAppend(Parse *pParse , ExprList *pList , Expr *pExpr ) ;
static ExprList *sqlite3ExprListAppendVector(Parse *pParse , ExprList *pList , IdList *pColumns ,
                                             Expr *pExpr ) ;
static void sqlite3ExprListSetSortOrder(ExprList *p , int iSortOrder , int eNulls ) ;
static void sqlite3ExprListSetName(Parse *pParse , ExprList *pList , Token *pName ,
                                   int dequote ) ;
static void sqlite3ExprListSetSpan(Parse *pParse , ExprList *pList , char const   *zStart ,
                                   char const   *zEnd ) ;
static void sqlite3ExprListDelete(sqlite3 *db , ExprList *pList ) ;
static u32 sqlite3ExprListFlags(ExprList const   *pList ) ;
static int sqlite3IndexHasDuplicateRootPage(Index *pIndex ) ;
static int sqlite3Init(sqlite3 *db , char **pzErrMsg ) ;
static int sqlite3InitCallback(void *pInit , int argc , char **argv , char **NotUsed ) ;
static int sqlite3InitOne(sqlite3 *db , int iDb , char **pzErrMsg , u32 mFlags ) ;
static void sqlite3Pragma(Parse *pParse , Token *pId1 , Token *pId2 , Token *pValue ,
                          int minusFlag ) ;
static Module *sqlite3PragmaVtabRegister(sqlite3 *db , char const   *zName ) ;
static void sqlite3ResetAllSchemasOfConnection(sqlite3 *db ) ;
static void sqlite3ResetOneSchema(sqlite3 *db , int iDb ) ;
static void sqlite3CollapseDatabaseArray(sqlite3 *db ) ;
static void sqlite3CommitInternalChanges(sqlite3 *db ) ;
static void sqlite3DeleteColumnNames(sqlite3 *db , Table *pTable ) ;
static int sqlite3ColumnsFromExprList(Parse *pParse , ExprList *pEList , i16 *pnCol ,
                                      Column **paCol ) ;
static void sqlite3SelectAddColumnTypeAndCollation(Parse *pParse , Table *pTab , Select *pSelect ,
                                                   char aff ) ;
static Table *sqlite3ResultSetOfSelect(Parse *pParse , Select *pSelect , char aff ) ;
static void sqlite3OpenMasterTable(Parse *p , int iDb ) ;
static Index *sqlite3PrimaryKeyIndex(Table *pTab ) ;
static i16 sqlite3ColumnOfIndex(Index *pIdx , i16 iCol ) ;
static void sqlite3StartTable(Parse *pParse , Token *pName1 , Token *pName2 , int isTemp ,
                              int isView , int isVirtual , int noErr ) ;
static void sqlite3AddColumn(Parse *pParse , Token *pName , Token *pType ) ;
static void sqlite3AddNotNull(Parse *pParse , int onError ) ;
static void sqlite3AddPrimaryKey(Parse *pParse , ExprList *pList , int onError , int autoInc___0 ,
                                 int sortOrder ) ;
static void sqlite3AddCheckConstraint(Parse *pParse , Expr *pCheckExpr ) ;
static void sqlite3AddDefaultValue(Parse *pParse , Expr *pExpr , char const   *zStart ,
                                   char const   *zEnd ) ;
static void sqlite3AddCollateType(Parse *pParse , Token *pToken ) ;
static void sqlite3EndTable(Parse *pParse , Token *pCons , Token *pEnd , u8 tabOpts ,
                            Select *pSelect ) ;
static int sqlite3ParseUri(char const   *zDefaultVfs , char const   *zUri , unsigned int *pFlags ,
                           sqlite3_vfs **ppVfs , char **pzFile , char **pzErrMsg ) ;
static Btree *sqlite3DbNameToBtree(sqlite3 *db , char const   *zDbName ) ;
static int sqlite3FaultSim(int iTest ) ;
static Bitvec *sqlite3BitvecCreate(u32 iSize ) ;
static int sqlite3BitvecTest(Bitvec *p , u32 i ) ;
static int sqlite3BitvecTestNotNull(Bitvec *p , u32 i ) ;
static int sqlite3BitvecSet(Bitvec *p , u32 i ) ;
static void sqlite3BitvecClear(Bitvec *p , u32 i , void *pBuf ) ;
static void sqlite3BitvecDestroy(Bitvec *p ) ;
static u32 sqlite3BitvecSize(Bitvec *p ) ;
static int sqlite3BitvecBuiltinTest(int sz , int *aOp___1 ) ;
static RowSet *sqlite3RowSetInit(sqlite3 *db ) ;
static void sqlite3RowSetDelete(void *pArg ) ;
static void sqlite3RowSetClear(void *pArg ) ;
static void sqlite3RowSetInsert(RowSet *p , i64 rowid ) ;
static int sqlite3RowSetTest(RowSet *pRowSet , int iBatch , long long iRowid ) ;
static int sqlite3RowSetNext(RowSet *p , i64 *pRowid ) ;
static void sqlite3CreateView(Parse *pParse , Token *pBegin , Token *pName1 , Token *pName2 ,
                              ExprList *pCNames , Select *pSelect , int isTemp , int noErr ) ;
static int sqlite3ViewGetColumnNames(Parse *pParse , Table *pTable ) ;
static void sqlite3DropTable(Parse *pParse , SrcList *pName , int isView , int noErr ) ;
static void sqlite3CodeDropTable(Parse *pParse , Table *pTab , int iDb , int isView ) ;
static void sqlite3DeleteTable(sqlite3 *db , Table *pTable ) ;
static void sqlite3FreeIndex(sqlite3 *db , Index *p ) ;
static void sqlite3AutoincrementBegin(Parse *pParse ) ;
static void sqlite3AutoincrementEnd(Parse *pParse ) ;
static void sqlite3Insert(Parse *pParse , SrcList *pTabList , Select *pSelect , IdList *pColumn ,
                          int onError , Upsert *pUpsert ) ;
static void *sqlite3ArrayAllocate(sqlite3 *db , void *pArray , int szEntry , int *pnEntry ,
                                  int *pIdx ) ;
static IdList *sqlite3IdListAppend(Parse *pParse , IdList *pList , Token *pToken ) ;
static int sqlite3IdListIndex(IdList *pList , char const   *zName ) ;
static SrcList *sqlite3SrcListEnlarge(Parse *pParse , SrcList *pSrc , int nExtra ,
                                      int iStart ) ;
static SrcList *sqlite3SrcListAppend(Parse *pParse , SrcList *pList , Token *pTable ,
                                     Token *pDatabase ) ;
static SrcList *sqlite3SrcListAppendFromTerm(Parse *pParse , SrcList *p , Token *pTable ,
                                             Token *pDatabase , Token *pAlias , Select *pSubquery ,
                                             Expr *pOn , IdList *pUsing ) ;
static void sqlite3SrcListIndexedBy(Parse *pParse , SrcList *p , Token *pIndexedBy ) ;
static void sqlite3SrcListFuncArgs(Parse *pParse , SrcList *p , ExprList *pList ) ;
static int sqlite3IndexedByLookup(Parse *pParse , struct SrcList_item *pFrom ) ;
static void sqlite3SrcListShiftJoinType(SrcList *p ) ;
static void sqlite3SrcListAssignCursors(Parse *pParse , SrcList *pList ) ;
static void sqlite3IdListDelete(sqlite3 *db , IdList *pList ) ;
static void sqlite3SrcListDelete(sqlite3 *db , SrcList *pList ) ;
static Index *sqlite3AllocateIndexObject(sqlite3 *db , i16 nCol , int nExtra , char **ppExtra ) ;
static void sqlite3CreateIndex(Parse *pParse , Token *pName1 , Token *pName2 , SrcList *pTblName ,
                               ExprList *pList , int onError , Token *pStart , Expr *pPIWhere ,
                               int sortOrder , int ifNotExist , u8 idxType ) ;
static void sqlite3DropIndex(Parse *pParse , SrcList *pName , int ifExists ) ;
static int sqlite3Select(Parse *pParse , Select *p , SelectDest *pDest ) ;
static Select *sqlite3SelectNew(Parse *pParse , ExprList *pEList , SrcList *pSrc ,
                                Expr *pWhere , ExprList *pGroupBy , Expr *pHaving ,
                                ExprList *pOrderBy , u32 selFlags , Expr *pLimit ) ;
static void sqlite3SelectDelete(sqlite3 *db , Select *p ) ;
static Table *sqlite3SrcListLookup(Parse *pParse , SrcList *pSrc ) ;
static int sqlite3IsReadOnly(Parse *pParse , Table *pTab , int viewOk ) ;
static void sqlite3OpenTable(Parse *pParse , int iCur , int iDb , Table *pTab , int opcode ) ;
static void sqlite3DeleteFrom(Parse *pParse , SrcList *pTabList , Expr *pWhere , ExprList *pOrderBy ,
                              Expr *pLimit ) ;
static void sqlite3Update(Parse *pParse , SrcList *pTabList , ExprList *pChanges ,
                          Expr *pWhere , int onError , ExprList *pOrderBy , Expr *pLimit ,
                          Upsert *pUpsert ) ;
static WhereInfo *sqlite3WhereBegin(Parse *pParse , SrcList *pTabList , Expr *pWhere ,
                                    ExprList *pOrderBy , ExprList *pResultSet , u16 wctrlFlags ,
                                    int iAuxArg ) ;
static void sqlite3WhereEnd(WhereInfo *pWInfo ) ;
static LogEst sqlite3WhereOutputRowCount(WhereInfo *pWInfo ) ;
static int sqlite3WhereIsDistinct(WhereInfo *pWInfo ) ;
static int sqlite3WhereIsOrdered(WhereInfo *pWInfo ) ;
static int sqlite3WhereOrderByLimitOptLabel(WhereInfo *pWInfo ) ;
static int sqlite3WhereIsSorted(WhereInfo *pWInfo ) ;
static int sqlite3WhereContinueLabel(WhereInfo *pWInfo ) ;
static int sqlite3WhereBreakLabel(WhereInfo *pWInfo ) ;
static int sqlite3WhereOkOnePass(WhereInfo *pWInfo , int *aiCur ) ;
static void sqlite3ExprCodeLoadIndexColumn(Parse *pParse , Index *pIdx , int iTabCur ,
                                           int iIdxCol , int regOut ) ;
static int sqlite3ExprCodeGetColumn(Parse *pParse , Table *pTab , int iColumn , int iTable ,
                                    int iReg , u8 p5 ) ;
static void sqlite3ExprCodeGetColumnOfTable(Vdbe *v , Table *pTab , int iTabCur ,
                                            int iCol , int regOut ) ;
static void sqlite3ExprCodeMove(Parse *pParse , int iFrom , int iTo , int nReg ) ;
static void sqlite3ExprCode(Parse *pParse , Expr *pExpr , int target ) ;
static void sqlite3ExprCodeCopy(Parse *pParse , Expr *pExpr , int target ) ;
static void sqlite3ExprCodeFactorable(Parse *pParse , Expr *pExpr , int target ) ;
static int sqlite3ExprCodeAtInit(Parse *pParse , Expr *pExpr , int regDest ) ;
static int sqlite3ExprCodeTemp(Parse *pParse , Expr *pExpr , int *pReg ) ;
static int sqlite3ExprCodeTarget(Parse *pParse , Expr *pExpr , int target ) ;
static void sqlite3ExprCodeAndCache(Parse *pParse , Expr *pExpr , int target ) ;
static int sqlite3ExprCodeExprList(Parse *pParse , ExprList *pList , int target ,
                                   int srcReg , u8 flags___0 ) ;
static void sqlite3ExprIfTrue(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull ) ;
static void sqlite3ExprIfFalse(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull ) ;
static void sqlite3ExprIfFalseDup(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull ) ;
static Table *sqlite3FindTable(sqlite3 *db , char const   *zName , char const   *zDatabase ) ;
static Table *sqlite3LocateTable(Parse *pParse , u32 flags___0 , char const   *zName ,
                                 char const   *zDbase ) ;
static Table *sqlite3LocateTableItem(Parse *pParse , u32 flags___0 , struct SrcList_item *p ) ;
static Index *sqlite3FindIndex(sqlite3 *db , char const   *zName , char const   *zDb ) ;
static void sqlite3UnlinkAndDeleteTable(sqlite3 *db , int iDb , char const   *zTabName ) ;
static void sqlite3UnlinkAndDeleteIndex(sqlite3 *db , int iDb , char const   *zIdxName ) ;
static void sqlite3Vacuum(Parse *pParse , Token *pNm , Expr *pInto ) ;
static int ( __attribute__((__noinline__)) sqlite3RunVacuum)(char **pzErrMsg , sqlite3 *db ,
                                                             int iDb , sqlite3_value *pOut ) ;
static char *sqlite3NameFromToken(sqlite3 *db , Token *pName ) ;
static int sqlite3ExprCompare(Parse *pParse , Expr *pA , Expr *pB , int iTab ) ;
static int sqlite3ExprCompareSkip(Expr *pA , Expr *pB , int iTab ) ;
static int sqlite3ExprListCompare(ExprList *pA , ExprList *pB , int iTab ) ;
static int sqlite3ExprImpliesExpr(Parse *pParse , Expr *pE1 , Expr *pE2 , int iTab ) ;
static int sqlite3ExprImpliesNonNullRow(Expr *p , int iTab ) ;
static void sqlite3ExprAnalyzeAggregates(NameContext *pNC , Expr *pExpr ) ;
static void sqlite3ExprAnalyzeAggList(NameContext *pNC , ExprList *pList ) ;
static int sqlite3ExprCoveredByIndex(Expr *pExpr , int iCur , Index *pIdx ) ;
static int sqlite3FunctionUsesThisSrc(Expr *pExpr , SrcList *pSrcList ) ;
static Vdbe *sqlite3GetVdbe(Parse *pParse ) ;
static void sqlite3PrngSaveState(void) ;
static void sqlite3PrngRestoreState(void) ;
static void sqlite3RollbackAll(sqlite3 *db , int tripCode ) ;
static void sqlite3CodeVerifySchema(Parse *pParse , int iDb ) ;
static void sqlite3CodeVerifyNamedSchema(Parse *pParse , char const   *zDb ) ;
static void sqlite3BeginTransaction(Parse *pParse , int type ) ;
static void sqlite3EndTransaction(Parse *pParse , int eType ) ;
static void sqlite3Savepoint(Parse *pParse , int op , Token *pName ) ;
static void sqlite3CloseSavepoints(sqlite3 *db ) ;
static void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db ) ;
static int sqlite3ExprIdToTrueFalse(Expr *pExpr ) ;
static int sqlite3ExprTruthValue(Expr const   *pExpr ) ;
static int sqlite3ExprIsConstant(Expr *p ) ;
static int sqlite3ExprIsConstantNotJoin(Expr *p ) ;
static int sqlite3ExprIsConstantOrFunction(Expr *p , u8 isInit ) ;
static int sqlite3ExprIsConstantOrGroupBy(Parse *pParse , Expr *p , ExprList *pGroupBy ) ;
static int sqlite3ExprIsTableConstant(Expr *p , int iCur ) ;
static int sqlite3ExprIsInteger(Expr *p , int *pValue ) ;
static int sqlite3ExprCanBeNull(Expr const   *p ) ;
static int sqlite3ExprNeedsNoAffinityChange(Expr const   *p , char aff ) ;
static int sqlite3IsRowid(char const   *z ) ;
static void sqlite3GenerateRowDelete(Parse *pParse , Table *pTab , Trigger *pTrigger ,
                                     int iDataCur , int iIdxCur , int iPk , i16 nPk ,
                                     u8 count , u8 onconf , u8 eMode , int iIdxNoSeek ) ;
static void sqlite3GenerateRowIndexDelete(Parse *pParse , Table *pTab , int iDataCur ,
                                          int iIdxCur , int *aRegIdx , int iIdxNoSeek ) ;
static int sqlite3GenerateIndexKey(Parse *pParse , Index *pIdx , int iDataCur , int regOut ,
                                   int prefixOnly , int *piPartIdxLabel , Index *pPrior ,
                                   int regPrior ) ;
static void sqlite3ResolvePartIdxLabel(Parse *pParse , int iLabel ) ;
static int sqlite3ExprReferencesUpdatedColumn(Expr *pExpr , int *aiChng , int chngRowid ) ;
static void sqlite3GenerateConstraintChecks(Parse *pParse , Table *pTab , int *aRegIdx ,
                                            int iDataCur , int iIdxCur , int regNewData ,
                                            int regOldData , u8 pkChng , u8 overrideError ,
                                            int ignoreDest , int *pbMayReplace , int *aiChng ,
                                            Upsert *pUpsert ) ;
static void sqlite3CompleteInsertion(Parse *pParse , Table *pTab , int iDataCur ,
                                     int iIdxCur , int regNewData , int *aRegIdx ,
                                     int update_flags , int appendBias , int useSeekResult ) ;
static int sqlite3OpenTableAndIndices(Parse *pParse , Table *pTab , int op , u8 p5 ,
                                      int iBase , u8 *aToOpen , int *piDataCur , int *piIdxCur ) ;
static void sqlite3BeginWriteOperation(Parse *pParse , int setStatement , int iDb ) ;
static void sqlite3MultiWrite(Parse *pParse ) ;
static void sqlite3MayAbort(Parse *pParse ) ;
static void sqlite3HaltConstraint(Parse *pParse , int errCode , int onError , char *p4 ,
                                  i8 p4type , u8 p5Errmsg ) ;
static void sqlite3UniqueConstraint(Parse *pParse , int onError , Index *pIdx ) ;
static void sqlite3RowidConstraint(Parse *pParse , int onError , Table *pTab ) ;
static Expr *sqlite3ExprDup(sqlite3 *db , Expr *p , int flags___0 ) ;
static ExprList *sqlite3ExprListDup(sqlite3 *db , ExprList *p , int flags___0 ) ;
static SrcList *sqlite3SrcListDup(sqlite3 *db , SrcList *p , int flags___0 ) ;
static IdList *sqlite3IdListDup(sqlite3 *db , IdList *p ) ;
static Select *sqlite3SelectDup(sqlite3 *db , Select *pDup , int flags___0 ) ;
static FuncDef *sqlite3FunctionSearch(int h , char const   *zFunc ) ;
static void sqlite3InsertBuiltinFuncs(FuncDef *aDef , int nDef ) ;
static FuncDef *sqlite3FindFunction(sqlite3 *db , char const   *zName , int nArg ,
                                    u8 enc , u8 createFlag ) ;
static void sqlite3RegisterBuiltinFunctions(void) ;
static void sqlite3RegisterDateTimeFunctions(void) ;
static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db ) ;
static int sqlite3SafetyCheckOk(sqlite3 *db ) ;
static int sqlite3SafetyCheckSickOrOk(sqlite3 *db ) ;
static void sqlite3ChangeCookie(Parse *pParse , int iDb ) ;
static void sqlite3MaterializeView(Parse *pParse , Table *pView , Expr *pWhere , ExprList *pOrderBy ,
                                   Expr *pLimit , int iCur ) ;
static void sqlite3BeginTrigger(Parse *pParse , Token *pName1 , Token *pName2 , int tr_tm ,
                                int op , IdList *pColumns , SrcList *pTableName ,
                                Expr *pWhen , int isTemp , int noErr ) ;
static void sqlite3FinishTrigger(Parse *pParse , TriggerStep *pStepList , Token *pAll ) ;
static void sqlite3DropTrigger(Parse *pParse , SrcList *pName , int noErr ) ;
static void sqlite3DropTriggerPtr(Parse *pParse , Trigger *pTrigger ) ;
static Trigger *sqlite3TriggersExist(Parse *pParse , Table *pTab , int op , ExprList *pChanges ,
                                     int *pMask ) ;
static Trigger *sqlite3TriggerList(Parse *pParse , Table *pTab ) ;
static void sqlite3CodeRowTrigger(Parse *pParse , Trigger *pTrigger , int op , ExprList *pChanges ,
                                  int tr_tm , Table *pTab , int reg , int orconf ,
                                  int ignoreJump ) ;
static void sqlite3CodeRowTriggerDirect(Parse *pParse , Trigger *p , Table *pTab ,
                                        int reg , int orconf , int ignoreJump ) ;
static void sqlite3DeleteTriggerStep(sqlite3 *db , TriggerStep *pTriggerStep ) ;
static TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db , Select *pSelect , char const   *zStart ,
                                             char const   *zEnd ) ;
static TriggerStep *sqlite3TriggerInsertStep(Parse *pParse , Token *pTableName , IdList *pColumn ,
                                             Select *pSelect , u8 orconf , Upsert *pUpsert ,
                                             char const   *zStart , char const   *zEnd ) ;
static TriggerStep *sqlite3TriggerUpdateStep(Parse *pParse , Token *pTableName , ExprList *pEList ,
                                             Expr *pWhere , u8 orconf , char const   *zStart ,
                                             char const   *zEnd ) ;
static TriggerStep *sqlite3TriggerDeleteStep(Parse *pParse , Token *pTableName , Expr *pWhere ,
                                             char const   *zStart , char const   *zEnd ) ;
static void sqlite3DeleteTrigger(sqlite3 *db , Trigger *pTrigger ) ;
static void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db , int iDb , char const   *zName ) ;
static u32 sqlite3TriggerColmask(Parse *pParse , Trigger *pTrigger , ExprList *pChanges ,
                                 int isNew , int tr_tm , Table *pTab , int orconf ) ;
static int sqlite3JoinType(Parse *pParse , Token *pA , Token *pB , Token *pC ) ;
static void sqlite3CreateForeignKey(Parse *pParse , ExprList *pFromCol , Token *pTo ,
                                    ExprList *pToCol , int flags___0 ) ;
static void sqlite3DeferForeignKey(Parse *pParse , int isDeferred ) ;
static void sqlite3AuthRead(Parse *pParse , Expr *pExpr , Schema *pSchema , SrcList *pTabList ) ;
static int sqlite3AuthCheck(Parse *pParse , int code , char const   *zArg1 , char const   *zArg2 ,
                            char const   *zArg3 ) ;
static void sqlite3AuthContextPush(Parse *pParse , AuthContext *pContext , char const   *zContext ) ;
static void sqlite3AuthContextPop(AuthContext *pContext ) ;
static int sqlite3AuthReadCol(Parse *pParse , char const   *zTab , char const   *zCol ,
                              int iDb ) ;
static void sqlite3Attach(Parse *pParse , Expr *p , Expr *pDbname , Expr *pKey ) ;
static void sqlite3Detach(Parse *pParse , Expr *pDbname ) ;
static void sqlite3FixInit(DbFixer *pFix , Parse *pParse , int iDb , char const   *zType ,
                           Token const   *pName ) ;
static int sqlite3FixSrcList(DbFixer *pFix , SrcList *pList ) ;
static int sqlite3FixSelect(DbFixer *pFix , Select *pSelect ) ;
static int sqlite3FixExpr(DbFixer *pFix , Expr *pExpr ) ;
static int sqlite3FixExprList(DbFixer *pFix , ExprList *pList ) ;
static int sqlite3FixTriggerStep(DbFixer *pFix , TriggerStep *pStep ) ;
static int sqlite3RealSameAsInt(double r1 , sqlite_int64 i ) ;
static int sqlite3AtoF(char const   *z , double *pResult , int length , u8 enc ) ;
static int sqlite3GetInt32(char const   *zNum , int *pValue ) ;
static int sqlite3Atoi(char const   *z ) ;
static int sqlite3Utf16ByteLen(void const   *zIn , int nChar ) ;
static int sqlite3Utf8CharLen(char const   *zIn , int nByte ) ;
static u32 sqlite3Utf8Read(unsigned char const   **pz ) ;
static LogEst sqlite3LogEst(u64 x___0 ) ;
static LogEst sqlite3LogEstAdd(LogEst a___0 , LogEst b ) ;
static LogEst sqlite3LogEstFromDouble(double x___0 ) ;
static VList *sqlite3VListAdd(sqlite3 *db , VList *pIn , char const   *zName , int nName ,
                              int iVal ) ;
static char const   *sqlite3VListNumToName(VList *pIn , int iVal ) ;
static int sqlite3VListNameToNum(VList *pIn , char const   *zName , int nName ) ;
static int sqlite3PutVarint(unsigned char *p , u64 v ) ;
static u8 sqlite3GetVarint(unsigned char const   *p , u64 *v ) ;
static u8 sqlite3GetVarint32(unsigned char const   *p , u32 *v ) ;
static int sqlite3VarintLen(u64 v ) ;
static char const   *sqlite3IndexAffinityStr(sqlite3 *db , Index *pIdx ) ;
static void sqlite3TableAffinity(Vdbe *v , Table *pTab , int iReg ) ;
static char sqlite3CompareAffinity(Expr *pExpr , char aff2 ) ;
static int sqlite3IndexAffinityOk(Expr *pExpr , char idx_affinity ) ;
static char sqlite3TableColumnAffinity(Table *pTab , int iCol ) ;
static char sqlite3ExprAffinity(Expr *pExpr ) ;
static int sqlite3Atoi64(char const   *zNum , i64 *pNum , int length , u8 enc ) ;
static int sqlite3DecOrHexToI64(char const   *z , i64 *pOut ) ;
static void sqlite3ErrorWithMsg(sqlite3 *db , int err_code , char const   *zFormat 
                                , ...) ;
static void sqlite3Error(sqlite3 *db , int err_code ) ;
static void sqlite3SystemError(sqlite3 *db , int rc ) ;
static void *sqlite3HexToBlob(sqlite3 *db , char const   *z , int n ) ;
static u8 sqlite3HexToInt(int h ) ;
static int sqlite3TwoPartName(Parse *pParse , Token *pName1 , Token *pName2 , Token **pUnqual ) ;
static char const   *sqlite3ErrStr(int rc ) ;
static int sqlite3ReadSchema(Parse *pParse ) ;
static CollSeq *sqlite3FindCollSeq(sqlite3 *db , u8 enc , char const   *zName , int create ) ;
static int sqlite3IsBinary(CollSeq const   *p ) ;
static CollSeq *sqlite3LocateCollSeq(Parse *pParse , char const   *zName ) ;
static CollSeq *sqlite3ExprCollSeq(Parse *pParse , Expr *pExpr ) ;
static CollSeq *sqlite3ExprNNCollSeq(Parse *pParse , Expr *pExpr ) ;
static int sqlite3ExprCollSeqMatch(Parse *pParse , Expr *pE1 , Expr *pE2 ) ;
static Expr *sqlite3ExprAddCollateToken(Parse *pParse , Expr *pExpr , Token const   *pCollName ,
                                        int dequote ) ;
static Expr *sqlite3ExprAddCollateString(Parse *pParse , Expr *pExpr , char const   *zC ) ;
static Expr *sqlite3ExprSkipCollate(Expr *pExpr ) ;
static Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr ) ;
static int sqlite3CheckCollSeq(Parse *pParse , CollSeq *pColl ) ;
static int sqlite3WritableSchema(sqlite3 *db ) ;
static int sqlite3CheckObjectName(Parse *pParse , char const   *zName , char const   *zType ,
                                  char const   *zTblName ) ;
static void sqlite3VdbeSetChanges(sqlite3 *db , int nChange ) ;
static int sqlite3AddInt64(i64 *pA , i64 iB ) ;
static int sqlite3SubInt64(i64 *pA , i64 iB ) ;
static int sqlite3MulInt64(i64 *pA , i64 iB ) ;
static int sqlite3AbsInt32(int x___0 ) ;
static u8 sqlite3GetBoolean(char const   *z , u8 dflt ) ;
static void const   *sqlite3ValueText(sqlite3_value *pVal , u8 enc ) ;
static int sqlite3ValueBytes(sqlite3_value *pVal , u8 enc ) ;
static void sqlite3ValueSetStr(sqlite3_value *v , int n , void const   *z , u8 enc ,
                               void (*xDel)(void * ) ) ;
static void sqlite3ValueSetNull(sqlite3_value *p ) ;
static void sqlite3ValueFree(sqlite3_value *v ) ;
static void sqlite3ResultIntReal(sqlite3_context *pCtx ) ;
static sqlite3_value *sqlite3ValueNew(sqlite3 *db ) ;
static char *sqlite3Utf16to8(sqlite3 *db , void const   *z , int nByte , u8 enc ) ;
static int sqlite3ValueFromExpr(sqlite3 *db , Expr *pExpr , u8 enc , u8 affinity ,
                                sqlite3_value **ppVal ) ;
static void sqlite3ValueApplyAffinity(sqlite3_value *pVal , u8 affinity , u8 enc ) ;
static void sqlite3RootPageMoved(sqlite3 *db , int iDb , int iFrom , int iTo ) ;
static void sqlite3Reindex(Parse *pParse , Token *pName1 , Token *pName2 ) ;
static void sqlite3AlterFunctions(void) ;
static void sqlite3AlterRenameTable(Parse *pParse , SrcList *pSrc , Token *pName ) ;
static void sqlite3AlterRenameColumn(Parse *pParse , SrcList *pSrc , Token *pOld ,
                                     Token *pNew ) ;
static int sqlite3GetToken(unsigned char const   *z , int *tokenType ) ;
static void sqlite3NestedParse(Parse *pParse , char const   *zFormat  , ...) ;
static void sqlite3ExpirePreparedStatements(sqlite3 *db , int iCode ) ;
static void sqlite3CodeRhsOfIN(Parse *pParse , Expr *pExpr , int iTab ) ;
static int sqlite3CodeSubselect(Parse *pParse , Expr *pExpr ) ;
static void sqlite3SelectPrep(Parse *pParse , Select *p , NameContext *pOuterNC ) ;
static void sqlite3SelectWrongNumTermsError(Parse *pParse , Select *p ) ;
static int sqlite3MatchSpanName(char const   *zSpan , char const   *zCol , char const   *zTab ,
                                char const   *zDb ) ;
static int sqlite3ResolveExprNames(NameContext *pNC , Expr *pExpr ) ;
static int sqlite3ResolveExprListNames(NameContext *pNC , ExprList *pList ) ;
static void sqlite3ResolveSelectNames(Parse *pParse , Select *p , NameContext *pOuterNC ) ;
static int sqlite3ResolveSelfReference(Parse *pParse , Table *pTab , int type , Expr *pExpr ,
                                       ExprList *pList ) ;
static int sqlite3ResolveOrderGroupBy(Parse *pParse , Select *pSelect , ExprList *pOrderBy ,
                                      char const   *zType ) ;
static void sqlite3ColumnDefault(Vdbe *v , Table *pTab , int i , int iReg ) ;
static void sqlite3AlterFinishAddColumn(Parse *pParse , Token *pColDef ) ;
static void sqlite3AlterBeginAddColumn(Parse *pParse , SrcList *pSrc ) ;
static void *sqlite3RenameTokenMap(Parse *pParse , void *pPtr , Token *pToken ) ;
static void sqlite3RenameTokenRemap(Parse *pParse , void *pTo , void *pFrom ) ;
static void sqlite3RenameExprUnmap(Parse *pParse , Expr *pExpr ) ;
static void sqlite3RenameExprlistUnmap(Parse *pParse , ExprList *pEList ) ;
static CollSeq *sqlite3GetCollSeq(Parse *pParse , u8 enc , CollSeq *pColl , char const   *zName ) ;
static char sqlite3AffinityType(char const   *zIn , Column *pCol ) ;
static void sqlite3Analyze(Parse *pParse , Token *pName1 , Token *pName2 ) ;
static int sqlite3InvokeBusyHandler(BusyHandler *p , sqlite3_file *pFile ) ;
static int sqlite3FindDb(sqlite3 *db , Token *pName ) ;
static int sqlite3FindDbName(sqlite3 *db , char const   *zName ) ;
static int sqlite3AnalysisLoad(sqlite3 *db , int iDb ) ;
static void sqlite3DeleteIndexSamples(sqlite3 *db , Index *pIdx ) ;
static void sqlite3DefaultRowEst(Index *pIdx ) ;
static void sqlite3RegisterLikeFunctions(sqlite3 *db , int caseSensitive ) ;
static int sqlite3IsLikeFunction(sqlite3 *db , Expr *pExpr , int *pIsNocase , char *aWc ) ;
static void sqlite3SchemaClear(void *p ) ;
static Schema *sqlite3SchemaGet(sqlite3 *db , Btree *pBt ) ;
static int sqlite3SchemaToIndex(sqlite3 *db , Schema *pSchema ) ;
static KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db , int N , int X ) ;
static void sqlite3KeyInfoUnref(KeyInfo *p ) ;
static KeyInfo *sqlite3KeyInfoRef(KeyInfo *p ) ;
static KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse , Index *pIdx ) ;
static KeyInfo *sqlite3KeyInfoFromExprList(Parse *pParse , ExprList *pList , int iStart ,
                                           int nExtra ) ;
static int sqlite3HasExplicitNulls(Parse *pParse , ExprList *pList ) ;
static int sqlite3CreateFunc(sqlite3 *db , char const   *zFunctionName , int nArg ,
                             int enc , void *pUserData , void (*xSFunc)(sqlite3_context * ,
                                                                        int  , sqlite3_value ** ) ,
                             void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             void (*xFinal)(sqlite3_context * ) , void (*xValue)(sqlite3_context * ) ,
                             void (*xInverse)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             FuncDestructor *pDestructor ) ;
static void sqlite3NoopDestructor(void *p ) ;
static void sqlite3OomFault(sqlite3 *db ) ;
static void sqlite3OomClear(sqlite3 *db ) ;
static int sqlite3ApiExit(sqlite3 *db , int rc ) ;
static int sqlite3OpenTempDatabase(Parse *pParse ) ;
static void sqlite3StrAccumInit(StrAccum *p , sqlite3 *db , char *zBase , int n ,
                                int mx ) ;
static char *sqlite3StrAccumFinish(StrAccum *p ) ;
static void sqlite3SelectDestInit(SelectDest *pDest , int eDest , int iParm ) ;
static Expr *sqlite3CreateColumnExpr(sqlite3 *db , SrcList *pSrc , int iSrc , int iCol ) ;
static void sqlite3BackupRestart(sqlite3_backup *pBackup ) ;
static void sqlite3BackupUpdate(sqlite3_backup *pBackup , Pgno iPage , u8 const   *aData ) ;
static int sqlite3ExprCheckIN(Parse *pParse , Expr *pIn ) ;
static void sqlite3Parser(void *yyp , int yymajor , Token yyminor ) ;
static int sqlite3ParserFallback(int iToken ) ;
static void sqlite3AutoLoadExtensions(sqlite3 *db ) ;
static void sqlite3TableLock(Parse *pParse , int iDb , int iTab , u8 isWriteLock ,
                             char const   *zName ) ;
static void sqlite3VtabClear(sqlite3 *db , Table *p ) ;
static void sqlite3VtabDisconnect(sqlite3 *db , Table *p ) ;
static int sqlite3VtabSync(sqlite3 *db , Vdbe *p ) ;
static int sqlite3VtabRollback(sqlite3 *db ) ;
static int sqlite3VtabCommit(sqlite3 *db ) ;
static void sqlite3VtabLock(VTable *pVTab ) ;
static void sqlite3VtabUnlock(VTable *pVTab ) ;
static void sqlite3VtabModuleUnref(sqlite3 *db , Module *pMod ) ;
static void sqlite3VtabUnlockList(sqlite3 *db ) ;
static int sqlite3VtabSavepoint(sqlite3 *db , int op , int iSavepoint ) ;
static void sqlite3VtabImportErrmsg(Vdbe *p , sqlite3_vtab *pVtab ) ;
static VTable *sqlite3GetVTable(sqlite3 *db , Table *pTab ) ;
static Module *sqlite3VtabCreateModule(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                                       void *pAux , void (*xDestroy)(void * ) ) ;
static int sqlite3VtabEponymousTableInit(Parse *pParse , Module *pMod ) ;
static void sqlite3VtabEponymousTableClear(sqlite3 *db , Module *pMod ) ;
static void sqlite3VtabMakeWritable(Parse *pParse , Table *pTab ) ;
static void sqlite3VtabBeginParse(Parse *pParse , Token *pName1 , Token *pName2 ,
                                  Token *pModuleName , int ifNotExists ) ;
static void sqlite3VtabFinishParse(Parse *pParse , Token *pEnd ) ;
static void sqlite3VtabArgInit(Parse *pParse ) ;
static void sqlite3VtabArgExtend(Parse *pParse , Token *p ) ;
static int sqlite3VtabCallCreate(sqlite3 *db , int iDb , char const   *zTab , char **pzErr ) ;
static int sqlite3VtabCallConnect(Parse *pParse , Table *pTab ) ;
static int sqlite3VtabCallDestroy(sqlite3 *db , int iDb , char const   *zTab ) ;
static int sqlite3VtabBegin(sqlite3 *db , VTable *pVTab ) ;
static FuncDef *sqlite3VtabOverloadFunction(sqlite3 *db , FuncDef *pDef , int nArg ,
                                            Expr *pExpr ) ;
static sqlite_int64 sqlite3StmtCurrentTime(sqlite3_context *p ) ;
static int sqlite3VdbeParameterIndex(Vdbe *p , char const   *zName , int nName ) ;
static int sqlite3TransferBindings(sqlite3_stmt *pFromStmt , sqlite3_stmt *pToStmt ) ;
static void sqlite3ParserReset(Parse *pParse ) ;
static int sqlite3Reprepare(Vdbe *p ) ;
static void sqlite3ExprListCheckLength(Parse *pParse , ExprList *pEList , char const   *zObject ) ;
static CollSeq *sqlite3BinaryCompareCollSeq(Parse *pParse , Expr *pLeft , Expr *pRight ) ;
static int sqlite3TempInMemory(sqlite3 const   *db ) ;
static char const   *sqlite3JournalModename(int eMode ) ;
static int sqlite3Checkpoint(sqlite3 *db , int iDb , int eMode , int *pnLog , int *pnCkpt ) ;
static int sqlite3WalDefaultHook(void *pClientData , sqlite3 *db , char const   *zDb ,
                                 int nFrame ) ;
static With *sqlite3WithAdd(Parse *pParse , With *pWith , Token *pName , ExprList *pArglist ,
                            Select *pQuery ) ;
static void sqlite3WithDelete(sqlite3 *db , With *pWith ) ;
static void sqlite3WithPush(Parse *pParse , With *pWith , u8 bFree ) ;
static Upsert *sqlite3UpsertNew(sqlite3 *db , ExprList *pTarget , Expr *pTargetWhere ,
                                ExprList *pSet , Expr *pWhere ) ;
static void sqlite3UpsertDelete(sqlite3 *db , Upsert *p ) ;
static Upsert *sqlite3UpsertDup(sqlite3 *db , Upsert *p ) ;
static int sqlite3UpsertAnalyzeTarget(Parse *pParse , SrcList *pTabList , Upsert *pUpsert ) ;
static void sqlite3UpsertDoUpdate(Parse *pParse , Upsert *pUpsert , Table *pTab ,
                                  Index *pIdx , int iCur ) ;
static void sqlite3FkCheck(Parse *pParse , Table *pTab , int regOld , int regNew ,
                           int *aChange , int bChngRowid ) ;
static void sqlite3FkDropTable(Parse *pParse , SrcList *pName , Table *pTab ) ;
static void sqlite3FkActions(Parse *pParse , Table *pTab , ExprList *pChanges , int regOld ,
                             int *aChange , int bChngRowid ) ;
static int sqlite3FkRequired(Parse *pParse , Table *pTab , int *aChange , int chngRowid ) ;
static u32 sqlite3FkOldmask(Parse *pParse , Table *pTab ) ;
static FKey *sqlite3FkReferences(Table *pTab ) ;
static void sqlite3FkDelete(sqlite3 *db , Table *pTab ) ;
static int sqlite3FkLocateIndex(Parse *pParse , Table *pParent , FKey *pFKey , Index **ppIdx ,
                                int **paiCol ) ;
static void sqlite3BeginBenignMalloc(void) ;
static void sqlite3EndBenignMalloc(void) ;
static int sqlite3FindInIndex(Parse *pParse , Expr *pX , u32 inFlags , int *prRhsHasNull ,
                              int *aiMap , int *piTab ) ;
static int sqlite3JournalOpen(sqlite3_vfs *pVfs , char const   *zName , sqlite3_file *pJfd ,
                              int flags___0 , int nSpill ) ;
static int sqlite3JournalSize(sqlite3_vfs *pVfs ) ;
static int sqlite3JournalIsInMemory(sqlite3_file *p ) ;
static void sqlite3MemJournalOpen(sqlite3_file *pJfd ) ;
static void sqlite3ExprSetHeightAndFlags(Parse *pParse , Expr *p ) ;
static int sqlite3SelectExprHeight(Select *p ) ;
static int sqlite3ExprCheckHeight(Parse *pParse , int nHeight ) ;
static u32 sqlite3Get4byte(u8 const   *p ) ;
static void sqlite3Put4byte(unsigned char *p , u32 v ) ;
static int sqlite3ExprVectorSize(Expr *pExpr ) ;
static int sqlite3ExprIsVector(Expr *pExpr ) ;
static Expr *sqlite3VectorFieldSubexpr(Expr *pVector , int i ) ;
static Expr *sqlite3ExprForVectorField(Parse *pParse , Expr *pVector , int iField ) ;
static void sqlite3VectorErrorMsg(Parse *pParse , Expr *pExpr ) ;
static unsigned char const   sqlite3UpperToLower[256]  = 
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107, 
        (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111, 
        (unsigned char const   )112,      (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119, 
        (unsigned char const   )120,      (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107, 
        (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111, 
        (unsigned char const   )112,      (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119, 
        (unsigned char const   )120,      (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
static unsigned char const   sqlite3CtypeMap[256]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )12,      (unsigned char const   )12,      (unsigned char const   )12, 
        (unsigned char const   )12,      (unsigned char const   )12,      (unsigned char const   )12,      (unsigned char const   )12, 
        (unsigned char const   )12,      (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )10,      (unsigned char const   )10, 
        (unsigned char const   )10,      (unsigned char const   )10,      (unsigned char const   )10,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )128,      (unsigned char const   )42,      (unsigned char const   )42,      (unsigned char const   )42, 
        (unsigned char const   )42,      (unsigned char const   )42,      (unsigned char const   )42,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64, 
        (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64,      (unsigned char const   )64};
static struct Sqlite3Config sqlite3Config  = 
     {1, (u8 )1, (u8 )0, (u8 )0, (u8 )1, (u8 )0, (u8 )1, 2147483646, 0, 1200, 100, 65536,
    {(void *(*)(int  ))0, (void (*)(void * ))0, (void *(*)(void * , int  ))0, (int (*)(void * ))0,
     (int (*)(int  ))0, (int (*)(void * ))0, (void (*)(void * ))0, (void *)0}, {(int (*)(void))0,
                                                                                (int (*)(void))0,
                                                                                (sqlite3_mutex *(*)(int  ))0,
                                                                                (void (*)(sqlite3_mutex * ))0,
                                                                                (void (*)(sqlite3_mutex * ))0,
                                                                                (int (*)(sqlite3_mutex * ))0,
                                                                                (void (*)(sqlite3_mutex * ))0,
                                                                                (int (*)(sqlite3_mutex * ))0,
                                                                                (int (*)(sqlite3_mutex * ))0},
    {0, (void *)0, (int (*)(void * ))0, (void (*)(void * ))0, (sqlite3_pcache *(*)(int szPage ,
                                                                                   int szExtra ,
                                                                                   int bPurgeable ))0,
     (void (*)(sqlite3_pcache * , int nCachesize ))0, (int (*)(sqlite3_pcache * ))0,
     (sqlite3_pcache_page *(*)(sqlite3_pcache * , unsigned int key , int createFlag ))0,
     (void (*)(sqlite3_pcache * , sqlite3_pcache_page * , int discard ))0, (void (*)(sqlite3_pcache * ,
                                                                                     sqlite3_pcache_page * ,
                                                                                     unsigned int oldKey ,
                                                                                     unsigned int newKey ))0,
     (void (*)(sqlite3_pcache * , unsigned int iLimit ))0, (void (*)(sqlite3_pcache * ))0,
     (void (*)(sqlite3_pcache * ))0}, (void *)0, 0, 0, 0, (sqlite_int64 )0, (sqlite_int64 )2147418112,
    (void *)0, 0, 20, 0, 0, (u32 )250, 0, 0, 0, 0, 0, 0, (sqlite3_mutex *)0, (void (*)(void * ,
                                                                                       int  ,
                                                                                       char const   * ))0,
    (void *)0, (int (*)(int  ))0, 0, 0, 2147483646, (u32 )2147483647, 0U};
static FuncDefHash sqlite3BuiltinFunctions  ;
static int sqlite3PendingByte  =    1073741824;
static unsigned char const   sqlite3OpcodeProperty[173]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )18, 
        (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )9,      (unsigned char const   )9, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )9, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )9, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )35,      (unsigned char const   )11,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )11,      (unsigned char const   )11,      (unsigned char const   )11,      (unsigned char const   )11, 
        (unsigned char const   )11,      (unsigned char const   )11,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )16,      (unsigned char const   )16, 
        (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )18,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )16,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )4, 
        (unsigned char const   )26,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0};
static char const   sqlite3StrBINARY[7]  = {      (char const   )'B',      (char const   )'I',      (char const   )'N',      (char const   )'A', 
        (char const   )'R',      (char const   )'Y',      (char const   )'\000'};
static void sqlite3VdbeError(Vdbe *p , char const   *zFormat  , ...) ;
static void sqlite3VdbeFreeCursor(Vdbe *p , VdbeCursor *pCx ) ;
static int sqlite3VdbeCursorMoveto(VdbeCursor **pp , int *piCol ) ;
static int sqlite3VdbeCursorRestore(VdbeCursor *p ) ;
static u32 sqlite3VdbeSerialTypeLen(u32 serial_type ) ;
static u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type ) ;
static u32 sqlite3VdbeSerialPut(unsigned char *buf , Mem *pMem , u32 serial_type ) ;
static u32 sqlite3VdbeSerialGet(unsigned char const   *buf , u32 serial_type , Mem *pMem ) ;
static void sqlite3VdbeDeleteAuxData(sqlite3 *db , AuxData **pp , int iOp , int mask ) ;
static int sqlite3VdbeIdxKeyCompare(sqlite3 *db , VdbeCursor *pC , UnpackedRecord *pUnpacked ,
                                    int *res ) ;
static int sqlite3VdbeIdxRowid(sqlite3 *db , BtCursor *pCur , i64 *rowid ) ;
static int sqlite3VdbeExec(Vdbe *p ) ;
static int sqlite3VdbeList(Vdbe *p ) ;
static int sqlite3VdbeHalt(Vdbe *p ) ;
static int sqlite3VdbeChangeEncoding(Mem *pMem , int desiredEnc ) ;
static int sqlite3VdbeMemTooBig(Mem *p ) ;
static int sqlite3VdbeMemCopy(Mem *pTo , Mem const   *pFrom ) ;
static void sqlite3VdbeMemShallowCopy(Mem *pTo , Mem const   *pFrom , int srcType ) ;
static void sqlite3VdbeMemMove(Mem *pTo , Mem *pFrom ) ;
static int sqlite3VdbeMemNulTerminate(Mem *pMem ) ;
static int sqlite3VdbeMemSetStr(Mem *pMem , char const   *z , int n , u8 enc , void (*xDel)(void * ) ) ;
static void sqlite3VdbeMemSetInt64(Mem *pMem , i64 val ) ;
static void sqlite3VdbeMemSetDouble(Mem *pMem , double val ) ;
static void sqlite3VdbeMemSetPointer(Mem *pMem , void *pPtr , char const   *zPType ,
                                     void (*xDestructor)(void * ) ) ;
static void sqlite3VdbeMemInit(Mem *pMem , sqlite3 *db , u16 flags___0 ) ;
static void sqlite3VdbeMemSetNull(Mem *pMem ) ;
static void sqlite3VdbeMemSetZeroBlob(Mem *pMem , int n ) ;
static int sqlite3VdbeMemSetRowSet(Mem *pMem ) ;
static int sqlite3VdbeMemMakeWriteable(Mem *pMem ) ;
static int sqlite3VdbeMemStringify(Mem *pMem , u8 enc , u8 bForce ) ;
static i64 sqlite3VdbeIntValue(Mem *pMem ) ;
static int sqlite3VdbeMemIntegerify(Mem *pMem ) ;
static double sqlite3VdbeRealValue(Mem *pMem ) ;
static int sqlite3VdbeBooleanValue(Mem *pMem , int ifNull ) ;
static void sqlite3VdbeIntegerAffinity(Mem *pMem ) ;
static int sqlite3VdbeMemRealify(Mem *pMem ) ;
static int sqlite3VdbeMemNumerify(Mem *pMem ) ;
static void sqlite3VdbeMemCast(Mem *pMem , u8 aff , u8 encoding ) ;
static int sqlite3VdbeMemFromBtree(BtCursor *pCur , u32 offset , u32 amt , Mem *pMem ) ;
static void sqlite3VdbeMemRelease(Mem *p ) ;
static int sqlite3VdbeMemFinalize(Mem *pMem , FuncDef *pFunc ) ;
static int sqlite3VdbeMemAggValue(Mem *pAccum , Mem *pOut , FuncDef *pFunc ) ;
static char const   *sqlite3OpcodeName(int i ) ;
static int ( __attribute__((__noinline__)) sqlite3VdbeMemGrow)(Mem *pMem , int n ,
                                                               int bPreserve ) ;
static int sqlite3VdbeMemClearAndResize(Mem *pMem , int szNew ) ;
static int sqlite3VdbeCloseStatement(Vdbe *p , int eOp ) ;
static void sqlite3VdbeFrameMemDel(void *pArg ) ;
static void sqlite3VdbeFrameDelete(VdbeFrame *p ) ;
static int sqlite3VdbeFrameRestore(VdbeFrame *pFrame ) ;
static int sqlite3VdbeTransferError(Vdbe *p ) ;
static int sqlite3VdbeSorterInit(sqlite3 *db , int nField , VdbeCursor *pCsr ) ;
static void sqlite3VdbeSorterReset(sqlite3 *db , VdbeSorter *pSorter ) ;
static void sqlite3VdbeSorterClose(sqlite3 *db , VdbeCursor *pCsr ) ;
static int sqlite3VdbeSorterRowkey(VdbeCursor const   *pCsr , Mem *pOut ) ;
static int sqlite3VdbeSorterNext(sqlite3 *db , VdbeCursor const   *pCsr ) ;
static int sqlite3VdbeSorterRewind(VdbeCursor const   *pCsr , int *pbEof ) ;
static int sqlite3VdbeSorterWrite(VdbeCursor const   *pCsr , Mem *pVal ) ;
static int sqlite3VdbeSorterCompare(VdbeCursor const   *pCsr , Mem *pVal , int nKeyCol ,
                                    int *pRes ) ;
static void sqlite3VdbeEnter(Vdbe *p ) ;
static int sqlite3VdbeCheckFk(Vdbe *p , int deferred ) ;
static int ( __attribute__((__noinline__)) sqlite3VdbeMemTranslate)(Mem *pMem , u8 desiredEnc ) ;
static int sqlite3VdbeMemHandleBom(Mem *pMem ) ;
static int sqlite3VdbeMemExpandBlob(Mem *pMem ) ;
static struct sqlite3StatType sqlite3Stat  =    {{(sqlite3StatValueType )0}, {(sqlite3StatValueType )0}};
static char const   statMutex[10]  = 
  {      (char const   )0,      (char const   )1,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )0,      (char const   )0};
static sqlite_int64 sqlite3StatusValue(int op ) 
{ 


  {
  return (sqlite3Stat.nowValue[op]);
}
}
static void sqlite3StatusUp(int op , int N ) 
{ 


  {
  sqlite3Stat.nowValue[op] += (sqlite3StatValueType )N;
  if (sqlite3Stat.nowValue[op] > sqlite3Stat.mxValue[op]) {
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
  return;
}
}
static void sqlite3StatusDown(int op , int N ) 
{ 


  {
  sqlite3Stat.nowValue[op] -= (sqlite3StatValueType )N;
  return;
}
}
static void sqlite3StatusHighwater(int op , int X ) 
{ 
  sqlite3StatValueType newValue ;

  {
  newValue = (sqlite3StatValueType )X;
  if (newValue > sqlite3Stat.mxValue[op]) {
    sqlite3Stat.mxValue[op] = newValue;
  }
  return;
}
}
int sqlite3_status64(int op , sqlite_int64 *pCurrent , sqlite_int64 *pHighwater ,
                     int resetFlag ) 
{ 
  sqlite3_mutex *pMutex ;
  int tmp ;
  sqlite3_mutex *tmp___0 ;
  sqlite3_mutex *tmp___1 ;

  {
  if (op < 0) {
    tmp = sqlite3MisuseError(20833);
    return (tmp);
  } else
  if (op >= (int )(sizeof(sqlite3Stat.nowValue) / sizeof(sqlite3Stat.nowValue[0]))) {
    tmp = sqlite3MisuseError(20833);
    return (tmp);
  }
  if (statMutex[op]) {
    tmp___0 = sqlite3Pcache1Mutex();
    pMutex = tmp___0;
  } else {
    tmp___1 = sqlite3MallocMutex();
    pMutex = tmp___1;
  }
  *pCurrent = sqlite3Stat.nowValue[op];
  *pHighwater = sqlite3Stat.mxValue[op];
  if (resetFlag) {
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
  return (0);
}
}
int sqlite3_status(int op , int *pCurrent , int *pHighwater , int resetFlag ) 
{ 
  sqlite_int64 iCur ;
  sqlite_int64 iHwtr ;
  int rc ;

  {
  iCur = (sqlite_int64 )0;
  iHwtr = (sqlite_int64 )0;
  rc = sqlite3_status64(op, & iCur, & iHwtr, resetFlag);
  if (rc == 0) {
    *pCurrent = (int )iCur;
    *pHighwater = (int )iHwtr;
  }
  return (rc);
}
}
static u32 countLookasideSlots(LookasideSlot *p ) 
{ 
  u32 cnt ;

  {
  cnt = (u32 )0;
  while (p) {
    p = p->pNext;
    cnt ++;
  }
  return (cnt);
}
}
static int sqlite3LookasideUsed(sqlite3 *db , int *pHighwater ) 
{ 
  u32 nInit ;
  u32 tmp ;
  u32 nFree ;
  u32 tmp___0 ;

  {
  tmp = countLookasideSlots(db->lookaside.pInit);
  nInit = tmp;
  tmp___0 = countLookasideSlots(db->lookaside.pFree);
  nFree = tmp___0;
  if (pHighwater) {
    *pHighwater = (int )(db->lookaside.nSlot - nInit);
  }
  return ((int )(db->lookaside.nSlot - (nInit + nFree)));
}
}
int sqlite3_db_status(sqlite3 *db , int op , int *pCurrent , int *pHighwater , int resetFlag ) 
{ 
  int rc ;
  LookasideSlot *p ;
  int totalUsed ;
  int i ;
  Btree *pBt ;
  Pager *pPager ;
  struct Pager *tmp ;
  int nByte ;
  int tmp___0 ;
  int tmp___1 ;
  int i___0 ;
  int nByte___0 ;
  Schema *pSchema ;
  HashElem *p___0 ;
  int tmp___2 ;
  sqlite_uint64 tmp___3 ;
  sqlite_uint64 tmp___4 ;
  sqlite_uint64 tmp___5 ;
  sqlite_uint64 tmp___6 ;
  struct Vdbe *pVdbe ;
  int nByte___1 ;
  int i___1 ;
  int nRet ;
  Pager *pPager___0 ;
  struct Pager *tmp___7 ;
  int tmp___8 ;

  {
  rc = 0;
  switch (op) {
  case 0: 
  *pCurrent = sqlite3LookasideUsed(db, pHighwater);
  if (resetFlag) {
    p = db->lookaside.pFree;
    if (p) {
      while (p->pNext) {
        p = p->pNext;
      }
      p->pNext = db->lookaside.pInit;
      db->lookaside.pInit = db->lookaside.pFree;
      db->lookaside.pFree = (LookasideSlot *)0;
    }
  }
  break;
  case 6: 
  case 5: 
  case 4: 
  *pCurrent = 0;
  *pHighwater = (int )db->lookaside.anStat[op - 4];
  if (resetFlag) {
    db->lookaside.anStat[op - 4] = (u32 )0;
  }
  break;
  case 1: 
  case 11: 
  totalUsed = 0;
  sqlite3BtreeEnterAll(db);
  i = 0;
  while (i < db->nDb) {
    pBt = (db->aDb + i)->pBt;
    if (pBt) {
      tmp = sqlite3BtreePager(pBt);
      pPager = tmp;
      tmp___0 = sqlite3PagerMemUsed(pPager);
      nByte = tmp___0;
      if (op == 11) {
        tmp___1 = sqlite3BtreeConnectionCount(pBt);
        nByte /= tmp___1;
      }
      totalUsed += nByte;
    }
    i ++;
  }
  *pCurrent = totalUsed;
  *pHighwater = 0;
  break;
  case 2: 
  nByte___0 = 0;
  sqlite3BtreeEnterAll(db);
  db->pnBytesFreed = & nByte___0;
  i___0 = 0;
  while (i___0 < db->nDb) {
    pSchema = (db->aDb + i___0)->pSchema;
    if ((unsigned long )pSchema != (unsigned long )((Schema *)0)) {
      tmp___2 = (*(sqlite3Config.m.xRoundup))((int )sizeof(HashElem ));
      nByte___0 = (int )((unsigned int )nByte___0 + (unsigned int )tmp___2 * (((pSchema->tblHash.count + pSchema->trigHash.count) + pSchema->idxHash.count) + pSchema->fkeyHash.count));
      tmp___3 = sqlite3_msize((void *)pSchema->tblHash.ht);
      nByte___0 = (int )((sqlite_uint64 )nByte___0 + tmp___3);
      tmp___4 = sqlite3_msize((void *)pSchema->trigHash.ht);
      nByte___0 = (int )((sqlite_uint64 )nByte___0 + tmp___4);
      tmp___5 = sqlite3_msize((void *)pSchema->idxHash.ht);
      nByte___0 = (int )((sqlite_uint64 )nByte___0 + tmp___5);
      tmp___6 = sqlite3_msize((void *)pSchema->fkeyHash.ht);
      nByte___0 = (int )((sqlite_uint64 )nByte___0 + tmp___6);
      p___0 = pSchema->trigHash.first;
      while (p___0) {
        sqlite3DeleteTrigger(db, (Trigger *)p___0->data);
        p___0 = p___0->next;
      }
      p___0 = pSchema->tblHash.first;
      while (p___0) {
        sqlite3DeleteTable(db, (Table *)p___0->data);
        p___0 = p___0->next;
      }
    }
    i___0 ++;
  }
  db->pnBytesFreed = (int *)0;
  *pHighwater = 0;
  *pCurrent = nByte___0;
  break;
  case 3: 
  nByte___1 = 0;
  db->pnBytesFreed = & nByte___1;
  pVdbe = db->pVdbe;
  while (pVdbe) {
    sqlite3VdbeClearObject(db, pVdbe);
    sqlite3DbFree(db, (void *)pVdbe);
    pVdbe = pVdbe->pNext;
  }
  db->pnBytesFreed = (int *)0;
  *pHighwater = 0;
  *pCurrent = nByte___1;
  break;
  case 12: 
  op = 10;
  case 9: 
  case 8: 
  case 7: 
  nRet = 0;
  i___1 = 0;
  while (i___1 < db->nDb) {
    if ((db->aDb + i___1)->pBt) {
      tmp___7 = sqlite3BtreePager((db->aDb + i___1)->pBt);
      pPager___0 = tmp___7;
      sqlite3PagerCacheStat(pPager___0, op, resetFlag, & nRet);
    }
    i___1 ++;
  }
  *pHighwater = 0;
  *pCurrent = nRet;
  break;
  case 10: 
  *pHighwater = 0;
  if (db->nDeferredImmCons > 0LL) {
    tmp___8 = 1;
  } else
  if (db->nDeferredCons > 0LL) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  *pCurrent = tmp___8;
  break;
  default: 
  rc = 1;
  }
  return (rc);
}
}
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
static int getDigits(char const   *zDate , char const   *zFormat  , ...) ;
static u16 const   aMx[6]  = {      (u16 const   )12,      (u16 const   )14,      (u16 const   )24,      (u16 const   )31, 
        (u16 const   )59,      (u16 const   )9999};
static int getDigits(char const   *zDate , char const   *zFormat  , ...) 
{ 
  va_list ap ;
  int cnt ;
  char nextC ;
  char N ;
  char min ;
  int val ;
  u16 max ;
  char tmp ;
  int *tmp___1 ;

  {
  cnt = 0;
  __builtin_va_start(ap, zFormat);
  while (1) {
    N = (char )((int const   )*(zFormat + 0) - 48);
    min = (char )((int const   )*(zFormat + 1) - 48);
    val = 0;
    max = (u16 )aMx[(int const   )*(zFormat + 2) - 97];
    nextC = (char )*(zFormat + 3);
    val = 0;
    while (1) {
      tmp = N;
      N = (char )((int )N - 1);
      if (! tmp) {
        break;
      }
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*zDate] & 4)) {
        goto end_getDigits;
      }
      val = (val * 10 + (int )*zDate) - 48;
      zDate ++;
    }
    if (val < (int )min) {
      goto end_getDigits;
    } else
    if (val > (int )max) {
      goto end_getDigits;
    } else
    if ((int )nextC != 0) {
      if ((int )nextC != (int )*zDate) {
        goto end_getDigits;
      }
    }
    tmp___1 = __builtin_va_arg(ap, int *);
    *tmp___1 = val;
    zDate ++;
    cnt ++;
    zFormat += 4;
    if (! nextC) {
      break;
    }
  }
  end_getDigits: 
  __builtin_va_end(ap);
  return (cnt);
}
}
static int parseTimezone(char const   *zDate , DateTime *p ) 
{ 
  int sgn ;
  int nHr ;
  int nMn ;
  int c ;
  int tmp ;

  {
  sgn = 0;
  while ((int const   )sqlite3CtypeMap[(unsigned char )*zDate] & 1) {
    zDate ++;
  }
  p->tz = 0;
  c = (int )*zDate;
  if (c == 45) {
    sgn = -1;
  } else
  if (c == 43) {
    sgn = 1;
  } else
  if (c == 90) {
    zDate ++;
    goto zulu_time;
  } else
  if (c == 122) {
    zDate ++;
    goto zulu_time;
  } else {
    return (c != 0);
  }
  zDate ++;
  tmp = getDigits(zDate, "20b:20e", & nHr, & nMn);
  if (tmp != 2) {
    return (1);
  }
  zDate += 5;
  p->tz = sgn * (nMn + nHr * 60);
  zulu_time: 
  while ((int const   )sqlite3CtypeMap[(unsigned char )*zDate] & 1) {
    zDate ++;
  }
  p->tzSet = (char)1;
  return ((int const   )*zDate != 0);
}
}
static int parseHhMmSs(char const   *zDate , DateTime *p ) 
{ 
  int h ;
  int m ;
  int s ;
  double ms ;
  int tmp ;
  int tmp___0 ;
  double rScale ;
  int tmp___1 ;

  {
  ms = 0.0;
  tmp = getDigits(zDate, "20c:20e", & h, & m);
  if (tmp != 2) {
    return (1);
  }
  zDate += 5;
  if ((int const   )*zDate == 58) {
    zDate ++;
    tmp___0 = getDigits(zDate, "20e", & s);
    if (tmp___0 != 1) {
      return (1);
    }
    zDate += 2;
    if ((int const   )*zDate == 46) {
      if ((int const   )sqlite3CtypeMap[(unsigned char )*(zDate + 1)] & 4) {
        rScale = 1.0;
        zDate ++;
        while ((int const   )sqlite3CtypeMap[(unsigned char )*zDate] & 4) {
          ms = (ms * 10.0 + (double )*zDate) - (double )48;
          rScale *= 10.0;
          zDate ++;
        }
        ms /= rScale;
      }
    }
  } else {
    s = 0;
  }
  p->validJD = (char)0;
  p->rawS = (char)0;
  p->validHMS = (char)1;
  p->h = h;
  p->m = m;
  p->s = (double )s + ms;
  tmp___1 = parseTimezone(zDate, p);
  if (tmp___1) {
    return (1);
  }
  if (p->tz != 0) {
    p->validTZ = (char)1;
  } else {
    p->validTZ = (char)0;
  }
  return (0);
}
}
static void datetimeError(DateTime *p ) 
{ 


  {
  memset((void *)p, 0, sizeof(*p));
  p->isError = (char)1;
  return;
}
}
static void computeJD(DateTime *p ) 
{ 
  int Y ;
  int M ;
  int D ;
  int A ;
  int B ;
  int X1 ;
  int X2 ;

  {
  if (p->validJD) {
    return;
  }
  if (p->validYMD) {
    Y = p->Y;
    M = p->M;
    D = p->D;
  } else {
    Y = 2000;
    M = 1;
    D = 1;
  }
  if (Y < -4713) {
    datetimeError(p);
    return;
  } else
  if (Y > 9999) {
    datetimeError(p);
    return;
  } else
  if (p->rawS) {
    datetimeError(p);
    return;
  }
  if (M <= 2) {
    Y --;
    M += 12;
  }
  A = Y / 100;
  B = (2 - A) + A / 4;
  X1 = (36525 * (Y + 4716)) / 100;
  X2 = (306001 * (M + 1)) / 10000;
  p->iJD = (sqlite_int64 )(((double )(((X1 + X2) + D) + B) - 1524.5) * (double )86400000);
  p->validJD = (char)1;
  if (p->validHMS) {
    p->iJD += (sqlite_int64 )(p->h * 3600000 + p->m * 60000) + (sqlite_int64 )(p->s * (double )1000);
    if (p->validTZ) {
      p->iJD -= (sqlite_int64 )(p->tz * 60000);
      p->validYMD = (char)0;
      p->validHMS = (char)0;
      p->validTZ = (char)0;
    }
  }
  return;
}
}
static int parseYyyyMmDd(char const   *zDate , DateTime *p ) 
{ 
  int Y ;
  int M ;
  int D ;
  int neg ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int const   )*(zDate + 0) == 45) {
    zDate ++;
    neg = 1;
  } else {
    neg = 0;
  }
  tmp = getDigits(zDate, "40f-21a-21d", & Y, & M, & D);
  if (tmp != 3) {
    return (1);
  }
  zDate += 10;
  while (1) {
    if (! ((int const   )sqlite3CtypeMap[(unsigned char )*zDate] & 1)) {
      if (! (84 == (int )*((u8 *)zDate))) {
        break;
      }
    }
    zDate ++;
  }
  tmp___0 = parseHhMmSs(zDate, p);
  if (! (tmp___0 == 0)) {
    if ((int const   )*zDate == 0) {
      p->validHMS = (char)0;
    } else {
      return (1);
    }
  }
  p->validJD = (char)0;
  p->validYMD = (char)1;
  if (neg) {
    p->Y = - Y;
  } else {
    p->Y = Y;
  }
  p->M = M;
  p->D = D;
  if (p->validTZ) {
    computeJD(p);
  }
  return (0);
}
}
static int setDateTimeToCurrent(sqlite3_context *context , DateTime *p ) 
{ 


  {
  p->iJD = sqlite3StmtCurrentTime(context);
  if (p->iJD > 0LL) {
    p->validJD = (char)1;
    return (0);
  } else {
    return (1);
  }
}
}
static void setRawDateNumber(DateTime *p , double r ) 
{ 


  {
  p->s = r;
  p->rawS = (char)1;
  if (r >= 0.0) {
    if (r < 5373484.5) {
      p->iJD = (sqlite_int64 )(r * 86400000.0 + 0.5);
      p->validJD = (char)1;
    }
  }
  return;
}
}
static int parseDateOrTime(sqlite3_context *context , char const   *zDate , DateTime *p ) 
{ 
  double r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp___5 = parseYyyyMmDd(zDate, p);
  if (tmp___5 == 0) {
    return (0);
  } else {
    tmp___4 = parseHhMmSs(zDate, p);
    if (tmp___4 == 0) {
      return (0);
    } else {
      tmp___2 = sqlite3StrICmp(zDate, "now");
      if (tmp___2 == 0) {
        tmp___3 = sqlite3NotPureFunc(context);
        if (tmp___3) {
          tmp = setDateTimeToCurrent(context, p);
          return (tmp);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        tmp___0 = sqlite3Strlen30(zDate);
        tmp___1 = sqlite3AtoF(zDate, & r, tmp___0, (u8 )1);
        if (tmp___1 > 0) {
          setRawDateNumber(p, r);
          return (0);
        }
      }
    }
  }
  return (1);
}
}
static int validJulianDay(sqlite_int64 iJD ) 
{ 
  int tmp ;

  {
  if (iJD >= 0LL) {
    if (iJD <= ((108096LL << 32) | 275971583LL)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static void computeYMD(DateTime *p ) 
{ 
  int Z ;
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int X1 ;
  int tmp ;

  {
  if (p->validYMD) {
    return;
  }
  if (! p->validJD) {
    p->Y = 2000;
    p->M = 1;
    p->D = 1;
  } else {
    tmp = validJulianDay(p->iJD);
    if (tmp) {
      Z = (int )((p->iJD + 43200000LL) / 86400000LL);
      A = (int )(((double )Z - 1867216.25) / 36524.25);
      A = ((Z + 1) + A) - A / 4;
      B = A + 1524;
      C = (int )(((double )B - 122.1) / 365.25);
      D = (36525 * (C & 32767)) / 100;
      E = (int )((double )(B - D) / 30.6001);
      X1 = (int )(30.6001 * (double )E);
      p->D = (B - D) - X1;
      if (E < 14) {
        p->M = E - 1;
      } else {
        p->M = E - 13;
      }
      if (p->M > 2) {
        p->Y = C - 4716;
      } else {
        p->Y = C - 4715;
      }
    } else {
      datetimeError(p);
      return;
    }
  }
  p->validYMD = (char)1;
  return;
}
}
static void computeHMS(DateTime *p ) 
{ 
  int s ;

  {
  if (p->validHMS) {
    return;
  }
  computeJD(p);
  s = (int )((p->iJD + 43200000LL) % 86400000LL);
  p->s = (double )s / 1000.0;
  s = (int )p->s;
  p->s -= (double )s;
  p->h = s / 3600;
  s -= p->h * 3600;
  p->m = s / 60;
  p->s += (double )(s - p->m * 60);
  p->rawS = (char)0;
  p->validHMS = (char)1;
  return;
}
}
static void computeYMD_HMS(DateTime *p ) 
{ 


  {
  computeYMD(p);
  computeHMS(p);
  return;
}
}
static void clearYMD_HMS_TZ(DateTime *p ) 
{ 


  {
  p->validYMD = (char)0;
  p->validHMS = (char)0;
  p->validTZ = (char)0;
  return;
}
}
static int osLocaltime(time_t *t , struct tm *pTm ) 
{ 
  int rc ;
  struct tm *pX ;

  {
  pX = localtime((time_t const   *)t);
  if (sqlite3Config.bLocaltimeFault) {
    pX = (struct tm *)0;
  }
  if (pX) {
    *pTm = *pX;
  }
  rc = (unsigned long )pX == (unsigned long )((struct tm *)0);
  return (rc);
}
}
static sqlite_int64 localtimeOffset(DateTime *p , sqlite3_context *pCtx , int *pRc ) 
{ 
  DateTime x___0 ;
  DateTime y ;
  time_t t ;
  struct tm sLocal ;
  int s ;
  int tmp ;

  {
  memset((void *)(& sLocal), 0, sizeof(sLocal));
  x___0 = *p;
  computeYMD_HMS(& x___0);
  if (x___0.Y < 1971) {
    goto _L;
  } else
  if (x___0.Y >= 2038) {
    _L: /* CIL Label */ 
    x___0.Y = 2000;
    x___0.M = 1;
    x___0.D = 1;
    x___0.h = 0;
    x___0.m = 0;
    x___0.s = 0.0;
  } else {
    s = (int )(x___0.s + 0.5);
    x___0.s = (double )s;
  }
  x___0.tz = 0;
  x___0.validJD = (char)0;
  computeJD(& x___0);
  t = (time_t )(x___0.iJD / 1000LL - 210866760000LL);
  tmp = osLocaltime(& t, & sLocal);
  if (tmp) {
    sqlite3_result_error(pCtx, "local time unavailable", -1);
    *pRc = 1;
    return ((sqlite_int64 )0);
  }
  y.Y = sLocal.tm_year + 1900;
  y.M = sLocal.tm_mon + 1;
  y.D = sLocal.tm_mday;
  y.h = sLocal.tm_hour;
  y.m = sLocal.tm_min;
  y.s = (double )sLocal.tm_sec;
  y.validYMD = (char)1;
  y.validHMS = (char)1;
  y.validJD = (char)0;
  y.rawS = (char)0;
  y.validTZ = (char)0;
  y.isError = (char)0;
  computeJD(& y);
  *pRc = 0;
  return (y.iJD - x___0.iJD);
}
}
static struct __anonstruct_aXformType_301096214  const  aXformType[6]  = {      {(u8 )0, (u8 )6, (char *)"second", 464269060800.0, 86400000.0 / ((24.0 * 60.0) * 60.0)}, 
        {(u8 )0,
      (u8 )6, (char *)"minute", 7737817680.0, 86400000.0 / (24.0 * 60.0)}, 
        {(u8 )0, (u8 )4, (char *)"hour", 128963628.0, 86400000.0 / 24.0}, 
        {(u8 )0, (u8 )3, (char *)"day", 5373485.0, 86400000.0}, 
        {(u8 )1, (u8 )5, (char *)"month", 176546.0, 30.0 * 86400000.0}, 
        {(u8 )2, (u8 )4, (char *)"year", 14713.0, 365.0 * 86400000.0}};
static int parseModifier(sqlite3_context *pCtx , char const   *z , int n , DateTime *p ) 
{ 
  int rc ;
  double r ;
  sqlite_int64 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  sqlite_int64 c1 ;
  sqlite_int64 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  sqlite_int64 Z ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  double rRounder ;
  int i ;
  int tmp___14 ;
  char const   *z2 ;
  DateTime tx ;
  sqlite_int64 day ;
  int tmp___15 ;
  int x___0 ;
  int y ;
  int tmp___16 ;

  {
  rc = 1;
  switch ((int const   )sqlite3UpperToLower[(u8 )*(z + 0)]) {
  case 108: 
  tmp___0 = sqlite3_stricmp(z, "localtime");
  if (tmp___0 == 0) {
    tmp___1 = sqlite3NotPureFunc(pCtx);
    if (tmp___1) {
      computeJD(p);
      tmp = localtimeOffset(p, pCtx, & rc);
      p->iJD += tmp;
      clearYMD_HMS_TZ(p);
    }
  }
  break;
  case 117: 
  tmp___5 = sqlite3_stricmp(z, "unixepoch");
  if (tmp___5 == 0) {
    if (p->rawS) {
      r = p->s * 1000.0 + 210866760000000.0;
      if (r >= 0.0) {
        if (r < 464269060800000.0) {
          clearYMD_HMS_TZ(p);
          p->iJD = (sqlite_int64 )r;
          p->validJD = (char)1;
          p->rawS = (char)0;
          rc = 0;
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = sqlite3_stricmp(z, "utc");
    if (tmp___3 == 0) {
      tmp___4 = sqlite3NotPureFunc(pCtx);
      if (tmp___4) {
        if ((int )p->tzSet == 0) {
          computeJD(p);
          c1 = localtimeOffset(p, pCtx, & rc);
          if (rc == 0) {
            p->iJD -= c1;
            clearYMD_HMS_TZ(p);
            tmp___2 = localtimeOffset(p, pCtx, & rc);
            p->iJD += c1 - tmp___2;
          }
          p->tzSet = (char)1;
        } else {
          rc = 0;
        }
      }
    }
  }
  break;
  case 119: 
  tmp___6 = sqlite3_strnicmp(z, "weekday ", 8);
  if (tmp___6 == 0) {
    tmp___7 = sqlite3Strlen30(z + 8);
    tmp___8 = sqlite3AtoF(z + 8, & r, tmp___7, (u8 )1);
    if (tmp___8 > 0) {
      n = (int )r;
      if ((double )n == r) {
        if (n >= 0) {
          if (r < (double )7) {
            computeYMD_HMS(p);
            p->validTZ = (char)0;
            p->validJD = (char)0;
            computeJD(p);
            Z = ((p->iJD + 129600000LL) / 86400000LL) % 7LL;
            if (Z > (sqlite_int64 )n) {
              Z -= 7LL;
            }
            p->iJD += ((sqlite_int64 )n - Z) * 86400000LL;
            clearYMD_HMS_TZ(p);
            rc = 0;
          }
        }
      }
    }
  }
  break;
  case 115: 
  tmp___9 = sqlite3_strnicmp(z, "start of ", 9);
  if (tmp___9 != 0) {
    break;
  }
  if (! p->validJD) {
    if (! p->validYMD) {
      if (! p->validHMS) {
        break;
      }
    }
  }
  z += 9;
  computeYMD(p);
  p->validHMS = (char)1;
  tmp___10 = 0;
  p->m = tmp___10;
  p->h = tmp___10;
  p->s = 0.0;
  p->rawS = (char)0;
  p->validTZ = (char)0;
  p->validJD = (char)0;
  tmp___13 = sqlite3_stricmp(z, "month");
  if (tmp___13 == 0) {
    p->D = 1;
    rc = 0;
  } else {
    tmp___12 = sqlite3_stricmp(z, "year");
    if (tmp___12 == 0) {
      p->M = 1;
      p->D = 1;
      rc = 0;
    } else {
      tmp___11 = sqlite3_stricmp(z, "day");
      if (tmp___11 == 0) {
        rc = 0;
      }
    }
  }
  break;
  case 57: 
  case 56: 
  case 55: 
  case 54: 
  case 53: 
  case 52: 
  case 51: 
  case 50: 
  case 49: 
  case 48: 
  case 45: 
  case 43: 
  n = 1;
  while (1) {
    if (*(z + n)) {
      if ((int const   )*(z + n) != 58) {
        if (! (! ((int const   )sqlite3CtypeMap[(unsigned char )*(z + n)] & 1))) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    n ++;
  }
  tmp___14 = sqlite3AtoF(z, & r, n, (u8 )1);
  if (tmp___14 <= 0) {
    rc = 1;
    break;
  }
  if ((int const   )*(z + n) == 58) {
    z2 = z;
    if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z2] & 4)) {
      z2 ++;
    }
    memset((void *)(& tx), 0, sizeof(tx));
    tmp___15 = parseHhMmSs(z2, & tx);
    if (tmp___15) {
      break;
    }
    computeJD(& tx);
    tx.iJD -= 43200000LL;
    day = tx.iJD / 86400000LL;
    tx.iJD -= day * 86400000LL;
    if ((int const   )*(z + 0) == 45) {
      tx.iJD = - tx.iJD;
    }
    computeJD(p);
    clearYMD_HMS_TZ(p);
    p->iJD += tx.iJD;
    rc = 0;
    break;
  }
  z += n;
  while ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 1) {
    z ++;
  }
  n = sqlite3Strlen30(z);
  if (n > 10) {
    break;
  } else
  if (n < 3) {
    break;
  }
  if ((int const   )sqlite3UpperToLower[(u8 )*(z + (n - 1))] == 115) {
    n --;
  }
  computeJD(p);
  rc = 1;
  if (r < (double )0) {
    rRounder = - 0.5;
  } else {
    rRounder = 0.5;
  }
  i = 0;
  while (i < (int )(sizeof(aXformType) / sizeof(aXformType[0]))) {
    if ((int const   )aXformType[i].nName == (int const   )n) {
      tmp___16 = sqlite3_strnicmp((char const   *)aXformType[i].zName, z, n);
      if (tmp___16 == 0) {
        if (r > (double )(- aXformType[i].rLimit)) {
          if (r < (double )aXformType[i].rLimit) {
            switch ((int const   )aXformType[i].eType) {
            case 1: 
            computeYMD_HMS(p);
            p->M += (int )r;
            if (p->M > 0) {
              x___0 = (p->M - 1) / 12;
            } else {
              x___0 = (p->M - 12) / 12;
            }
            p->Y += x___0;
            p->M -= x___0 * 12;
            p->validJD = (char)0;
            r -= (double )((int )r);
            break;
            case 2: 
            y = (int )r;
            computeYMD_HMS(p);
            p->Y += y;
            p->validJD = (char)0;
            r -= (double )((int )r);
            break;
            }
            computeJD(p);
            p->iJD += (sqlite_int64 )(r * (double )aXformType[i].rXform + rRounder);
            rc = 0;
            break;
          }
        }
      }
    }
    i ++;
  }
  clearYMD_HMS_TZ(p);
  break;
  default: 
  break;
  }
  return (rc);
}
}
static int isDate(sqlite3_context *context , int argc , sqlite3_value **argv , DateTime *p ) 
{ 
  int i ;
  int n ;
  unsigned char const   *z ;
  int eType ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  memset((void *)p, 0, sizeof(*p));
  if (argc == 0) {
    tmp = setDateTimeToCurrent(context, p);
    return (tmp);
  }
  eType = sqlite3_value_type(*(argv + 0));
  if (eType == 2) {
    tmp___0 = sqlite3_value_double(*(argv + 0));
    setRawDateNumber(p, tmp___0);
  } else
  if (eType == 1) {
    tmp___0 = sqlite3_value_double(*(argv + 0));
    setRawDateNumber(p, tmp___0);
  } else {
    z = sqlite3_value_text(*(argv + 0));
    if (! z) {
      return (1);
    } else {
      tmp___1 = parseDateOrTime(context, (char const   *)((char *)z), p);
      if (tmp___1) {
        return (1);
      }
    }
  }
  i = 1;
  while (i < argc) {
    z = sqlite3_value_text(*(argv + i));
    n = sqlite3_value_bytes(*(argv + i));
    if ((unsigned long )z == (unsigned long )((unsigned char const   *)0)) {
      return (1);
    } else {
      tmp___2 = parseModifier(context, (char const   *)((char *)z), n, p);
      if (tmp___2) {
        return (1);
      }
    }
    i ++;
  }
  computeJD(p);
  if (p->isError) {
    return (1);
  } else {
    tmp___3 = validJulianDay(p->iJD);
    if (! tmp___3) {
      return (1);
    }
  }
  return (0);
}
}
static void juliandayFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  DateTime x___0 ;
  int tmp ;

  {
  tmp = isDate(context, argc, argv, & x___0);
  if (tmp == 0) {
    computeJD(& x___0);
    sqlite3_result_double(context, (double )x___0.iJD / 86400000.0);
  }
  return;
}
}
static void datetimeFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  DateTime x___0 ;
  char zBuf[100] ;
  int tmp ;

  {
  tmp = isDate(context, argc, argv, & x___0);
  if (tmp == 0) {
    computeYMD_HMS(& x___0);
    sqlite3_snprintf((int )sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d", x___0.Y,
                     x___0.M, x___0.D, x___0.h, x___0.m, (int )x___0.s);
    sqlite3_result_text(context, (char const   *)(zBuf), -1, (void (*)(void * ))-1);
  }
  return;
}
}
static void timeFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  DateTime x___0 ;
  char zBuf[100] ;
  int tmp ;

  {
  tmp = isDate(context, argc, argv, & x___0);
  if (tmp == 0) {
    computeHMS(& x___0);
    sqlite3_snprintf((int )sizeof(zBuf), zBuf, "%02d:%02d:%02d", x___0.h, x___0.m,
                     (int )x___0.s);
    sqlite3_result_text(context, (char const   *)(zBuf), -1, (void (*)(void * ))-1);
  }
  return;
}
}
static void dateFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  DateTime x___0 ;
  char zBuf[100] ;
  int tmp ;

  {
  tmp = isDate(context, argc, argv, & x___0);
  if (tmp == 0) {
    computeYMD(& x___0);
    sqlite3_snprintf((int )sizeof(zBuf), zBuf, "%04d-%02d-%02d", x___0.Y, x___0.M,
                     x___0.D);
    sqlite3_result_text(context, (char const   *)(zBuf), -1, (void (*)(void * ))-1);
  }
  return;
}
}
static void strftimeFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  DateTime x___0 ;
  u64 n ;
  size_t i ;
  size_t j ;
  char *z ;
  sqlite3 *db ;
  char const   *zFmt ;
  char zBuf[100] ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  double s ;
  int tmp___3 ;
  int nDay ;
  DateTime y ;
  int wd ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void (*tmp___9)(void * ) ;

  {
  if (argc == 0) {
    return;
  }
  tmp = sqlite3_value_text(*(argv + 0));
  zFmt = (char const   *)tmp;
  if ((unsigned long )zFmt == (unsigned long )((char const   *)0)) {
    return;
  } else {
    tmp___0 = isDate(context, argc - 1, argv + 1, & x___0);
    if (tmp___0) {
      return;
    }
  }
  db = sqlite3_context_db_handle(context);
  i = (size_t )0;
  n = (u64 )1;
  while (*(zFmt + i)) {
    if ((int const   )*(zFmt + i) == 37) {
      switch ((int const   )*(zFmt + (i + 1UL))) {
      case 87: 
      case 83: 
      case 77: 
      case 109: 
      case 72: 
      case 100: 
      n ++;
      case 37: 
      case 119: 
      break;
      case 102: 
      n += 8ULL;
      break;
      case 106: 
      n += 3ULL;
      break;
      case 89: 
      n += 8ULL;
      break;
      case 74: 
      case 115: 
      n += 50ULL;
      break;
      default: 
      return;
      }
      i ++;
    }
    i ++;
    n ++;
  }
  if (n < (u64 )sizeof(zBuf)) {
    z = zBuf;
  } else
  if (n > (u64 )db->aLimit[0]) {
    sqlite3_result_error_toobig(context);
    return;
  } else {
    tmp___1 = sqlite3DbMallocRawNN(db, (u64 )((int )n));
    z = (char *)tmp___1;
    if ((unsigned long )z == (unsigned long )((char *)0)) {
      sqlite3_result_error_nomem(context);
      return;
    }
  }
  computeJD(& x___0);
  computeYMD_HMS(& x___0);
  j = (size_t )0;
  i = j;
  while (*(zFmt + i)) {
    if ((int const   )*(zFmt + i) != 37) {
      tmp___2 = j;
      j ++;
      *(z + tmp___2) = (char )*(zFmt + i);
    } else {
      i ++;
      switch ((int const   )*(zFmt + i)) {
      case 100: 
      sqlite3_snprintf(3, z + j, "%02d", x___0.D);
      j += 2UL;
      break;
      case 102: 
      s = x___0.s;
      if (s > 59.999) {
        s = 59.999;
      }
      sqlite3_snprintf(7, z + j, "%06.3f", s);
      tmp___3 = sqlite3Strlen30((char const   *)(z + j));
      j += (size_t )tmp___3;
      break;
      case 72: 
      sqlite3_snprintf(3, z + j, "%02d", x___0.h);
      j += 2UL;
      break;
      case 106: 
      case 87: 
      y = x___0;
      y.validJD = (char)0;
      y.M = 1;
      y.D = 1;
      computeJD(& y);
      nDay = (int )(((x___0.iJD - y.iJD) + 43200000LL) / 86400000LL);
      if ((int const   )*(zFmt + i) == 87) {
        wd = (int )(((x___0.iJD + 43200000LL) / 86400000LL) % 7LL);
        sqlite3_snprintf(3, z + j, "%02d", ((nDay + 7) - wd) / 7);
        j += 2UL;
      } else {
        sqlite3_snprintf(4, z + j, "%03d", nDay + 1);
        j += 3UL;
      }
      break;
      case 74: 
      sqlite3_snprintf(20, z + j, "%.16g", (double )x___0.iJD / 86400000.0);
      tmp___4 = sqlite3Strlen30((char const   *)(z + j));
      j += (size_t )tmp___4;
      break;
      case 109: 
      sqlite3_snprintf(3, z + j, "%02d", x___0.M);
      j += 2UL;
      break;
      case 77: 
      sqlite3_snprintf(3, z + j, "%02d", x___0.m);
      j += 2UL;
      break;
      case 115: 
      sqlite3_snprintf(30, z + j, "%lld", x___0.iJD / 1000LL - 210866760000LL);
      tmp___5 = sqlite3Strlen30((char const   *)(z + j));
      j += (size_t )tmp___5;
      break;
      case 83: 
      sqlite3_snprintf(3, z + j, "%02d", (int )x___0.s);
      j += 2UL;
      break;
      case 119: 
      tmp___6 = j;
      j ++;
      *(z + tmp___6) = (char )((int )((char )(((x___0.iJD + 129600000LL) / 86400000LL) % 7LL)) + 48);
      break;
      case 89: 
      sqlite3_snprintf(5, z + j, "%04d", x___0.Y);
      tmp___7 = sqlite3Strlen30((char const   *)(z + j));
      j += (size_t )tmp___7;
      break;
      default: 
      tmp___8 = j;
      j ++;
      *(z + tmp___8) = (char )'%';
      break;
      }
    }
    i ++;
  }
  *(z + j) = (char)0;
  if ((unsigned long )z == (unsigned long )(zBuf)) {
    tmp___9 = (void (*)(void * ))-1;
  } else {
    tmp___9 = (void (*)(void * ))(& sqlite3MallocSize);
  }
  sqlite3_result_text(context, (char const   *)z, -1, tmp___9);
  return;
}
}
static void ctimeFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 


  {
  timeFunc(context, 0, (sqlite3_value **)0);
  return;
}
}
static void cdateFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 


  {
  dateFunc(context, 0, (sqlite3_value **)0);
  return;
}
}
static void ctimestampFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 


  {
  datetimeFunc(context, 0, (sqlite3_value **)0);
  return;
}
}
static FuncDef aDateTimeFuncs[8]  = 
  {      {(i8 )-1, (u32 )10241, (void *)(& sqlite3Config), (FuncDef *)0, & juliandayFunc,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "julianday", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )10241, (void *)(& sqlite3Config), (FuncDef *)0, & dateFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "date", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )10241, (void *)(& sqlite3Config), (FuncDef *)0, & timeFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "time", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )10241, (void *)(& sqlite3Config), (FuncDef *)0, & datetimeFunc,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "datetime", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )10241, (void *)(& sqlite3Config), (FuncDef *)0, & strftimeFunc,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "strftime", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )8193, (void *)0, (FuncDef *)0, & ctimeFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "current_time", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )8193, (void *)0, (FuncDef *)0, & ctimestampFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "current_timestamp", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )8193, (void *)0, (FuncDef *)0, & cdateFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "current_date", {(FuncDef *)0}}};
static void sqlite3RegisterDateTimeFunctions(void) 
{ 


  {
  sqlite3InsertBuiltinFuncs(aDateTimeFuncs, (int )(sizeof(aDateTimeFuncs) / sizeof(aDateTimeFuncs[0])));
  return;
}
}
static void sqlite3OsClose(sqlite3_file *pId ) 
{ 


  {
  if (pId->pMethods) {
    (*((pId->pMethods)->xClose))(pId);
    pId->pMethods = (struct sqlite3_io_methods  const  *)0;
  }
  return;
}
}
static int sqlite3OsRead(sqlite3_file *id , void *pBuf , int amt , i64 offset ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xRead))(id, pBuf, amt, offset);
  return (tmp);
}
}
static int sqlite3OsWrite(sqlite3_file *id , void const   *pBuf , int amt , i64 offset ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xWrite))(id, pBuf, amt, offset);
  return (tmp);
}
}
static int sqlite3OsTruncate(sqlite3_file *id , i64 size ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xTruncate))(id, size);
  return (tmp);
}
}
static int sqlite3OsSync(sqlite3_file *id , int flags___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (flags___0) {
    tmp = (*((id->pMethods)->xSync))(id, flags___0);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3OsFileSize(sqlite3_file *id , i64 *pSize ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xFileSize))(id, pSize);
  return (tmp);
}
}
static int sqlite3OsLock(sqlite3_file *id , int lockType ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xLock))(id, lockType);
  return (tmp);
}
}
static int sqlite3OsUnlock(sqlite3_file *id , int lockType ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xUnlock))(id, lockType);
  return (tmp);
}
}
static int sqlite3OsCheckReservedLock(sqlite3_file *id , int *pResOut ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xCheckReservedLock))(id, pResOut);
  return (tmp);
}
}
static int sqlite3OsFileControl(sqlite3_file *id , int op , void *pArg ) 
{ 
  int tmp ;

  {
  if ((unsigned long )id->pMethods == (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    return (12);
  }
  tmp = (*((id->pMethods)->xFileControl))(id, op, pArg);
  return (tmp);
}
}
static void sqlite3OsFileControlHint(sqlite3_file *id , int op , void *pArg ) 
{ 


  {
  if (id->pMethods) {
    (*((id->pMethods)->xFileControl))(id, op, pArg);
  }
  return;
}
}
static int sqlite3OsSectorSize(sqlite3_file *id ) 
{ 
  int (*xSectorSize)(sqlite3_file * ) ;
  int tmp ;
  int tmp___0 ;

  {
  xSectorSize = (int (*)(sqlite3_file * ))(id->pMethods)->xSectorSize;
  if (xSectorSize) {
    tmp = (*xSectorSize)(id);
    tmp___0 = tmp;
  } else {
    tmp___0 = 4096;
  }
  return (tmp___0);
}
}
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xDeviceCharacteristics))(id);
  return (tmp);
}
}
static int sqlite3OsShmLock(sqlite3_file *id , int offset , int n , int flags___0 ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xShmLock))(id, offset, n, flags___0);
  return (tmp);
}
}
static void sqlite3OsShmBarrier(sqlite3_file *id ) 
{ 


  {
  (*((id->pMethods)->xShmBarrier))(id);
  return;
}
}
static int sqlite3OsShmUnmap(sqlite3_file *id , int deleteFlag ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xShmUnmap))(id, deleteFlag);
  return (tmp);
}
}
static int sqlite3OsShmMap(sqlite3_file *id , int iPage , int pgsz___0 , int bExtend ,
                           void volatile   **pp ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xShmMap))(id, iPage, pgsz___0, bExtend, pp);
  return (tmp);
}
}
static int sqlite3OsFetch(sqlite3_file *id , i64 iOff , int iAmt , void **pp ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xFetch))(id, iOff, iAmt, pp);
  return (tmp);
}
}
static int sqlite3OsUnfetch(sqlite3_file *id , i64 iOff , void *p ) 
{ 
  int tmp ;

  {
  tmp = (*((id->pMethods)->xUnfetch))(id, iOff, p);
  return (tmp);
}
}
static int sqlite3OsOpen(sqlite3_vfs *pVfs , char const   *zPath , sqlite3_file *pFile ,
                         int flags___0 , int *pFlagsOut ) 
{ 
  int rc ;

  {
  rc = (*(pVfs->xOpen))(pVfs, zPath, pFile, flags___0 & 556927, pFlagsOut);
  return (rc);
}
}
static int sqlite3OsDelete(sqlite3_vfs *pVfs , char const   *zPath , int dirSync ) 
{ 
  int tmp ;

  {
  tmp = (*(pVfs->xDelete))(pVfs, zPath, dirSync);
  return (tmp);
}
}
static int sqlite3OsAccess(sqlite3_vfs *pVfs , char const   *zPath , int flags___0 ,
                           int *pResOut ) 
{ 
  int tmp ;

  {
  tmp = (*(pVfs->xAccess))(pVfs, zPath, flags___0, pResOut);
  return (tmp);
}
}
static int sqlite3OsFullPathname(sqlite3_vfs *pVfs , char const   *zPath , int nPathOut ,
                                 char *zPathOut ) 
{ 
  int tmp ;

  {
  *(zPathOut + 0) = (char)0;
  tmp = (*(pVfs->xFullPathname))(pVfs, zPath, nPathOut, zPathOut);
  return (tmp);
}
}
static int sqlite3OsRandomness(sqlite3_vfs *pVfs , int nByte , char *zBufOut ) 
{ 
  int tmp ;

  {
  if (sqlite3Config.iPrngSeed) {
    memset((void *)zBufOut, 0, (size_t )nByte);
    if (nByte > (int )sizeof(unsigned int )) {
      nByte = (int )sizeof(unsigned int );
    }
    memcpy((void * __restrict  )zBufOut, (void const   * __restrict  )(& sqlite3Config.iPrngSeed),
           (size_t )nByte);
    return (0);
  } else {
    tmp = (*(pVfs->xRandomness))(pVfs, nByte, zBufOut);
    return (tmp);
  }
}
}
static int sqlite3OsSleep(sqlite3_vfs *pVfs , int nMicro ) 
{ 
  int tmp ;

  {
  tmp = (*(pVfs->xSleep))(pVfs, nMicro);
  return (tmp);
}
}
static int sqlite3OsGetLastError(sqlite3_vfs *pVfs ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (pVfs->xGetLastError) {
    tmp = (*(pVfs->xGetLastError))(pVfs, 0, (char *)0);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs , sqlite_int64 *pTimeOut ) 
{ 
  int rc ;
  double r ;

  {
  if (pVfs->iVersion >= 2) {
    if (pVfs->xCurrentTimeInt64) {
      rc = (*(pVfs->xCurrentTimeInt64))(pVfs, pTimeOut);
    } else {
      rc = (*(pVfs->xCurrentTime))(pVfs, & r);
      *pTimeOut = (sqlite_int64 )(r * 86400000.0);
    }
  } else {
    rc = (*(pVfs->xCurrentTime))(pVfs, & r);
    *pTimeOut = (sqlite_int64 )(r * 86400000.0);
  }
  return (rc);
}
}
static int sqlite3OsOpenMalloc(sqlite3_vfs *pVfs , char const   *zFile , sqlite3_file **ppFile ,
                               int flags___0 , int *pOutFlags ) 
{ 
  int rc ;
  sqlite3_file *pFile ;
  void *tmp ;

  {
  tmp = sqlite3MallocZero((u64 )pVfs->szOsFile);
  pFile = (sqlite3_file *)tmp;
  if (pFile) {
    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags___0, pOutFlags);
    if (rc != 0) {
      sqlite3_free((void *)pFile);
    } else {
      *ppFile = pFile;
    }
  } else {
    rc = 7;
  }
  return (rc);
}
}
static void sqlite3OsCloseFree(sqlite3_file *pFile ) 
{ 


  {
  sqlite3OsClose(pFile);
  sqlite3_free((void *)pFile);
  return;
}
}
static int sqlite3OsInit(void) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_malloc(10);
  p = tmp;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (7);
  }
  sqlite3_free(p);
  tmp___0 = sqlite3_os_init();
  return (tmp___0);
}
}
static sqlite3_vfs *vfsList  =    (sqlite3_vfs *)0;
sqlite3_vfs *sqlite3_vfs_find(char const   *zVfs ) 
{ 
  sqlite3_vfs *pVfs ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  pVfs = (sqlite3_vfs *)0;
  tmp = sqlite3_initialize();
  rc = tmp;
  if (rc) {
    return ((sqlite3_vfs *)0);
  }
  pVfs = vfsList;
  while (pVfs) {
    if ((unsigned long )zVfs == (unsigned long )((char const   *)0)) {
      break;
    }
    tmp___0 = strcmp(zVfs, pVfs->zName);
    if (tmp___0 == 0) {
      break;
    }
    pVfs = pVfs->pNext;
  }
  return (pVfs);
}
}
static void vfsUnlink(sqlite3_vfs *pVfs ) 
{ 
  sqlite3_vfs *p ;

  {
  if (! ((unsigned long )pVfs == (unsigned long )((sqlite3_vfs *)0))) {
    if ((unsigned long )vfsList == (unsigned long )pVfs) {
      vfsList = pVfs->pNext;
    } else
    if (vfsList) {
      p = vfsList;
      while (1) {
        if (p->pNext) {
          if (! ((unsigned long )p->pNext != (unsigned long )pVfs)) {
            break;
          }
        } else {
          break;
        }
        p = p->pNext;
      }
      if ((unsigned long )p->pNext == (unsigned long )pVfs) {
        p->pNext = pVfs->pNext;
      }
    }
  }
  return;
}
}
int sqlite3_vfs_register(sqlite3_vfs *pVfs , int makeDflt ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_initialize();
  rc = tmp;
  if (rc) {
    return (rc);
  }
  vfsUnlink(pVfs);
  if (makeDflt) {
    pVfs->pNext = vfsList;
    vfsList = pVfs;
  } else
  if ((unsigned long )vfsList == (unsigned long )((sqlite3_vfs *)0)) {
    pVfs->pNext = vfsList;
    vfsList = pVfs;
  } else {
    pVfs->pNext = vfsList->pNext;
    vfsList->pNext = pVfs;
  }
  return (0);
}
}
int sqlite3_vfs_unregister(sqlite3_vfs *pVfs ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_initialize();
  rc = tmp;
  if (rc) {
    return (rc);
  }
  vfsUnlink(pVfs);
  return (0);
}
}
static struct BenignMallocHooks sqlite3Hooks  =    {(void (*)(void))0, (void (*)(void))0};
static void sqlite3BenignMallocHooks(void (*xBenignBegin)(void) , void (*xBenignEnd)(void) ) 
{ 


  {
  sqlite3Hooks.xBenignBegin = xBenignBegin;
  sqlite3Hooks.xBenignEnd = xBenignEnd;
  return;
}
}
static void sqlite3BeginBenignMalloc(void) 
{ 


  {
  if (sqlite3Hooks.xBenignBegin) {
    (*(sqlite3Hooks.xBenignBegin))();
  }
  return;
}
}
static void sqlite3EndBenignMalloc(void) 
{ 


  {
  if (sqlite3Hooks.xBenignEnd) {
    (*(sqlite3Hooks.xBenignEnd))();
  }
  return;
}
}
static void *sqlite3MemMalloc(int nByte ) 
{ 
  sqlite_int64 *p ;
  void *tmp ;

  {
  tmp = malloc((size_t )(nByte + 8));
  p = (sqlite_int64 *)tmp;
  if (p) {
    *(p + 0) = (sqlite_int64 )nByte;
    p ++;
  } else {
    sqlite3_log(7, "failed to allocate %u bytes of memory", nByte);
  }
  return ((void *)p);
}
}
static void sqlite3MemFree(void *pPrior ) 
{ 
  sqlite_int64 *p ;

  {
  p = (sqlite_int64 *)pPrior;
  p --;
  free((void *)p);
  return;
}
}
static int sqlite3MemSize(void *pPrior ) 
{ 
  sqlite_int64 *p ;

  {
  p = (sqlite_int64 *)pPrior;
  p --;
  return ((int )*(p + 0));
}
}
static void *sqlite3MemRealloc(void *pPrior , int nByte ) 
{ 
  sqlite_int64 *p ;
  void *tmp ;
  int tmp___0 ;

  {
  p = (sqlite_int64 *)pPrior;
  p --;
  tmp = realloc((void *)p, (size_t )(nByte + 8));
  p = (sqlite_int64 *)tmp;
  if (p) {
    *(p + 0) = (sqlite_int64 )nByte;
    p ++;
  } else {
    tmp___0 = sqlite3MemSize(pPrior);
    sqlite3_log(7, "failed memory resize %u to %u bytes", tmp___0, nByte);
  }
  return ((void *)p);
}
}
static int sqlite3MemRoundup(int n ) 
{ 


  {
  return ((n + 7) & -8);
}
}
static int sqlite3MemInit(void *NotUsed ) 
{ 


  {
  return (0);
}
}
static void sqlite3MemShutdown(void *NotUsed ) 
{ 


  {
  return;
}
}
static struct sqlite3_mem_methods  const  defaultMethods  = 
     {& sqlite3MemMalloc, & sqlite3MemFree, & sqlite3MemRealloc, & sqlite3MemSize, & sqlite3MemRoundup,
    & sqlite3MemInit, & sqlite3MemShutdown, (void *)0};
static void sqlite3MemSetDefault(void) 
{ 


  {
  sqlite3_config(4, & defaultMethods);
  return;
}
}
int sqlite3_release_memory(int n ) 
{ 


  {
  return (0);
}
}
static struct Mem0Global mem0  =    {(sqlite3_mutex *)0, (sqlite_int64 )0, 0};
static sqlite3_mutex *sqlite3MallocMutex(void) 
{ 


  {
  return (mem0.mutex);
}
}
int sqlite3_memory_alarm(void (*xCallback)(void *pArg , sqlite_int64 used , int N ) ,
                         void *pArg , sqlite_int64 iThreshold ) 
{ 


  {
  return (0);
}
}
sqlite_int64 sqlite3_soft_heap_limit64(sqlite_int64 n ) 
{ 
  sqlite_int64 priorLimit ;
  sqlite_int64 excess ;
  sqlite_int64 nUsed ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  sqlite_int64 tmp___1 ;

  {
  tmp = sqlite3_initialize();
  rc = tmp;
  if (rc) {
    return ((sqlite_int64 )-1);
  }
  priorLimit = mem0.alarmThreshold;
  if (n < 0LL) {
    return (priorLimit);
  }
  mem0.alarmThreshold = n;
  nUsed = sqlite3StatusValue(0);
  if (n > 0LL) {
    if (n <= nUsed) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  mem0.nearlyFull = tmp___0;
  tmp___1 = sqlite3_memory_used();
  excess = tmp___1 - n;
  if (excess > 0LL) {
    sqlite3_release_memory((int )(excess & 2147483647LL));
  }
  return (priorLimit);
}
}
void sqlite3_soft_heap_limit(int n ) 
{ 


  {
  if (n < 0) {
    n = 0;
  }
  sqlite3_soft_heap_limit64((sqlite_int64 )n);
  return;
}
}
static int sqlite3MallocInit(void) 
{ 
  int rc ;

  {
  if ((unsigned long )sqlite3Config.m.xMalloc == (unsigned long )((void *(*)(int  ))0)) {
    sqlite3MemSetDefault();
  }
  memset((void *)(& mem0), 0, sizeof(mem0));
  mem0.mutex = (sqlite3_mutex *)8;
  if ((unsigned long )sqlite3Config.pPage == (unsigned long )((void *)0)) {
    sqlite3Config.pPage = (void *)0;
    sqlite3Config.szPage = 0;
  } else
  if (sqlite3Config.szPage < 512) {
    sqlite3Config.pPage = (void *)0;
    sqlite3Config.szPage = 0;
  } else
  if (sqlite3Config.nPage <= 0) {
    sqlite3Config.pPage = (void *)0;
    sqlite3Config.szPage = 0;
  }
  rc = (*(sqlite3Config.m.xInit))(sqlite3Config.m.pAppData);
  if (rc != 0) {
    memset((void *)(& mem0), 0, sizeof(mem0));
  }
  return (rc);
}
}
static int sqlite3HeapNearlyFull(void) 
{ 


  {
  return (mem0.nearlyFull);
}
}
static void sqlite3MallocEnd(void) 
{ 


  {
  if (sqlite3Config.m.xShutdown) {
    (*(sqlite3Config.m.xShutdown))(sqlite3Config.m.pAppData);
  }
  memset((void *)(& mem0), 0, sizeof(mem0));
  return;
}
}
sqlite_int64 sqlite3_memory_used(void) 
{ 
  sqlite_int64 res ;
  sqlite_int64 mx ;

  {
  sqlite3_status64(0, & res, & mx, 0);
  return (res);
}
}
sqlite_int64 sqlite3_memory_highwater(int resetFlag ) 
{ 
  sqlite_int64 res ;
  sqlite_int64 mx ;

  {
  sqlite3_status64(0, & res, & mx, resetFlag);
  return (mx);
}
}
static void sqlite3MallocAlarm(int nByte ) 
{ 


  {
  if (mem0.alarmThreshold <= 0LL) {
    return;
  }
  sqlite3_release_memory(nByte);
  return;
}
}
static void mallocWithAlarm(int n , void **pp ) 
{ 
  void *p ;
  int nFull ;
  sqlite_int64 nUsed ;
  sqlite_int64 tmp ;

  {
  nFull = (*(sqlite3Config.m.xRoundup))(n);
  sqlite3StatusHighwater(5, n);
  if (mem0.alarmThreshold > 0LL) {
    tmp = sqlite3StatusValue(0);
    nUsed = tmp;
    if (nUsed >= mem0.alarmThreshold - (sqlite_int64 )nFull) {
      mem0.nearlyFull = 1;
      sqlite3MallocAlarm(nFull);
    } else {
      mem0.nearlyFull = 0;
    }
  }
  p = (*(sqlite3Config.m.xMalloc))(nFull);
  if (p) {
    nFull = sqlite3MallocSize(p);
    sqlite3StatusUp(0, nFull);
    sqlite3StatusUp(9, 1);
  }
  *pp = p;
  return;
}
}
static void *sqlite3Malloc(u64 n ) 
{ 
  void *p ;

  {
  if (n == 0ULL) {
    p = (void *)0;
  } else
  if (n >= 2147483392ULL) {
    p = (void *)0;
  } else
  if (sqlite3Config.bMemstat) {
    mallocWithAlarm((int )n, & p);
  } else {
    p = (*(sqlite3Config.m.xMalloc))((int )n);
  }
  return (p);
}
}
void *sqlite3_malloc(int n ) 
{ 
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sqlite3_initialize();
  if (tmp) {
    return ((void *)0);
  }
  if (n <= 0) {
    tmp___1 = (void *)0;
  } else {
    tmp___0 = sqlite3Malloc((u64 )n);
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
void *sqlite3_malloc64(sqlite_uint64 n ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3_initialize();
  if (tmp) {
    return ((void *)0);
  }
  tmp___0 = sqlite3Malloc(n);
  return (tmp___0);
}
}
static int isLookaside(sqlite3 *db , void *p ) 
{ 
  int tmp ;

  {
  if ((uptr )p >= (uptr )db->lookaside.pStart) {
    if ((uptr )p < (uptr )db->lookaside.pEnd) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int sqlite3MallocSize(void *p ) 
{ 
  int tmp ;

  {
  tmp = (*(sqlite3Config.m.xSize))(p);
  return (tmp);
}
}
static int sqlite3DbMallocSize(sqlite3 *db , void *p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )db == (unsigned long )((sqlite3 *)0)) {
    tmp = (*(sqlite3Config.m.xSize))(p);
    return (tmp);
  } else {
    tmp___0 = isLookaside(db, p);
    if (tmp___0) {
      return ((int )db->lookaside.sz);
    } else {
      tmp = (*(sqlite3Config.m.xSize))(p);
      return (tmp);
    }
  }
}
}
sqlite_uint64 sqlite3_msize(void *p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (p) {
    tmp = (*(sqlite3Config.m.xSize))(p);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return ((sqlite_uint64 )tmp___0);
}
}
void sqlite3_free(void *p ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return;
  }
  if (sqlite3Config.bMemstat) {
    tmp = sqlite3MallocSize(p);
    sqlite3StatusDown(0, tmp);
    sqlite3StatusDown(9, 1);
    (*(sqlite3Config.m.xFree))(p);
  } else {
    (*(sqlite3Config.m.xFree))(p);
  }
  return;
}
}
static void ( __attribute__((__noinline__)) measureAllocationSize)(sqlite3 *db , void *p ) 
{ 
  int tmp ;

  {
  tmp = sqlite3DbMallocSize(db, p);
  *(db->pnBytesFreed) += tmp;
  return;
}
}
static void sqlite3DbFreeNN(sqlite3 *db , void *p ) 
{ 
  LookasideSlot *pBuf ;
  int tmp ;

  {
  if (db) {
    if (db->pnBytesFreed) {
      measureAllocationSize(db, p);
      return;
    }
    tmp = isLookaside(db, p);
    if (tmp) {
      pBuf = (LookasideSlot *)p;
      pBuf->pNext = db->lookaside.pFree;
      db->lookaside.pFree = pBuf;
      return;
    }
  }
  sqlite3_free(p);
  return;
}
}
static void sqlite3DbFree(sqlite3 *db , void *p ) 
{ 


  {
  if (p) {
    sqlite3DbFreeNN(db, p);
  }
  return;
}
}
static void *sqlite3Realloc(void *pOld , u64 nBytes ) 
{ 
  int nOld ;
  int nNew ;
  int nDiff ;
  void *pNew ;
  void *tmp ;
  sqlite_int64 tmp___0 ;

  {
  if ((unsigned long )pOld == (unsigned long )((void *)0)) {
    tmp = sqlite3Malloc(nBytes);
    return (tmp);
  }
  if (nBytes == 0ULL) {
    sqlite3_free(pOld);
    return ((void *)0);
  }
  if (nBytes >= 2147483392ULL) {
    return ((void *)0);
  }
  nOld = sqlite3MallocSize(pOld);
  nNew = (*(sqlite3Config.m.xRoundup))((int )nBytes);
  if (nOld == nNew) {
    pNew = pOld;
  } else
  if (sqlite3Config.bMemstat) {
    sqlite3StatusHighwater(5, (int )nBytes);
    nDiff = nNew - nOld;
    if (nDiff > 0) {
      tmp___0 = sqlite3StatusValue(0);
      if (tmp___0 >= mem0.alarmThreshold - (sqlite_int64 )nDiff) {
        sqlite3MallocAlarm(nDiff);
      }
    }
    pNew = (*(sqlite3Config.m.xRealloc))(pOld, nNew);
    if ((unsigned long )pNew == (unsigned long )((void *)0)) {
      if (mem0.alarmThreshold > 0LL) {
        sqlite3MallocAlarm((int )nBytes);
        pNew = (*(sqlite3Config.m.xRealloc))(pOld, nNew);
      }
    }
    if (pNew) {
      nNew = sqlite3MallocSize(pNew);
      sqlite3StatusUp(0, nNew - nOld);
    }
  } else {
    pNew = (*(sqlite3Config.m.xRealloc))(pOld, nNew);
  }
  return (pNew);
}
}
void *sqlite3_realloc(void *pOld , int n ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3_initialize();
  if (tmp) {
    return ((void *)0);
  }
  if (n < 0) {
    n = 0;
  }
  tmp___0 = sqlite3Realloc(pOld, (u64 )n);
  return (tmp___0);
}
}
void *sqlite3_realloc64(void *pOld , sqlite_uint64 n ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3_initialize();
  if (tmp) {
    return ((void *)0);
  }
  tmp___0 = sqlite3Realloc(pOld, n);
  return (tmp___0);
}
}
static void *sqlite3MallocZero(u64 n ) 
{ 
  void *p ;
  void *tmp ;

  {
  tmp = sqlite3Malloc(n);
  p = tmp;
  if (p) {
    memset(p, 0, (size_t )n);
  }
  return (p);
}
}
static void *sqlite3DbMallocZero(sqlite3 *db , u64 n ) 
{ 
  void *p ;

  {
  p = sqlite3DbMallocRaw(db, n);
  if (p) {
    memset(p, 0, (size_t )n);
  }
  return (p);
}
}
static void *( __attribute__((__noinline__)) dbMallocRawFinish)(sqlite3 *db , u64 n ) 
{ 
  void *p ;

  {
  p = sqlite3Malloc(n);
  if (! p) {
    sqlite3OomFault(db);
  }
  return (p);
}
}
static void *sqlite3DbMallocRaw(sqlite3 *db , u64 n ) 
{ 
  void *p ;
  void *tmp ;

  {
  if (db) {
    tmp = sqlite3DbMallocRawNN(db, n);
    return (tmp);
  }
  p = sqlite3Malloc(n);
  return (p);
}
}
static void *sqlite3DbMallocRawNN(sqlite3 *db , u64 n ) 
{ 
  LookasideSlot *pBuf ;
  void *tmp ;

  {
  if (db->lookaside.bDisable == 0U) {
    if (n > (u64 )db->lookaside.sz) {
      (db->lookaside.anStat[1]) ++;
    } else {
      pBuf = db->lookaside.pFree;
      if ((unsigned long )pBuf != (unsigned long )((LookasideSlot *)0)) {
        db->lookaside.pFree = pBuf->pNext;
        (db->lookaside.anStat[0]) ++;
        return ((void *)pBuf);
      } else {
        pBuf = db->lookaside.pInit;
        if ((unsigned long )pBuf != (unsigned long )((LookasideSlot *)0)) {
          db->lookaside.pInit = pBuf->pNext;
          (db->lookaside.anStat[0]) ++;
          return ((void *)pBuf);
        } else {
          (db->lookaside.anStat[2]) ++;
        }
      }
    }
  } else
  if (db->mallocFailed) {
    return ((void *)0);
  }
  tmp = dbMallocRawFinish(db, n);
  return (tmp);
}
}
static void *( __attribute__((__noinline__)) dbReallocFinish)(sqlite3 *db , void *p ,
                                                              u64 n ) ;
static void *sqlite3DbRealloc(sqlite3 *db , void *p , u64 n ) 
{ 
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    tmp = sqlite3DbMallocRawNN(db, n);
    return (tmp);
  }
  tmp___0 = isLookaside(db, p);
  if (tmp___0) {
    if (n <= (u64 )db->lookaside.sz) {
      return (p);
    }
  }
  tmp___1 = dbReallocFinish(db, p, n);
  return (tmp___1);
}
}
static void *( __attribute__((__noinline__)) dbReallocFinish)(sqlite3 *db , void *p ,
                                                              u64 n ) 
{ 
  void *pNew ;
  int tmp ;

  {
  pNew = (void *)0;
  if ((int )db->mallocFailed == 0) {
    tmp = isLookaside(db, p);
    if (tmp) {
      pNew = sqlite3DbMallocRawNN(db, n);
      if (pNew) {
        memcpy((void * __restrict  )pNew, (void const   * __restrict  )p, (size_t )db->lookaside.sz);
        sqlite3DbFree(db, p);
      }
    } else {
      pNew = sqlite3_realloc64(p, n);
      if (! pNew) {
        sqlite3OomFault(db);
      }
    }
  }
  return (pNew);
}
}
static void *sqlite3DbReallocOrFree(sqlite3 *db , void *p , u64 n ) 
{ 
  void *pNew ;

  {
  pNew = sqlite3DbRealloc(db, p, n);
  if (! pNew) {
    sqlite3DbFree(db, p);
  }
  return (pNew);
}
}
static char *sqlite3DbStrDup(sqlite3 *db , char const   *z ) 
{ 
  char *zNew ;
  size_t n ;
  size_t tmp ;
  void *tmp___0 ;

  {
  if ((unsigned long )z == (unsigned long )((char const   *)0)) {
    return ((char *)0);
  }
  tmp = strlen(z);
  n = tmp + 1UL;
  tmp___0 = sqlite3DbMallocRaw(db, (u64 )n);
  zNew = (char *)tmp___0;
  if (zNew) {
    memcpy((void * __restrict  )zNew, (void const   * __restrict  )z, n);
  }
  return (zNew);
}
}
static char *sqlite3DbStrNDup(sqlite3 *db , char const   *z , u64 n ) 
{ 
  char *zNew ;
  void *tmp ;

  {
  if ((unsigned long )z == (unsigned long )((char const   *)0)) {
    return ((char *)0);
  }
  tmp = sqlite3DbMallocRawNN(db, n + 1ULL);
  zNew = (char *)tmp;
  if (zNew) {
    memcpy((void * __restrict  )zNew, (void const   * __restrict  )z, (size_t )n);
    *(zNew + n) = (char)0;
  }
  return (zNew);
}
}
static char *sqlite3DbSpanDup(sqlite3 *db , char const   *zStart , char const   *zEnd ) 
{ 
  int n ;
  char *tmp ;

  {
  while ((int const   )sqlite3CtypeMap[(unsigned char )*(zStart + 0)] & 1) {
    zStart ++;
  }
  n = (int )(zEnd - zStart);
  while (1) {
    if (n > 0) {
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*(zStart + (n - 1))] & 1)) {
        break;
      }
    } else {
      break;
    }
    n --;
  }
  tmp = sqlite3DbStrNDup(db, zStart, (u64 )n);
  return (tmp);
}
}
static void sqlite3SetString(char **pz , sqlite3 *db , char const   *zNew ) 
{ 


  {
  sqlite3DbFree(db, (void *)*pz);
  *pz = sqlite3DbStrDup(db, zNew);
  return;
}
}
static void sqlite3OomFault(sqlite3 *db ) 
{ 


  {
  if ((int )db->mallocFailed == 0) {
    if ((int )db->bBenignMalloc == 0) {
      db->mallocFailed = (u8 )1;
      if (db->nVdbeExec > 0) {
        db->u1.isInterrupted = (int volatile   )1;
      }
      (db->lookaside.bDisable) ++;
      if (db->pParse) {
        (db->pParse)->rc = 7;
      }
    }
  }
  return;
}
}
static void sqlite3OomClear(sqlite3 *db ) 
{ 


  {
  if (db->mallocFailed) {
    if (db->nVdbeExec == 0) {
      db->mallocFailed = (u8 )0;
      db->u1.isInterrupted = (int volatile   )0;
      (db->lookaside.bDisable) --;
    }
  }
  return;
}
}
static int ( __attribute__((__noinline__)) apiOomError)(sqlite3 *db ) 
{ 


  {
  sqlite3OomClear(db);
  sqlite3Error(db, 7);
  return (7);
}
}
static int sqlite3ApiExit(sqlite3 *db , int rc ) 
{ 
  int tmp ;

  {
  if (db->mallocFailed) {
    tmp = apiOomError(db);
    return (tmp);
  } else
  if (rc == (10 | (12 << 8))) {
    tmp = apiOomError(db);
    return (tmp);
  }
  return (rc & db->errMask);
}
}
static char const   aDigits[33]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
static char const   aPrefix[7]  = {      (char const   )'-',      (char const   )'x',      (char const   )'0',      (char const   )'\000', 
        (char const   )'X',      (char const   )'0',      (char const   )'\000'};
static et_info const   fmtinfo[23]  = 
  {      {(char )'d', (etByte )10, (etByte )1, (etByte )16, (etByte )0, (etByte )0}, 
        {(char )'s', (etByte )0, (etByte )4, (etByte )5, (etByte )0, (etByte )0}, 
        {(char )'g', (etByte )0, (etByte )1, (etByte )3, (etByte )30, (etByte )0}, 
        {(char )'z', (etByte )0, (etByte )4, (etByte )6, (etByte )0, (etByte )0}, 
        {(char )'q', (etByte )0, (etByte )4, (etByte )9, (etByte )0, (etByte )0}, 
        {(char )'Q', (etByte )0, (etByte )4, (etByte )10, (etByte )0, (etByte )0}, 
        {(char )'w', (etByte )0, (etByte )4, (etByte )14, (etByte )0, (etByte )0}, 
        {(char )'c', (etByte )0, (etByte )0, (etByte )8, (etByte )0, (etByte )0}, 
        {(char )'o', (etByte )8, (etByte )0, (etByte )0, (etByte )0, (etByte )2}, 
        {(char )'u', (etByte )10, (etByte )0, (etByte )16, (etByte )0, (etByte )0}, 
        {(char )'x', (etByte )16, (etByte )0, (etByte )0, (etByte )16, (etByte )1}, 
        {(char )'X', (etByte )16, (etByte )0, (etByte )0, (etByte )0, (etByte )4}, 
        {(char )'f', (etByte )0, (etByte )1, (etByte )1, (etByte )0, (etByte )0}, 
        {(char )'e', (etByte )0, (etByte )1, (etByte )2, (etByte )30, (etByte )0}, 
        {(char )'E', (etByte )0, (etByte )1, (etByte )2, (etByte )14, (etByte )0}, 
        {(char )'G', (etByte )0, (etByte )1, (etByte )3, (etByte )14, (etByte )0}, 
        {(char )'i', (etByte )10, (etByte )1, (etByte )16, (etByte )0, (etByte )0}, 
        {(char )'n', (etByte )0, (etByte )0, (etByte )4, (etByte )0, (etByte )0}, 
        {(char )'%', (etByte )0, (etByte )0, (etByte )7, (etByte )0, (etByte )0}, 
        {(char )'p', (etByte )16, (etByte )0, (etByte )13, (etByte )0, (etByte )1}, 
        {(char )'T', (etByte )0, (etByte )0, (etByte )11, (etByte )0, (etByte )0}, 
        {(char )'S', (etByte )0, (etByte )0, (etByte )12, (etByte )0, (etByte )0}, 
        {(char )'r', (etByte )10, (etByte )1, (etByte )15, (etByte )0, (etByte )0}};
static double const   arRound[10]  = 
  {      (double const   )5.0e-01,      (double const   )5.0e-02,      (double const   )5.0e-03,      (double const   )5.0e-04, 
        (double const   )5.0e-05,      (double const   )5.0e-06,      (double const   )5.0e-07,      (double const   )5.0e-08, 
        (double const   )5.0e-09,      (double const   )5.0e-10};
static char et_getdigit(long double *val , int *cnt ) 
{ 
  int digit ;
  long double d ;

  {
  if (*cnt <= 0) {
    return ((char )'0');
  }
  (*cnt) --;
  digit = (int )*val;
  d = (long double )digit;
  digit += 48;
  *val = (*val - d) * (long double )10.0;
  return ((char )digit);
}
}
static void setStrAccumError(StrAccum *p , u8 eError ) 
{ 


  {
  p->accError = eError;
  if (p->mxAlloc) {
    sqlite3_str_reset(p);
  }
  if ((int )eError == 18) {
    sqlite3ErrorToParser(p->db, (int )eError);
  }
  return;
}
}
static sqlite_int64 getIntArg(PrintfArguments *p ) 
{ 
  int tmp ;
  sqlite_int64 tmp___0 ;

  {
  if (p->nArg <= p->nUsed) {
    return ((sqlite_int64 )0);
  }
  tmp = p->nUsed;
  (p->nUsed) ++;
  tmp___0 = sqlite3_value_int64(*(p->apArg + tmp));
  return (tmp___0);
}
}
static double getDoubleArg(PrintfArguments *p ) 
{ 
  int tmp ;
  double tmp___0 ;

  {
  if (p->nArg <= p->nUsed) {
    return (0.0);
  }
  tmp = p->nUsed;
  (p->nUsed) ++;
  tmp___0 = sqlite3_value_double(*(p->apArg + tmp));
  return (tmp___0);
}
}
static char *getTextArg(PrintfArguments *p ) 
{ 
  int tmp ;
  unsigned char const   *tmp___0 ;

  {
  if (p->nArg <= p->nUsed) {
    return ((char *)0);
  }
  tmp = p->nUsed;
  (p->nUsed) ++;
  tmp___0 = sqlite3_value_text(*(p->apArg + tmp));
  return ((char *)tmp___0);
}
}
static char *printfTempBuf(sqlite3_str *pAccum , sqlite_int64 n ) 
{ 
  char *z ;
  void *tmp ;

  {
  if (pAccum->accError) {
    return ((char *)0);
  }
  if (n > (sqlite_int64 )pAccum->nAlloc) {
    if (n > (sqlite_int64 )pAccum->mxAlloc) {
      setStrAccumError(pAccum, (u8 )18);
      return ((char *)0);
    }
  }
  tmp = sqlite3DbMallocRaw(pAccum->db, (u64 )n);
  z = (char *)tmp;
  if ((unsigned long )z == (unsigned long )((char *)0)) {
    setStrAccumError(pAccum, (u8 )7);
  }
  return (z);
}
}
static char const   zOrd[9]  = 
  {      (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'t', 
        (char const   )'n',      (char const   )'d',      (char const   )'r',      (char const   )'d', 
        (char const   )'\000'};
void sqlite3_str_vappendf(sqlite3_str *pAccum , char const   *fmt , va_list ap ) 
{ 
  int c ;
  char *bufpt ;
  int precision ;
  int length ;
  int idx ;
  int width ;
  etByte flag_leftjustify ;
  etByte flag_prefix ;
  etByte flag_alternateform ;
  etByte flag_altform2 ;
  etByte flag_zeropad ;
  etByte flag_long ;
  etByte done ;
  etByte cThousand ;
  etByte xtype ;
  u8 bArgList ;
  char prefix ;
  sqlite_uint64 longvalue ;
  long double realvalue ;
  et_info const   *infop ;
  char *zOut ;
  int nOut ;
  char *zExtra ;
  int exp ;
  int e2 ;
  int nsd ;
  double rounder ;
  etByte flag_dp ;
  etByte flag_rtz ;
  PrintfArguments *pArgList ;
  char buf[70] ;
  PrintfArguments *tmp ;
  unsigned int wx ;
  sqlite_int64 tmp___0 ;
  int tmp___1 ;
  sqlite_int64 tmp___2 ;
  int tmp___3 ;
  unsigned int px ;
  int tmp___4 ;
  i64 v ;
  i64 tmp___5 ;
  i64 tmp___6 ;
  i64 tmp___7 ;
  sqlite_int64 tmp___8 ;
  sqlite_uint64 tmp___9 ;
  sqlite_uint64 tmp___10 ;
  sqlite_uint64 tmp___11 ;
  u64 n ;
  int x___0 ;
  char const   *cset ;
  u8 base ;
  int nn ;
  int ix ;
  char const   *pre ;
  char x___1 ;
  double tmp___12 ;
  long double tmp___13 ;
  double rx ;
  sqlite_uint64 u ;
  int ex ;
  int tmp___14 ;
  long double scale ;
  i64 szBufNeeded ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int i ;
  int nPad ;
  int tmp___31 ;
  int tmp___32 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  unsigned int ch ;
  unsigned int tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  size_t tmp___43 ;
  unsigned char *z ;
  unsigned char *tmp___44 ;
  int tmp___45 ;
  size_t tmp___46 ;
  int ii ;
  int tmp___47 ;
  int i___0 ;
  int j ;
  int k ;
  int n___0 ;
  int isnull ;
  int needQuote ;
  char ch___0 ;
  char q ;
  int tmp___48 ;
  char *escarg ;
  char *tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  Token *pToken ;
  Token *tmp___55 ;
  SrcList *pSrc ;
  int k___0 ;
  struct SrcList_item *pItem ;
  SrcList *tmp___56 ;
  int tmp___57 ;

  {
  xtype = (etByte )17;
  zExtra = (char *)0;
  pArgList = (PrintfArguments *)0;
  bufpt = (char *)0;
  if (((int )pAccum->printfFlags & 2) != 0) {
    tmp = __builtin_va_arg(ap, PrintfArguments *);
    pArgList = tmp;
    bArgList = (u8 )1;
  } else {
    bArgList = (u8 )0;
  }
  while (1) {
    c = (int )*fmt;
    if (! (c != 0)) {
      break;
    }
    if (c != 37) {
      bufpt = (char *)fmt;
      while (1) {
        fmt ++;
        if (*fmt) {
          if (! ((int const   )*fmt != 37)) {
            break;
          }
        } else {
          break;
        }
      }
      sqlite3_str_append(pAccum, (char const   *)bufpt, (int )(fmt - (char const   *)bufpt));
      if ((int const   )*fmt == 0) {
        break;
      }
    }
    fmt ++;
    c = (int )*fmt;
    if (c == 0) {
      sqlite3_str_append(pAccum, "%", 1);
      break;
    }
    flag_zeropad = (etByte )0;
    flag_altform2 = flag_zeropad;
    flag_alternateform = flag_altform2;
    cThousand = flag_alternateform;
    flag_prefix = cThousand;
    flag_leftjustify = flag_prefix;
    done = (etByte )0;
    width = 0;
    flag_long = (etByte )0;
    precision = -1;
    while (1) {
      switch (c) {
      case 45: 
      flag_leftjustify = (etByte )1;
      break;
      case 43: 
      flag_prefix = (etByte )'+';
      break;
      case 32: 
      flag_prefix = (etByte )' ';
      break;
      case 35: 
      flag_alternateform = (etByte )1;
      break;
      case 33: 
      flag_altform2 = (etByte )1;
      break;
      case 48: 
      flag_zeropad = (etByte )1;
      break;
      case 44: 
      cThousand = (etByte )',';
      break;
      default: 
      done = (etByte )1;
      break;
      case 108: 
      flag_long = (etByte )1;
      fmt ++;
      c = (int )*fmt;
      if (c == 108) {
        fmt ++;
        c = (int )*fmt;
        flag_long = (etByte )2;
      }
      done = (etByte )1;
      break;
      case 57: 
      case 56: 
      case 55: 
      case 54: 
      case 53: 
      case 52: 
      case 51: 
      case 50: 
      case 49: 
      wx = (unsigned int )(c - 48);
      while (1) {
        fmt ++;
        c = (int )*fmt;
        if (c >= 48) {
          if (! (c <= 57)) {
            break;
          }
        } else {
          break;
        }
        wx = (wx * 10U + (unsigned int )c) - 48U;
      }
      width = (int )(wx & 2147483647U);
      if (c != 46) {
        if (c != 108) {
          done = (etByte )1;
        } else {
          fmt --;
        }
      } else {
        fmt --;
      }
      break;
      case 42: 
      if (bArgList) {
        tmp___0 = getIntArg(pArgList);
        width = (int )tmp___0;
      } else {
        tmp___1 = __builtin_va_arg(ap, int );
        width = tmp___1;
      }
      if (width < 0) {
        flag_leftjustify = (etByte )1;
        if (width >= -2147483647) {
          width = - width;
        } else {
          width = 0;
        }
      }
      c = (int )*(fmt + 1);
      if (c != 46) {
        if (c != 108) {
          fmt ++;
          c = (int )*fmt;
          done = (etByte )1;
        }
      }
      break;
      case 46: 
      fmt ++;
      c = (int )*fmt;
      if (c == 42) {
        if (bArgList) {
          tmp___2 = getIntArg(pArgList);
          precision = (int )tmp___2;
        } else {
          tmp___3 = __builtin_va_arg(ap, int );
          precision = tmp___3;
        }
        if (precision < 0) {
          if (precision >= -2147483647) {
            precision = - precision;
          } else {
            precision = -1;
          }
        }
        fmt ++;
        c = (int )*fmt;
      } else {
        px = 0U;
        while (1) {
          if (c >= 48) {
            if (! (c <= 57)) {
              break;
            }
          } else {
            break;
          }
          px = (px * 10U + (unsigned int )c) - 48U;
          fmt ++;
          c = (int )*fmt;
        }
        precision = (int )(px & 2147483647U);
      }
      if (c == 108) {
        fmt --;
      } else {
        done = (etByte )1;
      }
      break;
      }
      if (! done) {
        fmt ++;
        c = (int )*fmt;
        if (! (c != 0)) {
          break;
        }
      } else {
        break;
      }
    }
    infop = & fmtinfo[0];
    xtype = (etByte )17;
    idx = 0;
    while (idx < (int )(sizeof(fmtinfo) / sizeof(fmtinfo[0]))) {
      if (c == (int )fmtinfo[idx].fmttype) {
        infop = & fmtinfo[idx];
        xtype = (etByte )infop->type;
        break;
      }
      idx ++;
    }
    switch ((int )xtype) {
    case 13: 
    if (sizeof(char *) == sizeof(i64 )) {
      flag_long = (etByte )2;
    } else {
      if (sizeof(char *) == sizeof(long )) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
      flag_long = (etByte )tmp___4;
    }
    case 0: 
    case 15: 
    cThousand = (etByte )0;
    case 16: 
    if ((int const   )infop->flags & 1) {
      if (bArgList) {
        v = getIntArg(pArgList);
      } else
      if (flag_long) {
        if ((int )flag_long == 2) {
          tmp___5 = __builtin_va_arg(ap, i64 );
          v = tmp___5;
        } else {
          tmp___6 = __builtin_va_arg(ap, long );
          v = tmp___6;
        }
      } else {
        tmp___7 = __builtin_va_arg(ap, int );
        v = tmp___7;
      }
      if (v < 0LL) {
        if (v == -1LL - (4294967295LL | (2147483647LL << 32))) {
          longvalue = 1ULL << 63;
        } else {
          longvalue = (sqlite_uint64 )(- v);
        }
        prefix = (char )'-';
      } else {
        longvalue = (sqlite_uint64 )v;
        prefix = (char )flag_prefix;
      }
    } else {
      if (bArgList) {
        tmp___8 = getIntArg(pArgList);
        longvalue = (u64 )tmp___8;
      } else
      if (flag_long) {
        if ((int )flag_long == 2) {
          tmp___9 = __builtin_va_arg(ap, u64 );
          longvalue = tmp___9;
        } else {
          tmp___10 = __builtin_va_arg(ap, unsigned long );
          longvalue = tmp___10;
        }
      } else {
        tmp___11 = __builtin_va_arg(ap, unsigned int );
        longvalue = tmp___11;
      }
      prefix = (char)0;
    }
    if (longvalue == 0ULL) {
      flag_alternateform = (etByte )0;
    }
    if (flag_zeropad) {
      if (precision < width - ((int )prefix != 0)) {
        precision = width - ((int )prefix != 0);
      }
    }
    if (precision < 37) {
      nOut = 70;
      zOut = buf;
    } else {
      n = (u64 )precision + 10ULL;
      if (cThousand) {
        n += (u64 )(precision / 3);
      }
      zExtra = printfTempBuf(pAccum, (sqlite_int64 )n);
      zOut = zExtra;
      if ((unsigned long )zOut == (unsigned long )((char *)0)) {
        return;
      }
      nOut = (int )n;
    }
    bufpt = zOut + (nOut - 1);
    if ((int )xtype == 15) {
      x___0 = (int )(longvalue % 10ULL);
      if (x___0 >= 4) {
        x___0 = 0;
      } else
      if ((longvalue / 10ULL) % 10ULL == 1ULL) {
        x___0 = 0;
      }
      bufpt --;
      *bufpt = (char )zOrd[x___0 * 2 + 1];
      bufpt --;
      *bufpt = (char )zOrd[x___0 * 2];
    }
    cset = & aDigits[infop->charset];
    base = (u8 )infop->base;
    while (1) {
      bufpt --;
      *bufpt = (char )*(cset + longvalue % (unsigned long long )base);
      longvalue /= (sqlite_uint64 )base;
      if (! (longvalue > 0ULL)) {
        break;
      }
    }
    length = (int )((zOut + (nOut - 1)) - bufpt);
    while (precision > length) {
      bufpt --;
      *bufpt = (char )'0';
      length ++;
    }
    if (cThousand) {
      nn = (length - 1) / 3;
      ix = (length - 1) % 3 + 1;
      bufpt -= nn;
      idx = 0;
      while (nn > 0) {
        *(bufpt + idx) = *(bufpt + (idx + nn));
        ix --;
        if (ix == 0) {
          idx ++;
          *(bufpt + idx) = (char )cThousand;
          nn --;
          ix = 3;
        }
        idx ++;
      }
    }
    if (prefix) {
      bufpt --;
      *bufpt = prefix;
    }
    if (flag_alternateform) {
      if (infop->prefix) {
        pre = & aPrefix[infop->prefix];
        while (1) {
          x___1 = (char )*pre;
          if (! ((int )x___1 != 0)) {
            break;
          }
          bufpt --;
          *bufpt = x___1;
          pre ++;
        }
      }
    }
    length = (int )((zOut + (nOut - 1)) - bufpt);
    break;
    case 3: 
    case 2: 
    case 1: 
    if (bArgList) {
      tmp___12 = getDoubleArg(pArgList);
      realvalue = (long double )tmp___12;
    } else {
      tmp___13 = __builtin_va_arg(ap, double );
      realvalue = tmp___13;
    }
    if (precision < 0) {
      precision = 6;
    }
    if (realvalue < (long double )0.0) {
      realvalue = - realvalue;
      prefix = (char )'-';
    } else {
      prefix = (char )flag_prefix;
    }
    if ((int )xtype == 3) {
      if (precision > 0) {
        precision --;
      }
    }
    idx = precision & 4095;
    rounder = (double )arRound[idx % 10];
    while (idx >= 10) {
      rounder *= 1.0e-10;
      idx -= 10;
    }
    if ((int )xtype == 1) {
      rx = (double )realvalue;
      memcpy((void * __restrict  )(& u), (void const   * __restrict  )(& rx), sizeof(u));
      ex = -1023 + (int )((u >> 52) & 2047ULL);
      if (precision + ex / 3 < 15) {
        rounder = (double )((long double )rounder + realvalue * (long double )3e-16);
      }
      realvalue += (long double )rounder;
    }
    exp = 0;
    tmp___14 = sqlite3IsNaN((double )realvalue);
    if (tmp___14) {
      bufpt = (char *)"NaN";
      length = 3;
      break;
    }
    if (realvalue > (long double )0.0) {
      scale = (long double )1.0;
      while (1) {
        if (realvalue >= (long double )1e100 * scale) {
          if (! (exp <= 350)) {
            break;
          }
        } else {
          break;
        }
        scale *= (long double )1e100;
        exp += 100;
      }
      while (1) {
        if (realvalue >= (long double )1e10 * scale) {
          if (! (exp <= 350)) {
            break;
          }
        } else {
          break;
        }
        scale *= (long double )1e10;
        exp += 10;
      }
      while (1) {
        if (realvalue >= (long double )10.0 * scale) {
          if (! (exp <= 350)) {
            break;
          }
        } else {
          break;
        }
        scale *= (long double )10.0;
        exp ++;
      }
      realvalue /= scale;
      while (realvalue < (long double )1e-8) {
        realvalue *= (long double )1e8;
        exp -= 8;
      }
      while (realvalue < (long double )1.0) {
        realvalue *= (long double )10.0;
        exp --;
      }
      if (exp > 350) {
        bufpt = buf;
        buf[0] = prefix;
        memcpy((void * __restrict  )(buf + ((int )prefix != 0)), (void const   * __restrict  )"Inf",
               (size_t )4);
        length = 3 + ((int )prefix != 0);
        break;
      }
    }
    bufpt = buf;
    if ((int )xtype != 1) {
      realvalue += (long double )rounder;
      if (realvalue >= (long double )10.0) {
        realvalue *= (long double )0.1;
        exp ++;
      }
    }
    if ((int )xtype == 3) {
      flag_rtz = (etByte )(! flag_alternateform);
      if (exp < -4) {
        xtype = (etByte )2;
      } else
      if (exp > precision) {
        xtype = (etByte )2;
      } else {
        precision -= exp;
        xtype = (etByte )1;
      }
    } else {
      flag_rtz = flag_altform2;
    }
    if ((int )xtype == 2) {
      e2 = 0;
    } else {
      e2 = exp;
    }
    if (e2 > 0) {
      tmp___15 = e2;
    } else {
      tmp___15 = 0;
    }
    szBufNeeded = (((i64 )tmp___15 + (i64 )precision) + (i64 )width) + 15LL;
    if (szBufNeeded > 70LL) {
      zExtra = printfTempBuf(pAccum, szBufNeeded);
      bufpt = zExtra;
      if ((unsigned long )bufpt == (unsigned long )((char *)0)) {
        return;
      }
    }
    zOut = bufpt;
    nsd = 16 + (int )flag_altform2 * 10;
    if (precision > 0) {
      tmp___16 = 1;
    } else {
      tmp___16 = 0;
    }
    flag_dp = (etByte )((tmp___16 | (int )flag_alternateform) | (int )flag_altform2);
    if (prefix) {
      tmp___17 = bufpt;
      bufpt ++;
      *tmp___17 = prefix;
    }
    if (e2 < 0) {
      tmp___18 = bufpt;
      bufpt ++;
      *tmp___18 = (char )'0';
    } else {
      while (e2 >= 0) {
        tmp___19 = bufpt;
        bufpt ++;
        *tmp___19 = et_getdigit(& realvalue, & nsd);
        e2 --;
      }
    }
    if (flag_dp) {
      tmp___20 = bufpt;
      bufpt ++;
      *tmp___20 = (char )'.';
    }
    e2 ++;
    while (e2 < 0) {
      tmp___21 = bufpt;
      bufpt ++;
      *tmp___21 = (char )'0';
      precision --;
      e2 ++;
    }
    while (1) {
      tmp___23 = precision;
      precision --;
      if (! (tmp___23 > 0)) {
        break;
      }
      tmp___22 = bufpt;
      bufpt ++;
      *tmp___22 = et_getdigit(& realvalue, & nsd);
    }
    if (flag_rtz) {
      if (flag_dp) {
        while ((int )*(bufpt + -1) == 48) {
          bufpt --;
          *bufpt = (char)0;
        }
        if ((int )*(bufpt + -1) == 46) {
          if (flag_altform2) {
            tmp___24 = bufpt;
            bufpt ++;
            *tmp___24 = (char )'0';
          } else {
            bufpt --;
            *bufpt = (char)0;
          }
        }
      }
    }
    if ((int )xtype == 2) {
      tmp___25 = bufpt;
      bufpt ++;
      *tmp___25 = (char )aDigits[infop->charset];
      if (exp < 0) {
        tmp___26 = bufpt;
        bufpt ++;
        *tmp___26 = (char )'-';
        exp = - exp;
      } else {
        tmp___27 = bufpt;
        bufpt ++;
        *tmp___27 = (char )'+';
      }
      if (exp >= 100) {
        tmp___28 = bufpt;
        bufpt ++;
        *tmp___28 = (char )(exp / 100 + 48);
        exp %= 100;
      }
      tmp___29 = bufpt;
      bufpt ++;
      *tmp___29 = (char )(exp / 10 + 48);
      tmp___30 = bufpt;
      bufpt ++;
      *tmp___30 = (char )(exp % 10 + 48);
    }
    *bufpt = (char)0;
    length = (int )(bufpt - zOut);
    bufpt = zOut;
    if (flag_zeropad) {
      if (! flag_leftjustify) {
        if (length < width) {
          nPad = width - length;
          i = width;
          while (i >= nPad) {
            *(bufpt + i) = *(bufpt + (i - nPad));
            i --;
          }
          i = (int )prefix != 0;
          while (1) {
            tmp___32 = nPad;
            nPad --;
            if (! tmp___32) {
              break;
            }
            tmp___31 = i;
            i ++;
            *(bufpt + tmp___31) = (char )'0';
          }
          length = width;
        }
      }
    }
    break;
    case 4: 
    if (! bArgList) {
      tmp___34 = __builtin_va_arg(ap, int *);
      *tmp___34 = (int )pAccum->nChar;
    }
    width = 0;
    length = width;
    break;
    case 7: 
    buf[0] = (char )'%';
    bufpt = buf;
    length = 1;
    break;
    case 8: 
    if (bArgList) {
      bufpt = getTextArg(pArgList);
      length = 1;
      if (bufpt) {
        tmp___35 = bufpt;
        bufpt ++;
        c = (int )*tmp___35;
        buf[0] = (char )c;
        if ((c & 192) == 192) {
          while (1) {
            if (length < 4) {
              if (! (((int )*(bufpt + 0) & 192) == 128)) {
                break;
              }
            } else {
              break;
            }
            tmp___36 = length;
            length ++;
            tmp___37 = bufpt;
            bufpt ++;
            buf[tmp___36] = *tmp___37;
          }
        }
      } else {
        buf[0] = (char)0;
      }
    } else {
      tmp___39 = __builtin_va_arg(ap, unsigned int );
      ch = tmp___39;
      if (ch < 128U) {
        buf[0] = (char )(ch & 255U);
        length = 1;
      } else
      if (ch < 2048U) {
        buf[0] = (char )(192 + (int )((u8 )((ch >> 6) & 31U)));
        buf[1] = (char )(128 + (int )((u8 )(ch & 63U)));
        length = 2;
      } else
      if (ch < 65536U) {
        buf[0] = (char )(224 + (int )((u8 )((ch >> 12) & 15U)));
        buf[1] = (char )(128 + (int )((u8 )((ch >> 6) & 63U)));
        buf[2] = (char )(128 + (int )((u8 )(ch & 63U)));
        length = 3;
      } else {
        buf[0] = (char )(240 + (int )((u8 )((ch >> 18) & 7U)));
        buf[1] = (char )(128 + (int )((u8 )((ch >> 12) & 63U)));
        buf[2] = (char )(128 + (int )((u8 )((ch >> 6) & 63U)));
        buf[3] = (char )(128 + (int )((u8 )(ch & 63U)));
        length = 4;
      }
    }
    if (precision > 1) {
      width -= precision - 1;
      if (width > 1) {
        if (! flag_leftjustify) {
          sqlite3_str_appendchar(pAccum, width - 1, (char )' ');
          width = 0;
        }
      }
      while (1) {
        tmp___40 = precision;
        precision --;
        if (! (tmp___40 > 1)) {
          break;
        }
        sqlite3_str_append(pAccum, (char const   *)(buf), length);
      }
    }
    bufpt = buf;
    flag_altform2 = (etByte )1;
    goto adjust_width_for_utf8;
    case 6: 
    case 5: 
    if (bArgList) {
      bufpt = getTextArg(pArgList);
      xtype = (etByte )5;
    } else {
      tmp___41 = __builtin_va_arg(ap, char *);
      bufpt = tmp___41;
    }
    if ((unsigned long )bufpt == (unsigned long )((char *)0)) {
      bufpt = (char *)"";
    } else
    if ((int )xtype == 6) {
      if (pAccum->nChar == 0U) {
        if (pAccum->mxAlloc) {
          if (width == 0) {
            if (precision < 0) {
              if ((int )pAccum->accError == 0) {
                pAccum->zText = bufpt;
                tmp___42 = sqlite3DbMallocSize(pAccum->db, (void *)bufpt);
                pAccum->nAlloc = (u32 )tmp___42;
                tmp___43 = strlen((char const   *)bufpt);
                pAccum->nChar = (u32 )(2147483647 & (int )tmp___43);
                pAccum->printfFlags = (u8 )((int )pAccum->printfFlags | 4);
                length = 0;
                break;
              }
            }
          }
        }
      }
      zExtra = bufpt;
    }
    if (precision >= 0) {
      if (flag_altform2) {
        z = (unsigned char *)bufpt;
        while (1) {
          tmp___45 = precision;
          precision --;
          if (tmp___45 > 0) {
            if (! *(z + 0)) {
              break;
            }
          } else {
            break;
          }
          tmp___44 = z;
          z ++;
          if ((int )*tmp___44 >= 192) {
            while (((int )*z & 192) == 128) {
              z ++;
            }
          }
        }
        length = (int )(z - (unsigned char *)bufpt);
      } else {
        length = 0;
        while (1) {
          if (length < precision) {
            if (! *(bufpt + length)) {
              break;
            }
          } else {
            break;
          }
          length ++;
        }
      }
    } else {
      tmp___46 = strlen((char const   *)bufpt);
      length = 2147483647 & (int )tmp___46;
    }
    adjust_width_for_utf8: 
    if (flag_altform2) {
      if (width > 0) {
        ii = length - 1;
        while (ii >= 0) {
          tmp___47 = ii;
          ii --;
          if (((int )*(bufpt + tmp___47) & 192) == 128) {
            width ++;
          }
        }
      }
    }
    break;
    case 14: 
    case 10: 
    case 9: 
    if ((int )xtype == 14) {
      tmp___48 = '\"';
    } else {
      tmp___48 = '\'';
    }
    q = (char )tmp___48;
    if (bArgList) {
      escarg = getTextArg(pArgList);
    } else {
      tmp___49 = __builtin_va_arg(ap, char *);
      escarg = tmp___49;
    }
    isnull = (unsigned long )escarg == (unsigned long )((char *)0);
    if (isnull) {
      if ((int )xtype == 10) {
        escarg = (char *)"NULL";
      } else {
        escarg = (char *)"(NULL)";
      }
    }
    k = precision;
    n___0 = 0;
    i___0 = n___0;
    while (1) {
      if (k != 0) {
        ch___0 = *(escarg + i___0);
        if (! ((int )ch___0 != 0)) {
          break;
        }
      } else {
        break;
      }
      if ((int )ch___0 == (int )q) {
        n___0 ++;
      }
      if (flag_altform2) {
        if (((int )ch___0 & 192) == 192) {
          while (((int )*(escarg + (i___0 + 1)) & 192) == 128) {
            i___0 ++;
          }
        }
      }
      i___0 ++;
      k --;
    }
    if (! isnull) {
      if ((int )xtype == 10) {
        tmp___50 = 1;
      } else {
        tmp___50 = 0;
      }
    } else {
      tmp___50 = 0;
    }
    needQuote = tmp___50;
    n___0 += i___0 + 3;
    if (n___0 > 70) {
      zExtra = printfTempBuf(pAccum, (sqlite_int64 )n___0);
      bufpt = zExtra;
      if ((unsigned long )bufpt == (unsigned long )((char *)0)) {
        return;
      }
    } else {
      bufpt = buf;
    }
    j = 0;
    if (needQuote) {
      tmp___51 = j;
      j ++;
      *(bufpt + tmp___51) = q;
    }
    k = i___0;
    i___0 = 0;
    while (i___0 < k) {
      tmp___52 = j;
      j ++;
      ch___0 = *(escarg + i___0);
      *(bufpt + tmp___52) = ch___0;
      if ((int )ch___0 == (int )q) {
        tmp___53 = j;
        j ++;
        *(bufpt + tmp___53) = ch___0;
      }
      i___0 ++;
    }
    if (needQuote) {
      tmp___54 = j;
      j ++;
      *(bufpt + tmp___54) = q;
    }
    *(bufpt + j) = (char)0;
    length = j;
    goto adjust_width_for_utf8;
    case 11: 
    if (((int )pAccum->printfFlags & 1) == 0) {
      return;
    }
    tmp___55 = __builtin_va_arg(ap, Token *);
    pToken = tmp___55;
    if (pToken) {
      if (pToken->n) {
        sqlite3_str_append(pAccum, pToken->z, (int )pToken->n);
      }
    }
    width = 0;
    length = width;
    break;
    case 12: 
    if (((int )pAccum->printfFlags & 1) == 0) {
      return;
    }
    tmp___56 = __builtin_va_arg(ap, SrcList *);
    pSrc = tmp___56;
    tmp___57 = __builtin_va_arg(ap, int );
    k___0 = tmp___57;
    pItem = & pSrc->a[k___0];
    if (pItem->zDatabase) {
      sqlite3_str_appendall(pAccum, (char const   *)pItem->zDatabase);
      sqlite3_str_append(pAccum, ".", 1);
    }
    sqlite3_str_appendall(pAccum, (char const   *)pItem->zName);
    width = 0;
    length = width;
    break;
    default: 
    return;
    }
    width -= length;
    if (width > 0) {
      if (! flag_leftjustify) {
        sqlite3_str_appendchar(pAccum, width, (char )' ');
      }
      sqlite3_str_append(pAccum, (char const   *)bufpt, length);
      if (flag_leftjustify) {
        sqlite3_str_appendchar(pAccum, width, (char )' ');
      }
    } else {
      sqlite3_str_append(pAccum, (char const   *)bufpt, length);
    }
    if (zExtra) {
      sqlite3DbFree(pAccum->db, (void *)zExtra);
      zExtra = (char *)0;
    }
    fmt ++;
  }
  return;
}
}
static int sqlite3StrAccumEnlarge(StrAccum *p , int N ) 
{ 
  char *zNew ;
  char *zOld ;
  char *tmp ;
  i64 szNew ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  if (p->accError) {
    return (0);
  }
  if (p->mxAlloc == 0U) {
    setStrAccumError(p, (u8 )18);
    return ((int )((p->nAlloc - p->nChar) - 1U));
  } else {
    if (((int )p->printfFlags & 4) != 0) {
      tmp = p->zText;
    } else {
      tmp = (char *)0;
    }
    zOld = tmp;
    szNew = (i64 )p->nChar;
    szNew += (i64 )(N + 1);
    if (szNew + (i64 )p->nChar <= (i64 )p->mxAlloc) {
      szNew += (i64 )p->nChar;
    }
    if (szNew > (i64 )p->mxAlloc) {
      sqlite3_str_reset(p);
      setStrAccumError(p, (u8 )18);
      return (0);
    } else {
      p->nAlloc = (u32 )((int )szNew);
    }
    if (p->db) {
      tmp___0 = sqlite3DbRealloc(p->db, (void *)zOld, (u64 )p->nAlloc);
      zNew = (char *)tmp___0;
    } else {
      tmp___1 = sqlite3_realloc64((void *)zOld, (sqlite_uint64 )p->nAlloc);
      zNew = (char *)tmp___1;
    }
    if (zNew) {
      if (! (((int )p->printfFlags & 4) != 0)) {
        if (p->nChar > 0U) {
          memcpy((void * __restrict  )zNew, (void const   * __restrict  )p->zText,
                 (size_t )p->nChar);
        }
      }
      p->zText = zNew;
      tmp___2 = sqlite3DbMallocSize(p->db, (void *)zNew);
      p->nAlloc = (u32 )tmp___2;
      p->printfFlags = (u8 )((int )p->printfFlags | 4);
    } else {
      sqlite3_str_reset(p);
      setStrAccumError(p, (u8 )7);
      return (0);
    }
  }
  return (N);
}
}
void sqlite3_str_appendchar(sqlite3_str *p , int N , char c ) 
{ 
  u32 tmp ;
  int tmp___0 ;

  {
  if ((i64 )p->nChar + (i64 )N >= (i64 )p->nAlloc) {
    N = sqlite3StrAccumEnlarge(p, N);
    if (N <= 0) {
      return;
    }
  }
  while (1) {
    tmp___0 = N;
    N --;
    if (! (tmp___0 > 0)) {
      break;
    }
    tmp = p->nChar;
    (p->nChar) ++;
    *(p->zText + tmp) = c;
  }
  return;
}
}
static void ( __attribute__((__noinline__)) enlargeAndAppend)(StrAccum *p , char const   *z ,
                                                              int N ) 
{ 


  {
  N = sqlite3StrAccumEnlarge(p, N);
  if (N > 0) {
    memcpy((void * __restrict  )(p->zText + p->nChar), (void const   * __restrict  )z,
           (size_t )N);
    p->nChar += (u32 )N;
  }
  return;
}
}
void sqlite3_str_append(sqlite3_str *p , char const   *z , int N ) 
{ 


  {
  if (p->nChar + (u32 )N >= p->nAlloc) {
    enlargeAndAppend(p, z, N);
  } else
  if (N) {
    p->nChar += (u32 )N;
    memcpy((void * __restrict  )(p->zText + (p->nChar - (u32 )N)), (void const   * __restrict  )z,
           (size_t )N);
  }
  return;
}
}
void sqlite3_str_appendall(sqlite3_str *p , char const   *z ) 
{ 
  int tmp ;

  {
  tmp = sqlite3Strlen30(z);
  sqlite3_str_append(p, z, tmp);
  return;
}
}
static char *( __attribute__((__noinline__)) strAccumFinishRealloc)(StrAccum *p ) 
{ 
  char *zText___0 ;
  void *tmp ;

  {
  tmp = sqlite3DbMallocRaw(p->db, (u64 )(p->nChar + 1U));
  zText___0 = (char *)tmp;
  if (zText___0) {
    memcpy((void * __restrict  )zText___0, (void const   * __restrict  )p->zText,
           (size_t )(p->nChar + 1U));
    p->printfFlags = (u8 )((int )p->printfFlags | 4);
  } else {
    setStrAccumError(p, (u8 )7);
  }
  p->zText = zText___0;
  return (zText___0);
}
}
static char *sqlite3StrAccumFinish(StrAccum *p ) 
{ 
  char *tmp ;

  {
  if (p->zText) {
    *(p->zText + p->nChar) = (char)0;
    if (p->mxAlloc > 0U) {
      if (! (((int )p->printfFlags & 4) != 0)) {
        tmp = strAccumFinishRealloc(p);
        return (tmp);
      }
    }
  }
  return (p->zText);
}
}
static sqlite3_str sqlite3OomStr  =    {(sqlite3 *)0, (char *)0, (u32 )0, (u32 )0, (u32 )0, (u8 )7, (u8 )0};
char *sqlite3_str_finish(sqlite3_str *p ) 
{ 
  char *z ;

  {
  if ((unsigned long )p != (unsigned long )((sqlite3_str *)0)) {
    if ((unsigned long )p != (unsigned long )(& sqlite3OomStr)) {
      z = sqlite3StrAccumFinish(p);
      sqlite3_free((void *)p);
    } else {
      z = (char *)0;
    }
  } else {
    z = (char *)0;
  }
  return (z);
}
}
int sqlite3_str_errcode(sqlite3_str *p ) 
{ 
  int tmp ;

  {
  if (p) {
    tmp = (int )p->accError;
  } else {
    tmp = 7;
  }
  return (tmp);
}
}
int sqlite3_str_length(sqlite3_str *p ) 
{ 
  u32 tmp ;

  {
  if (p) {
    tmp = p->nChar;
  } else {
    tmp = (u32 )0;
  }
  return ((int )tmp);
}
}
char *sqlite3_str_value(sqlite3_str *p ) 
{ 


  {
  if ((unsigned long )p == (unsigned long )((sqlite3_str *)0)) {
    return ((char *)0);
  } else
  if (p->nChar == 0U) {
    return ((char *)0);
  }
  *(p->zText + p->nChar) = (char)0;
  return (p->zText);
}
}
void sqlite3_str_reset(struct sqlite3_str *p ) 
{ 


  {
  if (((int )p->printfFlags & 4) != 0) {
    sqlite3DbFree(p->db, (void *)p->zText);
    p->printfFlags = (u8 )((int )p->printfFlags & -5);
  }
  p->nAlloc = (u32 )0;
  p->nChar = (u32 )0;
  p->zText = (char *)0;
  return;
}
}
static void sqlite3StrAccumInit(StrAccum *p , sqlite3 *db , char *zBase , int n ,
                                int mx ) 
{ 


  {
  p->zText = zBase;
  p->db = db;
  p->nAlloc = (u32 )n;
  p->mxAlloc = (u32 )mx;
  p->nChar = (u32 )0;
  p->accError = (u8 )0;
  p->printfFlags = (u8 )0;
  return;
}
}
sqlite3_str *sqlite3_str_new(sqlite3 *db ) 
{ 
  sqlite3_str *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_malloc64((sqlite_uint64 )sizeof(*p));
  p = (sqlite3_str *)tmp;
  if (p) {
    if (db) {
      tmp___0 = db->aLimit[0];
    } else {
      tmp___0 = 1000000000;
    }
    sqlite3StrAccumInit(p, (sqlite3 *)0, (char *)0, 0, tmp___0);
  } else {
    p = & sqlite3OomStr;
  }
  return (p);
}
}
static char *sqlite3VMPrintf(sqlite3 *db , char const   *zFormat , va_list ap ) 
{ 
  char *z ;
  char zBase[70] ;
  StrAccum acc ;

  {
  sqlite3StrAccumInit(& acc, db, zBase, (int )sizeof(zBase), db->aLimit[0]);
  acc.printfFlags = (u8 )1;
  sqlite3_str_vappendf(& acc, zFormat, ap);
  z = sqlite3StrAccumFinish(& acc);
  if ((int )acc.accError == 7) {
    sqlite3OomFault(db);
  }
  return (z);
}
}
static char *sqlite3MPrintf(sqlite3 *db , char const   *zFormat  , ...) 
{ 
  va_list ap ;
  char *z ;

  {
  __builtin_va_start(ap, zFormat);
  z = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  return (z);
}
}
char *sqlite3_vmprintf(char const   *zFormat , va_list ap ) 
{ 
  char *z ;
  char zBase[70] ;
  StrAccum acc ;
  int tmp ;

  {
  tmp = sqlite3_initialize();
  if (tmp) {
    return ((char *)0);
  }
  sqlite3StrAccumInit(& acc, (sqlite3 *)0, zBase, (int )sizeof(zBase), 1000000000);
  sqlite3_str_vappendf(& acc, zFormat, ap);
  z = sqlite3StrAccumFinish(& acc);
  return (z);
}
}
char *sqlite3_mprintf(char const   *zFormat  , ...) 
{ 
  va_list ap ;
  char *z ;
  int tmp ;

  {
  tmp = sqlite3_initialize();
  if (tmp) {
    return ((char *)0);
  }
  __builtin_va_start(ap, zFormat);
  z = sqlite3_vmprintf(zFormat, ap);
  __builtin_va_end(ap);
  return (z);
}
}
char *sqlite3_vsnprintf(int n , char *zBuf , char const   *zFormat , va_list ap ) 
{ 
  StrAccum acc ;

  {
  if (n <= 0) {
    return (zBuf);
  }
  sqlite3StrAccumInit(& acc, (sqlite3 *)0, zBuf, n, 0);
  sqlite3_str_vappendf(& acc, zFormat, ap);
  *(zBuf + acc.nChar) = (char)0;
  return (zBuf);
}
}
char *sqlite3_snprintf(int n , char *zBuf , char const   *zFormat  , ...) 
{ 
  char *z ;
  va_list ap ;

  {
  __builtin_va_start(ap, zFormat);
  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
  __builtin_va_end(ap);
  return (z);
}
}
static void renderLogMsg(int iErrCode , char const   *zFormat , va_list ap ) 
{ 
  StrAccum acc ;
  char zMsg[210] ;
  char *tmp ;

  {
  sqlite3StrAccumInit(& acc, (sqlite3 *)0, zMsg, (int )sizeof(zMsg), 0);
  sqlite3_str_vappendf(& acc, zFormat, ap);
  tmp = sqlite3StrAccumFinish(& acc);
  (*(sqlite3Config.xLog))(sqlite3Config.pLogArg, iErrCode, (char const   *)tmp);
  return;
}
}
void sqlite3_log(int iErrCode , char const   *zFormat  , ...) 
{ 
  va_list ap ;

  {
  if (sqlite3Config.xLog) {
    __builtin_va_start(ap, zFormat);
    renderLogMsg(iErrCode, zFormat, ap);
    __builtin_va_end(ap);
  }
  return;
}
}
void sqlite3_str_appendf(struct sqlite3_str *p , char const   *zFormat  , ...) 
{ 
  va_list ap ;

  {
  __builtin_va_start(ap, zFormat);
  sqlite3_str_vappendf(p, zFormat, ap);
  __builtin_va_end(ap);
  return;
}
}
static struct sqlite3PrngType sqlite3Prng  ;
void sqlite3_randomness(int N , void *pBuf ) 
{ 
  unsigned char t ;
  unsigned char *zBuf ;
  int tmp ;
  int i ;
  char k[256] ;
  sqlite3_vfs *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  zBuf = (unsigned char *)pBuf;
  tmp = sqlite3_initialize();
  if (tmp) {
    return;
  }
  if (N <= 0) {
    sqlite3Prng.isInit = (unsigned char)0;
    return;
  } else
  if ((unsigned long )pBuf == (unsigned long )((void *)0)) {
    sqlite3Prng.isInit = (unsigned char)0;
    return;
  }
  if (! sqlite3Prng.isInit) {
    sqlite3Prng.j = (unsigned char)0;
    sqlite3Prng.i = (unsigned char)0;
    tmp___0 = sqlite3_vfs_find((char const   *)0);
    sqlite3OsRandomness(tmp___0, 256, k);
    i = 0;
    while (i < 256) {
      sqlite3Prng.s[i] = (u8 )i;
      i ++;
    }
    i = 0;
    while (i < 256) {
      sqlite3Prng.j = (unsigned char )((int )sqlite3Prng.j + ((int )sqlite3Prng.s[i] + (int )k[i]));
      t = sqlite3Prng.s[sqlite3Prng.j];
      sqlite3Prng.s[sqlite3Prng.j] = sqlite3Prng.s[i];
      sqlite3Prng.s[i] = t;
      i ++;
    }
    sqlite3Prng.isInit = (unsigned char)1;
  }
  while (1) {
    sqlite3Prng.i = (unsigned char )((int )sqlite3Prng.i + 1);
    t = sqlite3Prng.s[sqlite3Prng.i];
    sqlite3Prng.j = (unsigned char )((int )sqlite3Prng.j + (int )t);
    sqlite3Prng.s[sqlite3Prng.i] = sqlite3Prng.s[sqlite3Prng.j];
    sqlite3Prng.s[sqlite3Prng.j] = t;
    t = (unsigned char )((int )t + (int )sqlite3Prng.s[sqlite3Prng.i]);
    tmp___1 = zBuf;
    zBuf ++;
    *tmp___1 = sqlite3Prng.s[t];
    N --;
    if (! N) {
      break;
    }
  }
  return;
}
}
static struct sqlite3PrngType sqlite3SavedPrng  ;
static void sqlite3PrngSaveState(void) 
{ 


  {
  memcpy((void * __restrict  )(& sqlite3SavedPrng), (void const   * __restrict  )(& sqlite3Prng),
         sizeof(sqlite3Prng));
  return;
}
}
static void sqlite3PrngRestoreState(void) 
{ 


  {
  memcpy((void * __restrict  )(& sqlite3Prng), (void const   * __restrict  )(& sqlite3SavedPrng),
         sizeof(sqlite3Prng));
  return;
}
}
static unsigned char const   sqlite3Utf8Trans1[64]  = 
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0};
static u32 sqlite3Utf8Read(unsigned char const   **pz ) 
{ 
  unsigned int c ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
  tmp = *pz;
  (*pz) ++;
  c = (unsigned int )*tmp;
  if (c >= 192U) {
    c = (unsigned int )sqlite3Utf8Trans1[c - 192U];
    while (((int const   )*(*pz) & 192) == 128) {
      tmp___0 = *pz;
      (*pz) ++;
      c = (c << 6) + (unsigned int )(63 & (int )*tmp___0);
    }
    if (c < 128U) {
      c = 65533U;
    } else
    if ((c & 4294965248U) == 55296U) {
      c = 65533U;
    } else
    if ((c & 4294967294U) == 65534U) {
      c = 65533U;
    }
  }
  return (c);
}
}
static int ( __attribute__((__noinline__)) sqlite3VdbeMemTranslate)(Mem *pMem , u8 desiredEnc ) 
{ 
  sqlite_int64 len ;
  unsigned char *zOut ;
  unsigned char *zIn ;
  unsigned char *zTerm ;
  unsigned char *z ;
  unsigned int c ;
  u8 temp ;
  int rc ;
  unsigned char *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  int c2 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  int c2___0 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char *tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned char *tmp___41 ;
  unsigned char *tmp___42 ;
  unsigned char *tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;

  {
  if ((int )pMem->enc != 1) {
    if ((int )desiredEnc != 1) {
      rc = sqlite3VdbeMemMakeWriteable(pMem);
      if (rc != 0) {
        return (7);
      }
      zIn = (u8 *)pMem->z;
      zTerm = zIn + (pMem->n & -2);
      while ((unsigned long )zIn < (unsigned long )zTerm) {
        temp = *zIn;
        *zIn = *(zIn + 1);
        zIn ++;
        tmp = zIn;
        zIn ++;
        *tmp = temp;
      }
      pMem->enc = desiredEnc;
      goto translate_out;
    }
  }
  if ((int )desiredEnc == 1) {
    pMem->n &= -2;
    len = 2LL * (sqlite_int64 )pMem->n + 1LL;
  } else {
    len = 2LL * (sqlite_int64 )pMem->n + 2LL;
  }
  zIn = (u8 *)pMem->z;
  zTerm = zIn + pMem->n;
  tmp___0 = sqlite3DbMallocRaw(pMem->db, (u64 )len);
  zOut = (unsigned char *)tmp___0;
  if (! zOut) {
    return (7);
  }
  z = zOut;
  if ((int )pMem->enc == 1) {
    if ((int )desiredEnc == 2) {
      while ((unsigned long )zIn < (unsigned long )zTerm) {
        tmp___1 = zIn;
        zIn ++;
        c = (unsigned int )*tmp___1;
        if (c >= 192U) {
          c = (unsigned int )sqlite3Utf8Trans1[c - 192U];
          while (1) {
            if ((unsigned long )zIn != (unsigned long )zTerm) {
              if (! (((int )*zIn & 192) == 128)) {
                break;
              }
            } else {
              break;
            }
            tmp___2 = zIn;
            zIn ++;
            c = (c << 6) + (unsigned int )(63 & (int )*tmp___2);
          }
          if (c < 128U) {
            c = 65533U;
          } else
          if ((c & 4294965248U) == 55296U) {
            c = 65533U;
          } else
          if ((c & 4294967294U) == 65534U) {
            c = 65533U;
          }
        }
        if (c <= 65535U) {
          tmp___3 = z;
          z ++;
          *tmp___3 = (u8 )(c & 255U);
          tmp___4 = z;
          z ++;
          *tmp___4 = (u8 )((c >> 8) & 255U);
        } else {
          tmp___5 = z;
          z ++;
          *tmp___5 = (u8 )(((c >> 10) & 63U) + (((c - 65536U) >> 10) & 192U));
          tmp___6 = z;
          z ++;
          *tmp___6 = (u8 )(216U + (((c - 65536U) >> 18) & 3U));
          tmp___7 = z;
          z ++;
          *tmp___7 = (u8 )(c & 255U);
          tmp___8 = z;
          z ++;
          *tmp___8 = (u8 )(220U + ((c >> 8) & 3U));
        }
      }
    } else {
      while ((unsigned long )zIn < (unsigned long )zTerm) {
        tmp___9 = zIn;
        zIn ++;
        c = (unsigned int )*tmp___9;
        if (c >= 192U) {
          c = (unsigned int )sqlite3Utf8Trans1[c - 192U];
          while (1) {
            if ((unsigned long )zIn != (unsigned long )zTerm) {
              if (! (((int )*zIn & 192) == 128)) {
                break;
              }
            } else {
              break;
            }
            tmp___10 = zIn;
            zIn ++;
            c = (c << 6) + (unsigned int )(63 & (int )*tmp___10);
          }
          if (c < 128U) {
            c = 65533U;
          } else
          if ((c & 4294965248U) == 55296U) {
            c = 65533U;
          } else
          if ((c & 4294967294U) == 65534U) {
            c = 65533U;
          }
        }
        if (c <= 65535U) {
          tmp___11 = z;
          z ++;
          *tmp___11 = (u8 )((c >> 8) & 255U);
          tmp___12 = z;
          z ++;
          *tmp___12 = (u8 )(c & 255U);
        } else {
          tmp___13 = z;
          z ++;
          *tmp___13 = (u8 )(216U + (((c - 65536U) >> 18) & 3U));
          tmp___14 = z;
          z ++;
          *tmp___14 = (u8 )(((c >> 10) & 63U) + (((c - 65536U) >> 10) & 192U));
          tmp___15 = z;
          z ++;
          *tmp___15 = (u8 )(220U + ((c >> 8) & 3U));
          tmp___16 = z;
          z ++;
          *tmp___16 = (u8 )(c & 255U);
        }
      }
    }
    pMem->n = (int )(z - zOut);
    tmp___17 = z;
    z ++;
    *tmp___17 = (unsigned char)0;
  } else {
    if ((int )pMem->enc == 2) {
      while ((unsigned long )zIn < (unsigned long )zTerm) {
        tmp___18 = zIn;
        zIn ++;
        c = (unsigned int )*tmp___18;
        tmp___19 = zIn;
        zIn ++;
        c += (unsigned int )((int )*tmp___19 << 8);
        if (c >= 55296U) {
          if (c < 57344U) {
            if ((unsigned long )zIn < (unsigned long )zTerm) {
              tmp___20 = zIn;
              zIn ++;
              c2 = (int )*tmp___20;
              tmp___21 = zIn;
              zIn ++;
              c2 += (int )*tmp___21 << 8;
              c = ((unsigned int )(c2 & 1023) + ((c & 63U) << 10)) + (((c & 960U) + 64U) << 10);
            }
          }
        }
        if (c < 128U) {
          tmp___22 = z;
          z ++;
          *tmp___22 = (u8 )(c & 255U);
        } else
        if (c < 2048U) {
          tmp___23 = z;
          z ++;
          *tmp___23 = (unsigned char )(192 + (int )((u8 )((c >> 6) & 31U)));
          tmp___24 = z;
          z ++;
          *tmp___24 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
        } else
        if (c < 65536U) {
          tmp___25 = z;
          z ++;
          *tmp___25 = (unsigned char )(224 + (int )((u8 )((c >> 12) & 15U)));
          tmp___26 = z;
          z ++;
          *tmp___26 = (unsigned char )(128 + (int )((u8 )((c >> 6) & 63U)));
          tmp___27 = z;
          z ++;
          *tmp___27 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
        } else {
          tmp___28 = z;
          z ++;
          *tmp___28 = (unsigned char )(240 + (int )((u8 )((c >> 18) & 7U)));
          tmp___29 = z;
          z ++;
          *tmp___29 = (unsigned char )(128 + (int )((u8 )((c >> 12) & 63U)));
          tmp___30 = z;
          z ++;
          *tmp___30 = (unsigned char )(128 + (int )((u8 )((c >> 6) & 63U)));
          tmp___31 = z;
          z ++;
          *tmp___31 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
        }
      }
    } else {
      while ((unsigned long )zIn < (unsigned long )zTerm) {
        tmp___32 = zIn;
        zIn ++;
        c = (unsigned int )((int )*tmp___32 << 8);
        tmp___33 = zIn;
        zIn ++;
        c += (unsigned int )*tmp___33;
        if (c >= 55296U) {
          if (c < 57344U) {
            if ((unsigned long )zIn < (unsigned long )zTerm) {
              tmp___34 = zIn;
              zIn ++;
              c2___0 = (int )*tmp___34 << 8;
              tmp___35 = zIn;
              zIn ++;
              c2___0 += (int )*tmp___35;
              c = ((unsigned int )(c2___0 & 1023) + ((c & 63U) << 10)) + (((c & 960U) + 64U) << 10);
            }
          }
        }
        if (c < 128U) {
          tmp___36 = z;
          z ++;
          *tmp___36 = (u8 )(c & 255U);
        } else
        if (c < 2048U) {
          tmp___37 = z;
          z ++;
          *tmp___37 = (unsigned char )(192 + (int )((u8 )((c >> 6) & 31U)));
          tmp___38 = z;
          z ++;
          *tmp___38 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
        } else
        if (c < 65536U) {
          tmp___39 = z;
          z ++;
          *tmp___39 = (unsigned char )(224 + (int )((u8 )((c >> 12) & 15U)));
          tmp___40 = z;
          z ++;
          *tmp___40 = (unsigned char )(128 + (int )((u8 )((c >> 6) & 63U)));
          tmp___41 = z;
          z ++;
          *tmp___41 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
        } else {
          tmp___42 = z;
          z ++;
          *tmp___42 = (unsigned char )(240 + (int )((u8 )((c >> 18) & 7U)));
          tmp___43 = z;
          z ++;
          *tmp___43 = (unsigned char )(128 + (int )((u8 )((c >> 12) & 63U)));
          tmp___44 = z;
          z ++;
          *tmp___44 = (unsigned char )(128 + (int )((u8 )((c >> 6) & 63U)));
          tmp___45 = z;
          z ++;
          *tmp___45 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
        }
      }
    }
    pMem->n = (int )(z - zOut);
  }
  *z = (unsigned char)0;
  c = (unsigned int )pMem->flags;
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = (u16 )(514U | (c & 32831U));
  pMem->enc = desiredEnc;
  pMem->z = (char *)zOut;
  pMem->zMalloc = pMem->z;
  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, (void *)pMem->z);
  translate_out: 
  return (0);
}
}
static int sqlite3VdbeMemHandleBom(Mem *pMem ) 
{ 
  int rc ;
  u8 bom ;
  u8 b1 ;
  u8 b2 ;

  {
  rc = 0;
  bom = (u8 )0;
  if (pMem->n > 1) {
    b1 = *((u8 *)pMem->z);
    b2 = *((u8 *)pMem->z + 1);
    if ((int )b1 == 254) {
      if ((int )b2 == 255) {
        bom = (u8 )3;
      }
    }
    if ((int )b1 == 255) {
      if ((int )b2 == 254) {
        bom = (u8 )2;
      }
    }
  }
  if (bom) {
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if (rc == 0) {
      pMem->n -= 2;
      memmove((void *)pMem->z, (void const   *)(pMem->z + 2), (size_t )pMem->n);
      *(pMem->z + pMem->n) = (char )'\000';
      *(pMem->z + (pMem->n + 1)) = (char )'\000';
      pMem->flags = (u16 )((int )pMem->flags | 512);
      pMem->enc = bom;
    }
  }
  return (rc);
}
}
static int sqlite3Utf8CharLen(char const   *zIn , int nByte ) 
{ 
  int r ;
  u8 const   *z ;
  u8 const   *zTerm ;
  u8 const   *tmp ;

  {
  r = 0;
  z = (u8 const   *)zIn;
  if (nByte >= 0) {
    zTerm = z + nByte;
  } else {
    zTerm = (u8 const   *)-1;
  }
  while (1) {
    if ((int const   )*z != 0) {
      if (! ((unsigned long )z < (unsigned long )zTerm)) {
        break;
      }
    } else {
      break;
    }
    tmp = z;
    z ++;
    if ((int const   )*tmp >= 192) {
      while (((int const   )*z & 192) == 128) {
        z ++;
      }
    }
    r ++;
  }
  return (r);
}
}
static char *sqlite3Utf16to8(sqlite3 *db , void const   *z , int nByte , u8 enc ) 
{ 
  Mem m ;

  {
  memset((void *)(& m), 0, sizeof(m));
  m.db = db;
  sqlite3VdbeMemSetStr(& m, (char const   *)z, nByte, enc, (void (*)(void * ))0);
  sqlite3VdbeChangeEncoding(& m, 1);
  if (db->mallocFailed) {
    sqlite3VdbeMemRelease(& m);
    m.z = (char *)0;
  }
  return (m.z);
}
}
static int sqlite3Utf16ByteLen(void const   *zIn , int nChar ) 
{ 
  int c ;
  unsigned char const   *z ;
  int n ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  int c2___0 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;

  {
  z = (unsigned char const   *)zIn;
  n = 0;
  while (n < nChar) {
    tmp___3 = z;
    z ++;
    c = (int )*tmp___3;
    tmp___4 = z;
    z ++;
    c += (int )((int const   )*tmp___4 << 8);
    if (c >= 55296) {
      if (c < 57344) {
        tmp___5 = z;
        z ++;
        c2___0 = (int )*tmp___5;
        tmp___6 = z;
        z ++;
        c2___0 += (int )((int const   )*tmp___6 << 8);
        c = ((c2___0 & 1023) + ((c & 63) << 10)) + (((c & 960) + 64) << 10);
      }
    }
    n ++;
  }
  return ((int )(z - (unsigned char const   *)zIn));
}
}
static int sqlite3FaultSim(int iTest ) 
{ 
  int (*xCallback)(int  ) ;
  int tmp ;
  int tmp___0 ;

  {
  xCallback = sqlite3Config.xTestCallback;
  if (xCallback) {
    tmp = (*xCallback)(iTest);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3IsNaN(double x___0 ) 
{ 
  u64 y ;
  int tmp ;

  {
  memcpy((void * __restrict  )(& y), (void const   * __restrict  )(& x___0), sizeof(y));
  if ((y & (2047ULL << 52)) == 2047ULL << 52) {
    if ((y & ((1ULL << 52) - 1ULL)) != 0ULL) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int sqlite3Strlen30(char const   *z ) 
{ 
  size_t tmp ;

  {
  if ((unsigned long )z == (unsigned long )((char const   *)0)) {
    return (0);
  }
  tmp = strlen(z);
  return (1073741823 & (int )tmp);
}
}
static char *sqlite3ColumnType(Column *pCol , char *zDflt ) 
{ 
  size_t tmp ;

  {
  if (((int )pCol->colFlags & 4) == 0) {
    return (zDflt);
  }
  tmp = strlen((char const   *)pCol->zName);
  return ((pCol->zName + tmp) + 1);
}
}
static void ( __attribute__((__noinline__)) sqlite3ErrorFinish)(sqlite3 *db , int err_code ) 
{ 


  {
  if (db->pErr) {
    sqlite3ValueSetNull(db->pErr);
  }
  sqlite3SystemError(db, err_code);
  return;
}
}
static void sqlite3Error(sqlite3 *db , int err_code ) 
{ 


  {
  db->errCode = err_code;
  if (err_code) {
    sqlite3ErrorFinish(db, err_code);
  } else
  if (db->pErr) {
    sqlite3ErrorFinish(db, err_code);
  }
  return;
}
}
static void sqlite3SystemError(sqlite3 *db , int rc ) 
{ 


  {
  if (rc == (10 | (12 << 8))) {
    return;
  }
  rc &= 255;
  if (rc == 14) {
    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);
  } else
  if (rc == 10) {
    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);
  }
  return;
}
}
static void sqlite3ErrorWithMsg(sqlite3 *db , int err_code , char const   *zFormat 
                                , ...) 
{ 
  char *z ;
  va_list ap ;
  sqlite3_value *tmp ;

  {
  db->errCode = err_code;
  sqlite3SystemError(db, err_code);
  if ((unsigned long )zFormat == (unsigned long )((char const   *)0)) {
    sqlite3Error(db, err_code);
  } else
  if (db->pErr) {
    __builtin_va_start(ap, zFormat);
    z = sqlite3VMPrintf(db, zFormat, ap);
    __builtin_va_end(ap);
    sqlite3ValueSetStr(db->pErr, -1, (void const   *)z, (u8 )1, (void (*)(void * ))(& sqlite3MallocSize));
  } else {
    tmp = sqlite3ValueNew(db);
    db->pErr = tmp;
    if ((unsigned long )tmp != (unsigned long )((sqlite3_value *)0)) {
      __builtin_va_start(ap, zFormat);
      z = sqlite3VMPrintf(db, zFormat, ap);
      __builtin_va_end(ap);
      sqlite3ValueSetStr(db->pErr, -1, (void const   *)z, (u8 )1, (void (*)(void * ))(& sqlite3MallocSize));
    }
  }
  return;
}
}
static void sqlite3ErrorMsg(Parse *pParse , char const   *zFormat  , ...) 
{ 
  char *zMsg ;
  va_list ap ;
  sqlite3 *db ;

  {
  db = pParse->db;
  __builtin_va_start(ap, zFormat);
  zMsg = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  if (db->suppressErr) {
    sqlite3DbFree(db, (void *)zMsg);
  } else {
    (pParse->nErr) ++;
    sqlite3DbFree(db, (void *)pParse->zErrMsg);
    pParse->zErrMsg = zMsg;
    pParse->rc = 1;
  }
  return;
}
}
static int sqlite3ErrorToParser(sqlite3 *db , int errCode ) 
{ 
  Parse *pParse ;

  {
  if ((unsigned long )db == (unsigned long )((sqlite3 *)0)) {
    return (errCode);
  } else {
    pParse = db->pParse;
    if ((unsigned long )pParse == (unsigned long )((Parse *)0)) {
      return (errCode);
    }
  }
  pParse->rc = errCode;
  (pParse->nErr) ++;
  return (errCode);
}
}
static void sqlite3Dequote(char *z ) 
{ 
  char quote ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )z == (unsigned long )((char *)0)) {
    return;
  }
  quote = *(z + 0);
  if (! ((int const   )sqlite3CtypeMap[(unsigned char )quote] & 128)) {
    return;
  }
  if ((int )quote == 91) {
    quote = (char )']';
  }
  i = 1;
  j = 0;
  while (1) {
    if ((int )*(z + i) == (int )quote) {
      if ((int )*(z + (i + 1)) == (int )quote) {
        tmp = j;
        j ++;
        *(z + tmp) = quote;
        i ++;
      } else {
        break;
      }
    } else {
      tmp___0 = j;
      j ++;
      *(z + tmp___0) = *(z + i);
    }
    i ++;
  }
  *(z + j) = (char)0;
  return;
}
}
static void sqlite3DequoteExpr(Expr *p ) 
{ 
  int tmp ;

  {
  if ((int )*(p->u.zToken + 0) == 34) {
    tmp = 67108928;
  } else {
    tmp = 67108864;
  }
  p->flags |= (unsigned int )tmp;
  sqlite3Dequote(p->u.zToken);
  return;
}
}
static void sqlite3TokenInit(Token *p , char *z ) 
{ 
  int tmp ;

  {
  p->z = (char const   *)z;
  tmp = sqlite3Strlen30((char const   *)z);
  p->n = (unsigned int )tmp;
  return;
}
}
int sqlite3_stricmp(char const   *zLeft , char const   *zRight ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )zLeft == (unsigned long )((char const   *)0)) {
    if (zRight) {
      tmp = -1;
    } else {
      tmp = 0;
    }
    return (tmp);
  } else
  if ((unsigned long )zRight == (unsigned long )((char const   *)0)) {
    return (1);
  }
  tmp___0 = sqlite3StrICmp(zLeft, zRight);
  return (tmp___0);
}
}
static int sqlite3StrICmp(char const   *zLeft , char const   *zRight ) 
{ 
  unsigned char *a___0 ;
  unsigned char *b ;
  int c ;
  int x___0 ;

  {
  a___0 = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while (1) {
    c = (int )*a___0;
    x___0 = (int )*b;
    if (c == x___0) {
      if (c == 0) {
        break;
      }
    } else {
      c = (int )sqlite3UpperToLower[c] - (int )sqlite3UpperToLower[x___0];
      if (c) {
        break;
      }
    }
    a___0 ++;
    b ++;
  }
  return (c);
}
}
int sqlite3_strnicmp(char const   *zLeft , char const   *zRight , int N ) 
{ 
  register unsigned char *a___0 ;
  register unsigned char *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )zLeft == (unsigned long )((char const   *)0)) {
    if (zRight) {
      tmp = -1;
    } else {
      tmp = 0;
    }
    return (tmp);
  } else
  if ((unsigned long )zRight == (unsigned long )((char const   *)0)) {
    return (1);
  }
  a___0 = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while (1) {
    tmp___0 = N;
    N --;
    if (tmp___0 > 0) {
      if ((int )*a___0 != 0) {
        if (! ((int const   )sqlite3UpperToLower[*a___0] == (int const   )sqlite3UpperToLower[*b])) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    a___0 ++;
    b ++;
  }
  if (N < 0) {
    tmp___1 = 0;
  } else {
    tmp___1 = (int )((int const   )sqlite3UpperToLower[*a___0] - (int const   )sqlite3UpperToLower[*b]);
  }
  return (tmp___1);
}
}
static long double sqlite3Pow10(int E ) 
{ 
  long double x___0 ;
  long double r ;

  {
  x___0 = (long double )10.0;
  r = (long double )1.0;
  while (1) {
    if (E & 1) {
      r *= x___0;
    }
    E >>= 1;
    if (E == 0) {
      break;
    }
    x___0 *= x___0;
  }
  return (r);
}
}
static int sqlite3AtoF(char const   *z , double *pResult , int length , u8 enc ) 
{ 
  int incr ;
  char const   *zEnd ;
  int sign ;
  i64 s ;
  int d ;
  int esign ;
  int e ;
  int eValid ;
  double result ;
  int nDigit ;
  int eType ;
  int i ;
  long double scale ;
  long double tmp ;
  float tmp___0 ;
  long double scale___0 ;
  long double tmp___1 ;

  {
  zEnd = z + length;
  sign = 1;
  s = (i64 )0;
  d = 0;
  esign = 1;
  e = 0;
  eValid = 1;
  nDigit = 0;
  eType = 1;
  *pResult = 0.0;
  if ((int )enc == 1) {
    incr = 1;
  } else {
    incr = 2;
    i = 3 - (int )enc;
    while (1) {
      if (i < length) {
        if (! ((int const   )*(z + i) == 0)) {
          break;
        }
      } else {
        break;
      }
      i += 2;
    }
    if (i < length) {
      eType = -100;
    }
    zEnd = z + (i ^ 1);
    z += (int )enc & 1;
  }
  while (1) {
    if ((unsigned long )z < (unsigned long )zEnd) {
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 1)) {
        break;
      }
    } else {
      break;
    }
    z += incr;
  }
  if ((unsigned long )z >= (unsigned long )zEnd) {
    return (0);
  }
  if ((int const   )*z == 45) {
    sign = -1;
    z += incr;
  } else
  if ((int const   )*z == 43) {
    z += incr;
  }
  while (1) {
    if ((unsigned long )z < (unsigned long )zEnd) {
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 4)) {
        break;
      }
    } else {
      break;
    }
    s = s * 10LL + (i64 )((int const   )*z - 48);
    z += incr;
    nDigit ++;
    if (s >= ((4294967295LL | (2147483647LL << 32)) - 9LL) / 10LL) {
      while (1) {
        if ((unsigned long )z < (unsigned long )zEnd) {
          if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 4)) {
            break;
          }
        } else {
          break;
        }
        z += incr;
        d ++;
      }
    }
  }
  if ((unsigned long )z >= (unsigned long )zEnd) {
    goto do_atof_calc;
  }
  if ((int const   )*z == 46) {
    z += incr;
    eType ++;
    while (1) {
      if ((unsigned long )z < (unsigned long )zEnd) {
        if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 4)) {
          break;
        }
      } else {
        break;
      }
      if (s < ((4294967295LL | (2147483647LL << 32)) - 9LL) / 10LL) {
        s = s * 10LL + (i64 )((int const   )*z - 48);
        d --;
        nDigit ++;
      }
      z += incr;
    }
  }
  if ((unsigned long )z >= (unsigned long )zEnd) {
    goto do_atof_calc;
  }
  if ((int const   )*z == 101) {
    goto _L;
  } else
  if ((int const   )*z == 69) {
    _L: /* CIL Label */ 
    z += incr;
    eValid = 0;
    eType ++;
    if ((unsigned long )z >= (unsigned long )zEnd) {
      goto do_atof_calc;
    }
    if ((int const   )*z == 45) {
      esign = -1;
      z += incr;
    } else
    if ((int const   )*z == 43) {
      z += incr;
    }
    while (1) {
      if ((unsigned long )z < (unsigned long )zEnd) {
        if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 4)) {
          break;
        }
      } else {
        break;
      }
      if (e < 10000) {
        e = e * 10 + (int )((int const   )*z - 48);
      } else {
        e = 10000;
      }
      z += incr;
      eValid = 1;
    }
  }
  while (1) {
    if ((unsigned long )z < (unsigned long )zEnd) {
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 1)) {
        break;
      }
    } else {
      break;
    }
    z += incr;
  }
  do_atof_calc: 
  e = e * esign + d;
  if (e < 0) {
    esign = -1;
    e *= -1;
  } else {
    esign = 1;
  }
  if (s == 0LL) {
    if (sign < 0) {
      result = - ((double )0);
    } else {
      result = (double )0;
    }
  } else {
    while (e > 0) {
      if (esign > 0) {
        if (s >= (4294967295LL | (2147483647LL << 32)) / 10LL) {
          break;
        }
        s *= 10LL;
      } else {
        if (s % 10LL != 0LL) {
          break;
        }
        s /= 10LL;
      }
      e --;
    }
    if (sign < 0) {
      s = - s;
    } else {
      s = s;
    }
    if (e == 0) {
      result = (double )s;
    } else
    if (e > 307) {
      if (e < 342) {
        tmp = sqlite3Pow10(e - 308);
        scale = tmp;
        if (esign < 0) {
          result = (double )((long double )s / scale);
          result /= 1.0e+308;
        } else {
          result = (double )((long double )s * scale);
          result *= 1.0e+308;
        }
      } else
      if (esign < 0) {
        result = 0.0 * (double )s;
      } else {
        tmp___0 = __builtin_inff();
        result = (double )(tmp___0 * (float )s);
      }
    } else {
      tmp___1 = sqlite3Pow10(e);
      scale___0 = tmp___1;
      if (esign < 0) {
        result = (double )((long double )s / scale___0);
      } else {
        result = (double )((long double )s * scale___0);
      }
    }
  }
  *pResult = result;
  if ((unsigned long )z == (unsigned long )zEnd) {
    if (nDigit > 0) {
      if (eValid) {
        if (eType > 0) {
          return (eType);
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if (eType >= 2) {
    if (eType == 3) {
      goto _L___0;
    } else
    if (eValid) {
      _L___0: /* CIL Label */ 
      if (nDigit > 0) {
        return (-1);
      } else {
        return (0);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
static int compare2pow63(char const   *zNum , int incr ) 
{ 
  int c ;
  int i ;
  char const   *pow63 ;

  {
  c = 0;
  pow63 = "922337203685477580";
  i = 0;
  while (1) {
    if (c == 0) {
      if (! (i < 18)) {
        break;
      }
    } else {
      break;
    }
    c = (int )(((int const   )*(zNum + i * incr) - (int const   )*(pow63 + i)) * 10);
    i ++;
  }
  if (c == 0) {
    c = (int )((int const   )*(zNum + 18 * incr) - 56);
  }
  return (c);
}
}
static int sqlite3Atoi64(char const   *zNum , i64 *pNum , int length , u8 enc ) 
{ 
  int incr ;
  u64 u ;
  int neg ;
  int i ;
  int c ;
  int nonNum ;
  int rc ;
  char const   *zStart ;
  char const   *zEnd ;
  int jj ;
  int tmp ;
  int tmp___0 ;

  {
  u = (u64 )0;
  neg = 0;
  c = 0;
  nonNum = 0;
  zEnd = zNum + length;
  if ((int )enc == 1) {
    incr = 1;
  } else {
    incr = 2;
    i = 3 - (int )enc;
    while (1) {
      if (i < length) {
        if (! ((int const   )*(zNum + i) == 0)) {
          break;
        }
      } else {
        break;
      }
      i += 2;
    }
    nonNum = i < length;
    zEnd = zNum + (i ^ 1);
    zNum += (int )enc & 1;
  }
  while (1) {
    if ((unsigned long )zNum < (unsigned long )zEnd) {
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*zNum] & 1)) {
        break;
      }
    } else {
      break;
    }
    zNum += incr;
  }
  if ((unsigned long )zNum < (unsigned long )zEnd) {
    if ((int const   )*zNum == 45) {
      neg = 1;
      zNum += incr;
    } else
    if ((int const   )*zNum == 43) {
      zNum += incr;
    }
  }
  zStart = zNum;
  while (1) {
    if ((unsigned long )zNum < (unsigned long )zEnd) {
      if (! ((int const   )*(zNum + 0) == 48)) {
        break;
      }
    } else {
      break;
    }
    zNum += incr;
  }
  i = 0;
  while (1) {
    if ((unsigned long )(zNum + i) < (unsigned long )zEnd) {
      c = (int )*(zNum + i);
      if (c >= 48) {
        if (! (c <= 57)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    u = (u * 10ULL + (u64 )c) - 48ULL;
    i += incr;
  }
  if (u > (u64 )(4294967295LL | (2147483647LL << 32))) {
    if (neg) {
      *pNum = -1LL - (4294967295LL | (2147483647LL << 32));
    } else {
      *pNum = 4294967295LL | (2147483647LL << 32);
    }
  } else
  if (neg) {
    *pNum = - ((i64 )u);
  } else {
    *pNum = (i64 )u;
  }
  rc = 0;
  if (i == 0) {
    if ((unsigned long )zStart == (unsigned long )zNum) {
      rc = -1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (nonNum) {
    rc = 1;
  } else
  if ((unsigned long )(zNum + i) < (unsigned long )zEnd) {
    jj = i;
    while (1) {
      if (! ((int const   )sqlite3CtypeMap[(unsigned char )*(zNum + jj)] & 1)) {
        rc = 1;
        break;
      }
      jj += incr;
      if (! ((unsigned long )(zNum + jj) < (unsigned long )zEnd)) {
        break;
      }
    }
  }
  if (i < 19 * incr) {
    return (rc);
  } else {
    if (i > 19 * incr) {
      c = 1;
    } else {
      tmp = compare2pow63(zNum, incr);
      c = tmp;
    }
    if (c < 0) {
      return (rc);
    } else {
      if (neg) {
        *pNum = -1LL - (4294967295LL | (2147483647LL << 32));
      } else {
        *pNum = 4294967295LL | (2147483647LL << 32);
      }
      if (c > 0) {
        return (2);
      } else {
        if (neg) {
          tmp___0 = rc;
        } else {
          tmp___0 = 3;
        }
        return (tmp___0);
      }
    }
  }
}
}
static int sqlite3DecOrHexToI64(char const   *z , i64 *pOut ) 
{ 
  u64 u ;
  int i ;
  int k ;
  u8 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((int const   )*(z + 0) == 48) {
    if ((int const   )*(z + 1) == 120) {
      goto _L;
    } else
    if ((int const   )*(z + 1) == 88) {
      _L: /* CIL Label */ 
      u = (u64 )0;
      i = 2;
      while ((int const   )*(z + i) == 48) {
        i ++;
      }
      k = i;
      while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + k)] & 8) {
        tmp = sqlite3HexToInt((int )*(z + k));
        u = u * 16ULL + (u64 )tmp;
        k ++;
      }
      memcpy((void * __restrict  )pOut, (void const   * __restrict  )(& u), (size_t )8);
      if ((int const   )*(z + k) == 0) {
        if (k - i <= 16) {
          tmp___0 = 0;
        } else {
          tmp___0 = 2;
        }
      } else {
        tmp___0 = 2;
      }
      return (tmp___0);
    } else {
      tmp___1 = sqlite3Strlen30(z);
      tmp___2 = sqlite3Atoi64(z, pOut, tmp___1, (u8 )1);
      return (tmp___2);
    }
  } else {
    tmp___1 = sqlite3Strlen30(z);
    tmp___2 = sqlite3Atoi64(z, pOut, tmp___1, (u8 )1);
    return (tmp___2);
  }
}
}
static int sqlite3GetInt32(char const   *zNum , int *pValue ) 
{ 
  sqlite_int64 v ;
  int i ;
  int c ;
  int neg ;
  u32 u ;
  u8 tmp ;

  {
  v = (sqlite_int64 )0;
  neg = 0;
  if ((int const   )*(zNum + 0) == 45) {
    neg = 1;
    zNum ++;
  } else
  if ((int const   )*(zNum + 0) == 43) {
    zNum ++;
  } else
  if ((int const   )*(zNum + 0) == 48) {
    if ((int const   )*(zNum + 1) == 120) {
      goto _L;
    } else
    if ((int const   )*(zNum + 1) == 88) {
      _L: /* CIL Label */ 
      if ((int const   )sqlite3CtypeMap[(unsigned char )*(zNum + 2)] & 8) {
        u = (u32 )0;
        zNum += 2;
        while ((int const   )*(zNum + 0) == 48) {
          zNum ++;
        }
        i = 0;
        while (1) {
          if ((int const   )sqlite3CtypeMap[(unsigned char )*(zNum + i)] & 8) {
            if (! (i < 8)) {
              break;
            }
          } else {
            break;
          }
          tmp = sqlite3HexToInt((int )*(zNum + i));
          u = u * 16U + (u32 )tmp;
          i ++;
        }
        if ((u & 2147483648U) == 0U) {
          if (((int const   )sqlite3CtypeMap[(unsigned char )*(zNum + i)] & 8) == 0) {
            memcpy((void * __restrict  )pValue, (void const   * __restrict  )(& u),
                   (size_t )4);
            return (1);
          } else {
            return (0);
          }
        } else {
          return (0);
        }
      }
    }
  }
  if (! ((int const   )sqlite3CtypeMap[(unsigned char )*(zNum + 0)] & 4)) {
    return (0);
  }
  while ((int const   )*(zNum + 0) == 48) {
    zNum ++;
  }
  i = 0;
  while (1) {
    if (i < 11) {
      c = (int )((int const   )*(zNum + i) - 48);
      if (c >= 0) {
        if (! (c <= 9)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    v = v * 10LL + (sqlite_int64 )c;
    i ++;
  }
  if (i > 10) {
    return (0);
  }
  if (v - (sqlite_int64 )neg > 2147483647LL) {
    return (0);
  }
  if (neg) {
    v = - v;
  }
  *pValue = (int )v;
  return (1);
}
}
static int sqlite3Atoi(char const   *z ) 
{ 
  int x___0 ;

  {
  x___0 = 0;
  if (z) {
    sqlite3GetInt32(z, & x___0);
  }
  return (x___0);
}
}
static int ( __attribute__((__noinline__)) putVarint64)(unsigned char *p , u64 v ) 
{ 
  int i ;
  int j ;
  int n ;
  u8 buf[10] ;
  int tmp ;

  {
  if (v & (4278190080ULL << 32)) {
    *(p + 8) = (u8 )v;
    v >>= 8;
    i = 7;
    while (i >= 0) {
      *(p + i) = (u8 )((v & 127ULL) | 128ULL);
      v >>= 7;
      i --;
    }
    return (9);
  }
  n = 0;
  while (1) {
    tmp = n;
    n ++;
    buf[tmp] = (u8 )((v & 127ULL) | 128ULL);
    v >>= 7;
    if (! (v != 0ULL)) {
      break;
    }
  }
  buf[0] = (u8 )((int )buf[0] & 127);
  i = 0;
  j = n - 1;
  while (j >= 0) {
    *(p + i) = buf[j];
    j --;
    i ++;
  }
  return (n);
}
}
static int sqlite3PutVarint(unsigned char *p , u64 v ) 
{ 
  int tmp ;

  {
  if (v <= 127ULL) {
    *(p + 0) = (unsigned char )(v & 127ULL);
    return (1);
  }
  if (v <= 16383ULL) {
    *(p + 0) = (unsigned char )(((v >> 7) & 127ULL) | 128ULL);
    *(p + 1) = (unsigned char )(v & 127ULL);
    return (2);
  }
  tmp = putVarint64(p, v);
  return (tmp);
}
}
static u8 sqlite3GetVarint(unsigned char const   *p , u64 *v ) 
{ 
  u32 a___0 ;
  u32 b ;
  u32 s ;

  {
  if ((int )*((signed char *)p + 0) >= 0) {
    *v = (u64 )*p;
    return ((u8 )1);
  }
  if ((int )*((signed char *)p + 1) >= 0) {
    *v = (u64 )(((u32 )((int const   )*(p + 0) & 127) << 7) | (unsigned int )*(p + 1));
    return ((u8 )2);
  }
  a___0 = (u32 )*(p + 0) << 14;
  b = (u32 )*(p + 1);
  p += 2;
  a___0 |= (unsigned int )*p;
  if (! (a___0 & 128U)) {
    a___0 &= 2080895U;
    b &= 127U;
    b <<= 7;
    a___0 |= b;
    *v = (u64 )a___0;
    return ((u8 )3);
  }
  a___0 &= 2080895U;
  p ++;
  b <<= 14;
  b |= (unsigned int )*p;
  if (! (b & 128U)) {
    b &= 2080895U;
    a___0 <<= 7;
    a___0 |= b;
    *v = (u64 )a___0;
    return ((u8 )4);
  }
  b &= 2080895U;
  s = a___0;
  p ++;
  a___0 <<= 14;
  a___0 |= (unsigned int )*p;
  if (! (a___0 & 128U)) {
    b <<= 7;
    a___0 |= b;
    s >>= 18;
    *v = ((u64 )s << 32) | (unsigned long long )a___0;
    return ((u8 )5);
  }
  s <<= 7;
  s |= b;
  p ++;
  b <<= 14;
  b |= (unsigned int )*p;
  if (! (b & 128U)) {
    a___0 &= 2080895U;
    a___0 <<= 7;
    a___0 |= b;
    s >>= 18;
    *v = ((u64 )s << 32) | (unsigned long long )a___0;
    return ((u8 )6);
  }
  p ++;
  a___0 <<= 14;
  a___0 |= (unsigned int )*p;
  if (! (a___0 & 128U)) {
    a___0 &= 4028612735U;
    b &= 2080895U;
    b <<= 7;
    a___0 |= b;
    s >>= 11;
    *v = ((u64 )s << 32) | (unsigned long long )a___0;
    return ((u8 )7);
  }
  a___0 &= 2080895U;
  p ++;
  b <<= 14;
  b |= (unsigned int )*p;
  if (! (b & 128U)) {
    b &= 4028612735U;
    a___0 <<= 7;
    a___0 |= b;
    s >>= 4;
    *v = ((u64 )s << 32) | (unsigned long long )a___0;
    return ((u8 )8);
  }
  p ++;
  a___0 <<= 15;
  a___0 |= (unsigned int )*p;
  b &= 2080895U;
  b <<= 8;
  a___0 |= b;
  s <<= 4;
  b = (u32 )*(p + -4);
  b &= 127U;
  b >>= 3;
  s |= b;
  *v = ((u64 )s << 32) | (unsigned long long )a___0;
  return ((u8 )9);
}
}
static u8 sqlite3GetVarint32(unsigned char const   *p , u32 *v ) 
{ 
  u32 a___0 ;
  u32 b ;
  u64 v64 ;
  u8 n ;

  {
  a___0 = (u32 )*p;
  p ++;
  b = (u32 )*p;
  if (! (b & 128U)) {
    a___0 &= 127U;
    a___0 <<= 7;
    *v = a___0 | b;
    return ((u8 )2);
  }
  p ++;
  a___0 <<= 14;
  a___0 |= (unsigned int )*p;
  if (! (a___0 & 128U)) {
    a___0 &= (unsigned int )((127 << 14) | 127);
    b &= 127U;
    b <<= 7;
    *v = a___0 | b;
    return ((u8 )3);
  }
  p -= 2;
  n = sqlite3GetVarint(p, & v64);
  if ((v64 & ((1ULL << 32) - 1ULL)) != v64) {
    *v = 4294967295U;
  } else {
    *v = (u32 )v64;
  }
  return (n);
}
}
static int sqlite3VarintLen(u64 v ) 
{ 
  int i ;

  {
  i = 1;
  while (1) {
    v >>= 7;
    if (! (v != 0ULL)) {
      break;
    }
    i ++;
  }
  return (i);
}
}
static u32 sqlite3Get4byte(u8 const   *p ) 
{ 
  u32 x___0 ;
  int tmp ;

  {
  memcpy((void * __restrict  )(& x___0), (void const   * __restrict  )p, (size_t )4);
  tmp = __builtin_bswap32((int )x___0);
  return ((u32 )tmp);
}
}
static void sqlite3Put4byte(unsigned char *p , u32 v ) 
{ 
  u32 x___0 ;
  int tmp ;

  {
  tmp = __builtin_bswap32((int )v);
  x___0 = (u32 )tmp;
  memcpy((void * __restrict  )p, (void const   * __restrict  )(& x___0), (size_t )4);
  return;
}
}
static u8 sqlite3HexToInt(int h ) 
{ 


  {
  h += 9 * (1 & (h >> 6));
  return ((u8 )(h & 15));
}
}
static void *sqlite3HexToBlob(sqlite3 *db , char const   *z , int n ) 
{ 
  char *zBlob ;
  int i ;
  void *tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;

  {
  tmp = sqlite3DbMallocRawNN(db, (u64 )(n / 2 + 1));
  zBlob = (char *)tmp;
  n --;
  if (zBlob) {
    i = 0;
    while (i < n) {
      tmp___0 = sqlite3HexToInt((int )*(z + i));
      tmp___1 = sqlite3HexToInt((int )*(z + (i + 1)));
      *(zBlob + i / 2) = (char )(((int )tmp___0 << 4) | (int )tmp___1);
      i += 2;
    }
    *(zBlob + i / 2) = (char)0;
  }
  return ((void *)zBlob);
}
}
static void logBadConnection(char const   *zType ) 
{ 


  {
  sqlite3_log(21, "API call with %s database connection pointer", zType);
  return;
}
}
static int sqlite3SafetyCheckOk(sqlite3 *db ) 
{ 
  u32 magic ;
  int tmp ;

  {
  if ((unsigned long )db == (unsigned long )((sqlite3 *)0)) {
    logBadConnection("NULL");
    return (0);
  }
  magic = db->magic;
  if (magic != 2687084183U) {
    tmp = sqlite3SafetyCheckSickOrOk(db);
    if (tmp) {
      logBadConnection("unopened");
    }
    return (0);
  } else {
    return (1);
  }
}
}
static int sqlite3SafetyCheckSickOrOk(sqlite3 *db ) 
{ 
  u32 magic ;

  {
  magic = db->magic;
  if (magic != 1266094736U) {
    if (magic != 2687084183U) {
      if (magic != 4030429446U) {
        logBadConnection("invalid");
        return (0);
      } else {
        return (1);
      }
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
static int sqlite3AddInt64(i64 *pA , i64 iB ) 
{ 
  i64 iA ;

  {
  iA = *pA;
  if (iB >= 0LL) {
    if (iA > 0LL) {
      if ((4294967295LL | (2147483647LL << 32)) - iA < iB) {
        return (1);
      }
    }
  } else
  if (iA < 0LL) {
    if (- (iA + (4294967295LL | (2147483647LL << 32))) > iB + 1LL) {
      return (1);
    }
  }
  *pA += iB;
  return (0);
}
}
static int sqlite3SubInt64(i64 *pA , i64 iB ) 
{ 
  int tmp ;

  {
  if (iB == -1LL - (4294967295LL | (2147483647LL << 32))) {
    if (*pA >= 0LL) {
      return (1);
    }
    *pA -= iB;
    return (0);
  } else {
    tmp = sqlite3AddInt64(pA, - iB);
    return (tmp);
  }
}
}
static int sqlite3MulInt64(i64 *pA , i64 iB ) 
{ 
  i64 iA ;

  {
  iA = *pA;
  if (iB > 0LL) {
    if (iA > (4294967295LL | (2147483647LL << 32)) / iB) {
      return (1);
    }
    if (iA < (-1LL - (4294967295LL | (2147483647LL << 32))) / iB) {
      return (1);
    }
  } else
  if (iB < 0LL) {
    if (iA > 0LL) {
      if (iB < (-1LL - (4294967295LL | (2147483647LL << 32))) / iA) {
        return (1);
      }
    } else
    if (iA < 0LL) {
      if (iB == -1LL - (4294967295LL | (2147483647LL << 32))) {
        return (1);
      }
      if (iA == -1LL - (4294967295LL | (2147483647LL << 32))) {
        return (1);
      }
      if (- iA > (4294967295LL | (2147483647LL << 32)) / - iB) {
        return (1);
      }
    }
  }
  *pA = iA * iB;
  return (0);
}
}
static int sqlite3AbsInt32(int x___0 ) 
{ 


  {
  if (x___0 >= 0) {
    return (x___0);
  }
  if (x___0 == (-0x7FFFFFFF-1)) {
    return (2147483647);
  }
  return (- x___0);
}
}
static unsigned char const   x[32]  = 
  {      (unsigned char const   )10,      (unsigned char const   )10,      (unsigned char const   )9,      (unsigned char const   )9, 
        (unsigned char const   )8,      (unsigned char const   )8,      (unsigned char const   )7,      (unsigned char const   )7, 
        (unsigned char const   )7,      (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2};
static LogEst sqlite3LogEstAdd(LogEst a___0 , LogEst b ) 
{ 


  {
  if ((int )a___0 >= (int )b) {
    if ((int )a___0 > (int )b + 49) {
      return (a___0);
    }
    if ((int )a___0 > (int )b + 31) {
      return ((LogEst )((int )a___0 + 1));
    }
    return ((LogEst )((int )a___0 + (int )x[(int )a___0 - (int )b]));
  } else {
    if ((int )b > (int )a___0 + 49) {
      return (b);
    }
    if ((int )b > (int )a___0 + 31) {
      return ((LogEst )((int )b + 1));
    }
    return ((LogEst )((int )b + (int )x[(int )b - (int )a___0]));
  }
}
}
static LogEst a[8]  = 
  {      (LogEst )0,      (LogEst )2,      (LogEst )3,      (LogEst )5, 
        (LogEst )6,      (LogEst )7,      (LogEst )8,      (LogEst )9};
static LogEst sqlite3LogEst(u64 x___0 ) 
{ 
  LogEst y ;
  int i ;
  int tmp ;

  {
  y = (LogEst )40;
  if (x___0 < 8ULL) {
    if (x___0 < 2ULL) {
      return ((LogEst )0);
    }
    while (x___0 < 8ULL) {
      y = (LogEst )((int )y - 10);
      x___0 <<= 1;
    }
  } else {
    tmp = __builtin_clzll(x___0);
    i = 60 - tmp;
    y = (LogEst )((int )y + i * 10);
    x___0 >>= i;
  }
  return ((LogEst )(((int )a[x___0 & 7ULL] + (int )y) - 10));
}
}
static LogEst sqlite3LogEstFromDouble(double x___0 ) 
{ 
  u64 a___0 ;
  LogEst e ;
  LogEst tmp ;

  {
  if (x___0 <= (double )1) {
    return ((LogEst )0);
  }
  if (x___0 <= (double )2000000000) {
    tmp = sqlite3LogEst((u64 )x___0);
    return (tmp);
  }
  memcpy((void * __restrict  )(& a___0), (void const   * __restrict  )(& x___0), (size_t )8);
  e = (LogEst )((a___0 >> 52) - 1022ULL);
  return ((LogEst )((int )e * 10));
}
}
static VList *sqlite3VListAdd(sqlite3 *db , VList *pIn , char const   *zName , int nName ,
                              int iVal ) 
{ 
  int nInt ;
  char *z ;
  int i ;
  sqlite_int64 nAlloc ;
  sqlite_int64 tmp ;
  VList *pOut ;
  void *tmp___0 ;

  {
  nInt = nName / 4 + 3;
  if ((unsigned long )pIn == (unsigned long )((VList *)0)) {
    goto _L;
  } else
  if (*(pIn + 1) + nInt > *(pIn + 0)) {
    _L: /* CIL Label */ 
    if (pIn) {
      tmp = 2LL * (sqlite_int64 )*(pIn + 0);
    } else {
      tmp = (sqlite_int64 )10;
    }
    nAlloc = tmp + (sqlite_int64 )nInt;
    tmp___0 = sqlite3DbRealloc(db, (void *)pIn, (unsigned long long )nAlloc * (unsigned long long )sizeof(int ));
    pOut = (VList *)tmp___0;
    if ((unsigned long )pOut == (unsigned long )((VList *)0)) {
      return (pIn);
    }
    if ((unsigned long )pIn == (unsigned long )((VList *)0)) {
      *(pOut + 1) = 2;
    }
    pIn = pOut;
    *(pIn + 0) = (VList )nAlloc;
  }
  i = *(pIn + 1);
  *(pIn + i) = iVal;
  *(pIn + (i + 1)) = nInt;
  z = (char *)(pIn + (i + 2));
  *(pIn + 1) = i + nInt;
  memcpy((void * __restrict  )z, (void const   * __restrict  )zName, (size_t )nName);
  *(z + nName) = (char)0;
  return (pIn);
}
}
static char const   *sqlite3VListNumToName(VList *pIn , int iVal ) 
{ 
  int i ;
  int mx ;

  {
  if ((unsigned long )pIn == (unsigned long )((VList *)0)) {
    return ((char const   *)0);
  }
  mx = *(pIn + 1);
  i = 2;
  while (1) {
    if (*(pIn + i) == iVal) {
      return ((char const   *)((char *)(pIn + (i + 2))));
    }
    i += *(pIn + (i + 1));
    if (! (i < mx)) {
      break;
    }
  }
  return ((char const   *)0);
}
}
static int sqlite3VListNameToNum(VList *pIn , char const   *zName , int nName ) 
{ 
  int i ;
  int mx ;
  char const   *z ;
  int tmp ;

  {
  if ((unsigned long )pIn == (unsigned long )((VList *)0)) {
    return (0);
  }
  mx = *(pIn + 1);
  i = 2;
  while (1) {
    z = (char const   *)(pIn + (i + 2));
    tmp = strncmp(z, zName, (size_t )nName);
    if (tmp == 0) {
      if ((int const   )*(z + nName) == 0) {
        return (*(pIn + i));
      }
    }
    i += *(pIn + (i + 1));
    if (! (i < mx)) {
      break;
    }
  }
  return (0);
}
}
static void sqlite3HashInit(Hash *pNew ) 
{ 


  {
  pNew->first = (HashElem *)0;
  pNew->count = 0U;
  pNew->htsize = 0U;
  pNew->ht = (struct _ht *)0;
  return;
}
}
static void sqlite3HashClear(Hash *pH ) 
{ 
  HashElem *elem ;
  HashElem *next_elem ;

  {
  elem = pH->first;
  pH->first = (HashElem *)0;
  sqlite3_free((void *)pH->ht);
  pH->ht = (struct _ht *)0;
  pH->htsize = 0U;
  while (elem) {
    next_elem = elem->next;
    sqlite3_free((void *)elem);
    elem = next_elem;
  }
  pH->count = 0U;
  return;
}
}
static unsigned int strHash(char const   *z ) 
{ 
  unsigned int h ;
  unsigned char c ;
  char const   *tmp ;

  {
  h = 0U;
  while (1) {
    tmp = z;
    z ++;
    c = (unsigned char )*tmp;
    if (! ((int )c != 0)) {
      break;
    }
    h += (unsigned int )sqlite3UpperToLower[c];
    h *= 2654435761U;
  }
  return (h);
}
}
static void insertElement(Hash *pH , struct _ht *pEntry , HashElem *pNew ) 
{ 
  HashElem *pHead ;

  {
  if (pEntry) {
    if (pEntry->count) {
      pHead = pEntry->chain;
    } else {
      pHead = (HashElem *)0;
    }
    (pEntry->count) ++;
    pEntry->chain = pNew;
  } else {
    pHead = (HashElem *)0;
  }
  if (pHead) {
    pNew->next = pHead;
    pNew->prev = pHead->prev;
    if (pHead->prev) {
      (pHead->prev)->next = pNew;
    } else {
      pH->first = pNew;
    }
    pHead->prev = pNew;
  } else {
    pNew->next = pH->first;
    if (pH->first) {
      (pH->first)->prev = pNew;
    }
    pNew->prev = (HashElem *)0;
    pH->first = pNew;
  }
  return;
}
}
static int rehash(Hash *pH , unsigned int new_size ) 
{ 
  struct _ht *new_ht ;
  HashElem *elem ;
  HashElem *next_elem ;
  void *tmp ;
  int tmp___0 ;
  unsigned int h ;
  unsigned int tmp___1 ;

  {
  if ((unsigned long )new_size * sizeof(struct _ht ) > 1024UL) {
    new_size = (unsigned int )(1024UL / sizeof(struct _ht ));
  }
  if (new_size == pH->htsize) {
    return (0);
  }
  sqlite3BeginBenignMalloc();
  tmp = sqlite3Malloc((u64 )((unsigned long )new_size * sizeof(struct _ht )));
  new_ht = (struct _ht *)tmp;
  sqlite3EndBenignMalloc();
  if ((unsigned long )new_ht == (unsigned long )((struct _ht *)0)) {
    return (0);
  }
  sqlite3_free((void *)pH->ht);
  pH->ht = new_ht;
  tmp___0 = sqlite3MallocSize((void *)new_ht);
  new_size = (unsigned int )((unsigned long )tmp___0 / sizeof(struct _ht ));
  pH->htsize = new_size;
  memset((void *)new_ht, 0, (unsigned long )new_size * sizeof(struct _ht ));
  elem = pH->first;
  pH->first = (HashElem *)0;
  while (elem) {
    tmp___1 = strHash(elem->pKey);
    h = tmp___1 % new_size;
    next_elem = elem->next;
    insertElement(pH, new_ht + h, elem);
    elem = next_elem;
  }
  return (1);
}
}
static HashElem *findElementWithHash(Hash const   *pH , char const   *pKey , unsigned int *pHash ) ;
static HashElem nullElement  =    {(HashElem *)0, (HashElem *)0, (void *)0, (char const   *)0};
static HashElem *findElementWithHash(Hash const   *pH , char const   *pKey , unsigned int *pHash ) 
{ 
  HashElem *elem ;
  unsigned int count ;
  unsigned int h ;
  struct _ht *pEntry ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  if (pH->ht) {
    tmp = strHash(pKey);
    h = tmp % (unsigned int )pH->htsize;
    pEntry = pH->ht + h;
    elem = pEntry->chain;
    count = pEntry->count;
  } else {
    h = 0U;
    elem = (HashElem *)pH->first;
    count = (unsigned int )pH->count;
  }
  if (pHash) {
    *pHash = h;
  }
  while (1) {
    tmp___1 = count;
    count --;
    if (! tmp___1) {
      break;
    }
    tmp___0 = sqlite3StrICmp(elem->pKey, pKey);
    if (tmp___0 == 0) {
      return (elem);
    }
    elem = elem->next;
  }
  return (& nullElement);
}
}
static void removeElementGivenHash(Hash *pH , HashElem *elem , unsigned int h ) 
{ 
  struct _ht *pEntry ;

  {
  if (elem->prev) {
    (elem->prev)->next = elem->next;
  } else {
    pH->first = elem->next;
  }
  if (elem->next) {
    (elem->next)->prev = elem->prev;
  }
  if (pH->ht) {
    pEntry = pH->ht + h;
    if ((unsigned long )pEntry->chain == (unsigned long )elem) {
      pEntry->chain = elem->next;
    }
    (pEntry->count) --;
  }
  sqlite3_free((void *)elem);
  (pH->count) --;
  if (pH->count == 0U) {
    sqlite3HashClear(pH);
  }
  return;
}
}
static void *sqlite3HashFind(Hash const   *pH , char const   *pKey ) 
{ 
  HashElem *tmp ;

  {
  tmp = findElementWithHash(pH, pKey, (unsigned int *)0);
  return (tmp->data);
}
}
static void *sqlite3HashInsert(Hash *pH , char const   *pKey , void *data ) 
{ 
  unsigned int h ;
  HashElem *elem ;
  HashElem *new_elem ;
  void *old_data ;
  void *tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  struct _ht *tmp___2 ;

  {
  elem = findElementWithHash((Hash const   *)pH, pKey, & h);
  if (elem->data) {
    old_data = elem->data;
    if ((unsigned long )data == (unsigned long )((void *)0)) {
      removeElementGivenHash(pH, elem, h);
    } else {
      elem->data = data;
      elem->pKey = pKey;
    }
    return (old_data);
  }
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  tmp = sqlite3Malloc((u64 )sizeof(HashElem ));
  new_elem = (HashElem *)tmp;
  if ((unsigned long )new_elem == (unsigned long )((HashElem *)0)) {
    return (data);
  }
  new_elem->pKey = pKey;
  new_elem->data = data;
  (pH->count) ++;
  if (pH->count >= 10U) {
    if (pH->count > 2U * pH->htsize) {
      tmp___1 = rehash(pH, pH->count * 2U);
      if (tmp___1) {
        tmp___0 = strHash(pKey);
        h = tmp___0 % pH->htsize;
      }
    }
  }
  if (pH->ht) {
    tmp___2 = pH->ht + h;
  } else {
    tmp___2 = (struct _ht *)0;
  }
  insertElement(pH, tmp___2, new_elem);
  return ((void *)0);
}
}
static char const   * const  azName[173]  = 
  {      (char const   * const  )"Savepoint",      (char const   * const  )"AutoCommit",      (char const   * const  )"Transaction",      (char const   * const  )"SorterNext", 
        (char const   * const  )"Prev",      (char const   * const  )"Next",      (char const   * const  )"Checkpoint",      (char const   * const  )"JournalMode", 
        (char const   * const  )"Vacuum",      (char const   * const  )"VFilter",      (char const   * const  )"VUpdate",      (char const   * const  )"Goto", 
        (char const   * const  )"Gosub",      (char const   * const  )"InitCoroutine",      (char const   * const  )"Yield",      (char const   * const  )"MustBeInt", 
        (char const   * const  )"Jump",      (char const   * const  )"Once",      (char const   * const  )"If",      (char const   * const  )"Not", 
        (char const   * const  )"IfNot",      (char const   * const  )"IfNullRow",      (char const   * const  )"SeekLT",      (char const   * const  )"SeekLE", 
        (char const   * const  )"SeekGE",      (char const   * const  )"SeekGT",      (char const   * const  )"IfNoHope",      (char const   * const  )"NoConflict", 
        (char const   * const  )"NotFound",      (char const   * const  )"Found",      (char const   * const  )"SeekRowid",      (char const   * const  )"NotExists", 
        (char const   * const  )"Last",      (char const   * const  )"IfSmaller",      (char const   * const  )"SorterSort",      (char const   * const  )"Sort", 
        (char const   * const  )"Rewind",      (char const   * const  )"IdxLE",      (char const   * const  )"IdxGT",      (char const   * const  )"IdxLT", 
        (char const   * const  )"IdxGE",      (char const   * const  )"RowSetRead",      (char const   * const  )"RowSetTest",      (char const   * const  )"Or", 
        (char const   * const  )"And",      (char const   * const  )"Program",      (char const   * const  )"FkIfZero",      (char const   * const  )"IfPos", 
        (char const   * const  )"IfNotZero",      (char const   * const  )"DecrJumpZero",      (char const   * const  )"IsNull",      (char const   * const  )"NotNull", 
        (char const   * const  )"Ne",      (char const   * const  )"Eq",      (char const   * const  )"Gt",      (char const   * const  )"Le", 
        (char const   * const  )"Lt",      (char const   * const  )"Ge",      (char const   * const  )"ElseNotEq",      (char const   * const  )"IncrVacuum", 
        (char const   * const  )"VNext",      (char const   * const  )"Init",      (char const   * const  )"PureFunc0",      (char const   * const  )"Function0", 
        (char const   * const  )"PureFunc",      (char const   * const  )"Function",      (char const   * const  )"Return",      (char const   * const  )"EndCoroutine", 
        (char const   * const  )"HaltIfNull",      (char const   * const  )"Halt",      (char const   * const  )"Integer",      (char const   * const  )"Int64", 
        (char const   * const  )"String",      (char const   * const  )"Null",      (char const   * const  )"SoftNull",      (char const   * const  )"Blob", 
        (char const   * const  )"Variable",      (char const   * const  )"Move",      (char const   * const  )"Copy",      (char const   * const  )"SCopy", 
        (char const   * const  )"IntCopy",      (char const   * const  )"ResultRow",      (char const   * const  )"CollSeq",      (char const   * const  )"AddImm", 
        (char const   * const  )"RealAffinity",      (char const   * const  )"Cast",      (char const   * const  )"Permutation",      (char const   * const  )"Compare", 
        (char const   * const  )"IsTrue",      (char const   * const  )"Offset",      (char const   * const  )"Column",      (char const   * const  )"Affinity", 
        (char const   * const  )"MakeRecord",      (char const   * const  )"Count",      (char const   * const  )"ReadCookie",      (char const   * const  )"SetCookie", 
        (char const   * const  )"ReopenIdx",      (char const   * const  )"OpenRead",      (char const   * const  )"OpenWrite",      (char const   * const  )"BitAnd", 
        (char const   * const  )"BitOr",      (char const   * const  )"ShiftLeft",      (char const   * const  )"ShiftRight",      (char const   * const  )"Add", 
        (char const   * const  )"Subtract",      (char const   * const  )"Multiply",      (char const   * const  )"Divide",      (char const   * const  )"Remainder", 
        (char const   * const  )"Concat",      (char const   * const  )"OpenDup",      (char const   * const  )"BitNot",      (char const   * const  )"OpenAutoindex", 
        (char const   * const  )"OpenEphemeral",      (char const   * const  )"String8",      (char const   * const  )"SorterOpen",      (char const   * const  )"SequenceTest", 
        (char const   * const  )"OpenPseudo",      (char const   * const  )"Close",      (char const   * const  )"ColumnsUsed",      (char const   * const  )"SeekHit", 
        (char const   * const  )"Sequence",      (char const   * const  )"NewRowid",      (char const   * const  )"Insert",      (char const   * const  )"Delete", 
        (char const   * const  )"ResetCount",      (char const   * const  )"SorterCompare",      (char const   * const  )"SorterData",      (char const   * const  )"RowData", 
        (char const   * const  )"Rowid",      (char const   * const  )"NullRow",      (char const   * const  )"SeekEnd",      (char const   * const  )"SorterInsert", 
        (char const   * const  )"IdxInsert",      (char const   * const  )"IdxDelete",      (char const   * const  )"DeferredSeek",      (char const   * const  )"IdxRowid", 
        (char const   * const  )"Destroy",      (char const   * const  )"Clear",      (char const   * const  )"ResetSorter",      (char const   * const  )"CreateBtree", 
        (char const   * const  )"SqlExec",      (char const   * const  )"ParseSchema",      (char const   * const  )"LoadAnalysis",      (char const   * const  )"DropTable", 
        (char const   * const  )"DropIndex",      (char const   * const  )"DropTrigger",      (char const   * const  )"IntegrityCk",      (char const   * const  )"RowSetAdd", 
        (char const   * const  )"Real",      (char const   * const  )"Param",      (char const   * const  )"FkCounter",      (char const   * const  )"MemMax", 
        (char const   * const  )"OffsetLimit",      (char const   * const  )"AggInverse",      (char const   * const  )"AggStep",      (char const   * const  )"AggStep1", 
        (char const   * const  )"AggValue",      (char const   * const  )"AggFinal",      (char const   * const  )"Expire",      (char const   * const  )"TableLock", 
        (char const   * const  )"VBegin",      (char const   * const  )"VCreate",      (char const   * const  )"VDestroy",      (char const   * const  )"VOpen", 
        (char const   * const  )"VColumn",      (char const   * const  )"VRename",      (char const   * const  )"Pagecount",      (char const   * const  )"MaxPgcnt", 
        (char const   * const  )"Trace",      (char const   * const  )"CursorHint",      (char const   * const  )"Noop",      (char const   * const  )"Explain", 
        (char const   * const  )"Abortable"};
static char const   *sqlite3OpcodeName(int i ) 
{ 


  {
  return ((char const   *)azName[i]);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
extern int fsync(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off64_t __length )  __asm__("ftruncate64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mremap)(void *__addr ,
                                                                               size_t __old_len ,
                                                                               size_t __new_len ,
                                                                               int __flags 
                                                                               , ...) ;
static pid_t randomnessPid  =    0;
static int posixOpen(char const   *zFile , int flags___0 , int mode ) 
{ 
  int tmp ;

  {
  tmp = open(zFile, flags___0, mode);
  return (tmp);
}
}
static int openDirectory(char const   *zFilename , int *pFd ) ;
static int unixGetpagesize(void) ;
static struct unix_syscall aSyscall[29]  = 
  {      {"open", (void (*)(void))(& posixOpen), (void (*)(void))0}, 
        {"close", (void (*)(void))(& close), (void (*)(void))0}, 
        {"access", (void (*)(void))(& access), (void (*)(void))0}, 
        {"getcwd", (void (*)(void))(& getcwd), (void (*)(void))0}, 
        {"stat", (void (*)(void))(& stat), (void (*)(void))0}, 
        {"fstat", (void (*)(void))(& fstat), (void (*)(void))0}, 
        {"ftruncate", (void (*)(void))(& ftruncate), (void (*)(void))0}, 
        {"fcntl", (void (*)(void))(& fcntl), (void (*)(void))0}, 
        {"read", (void (*)(void))(& read), (void (*)(void))0}, 
        {"pread", (void (*)(void))0, (void (*)(void))0}, 
        {"pread64", (void (*)(void))0, (void (*)(void))0}, 
        {"write", (void (*)(void))(& write), (void (*)(void))0}, 
        {"pwrite", (void (*)(void))0, (void (*)(void))0}, 
        {"pwrite64", (void (*)(void))0, (void (*)(void))0}, 
        {"fchmod", (void (*)(void))(& fchmod), (void (*)(void))0}, 
        {"fallocate", (void (*)(void))0, (void (*)(void))0}, 
        {"unlink", (void (*)(void))(& unlink), (void (*)(void))0}, 
        {"openDirectory", (void (*)(void))(& openDirectory), (void (*)(void))0}, 
        {"mkdir", (void (*)(void))(& mkdir), (void (*)(void))0}, 
        {"rmdir", (void (*)(void))(& rmdir), (void (*)(void))0}, 
        {"fchown", (void (*)(void))(& fchown), (void (*)(void))0}, 
        {"geteuid", (void (*)(void))(& geteuid), (void (*)(void))0}, 
        {"mmap", (void (*)(void))(& mmap), (void (*)(void))0}, 
        {"munmap", (void (*)(void))(& munmap), (void (*)(void))0}, 
        {"mremap", (void (*)(void))(& mremap), (void (*)(void))0}, 
        {"getpagesize", (void (*)(void))(& unixGetpagesize), (void (*)(void))0}, 
        {"readlink", (void (*)(void))(& readlink), (void (*)(void))0}, 
        {"lstat", (void (*)(void))(& lstat), (void (*)(void))0}, 
        {"ioctl", (void (*)(void))0, (void (*)(void))0}};
static int robustFchown(int fd , uid_t uid , gid_t gid ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  uid_t tmp___2 ;

  {
  tmp___2 = (*((uid_t (*)(void))aSyscall[21].pCurrent))();
  if (tmp___2) {
    tmp___1 = 0;
  } else {
    tmp___0 = (*((int (*)(int  , uid_t  , gid_t  ))aSyscall[20].pCurrent))(fd, uid,
                                                                           gid);
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
static int unixSetSystemCall(sqlite3_vfs *pNotUsed , char const   *zName , void (*pNewFunc)(void) ) 
{ 
  unsigned int i ;
  int rc ;
  int tmp ;

  {
  rc = 12;
  if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
    rc = 0;
    i = 0U;
    while ((unsigned long )i < sizeof(aSyscall) / sizeof(aSyscall[0])) {
      if (aSyscall[i].pDefault) {
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
      i ++;
    }
  } else {
    i = 0U;
    while ((unsigned long )i < sizeof(aSyscall) / sizeof(aSyscall[0])) {
      tmp = strcmp(zName, aSyscall[i].zName);
      if (tmp == 0) {
        if ((unsigned long )aSyscall[i].pDefault == (unsigned long )((void (*)(void))0)) {
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = 0;
        if ((unsigned long )pNewFunc == (unsigned long )((void (*)(void))0)) {
          pNewFunc = aSyscall[i].pDefault;
        }
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
      i ++;
    }
  }
  return (rc);
}
}
static sqlite3_syscall_ptr unixGetSystemCall(sqlite3_vfs *pNotUsed , char const   *zName ) 
{ 
  unsigned int i ;
  int tmp ;

  {
  i = 0U;
  while ((unsigned long )i < sizeof(aSyscall) / sizeof(aSyscall[0])) {
    tmp = strcmp(zName, aSyscall[i].zName);
    if (tmp == 0) {
      return (aSyscall[i].pCurrent);
    }
    i ++;
  }
  return ((sqlite3_syscall_ptr )0);
}
}
static char const   *unixNextSystemCall(sqlite3_vfs *p , char const   *zName ) 
{ 
  int i ;
  int tmp ;

  {
  i = -1;
  if (zName) {
    i = 0;
    while (i < (int )(sizeof(aSyscall) / sizeof(aSyscall[0])) - 1) {
      tmp = strcmp(zName, aSyscall[i].zName);
      if (tmp == 0) {
        break;
      }
      i ++;
    }
  }
  i ++;
  while (i < (int )(sizeof(aSyscall) / sizeof(aSyscall[0]))) {
    if ((unsigned long )aSyscall[i].pCurrent != (unsigned long )((void (*)(void))0)) {
      return (aSyscall[i].zName);
    }
    i ++;
  }
  return ((char const   *)0);
}
}
static int robust_open(char const   *z , int f , mode_t m ) 
{ 
  int fd ;
  mode_t m2 ;
  mode_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct stat statbuf ;
  int tmp___2 ;

  {
  if (m) {
    tmp = m;
  } else {
    tmp = (mode_t )420;
  }
  m2 = tmp;
  while (1) {
    fd = (*((int (*)(char const   * , int  , int  ))aSyscall[0].pCurrent))(z, f | 524288,
                                                                           (int )m2);
    if (fd < 0) {
      tmp___0 = __errno_location();
      if (*tmp___0 == 4) {
        continue;
      }
      break;
    }
    if (fd >= 3) {
      break;
    }
    (*((int (*)(int  ))aSyscall[1].pCurrent))(fd);
    sqlite3_log(28, "attempt to open \"%s\" as file descriptor %d", z, fd);
    fd = -1;
    tmp___1 = (*((int (*)(char const   * , int  , int  ))aSyscall[0].pCurrent))("/dev/null",
                                                                                f,
                                                                                (int )m);
    if (tmp___1 < 0) {
      break;
    }
  }
  if (fd >= 0) {
    if (m != 0U) {
      tmp___2 = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(fd, & statbuf);
      if (tmp___2 == 0) {
        if (statbuf.st_size == 0L) {
          if ((statbuf.st_mode & 511U) != m) {
            (*((int (*)(int  , mode_t  ))aSyscall[14].pCurrent))(fd, m);
          }
        }
      }
    }
  }
  return (fd);
}
}
static sqlite3_mutex *unixBigLock  =    (sqlite3_mutex *)0;
static void unixEnterMutex(void) 
{ 


  {
  return;
}
}
static void unixLeaveMutex(void) 
{ 


  {
  return;
}
}
static int robust_ftruncate(int h , sqlite_int64 sz ) 
{ 
  int rc ;
  int *tmp ;

  {
  while (1) {
    rc = (*((int (*)(int  , off_t  ))aSyscall[6].pCurrent))(h, (off_t )sz);
    if (rc < 0) {
      tmp = __errno_location();
      if (! (*tmp == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  return (rc);
}
}
static int sqliteErrorFromPosixError(int posixError , int sqliteIOErr ) 
{ 


  {
  switch (posixError) {
  case 37: 
  case 4: 
  case 16: 
  case 110: 
  case 11: 
  case 13: 
  return (5);
  case 1: 
  return (3);
  default: 
  return (sqliteIOErr);
  }
}
}
static unixInodeInfo *inodeList  =    (unixInodeInfo *)0;
static int unixLogErrorAtLine(int errcode , char const   *zFunc , char const   *zPath ,
                              int iLine ) 
{ 
  char *zErr ;
  int iErrno ;
  int *tmp ;

  {
  tmp = __errno_location();
  iErrno = *tmp;
  zErr = strerror(iErrno);
  if ((unsigned long )zPath == (unsigned long )((char const   *)0)) {
    zPath = "";
  }
  sqlite3_log(errcode, "os_unix.c:%d: (%d) %s(%s) - %s", iLine, iErrno, zFunc, zPath,
              zErr);
  return (errcode);
}
}
static void robust_close(unixFile *pFile , int h , int lineno ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  tmp___0 = (*((int (*)(int  ))aSyscall[1].pCurrent))(h);
  if (tmp___0) {
    if (pFile) {
      tmp = pFile->zPath;
    } else {
      tmp = (char const   *)0;
    }
    unixLogErrorAtLine(10 | (16 << 8), "close", tmp, lineno);
  }
  return;
}
}
static void storeLastErrno(unixFile *pFile , int error ) 
{ 


  {
  pFile->lastErrno = error;
  return;
}
}
static void closePendingFds(unixFile *pFile ) 
{ 
  unixInodeInfo *pInode ;
  UnixUnusedFd *p ;
  UnixUnusedFd *pNext ;

  {
  pInode = pFile->pInode;
  p = pInode->pUnused;
  while (p) {
    pNext = p->pNext;
    robust_close(pFile, p->fd, 33983);
    sqlite3_free((void *)p);
    p = pNext;
  }
  pInode->pUnused = (UnixUnusedFd *)0;
  return;
}
}
static void releaseInodeInfo(unixFile *pFile ) 
{ 
  unixInodeInfo *pInode ;

  {
  pInode = pFile->pInode;
  if (pInode) {
    (pInode->nRef) --;
    if (pInode->nRef == 0) {
      closePendingFds(pFile);
      if (pInode->pPrev) {
        (pInode->pPrev)->pNext = pInode->pNext;
      } else {
        inodeList = pInode->pNext;
      }
      if (pInode->pNext) {
        (pInode->pNext)->pPrev = pInode->pPrev;
      }
      sqlite3_free((void *)pInode);
    }
  }
  return;
}
}
static int findInodeInfo(unixFile *pFile , unixInodeInfo **ppInode ) 
{ 
  int rc ;
  int fd ;
  struct unixFileId fileId ;
  struct stat statbuf ;
  unixInodeInfo *pInode ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  pInode = (unixInodeInfo *)0;
  fd = pFile->h;
  rc = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(fd, & statbuf);
  if (rc != 0) {
    tmp = __errno_location();
    storeLastErrno(pFile, *tmp);
    return (10);
  }
  memset((void *)(& fileId), 0, sizeof(fileId));
  fileId.dev = statbuf.st_dev;
  fileId.ino = (u64 )statbuf.st_ino;
  pInode = inodeList;
  while (1) {
    if (pInode) {
      tmp___0 = memcmp((void const   *)(& fileId), (void const   *)(& pInode->fileId),
                       sizeof(fileId));
      if (! tmp___0) {
        break;
      }
    } else {
      break;
    }
    pInode = pInode->pNext;
  }
  if ((unsigned long )pInode == (unsigned long )((unixInodeInfo *)0)) {
    tmp___1 = sqlite3_malloc64((sqlite_uint64 )sizeof(*pInode));
    pInode = (unixInodeInfo *)tmp___1;
    if ((unsigned long )pInode == (unsigned long )((unixInodeInfo *)0)) {
      return (7);
    }
    memset((void *)pInode, 0, sizeof(*pInode));
    memcpy((void * __restrict  )(& pInode->fileId), (void const   * __restrict  )(& fileId),
           sizeof(fileId));
    if (sqlite3Config.bCoreMutex) {
      pInode->pLockMutex = (sqlite3_mutex *)8;
      if ((unsigned long )pInode->pLockMutex == (unsigned long )((sqlite3_mutex *)0)) {
        sqlite3_free((void *)pInode);
        return (7);
      }
    }
    pInode->nRef = 1;
    pInode->pNext = inodeList;
    pInode->pPrev = (unixInodeInfo *)0;
    if (inodeList) {
      inodeList->pPrev = pInode;
    }
    inodeList = pInode;
  } else {
    (pInode->nRef) ++;
  }
  *ppInode = pInode;
  return (0);
}
}
static int fileHasMoved(unixFile *pFile ) 
{ 
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )pFile->pInode != (unsigned long )((unixInodeInfo *)0)) {
    tmp = (*((int (*)(char const   * , struct stat * ))aSyscall[4].pCurrent))(pFile->zPath,
                                                                              & buf);
    if (tmp != 0) {
      tmp___0 = 1;
    } else
    if ((u64 )buf.st_ino != (pFile->pInode)->fileId.ino) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static void verifyDbFile(unixFile *pFile ) 
{ 
  struct stat buf ;
  int rc ;
  int tmp ;

  {
  if ((int )pFile->ctrlFlags & 128) {
    return;
  }
  rc = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(pFile->h, & buf);
  if (rc != 0) {
    sqlite3_log(28, "cannot fstat db file %s", pFile->zPath);
    return;
  }
  if (buf.st_nlink == 0UL) {
    sqlite3_log(28, "file unlinked while open: %s", pFile->zPath);
    return;
  }
  if (buf.st_nlink > 1UL) {
    sqlite3_log(28, "multiple links to file: %s", pFile->zPath);
    return;
  }
  tmp = fileHasMoved(pFile);
  if (tmp) {
    sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
    return;
  }
  return;
}
}
static int unixCheckReservedLock(sqlite3_file *id , int *pResOut ) 
{ 
  int rc ;
  int reserved ;
  unixFile *pFile ;
  struct flock lock ;
  int *tmp ;
  int tmp___0 ;

  {
  rc = 0;
  reserved = 0;
  pFile = (unixFile *)id;
  if ((int )(pFile->pInode)->eFileLock > 1) {
    reserved = 1;
  }
  if (! reserved) {
    if (! (pFile->pInode)->bProcessLock) {
      lock.l_whence = (short)0;
      lock.l_start = (__off64_t )(sqlite3PendingByte + 1);
      lock.l_len = (__off64_t )1;
      lock.l_type = (short)1;
      tmp___0 = (*((int (*)(int  , int   , ...))aSyscall[7].pCurrent))(pFile->h, 5,
                                                                       & lock);
      if (tmp___0) {
        rc = 10 | (14 << 8);
        tmp = __errno_location();
        storeLastErrno(pFile, *tmp);
      } else
      if ((int )lock.l_type != 2) {
        reserved = 1;
      }
    }
  }
  *pResOut = reserved;
  return (rc);
}
}
static int unixFileLock(unixFile *pFile , struct flock *pLock ) 
{ 
  int rc ;
  unixInodeInfo *pInode ;
  struct flock lock ;

  {
  pInode = pFile->pInode;
  if (((int )pFile->ctrlFlags & 3) == 1) {
    if ((int )pInode->bProcessLock == 0) {
      lock.l_whence = (short)0;
      lock.l_start = (__off64_t )(sqlite3PendingByte + 2);
      lock.l_len = (__off64_t )510;
      lock.l_type = (short)1;
      rc = (*((int (*)(int  , int   , ...))aSyscall[7].pCurrent))(pFile->h, 6, & lock);
      if (rc < 0) {
        return (rc);
      }
      pInode->bProcessLock = (unsigned char)1;
      (pInode->nLock) ++;
    } else {
      rc = 0;
    }
  } else {
    rc = (*((int (*)(int  , int   , ...))aSyscall[7].pCurrent))(pFile->h, 6, pLock);
  }
  return (rc);
}
}
static int unixLock(sqlite3_file *id , int eFileLock ) 
{ 
  int rc ;
  unixFile *pFile ;
  unixInodeInfo *pInode ;
  struct flock lock ;
  int tErrno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  rc = 0;
  pFile = (unixFile *)id;
  tErrno = 0;
  if ((int )pFile->eFileLock >= eFileLock) {
    return (0);
  }
  pInode = pFile->pInode;
  if ((int )pFile->eFileLock != (int )pInode->eFileLock) {
    if ((int )pInode->eFileLock >= 3) {
      rc = 5;
      goto end_lock;
    } else
    if (eFileLock > 1) {
      rc = 5;
      goto end_lock;
    }
  }
  if (eFileLock == 1) {
    if ((int )pInode->eFileLock == 1) {
      pFile->eFileLock = (unsigned char)1;
      (pInode->nShared) ++;
      (pInode->nLock) ++;
      goto end_lock;
    } else
    if ((int )pInode->eFileLock == 2) {
      pFile->eFileLock = (unsigned char)1;
      (pInode->nShared) ++;
      (pInode->nLock) ++;
      goto end_lock;
    }
  }
  lock.l_len = 1L;
  lock.l_whence = (short)0;
  if (eFileLock == 1) {
    goto _L;
  } else
  if (eFileLock == 4) {
    if ((int )pFile->eFileLock < 3) {
      _L: /* CIL Label */ 
      if (eFileLock == 1) {
        lock.l_type = (short)0;
      } else {
        lock.l_type = (short)1;
      }
      lock.l_start = (__off64_t )sqlite3PendingByte;
      tmp___0 = unixFileLock(pFile, & lock);
      if (tmp___0) {
        tmp = __errno_location();
        tErrno = *tmp;
        rc = sqliteErrorFromPosixError(tErrno, 10 | (15 << 8));
        if (rc != 5) {
          storeLastErrno(pFile, tErrno);
        }
        goto end_lock;
      }
    }
  }
  if (eFileLock == 1) {
    lock.l_start = (__off64_t )(sqlite3PendingByte + 2);
    lock.l_len = (__off64_t )510;
    tmp___2 = unixFileLock(pFile, & lock);
    if (tmp___2) {
      tmp___1 = __errno_location();
      tErrno = *tmp___1;
      rc = sqliteErrorFromPosixError(tErrno, 10 | (15 << 8));
    }
    lock.l_start = (__off64_t )sqlite3PendingByte;
    lock.l_len = 1L;
    lock.l_type = (short)2;
    tmp___4 = unixFileLock(pFile, & lock);
    if (tmp___4) {
      if (rc == 0) {
        tmp___3 = __errno_location();
        tErrno = *tmp___3;
        rc = 10 | (8 << 8);
      }
    }
    if (rc) {
      if (rc != 5) {
        storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    } else {
      pFile->eFileLock = (unsigned char)1;
      (pInode->nLock) ++;
      pInode->nShared = 1;
    }
  } else
  if (eFileLock == 4) {
    if (pInode->nShared > 1) {
      rc = 5;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    lock.l_type = (short)1;
    if (eFileLock == 2) {
      lock.l_start = (__off64_t )(sqlite3PendingByte + 1);
      lock.l_len = 1L;
    } else {
      lock.l_start = (__off64_t )(sqlite3PendingByte + 2);
      lock.l_len = (__off64_t )510;
    }
    tmp___6 = unixFileLock(pFile, & lock);
    if (tmp___6) {
      tmp___5 = __errno_location();
      tErrno = *tmp___5;
      rc = sqliteErrorFromPosixError(tErrno, 10 | (15 << 8));
      if (rc != 5) {
        storeLastErrno(pFile, tErrno);
      }
    }
  }
  if (rc == 0) {
    pFile->eFileLock = (unsigned char )eFileLock;
    pInode->eFileLock = (unsigned char )eFileLock;
  } else
  if (eFileLock == 4) {
    pFile->eFileLock = (unsigned char)3;
    pInode->eFileLock = (unsigned char)3;
  }
  end_lock: ;
  return (rc);
}
}
static void setPendingFd(unixFile *pFile ) 
{ 
  unixInodeInfo *pInode ;
  UnixUnusedFd *p ;

  {
  pInode = pFile->pInode;
  p = pFile->pPreallocatedUnused;
  p->pNext = pInode->pUnused;
  pInode->pUnused = p;
  pFile->h = -1;
  pFile->pPreallocatedUnused = (UnixUnusedFd *)0;
  return;
}
}
static int posixUnlock(sqlite3_file *id , int eFileLock , int handleNFSUnlock ) 
{ 
  unixFile *pFile ;
  unixInodeInfo *pInode ;
  struct flock lock ;
  int rc ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  pFile = (unixFile *)id;
  rc = 0;
  if ((int )pFile->eFileLock <= eFileLock) {
    return (0);
  }
  pInode = pFile->pInode;
  if ((int )pFile->eFileLock > 1) {
    if (eFileLock == 1) {
      lock.l_type = (short)0;
      lock.l_whence = (short)0;
      lock.l_start = (__off64_t )(sqlite3PendingByte + 2);
      lock.l_len = (__off64_t )510;
      tmp___0 = unixFileLock(pFile, & lock);
      if (tmp___0) {
        rc = 10 | (9 << 8);
        tmp = __errno_location();
        storeLastErrno(pFile, *tmp);
        goto end_unlock;
      }
    }
    lock.l_type = (short)2;
    lock.l_whence = (short)0;
    lock.l_start = (__off64_t )sqlite3PendingByte;
    lock.l_len = 2L;
    tmp___2 = unixFileLock(pFile, & lock);
    if (tmp___2 == 0) {
      pInode->eFileLock = (unsigned char)1;
    } else {
      rc = 10 | (8 << 8);
      tmp___1 = __errno_location();
      storeLastErrno(pFile, *tmp___1);
      goto end_unlock;
    }
  }
  if (eFileLock == 0) {
    (pInode->nShared) --;
    if (pInode->nShared == 0) {
      lock.l_type = (short)2;
      lock.l_whence = (short)0;
      lock.l_len = 0L;
      lock.l_start = lock.l_len;
      tmp___4 = unixFileLock(pFile, & lock);
      if (tmp___4 == 0) {
        pInode->eFileLock = (unsigned char)0;
      } else {
        rc = 10 | (8 << 8);
        tmp___3 = __errno_location();
        storeLastErrno(pFile, *tmp___3);
        pInode->eFileLock = (unsigned char)0;
        pFile->eFileLock = (unsigned char)0;
      }
    }
    (pInode->nLock) --;
    if (pInode->nLock == 0) {
      closePendingFds(pFile);
    }
  }
  end_unlock: ;
  if (rc == 0) {
    pFile->eFileLock = (unsigned char )eFileLock;
  }
  return (rc);
}
}
static int unixUnlock(sqlite3_file *id , int eFileLock ) 
{ 
  int tmp ;

  {
  tmp = posixUnlock(id, eFileLock, 0);
  return (tmp);
}
}
static int unixMapfile(unixFile *pFd , i64 nMap ) ;
static void unixUnmapfile(unixFile *pFd ) ;
static int closeUnixFile(sqlite3_file *id ) 
{ 
  unixFile *pFile ;

  {
  pFile = (unixFile *)id;
  unixUnmapfile(pFile);
  if (pFile->h >= 0) {
    robust_close(pFile, pFile->h, 34763);
    pFile->h = -1;
  }
  sqlite3_free((void *)pFile->pPreallocatedUnused);
  memset((void *)pFile, 0, sizeof(unixFile ));
  return (0);
}
}
static int unixClose(sqlite3_file *id ) 
{ 
  int rc ;
  unixFile *pFile ;
  unixInodeInfo *pInode ;

  {
  rc = 0;
  pFile = (unixFile *)id;
  pInode = pFile->pInode;
  verifyDbFile(pFile);
  unixUnlock(id, 0);
  unixEnterMutex();
  if (pInode->nLock) {
    setPendingFd(pFile);
  }
  releaseInodeInfo(pFile);
  rc = closeUnixFile(id);
  unixLeaveMutex();
  return (rc);
}
}
static int nolockCheckReservedLock(sqlite3_file *NotUsed , int *pResOut ) 
{ 


  {
  *pResOut = 0;
  return (0);
}
}
static int nolockLock(sqlite3_file *NotUsed , int NotUsed2 ) 
{ 


  {
  return (0);
}
}
static int nolockUnlock(sqlite3_file *NotUsed , int NotUsed2 ) 
{ 


  {
  return (0);
}
}
static int nolockClose(sqlite3_file *id ) 
{ 
  int tmp ;

  {
  tmp = closeUnixFile(id);
  return (tmp);
}
}
static int dotlockCheckReservedLock(sqlite3_file *id , int *pResOut ) 
{ 
  int rc ;
  int reserved ;
  unixFile *pFile ;
  int tmp ;

  {
  rc = 0;
  reserved = 0;
  pFile = (unixFile *)id;
  tmp = (*((int (*)(char const   * , int  ))aSyscall[2].pCurrent))((char const   *)pFile->lockingContext,
                                                                   0);
  reserved = tmp == 0;
  *pResOut = reserved;
  return (rc);
}
}
static int dotlockLock(sqlite3_file *id , int eFileLock ) 
{ 
  unixFile *pFile ;
  char *zLockFile ;
  int rc ;
  int tErrno ;
  int *tmp ;

  {
  pFile = (unixFile *)id;
  zLockFile = (char *)pFile->lockingContext;
  rc = 0;
  if ((int )pFile->eFileLock > 0) {
    pFile->eFileLock = (unsigned char )eFileLock;
    utimes((char const   *)zLockFile, (struct timeval  const  *)((void *)0));
    return (0);
  }
  rc = (*((int (*)(char const   * , mode_t  ))aSyscall[18].pCurrent))((char const   *)zLockFile,
                                                                      (mode_t )511);
  if (rc < 0) {
    tmp = __errno_location();
    tErrno = *tmp;
    if (17 == tErrno) {
      rc = 5;
    } else {
      rc = sqliteErrorFromPosixError(tErrno, 10 | (15 << 8));
      if (rc != 5) {
        storeLastErrno(pFile, tErrno);
      }
    }
    return (rc);
  }
  pFile->eFileLock = (unsigned char )eFileLock;
  return (rc);
}
}
static int dotlockUnlock(sqlite3_file *id , int eFileLock ) 
{ 
  unixFile *pFile ;
  char *zLockFile ;
  int rc ;
  int tErrno ;
  int *tmp ;

  {
  pFile = (unixFile *)id;
  zLockFile = (char *)pFile->lockingContext;
  if ((int )pFile->eFileLock == eFileLock) {
    return (0);
  }
  if (eFileLock == 1) {
    pFile->eFileLock = (unsigned char)1;
    return (0);
  }
  rc = (*((int (*)(char const   * ))aSyscall[19].pCurrent))((char const   *)zLockFile);
  if (rc < 0) {
    tmp = __errno_location();
    tErrno = *tmp;
    if (tErrno == 2) {
      rc = 0;
    } else {
      rc = 10 | (8 << 8);
      storeLastErrno(pFile, tErrno);
    }
    return (rc);
  }
  pFile->eFileLock = (unsigned char)0;
  return (0);
}
}
static int dotlockClose(sqlite3_file *id ) 
{ 
  unixFile *pFile ;
  int tmp ;

  {
  pFile = (unixFile *)id;
  dotlockUnlock(id, 0);
  sqlite3_free(pFile->lockingContext);
  tmp = closeUnixFile(id);
  return (tmp);
}
}
static int seekAndRead(unixFile *id , sqlite_int64 offset , void *pBuf , int cnt ) 
{ 
  int got ;
  int prior ;
  i64 newOffset ;
  __off64_t tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  prior = 0;
  while (1) {
    tmp = lseek(id->h, (__off64_t )offset, 0);
    newOffset = (i64 )tmp;
    if (newOffset < 0LL) {
      tmp___0 = __errno_location();
      storeLastErrno(id, *tmp___0);
      return (-1);
    }
    tmp___1 = (*((ssize_t (*)(int  , void * , size_t  ))aSyscall[8].pCurrent))(id->h,
                                                                               pBuf,
                                                                               (size_t )cnt);
    got = (int )tmp___1;
    if (got == cnt) {
      break;
    }
    if (got < 0) {
      tmp___2 = __errno_location();
      if (*tmp___2 == 4) {
        got = 1;
        goto __Cont;
      }
      prior = 0;
      tmp___3 = __errno_location();
      storeLastErrno(id, *tmp___3);
      break;
    } else
    if (got > 0) {
      cnt -= got;
      offset += (sqlite_int64 )got;
      prior += got;
      pBuf = (void *)((char *)pBuf + got);
    }
    __Cont: /* CIL Label */ 
    if (! (got > 0)) {
      break;
    }
  }
  return (got + prior);
}
}
static int unixRead(sqlite3_file *id , void *pBuf , int amt , sqlite_int64 offset ) 
{ 
  unixFile *pFile ;
  int got ;
  int nCopy ;

  {
  pFile = (unixFile *)id;
  if (offset < pFile->mmapSize) {
    if (offset + (sqlite_int64 )amt <= pFile->mmapSize) {
      memcpy((void * __restrict  )pBuf, (void const   * __restrict  )((u8 *)pFile->pMapRegion + offset),
             (size_t )amt);
      return (0);
    } else {
      nCopy = (int )(pFile->mmapSize - offset);
      memcpy((void * __restrict  )pBuf, (void const   * __restrict  )((u8 *)pFile->pMapRegion + offset),
             (size_t )nCopy);
      pBuf = (void *)((u8 *)pBuf + nCopy);
      amt -= nCopy;
      offset += (sqlite_int64 )nCopy;
    }
  }
  got = seekAndRead(pFile, offset, pBuf, amt);
  if (got == amt) {
    return (0);
  } else
  if (got < 0) {
    return (10 | (1 << 8));
  } else {
    storeLastErrno(pFile, 0);
    memset((void *)((char *)pBuf + got), 0, (size_t )(amt - got));
    return (10 | (2 << 8));
  }
}
}
static int seekAndWriteFd(int fd , i64 iOff , void const   *pBuf , int nBuf , int *piErrno ) 
{ 
  int rc ;
  i64 iSeek ;
  __off64_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  rc = 0;
  nBuf &= 131071;
  while (1) {
    tmp = lseek(fd, (__off64_t )iOff, 0);
    iSeek = (i64 )tmp;
    if (iSeek < 0LL) {
      rc = -1;
      break;
    }
    tmp___0 = (*((ssize_t (*)(int  , void const   * , size_t  ))aSyscall[11].pCurrent))(fd,
                                                                                        pBuf,
                                                                                        (size_t )nBuf);
    rc = (int )tmp___0;
    if (rc < 0) {
      tmp___1 = __errno_location();
      if (! (*tmp___1 == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  if (rc < 0) {
    tmp___2 = __errno_location();
    *piErrno = *tmp___2;
  }
  return (rc);
}
}
static int seekAndWrite(unixFile *id , i64 offset , void const   *pBuf , int cnt ) 
{ 
  int tmp ;

  {
  tmp = seekAndWriteFd(id->h, offset, pBuf, cnt, & id->lastErrno);
  return (tmp);
}
}
static int unixWrite(sqlite3_file *id , void const   *pBuf , int amt , sqlite_int64 offset ) 
{ 
  unixFile *pFile ;
  int wrote ;

  {
  pFile = (unixFile *)id;
  wrote = 0;
  while (1) {
    wrote = seekAndWrite(pFile, offset, pBuf, amt);
    if (wrote < amt) {
      if (! (wrote > 0)) {
        break;
      }
    } else {
      break;
    }
    amt -= wrote;
    offset += (sqlite_int64 )wrote;
    pBuf = (void const   *)((char *)pBuf + wrote);
  }
  if (amt > wrote) {
    if (wrote < 0) {
      if (pFile->lastErrno != 28) {
        return (10 | (3 << 8));
      } else {
        storeLastErrno(pFile, 0);
        return (13);
      }
    } else {
      storeLastErrno(pFile, 0);
      return (13);
    }
  }
  return (0);
}
}
static int full_fsync(int fd , int fullSync , int dataOnly ) 
{ 
  int rc ;

  {
  rc = fsync(fd);
  return (rc);
}
}
static int openDirectory(char const   *zFilename , int *pFd ) 
{ 
  int ii ;
  int fd ;
  char zDirname[513] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  fd = -1;
  sqlite3_snprintf(512, zDirname, "%s", zFilename);
  tmp = strlen((char const   *)(zDirname));
  ii = (int )tmp;
  while (1) {
    if (ii > 0) {
      if (! ((int )zDirname[ii] != 47)) {
        break;
      }
    } else {
      break;
    }
    ii --;
  }
  if (ii > 0) {
    zDirname[ii] = (char )'\000';
  } else {
    if ((int )zDirname[0] != 47) {
      zDirname[0] = (char )'.';
    }
    zDirname[1] = (char)0;
  }
  fd = robust_open((char const   *)(zDirname), 0, (mode_t )0);
  *pFd = fd;
  if (fd >= 0) {
    return (0);
  }
  tmp___0 = sqlite3CantopenError(36366);
  tmp___1 = unixLogErrorAtLine(tmp___0, "openDirectory", (char const   *)(zDirname),
                               36366);
  return (tmp___1);
}
}
static int unixSync(sqlite3_file *id , int flags___0 ) 
{ 
  int rc ;
  unixFile *pFile ;
  int isDataOnly ;
  int isFullsync ;
  int *tmp ;
  int tmp___0 ;
  int dirfd ;

  {
  pFile = (unixFile *)id;
  isDataOnly = flags___0 & 16;
  isFullsync = (flags___0 & 15) == 3;
  rc = full_fsync(pFile->h, isFullsync, isDataOnly);
  if (rc) {
    tmp = __errno_location();
    storeLastErrno(pFile, *tmp);
    tmp___0 = unixLogErrorAtLine(10 | (4 << 8), "full_fsync", pFile->zPath, 36407);
    return (tmp___0);
  }
  if ((int )pFile->ctrlFlags & 8) {
    rc = (*((int (*)(char const   * , int * ))aSyscall[17].pCurrent))(pFile->zPath,
                                                                      & dirfd);
    if (rc == 0) {
      full_fsync(dirfd, 0, 0);
      robust_close(pFile, dirfd, 36421);
    } else {
      rc = 0;
    }
    pFile->ctrlFlags = (unsigned short )((int )pFile->ctrlFlags & -9);
  }
  return (rc);
}
}
static int unixTruncate(sqlite3_file *id , i64 nByte ) 
{ 
  unixFile *pFile ;
  int rc ;
  int *tmp ;
  int tmp___0 ;

  {
  pFile = (unixFile *)id;
  if (pFile->szChunk > 0) {
    nByte = (((nByte + (i64 )pFile->szChunk) - 1LL) / (i64 )pFile->szChunk) * (i64 )pFile->szChunk;
  }
  rc = robust_ftruncate(pFile->h, nByte);
  if (rc) {
    tmp = __errno_location();
    storeLastErrno(pFile, *tmp);
    tmp___0 = unixLogErrorAtLine(10 | (6 << 8), "ftruncate", pFile->zPath, 36452);
    return (tmp___0);
  } else {
    if (nByte < pFile->mmapSize) {
      pFile->mmapSize = nByte;
    }
    return (0);
  }
}
}
static int unixFileSize(sqlite3_file *id , i64 *pSize ) 
{ 
  int rc ;
  struct stat buf ;
  int *tmp ;

  {
  rc = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(((unixFile *)id)->h,
                                                                 & buf);
  if (rc != 0) {
    tmp = __errno_location();
    storeLastErrno((unixFile *)id, *tmp);
    return (10 | (7 << 8));
  }
  *pSize = (i64 )buf.st_size;
  if (*pSize == 1LL) {
    *pSize = (i64 )0;
  }
  return (0);
}
}
static int fcntlSizeHint(unixFile *pFile , i64 nByte ) 
{ 
  i64 nSize ;
  struct stat buf ;
  int tmp ;
  int nBlk ;
  int nWrite ;
  i64 iWrite ;
  int rc ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (pFile->szChunk > 0) {
    tmp = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(pFile->h, & buf);
    if (tmp) {
      return (10 | (7 << 8));
    }
    nSize = (((nByte + (i64 )pFile->szChunk) - 1LL) / (i64 )pFile->szChunk) * (i64 )pFile->szChunk;
    if (nSize > (i64 )buf.st_size) {
      nBlk = (int )buf.st_blksize;
      nWrite = 0;
      iWrite = (i64 )(((buf.st_size / (__off_t )nBlk) * (__off_t )nBlk + (__off_t )nBlk) - 1L);
      while (iWrite < (nSize + (i64 )nBlk) - 1LL) {
        if (iWrite >= nSize) {
          iWrite = nSize - 1LL;
        }
        nWrite = seekAndWrite(pFile, iWrite, (void const   *)"", 1);
        if (nWrite != 1) {
          return (10 | (3 << 8));
        }
        iWrite += (i64 )nBlk;
      }
    }
  }
  if (pFile->mmapSizeMax > 0LL) {
    if (nByte > pFile->mmapSize) {
      if (pFile->szChunk <= 0) {
        tmp___2 = robust_ftruncate(pFile->h, nByte);
        if (tmp___2) {
          tmp___0 = __errno_location();
          storeLastErrno(pFile, *tmp___0);
          tmp___1 = unixLogErrorAtLine(10 | (6 << 8), "ftruncate", pFile->zPath, 36573);
          return (tmp___1);
        }
      }
      rc = unixMapfile(pFile, nByte);
      return (rc);
    }
  }
  return (0);
}
}
static void unixModeBit(unixFile *pFile , unsigned char mask , int *pArg ) 
{ 


  {
  if (*pArg < 0) {
    *pArg = ((int )pFile->ctrlFlags & (int )mask) != 0;
  } else
  if (*pArg == 0) {
    pFile->ctrlFlags = (unsigned short )((int )pFile->ctrlFlags & ~ ((int )mask));
  } else {
    pFile->ctrlFlags = (unsigned short )((int )pFile->ctrlFlags | (int )mask);
  }
  return;
}
}
static int unixGetTempname(int nBuf , char *zBuf ) ;
static int unixFileControl(sqlite3_file *id , int op , void *pArg ) 
{ 
  unixFile *pFile ;
  int rc ;
  char *zTFile ;
  void *tmp ;
  i64 newLimit ;
  int rc___0 ;

  {
  pFile = (unixFile *)id;
  switch (op) {
  case 1: 
  *((int *)pArg) = (int )pFile->eFileLock;
  return (0);
  case 4: 
  *((int *)pArg) = pFile->lastErrno;
  return (0);
  case 6: 
  pFile->szChunk = *((int *)pArg);
  return (0);
  case 5: 
  rc = fcntlSizeHint(pFile, *((i64 *)pArg));
  return (rc);
  case 10: 
  unixModeBit(pFile, (unsigned char)4, (int *)pArg);
  return (0);
  case 13: 
  unixModeBit(pFile, (unsigned char)16, (int *)pArg);
  return (0);
  case 12: 
  *((char **)pArg) = sqlite3_mprintf("%s", (pFile->pVfs)->zName);
  return (0);
  case 16: 
  tmp = sqlite3_malloc64((sqlite_uint64 )(pFile->pVfs)->mxPathname);
  zTFile = (char *)tmp;
  if (zTFile) {
    unixGetTempname((pFile->pVfs)->mxPathname, zTFile);
    *((char **)pArg) = zTFile;
  }
  return (0);
  case 20: 
  *((int *)pArg) = fileHasMoved(pFile);
  return (0);
  case 18: 
  newLimit = *((i64 *)pArg);
  rc___0 = 0;
  if (newLimit > sqlite3Config.mxMmap) {
    newLimit = sqlite3Config.mxMmap;
  }
  if (newLimit > 0LL) {
    if (sizeof(size_t ) < 8UL) {
      newLimit &= 2147483647LL;
    }
  }
  *((i64 *)pArg) = pFile->mmapSizeMax;
  if (newLimit >= 0LL) {
    if (newLimit != pFile->mmapSizeMax) {
      if (pFile->nFetchOut == 0) {
        pFile->mmapSizeMax = newLimit;
        if (pFile->mmapSize > 0LL) {
          unixUnmapfile(pFile);
          rc___0 = unixMapfile(pFile, (i64 )-1);
        }
      }
    }
  }
  return (rc___0);
  }
  return (12);
}
}
static void setDeviceCharacteristics(unixFile *pFd ) 
{ 


  {
  if (pFd->sectorSize == 0) {
    if ((int )pFd->ctrlFlags & 16) {
      pFd->deviceCharacteristics |= 4096;
    }
    pFd->sectorSize = 4096;
  }
  return;
}
}
static int unixSectorSize(sqlite3_file *id ) 
{ 
  unixFile *pFd ;

  {
  pFd = (unixFile *)id;
  setDeviceCharacteristics(pFd);
  return (pFd->sectorSize);
}
}
static int unixDeviceCharacteristics(sqlite3_file *id ) 
{ 
  unixFile *pFd ;

  {
  pFd = (unixFile *)id;
  setDeviceCharacteristics(pFd);
  return (pFd->deviceCharacteristics);
}
}
static int unixGetpagesize(void) 
{ 
  long tmp ;

  {
  tmp = sysconf(30);
  return ((int )tmp);
}
}
static int unixShmSystemLock(unixFile *pFile , int lockType , int ofst , int n ) 
{ 
  unixShmNode *pShmNode ;
  struct flock f ;
  int rc ;

  {
  rc = 0;
  pShmNode = (pFile->pInode)->pShmNode;
  if (pShmNode->hShm >= 0) {
    f.l_type = (short )lockType;
    f.l_whence = (short)0;
    f.l_start = (__off64_t )ofst;
    f.l_len = (__off64_t )n;
    rc = (*((int (*)(int  , int   , ...))aSyscall[7].pCurrent))(pShmNode->hShm, 6,
                                                                & f);
    if (rc != -1) {
      rc = 0;
    } else {
      rc = 5;
    }
  }
  return (rc);
}
}
static int unixShmRegionPerMap(void) 
{ 
  int shmsz ;
  int pgsz___0 ;
  int tmp ;

  {
  shmsz = 32768;
  tmp = (*((int (*)(void))aSyscall[25].pCurrent))();
  pgsz___0 = tmp;
  if (pgsz___0 < shmsz) {
    return (1);
  }
  return (pgsz___0 / shmsz);
}
}
static void unixShmPurge(unixFile *pFd ) 
{ 
  unixShmNode *p ;
  int nShmPerMap ;
  int tmp ;
  int i ;

  {
  p = (pFd->pInode)->pShmNode;
  if (p) {
    if (p->nRef == 0) {
      tmp = unixShmRegionPerMap();
      nShmPerMap = tmp;
      i = 0;
      while (i < (int )p->nRegion) {
        if (p->hShm >= 0) {
          (*((int (*)(void * , size_t  ))aSyscall[23].pCurrent))((void *)*(p->apRegion + i),
                                                                 (size_t )p->szRegion);
        } else {
          sqlite3_free((void *)*(p->apRegion + i));
        }
        i += nShmPerMap;
      }
      sqlite3_free((void *)p->apRegion);
      if (p->hShm >= 0) {
        robust_close(pFd, p->hShm, 37076);
        p->hShm = -1;
      }
      (p->pInode)->pShmNode = (unixShmNode *)0;
      sqlite3_free((void *)p);
    }
  }
  return;
}
}
static int unixLockSharedMemory(unixFile *pDbFd , unixShmNode *pShmNode ) 
{ 
  struct flock lock ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  rc = 0;
  lock.l_whence = (short)0;
  lock.l_start = (__off64_t )128;
  lock.l_len = (__off64_t )1;
  lock.l_type = (short)1;
  tmp___0 = (*((int (*)(int  , int   , ...))aSyscall[7].pCurrent))(pShmNode->hShm,
                                                                   5, & lock);
  if (tmp___0 != 0) {
    rc = 10 | (15 << 8);
  } else
  if ((int )lock.l_type == 2) {
    if (pShmNode->isReadonly) {
      pShmNode->isUnlocked = (u8 )1;
      rc = 8 | (5 << 8);
    } else {
      rc = unixShmSystemLock(pDbFd, 1, 128, 1);
      if (rc == 0) {
        tmp = robust_ftruncate(pShmNode->hShm, (sqlite_int64 )3);
        if (tmp) {
          rc = unixLogErrorAtLine(10 | (18 << 8), "ftruncate", (char const   *)pShmNode->zFilename,
                                  37133);
        }
      }
    }
  } else
  if ((int )lock.l_type == 1) {
    rc = 5;
  }
  if (rc == 0) {
    rc = unixShmSystemLock(pDbFd, 0, 128, 1);
  }
  return (rc);
}
}
static int unixOpenSharedMemory(unixFile *pDbFd ) 
{ 
  struct unixShm *p ;
  struct unixShmNode *pShmNode ;
  int rc ;
  unixInodeInfo *pInode ;
  char *zShm ;
  int nShmFilename ;
  void *tmp ;
  struct stat sStat ;
  char const   *zBasePath ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  p = (struct unixShm *)0;
  rc = 0;
  tmp = sqlite3_malloc64((sqlite_uint64 )sizeof(*p));
  p = (struct unixShm *)tmp;
  if ((unsigned long )p == (unsigned long )((struct unixShm *)0)) {
    return (7);
  }
  memset((void *)p, 0, sizeof(*p));
  unixEnterMutex();
  pInode = pDbFd->pInode;
  pShmNode = pInode->pShmNode;
  if ((unsigned long )pShmNode == (unsigned long )((struct unixShmNode *)0)) {
    zBasePath = pDbFd->zPath;
    tmp___0 = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(pDbFd->h,
                                                                        & sStat);
    if (tmp___0) {
      rc = 10 | (7 << 8);
      goto shm_open_err;
    }
    tmp___1 = strlen(zBasePath);
    nShmFilename = 6 + (int )tmp___1;
    tmp___2 = sqlite3_malloc64((sqlite_uint64 )(sizeof(*pShmNode) + (unsigned long )nShmFilename));
    pShmNode = (struct unixShmNode *)tmp___2;
    if ((unsigned long )pShmNode == (unsigned long )((struct unixShmNode *)0)) {
      rc = 7;
      goto shm_open_err;
    }
    memset((void *)pShmNode, 0, sizeof(*pShmNode) + (unsigned long )nShmFilename);
    tmp___3 = (char *)(pShmNode + 1);
    pShmNode->zFilename = tmp___3;
    zShm = tmp___3;
    sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);
    pShmNode->hShm = -1;
    (pDbFd->pInode)->pShmNode = pShmNode;
    pShmNode->pInode = pDbFd->pInode;
    if (sqlite3Config.bCoreMutex) {
      pShmNode->pShmMutex = (sqlite3_mutex *)8;
      if ((unsigned long )pShmNode->pShmMutex == (unsigned long )((sqlite3_mutex *)0)) {
        rc = 7;
        goto shm_open_err;
      }
    }
    if ((int )pInode->bProcessLock == 0) {
      tmp___4 = sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0);
      if (0 == tmp___4) {
        pShmNode->hShm = robust_open((char const   *)zShm, 66, sStat.st_mode & 511U);
      }
      if (pShmNode->hShm < 0) {
        pShmNode->hShm = robust_open((char const   *)zShm, 0, sStat.st_mode & 511U);
        if (pShmNode->hShm < 0) {
          tmp___5 = sqlite3CantopenError(37256);
          rc = unixLogErrorAtLine(tmp___5, "open", (char const   *)zShm, 37256);
          goto shm_open_err;
        }
        pShmNode->isReadonly = (u8 )1;
      }
      robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);
      rc = unixLockSharedMemory(pDbFd, pShmNode);
      if (rc != 0) {
        if (rc != (8 | (5 << 8))) {
          goto shm_open_err;
        }
      }
    }
  }
  p->pShmNode = pShmNode;
  (pShmNode->nRef) ++;
  pDbFd->pShm = p;
  unixLeaveMutex();
  p->pNext = pShmNode->pFirst;
  pShmNode->pFirst = p;
  return (rc);
  shm_open_err: 
  unixShmPurge(pDbFd);
  sqlite3_free((void *)p);
  unixLeaveMutex();
  return (rc);
}
}
static int unixShmMap(sqlite3_file *fd , int iRegion , int szRegion , int bExtend ,
                      void volatile   **pp ) ;
static int const   pgsz  =    (int const   )4096;
static int unixShmMap(sqlite3_file *fd , int iRegion , int szRegion , int bExtend ,
                      void volatile   **pp ) 
{ 
  unixFile *pDbFd ;
  unixShm *p ;
  unixShmNode *pShmNode ;
  int rc ;
  int nShmPerMap ;
  int tmp ;
  int nReqRegion ;
  char **apNew ;
  int nByte ;
  struct stat sStat ;
  int tmp___0 ;
  int iPg ;
  int x___0 ;
  char const   *zFile ;
  int tmp___1 ;
  void *tmp___2 ;
  int nMap ;
  int i ;
  void *pMem ;
  int tmp___3 ;

  {
  pDbFd = (unixFile *)fd;
  rc = 0;
  tmp = unixShmRegionPerMap();
  nShmPerMap = tmp;
  if ((unsigned long )pDbFd->pShm == (unsigned long )((unixShm *)0)) {
    rc = unixOpenSharedMemory(pDbFd);
    if (rc != 0) {
      return (rc);
    }
  }
  p = pDbFd->pShm;
  pShmNode = p->pShmNode;
  if (pShmNode->isUnlocked) {
    rc = unixLockSharedMemory(pDbFd, pShmNode);
    if (rc != 0) {
      goto shmpage_out;
    }
    pShmNode->isUnlocked = (u8 )0;
  }
  nReqRegion = ((iRegion + nShmPerMap) / nShmPerMap) * nShmPerMap;
  if ((int )pShmNode->nRegion < nReqRegion) {
    nByte = nReqRegion * szRegion;
    pShmNode->szRegion = szRegion;
    if (pShmNode->hShm >= 0) {
      tmp___0 = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(pShmNode->hShm,
                                                                          & sStat);
      if (tmp___0) {
        rc = 10 | (19 << 8);
        goto shmpage_out;
      }
      if (sStat.st_size < (__off_t )nByte) {
        if (! bExtend) {
          goto shmpage_out;
        } else {
          iPg = (int )(sStat.st_size / (__off_t )pgsz);
          while (iPg < nByte / (int )pgsz) {
            x___0 = 0;
            tmp___1 = seekAndWriteFd(pShmNode->hShm, (i64 )((iPg * (int )pgsz + (int )pgsz) - 1),
                                     (void const   *)"", 1, & x___0);
            if (tmp___1 != 1) {
              zFile = (char const   *)pShmNode->zFilename;
              rc = unixLogErrorAtLine(10 | (19 << 8), "write", zFile, 37400);
              goto shmpage_out;
            }
            iPg ++;
          }
        }
      }
    }
    tmp___2 = sqlite3_realloc((void *)pShmNode->apRegion, (int )((unsigned long )nReqRegion * sizeof(char *)));
    apNew = (char **)tmp___2;
    if (! apNew) {
      rc = 10 | (12 << 8);
      goto shmpage_out;
    }
    pShmNode->apRegion = apNew;
    while ((int )pShmNode->nRegion < nReqRegion) {
      nMap = szRegion * nShmPerMap;
      if (pShmNode->hShm >= 0) {
        if (pShmNode->isReadonly) {
          tmp___3 = 1;
        } else {
          tmp___3 = 3;
        }
        pMem = (*((void *(*)(void * , size_t  , int  , int  , int  , off_t  ))aSyscall[22].pCurrent))((void *)0,
                                                                                                      (size_t )nMap,
                                                                                                      tmp___3,
                                                                                                      1,
                                                                                                      pShmNode->hShm,
                                                                                                      (off_t )((i64 )szRegion * (i64 )pShmNode->nRegion));
        if ((unsigned long )pMem == (unsigned long )((void *)-1)) {
          rc = unixLogErrorAtLine(10 | (21 << 8), "mmap", (char const   *)pShmNode->zFilename,
                                  37427);
          goto shmpage_out;
        }
      } else {
        pMem = sqlite3_malloc64((sqlite_uint64 )nMap);
        if ((unsigned long )pMem == (unsigned long )((void *)0)) {
          rc = 7;
          goto shmpage_out;
        }
        memset(pMem, 0, (size_t )nMap);
      }
      i = 0;
      while (i < nShmPerMap) {
        *(pShmNode->apRegion + ((int )pShmNode->nRegion + i)) = (char *)pMem + szRegion * i;
        i ++;
      }
      pShmNode->nRegion = (u16 )((int )pShmNode->nRegion + nShmPerMap);
    }
  }
  shmpage_out: 
  if ((int )pShmNode->nRegion > iRegion) {
    *pp = (void volatile   *)*(pShmNode->apRegion + iRegion);
  } else {
    *pp = (void volatile   *)0;
  }
  if (pShmNode->isReadonly) {
    if (rc == 0) {
      rc = 8;
    }
  }
  return (rc);
}
}
static int unixShmLock(sqlite3_file *fd , int ofst , int n , int flags___0 ) 
{ 
  unixFile *pDbFd ;
  unixShm *p ;
  unixShm *pX ;
  unixShmNode *pShmNode ;
  int rc ;
  u16 mask ;
  u16 allMask ;
  u16 allShared ;

  {
  pDbFd = (unixFile *)fd;
  p = pDbFd->pShm;
  pShmNode = p->pShmNode;
  rc = 0;
  mask = (u16 )((1 << (ofst + n)) - (1 << ofst));
  if (flags___0 & 1) {
    allMask = (u16 )0;
    pX = pShmNode->pFirst;
    while (pX) {
      if ((unsigned long )pX == (unsigned long )p) {
        goto __Cont;
      }
      allMask = (u16 )((int )allMask | (int )pX->sharedMask);
      __Cont: /* CIL Label */ 
      pX = pX->pNext;
    }
    if (((int )mask & (int )allMask) == 0) {
      rc = unixShmSystemLock(pDbFd, 2, ofst + 120, n);
    } else {
      rc = 0;
    }
    if (rc == 0) {
      p->exclMask = (u16 )((int )p->exclMask & ~ ((int )mask));
      p->sharedMask = (u16 )((int )p->sharedMask & ~ ((int )mask));
    }
  } else
  if (flags___0 & 4) {
    allShared = (u16 )0;
    pX = pShmNode->pFirst;
    while (pX) {
      if (((int )pX->exclMask & (int )mask) != 0) {
        rc = 5;
        break;
      }
      allShared = (u16 )((int )allShared | (int )pX->sharedMask);
      pX = pX->pNext;
    }
    if (rc == 0) {
      if (((int )allShared & (int )mask) == 0) {
        rc = unixShmSystemLock(pDbFd, 0, ofst + 120, n);
      } else {
        rc = 0;
      }
    }
    if (rc == 0) {
      p->sharedMask = (u16 )((int )p->sharedMask | (int )mask);
    }
  } else {
    pX = pShmNode->pFirst;
    while (pX) {
      if (((int )pX->exclMask & (int )mask) != 0) {
        rc = 5;
        break;
      } else
      if (((int )pX->sharedMask & (int )mask) != 0) {
        rc = 5;
        break;
      }
      pX = pX->pNext;
    }
    if (rc == 0) {
      rc = unixShmSystemLock(pDbFd, 1, ofst + 120, n);
      if (rc == 0) {
        p->exclMask = (u16 )((int )p->exclMask | (int )mask);
      }
    }
  }
  return (rc);
}
}
static void unixShmBarrier(sqlite3_file *fd ) 
{ 


  {
  unixEnterMutex();
  unixLeaveMutex();
  return;
}
}
static int unixShmUnmap(sqlite3_file *fd , int deleteFlag ) 
{ 
  unixShm *p ;
  unixShmNode *pShmNode ;
  unixShm **pp ;
  unixFile *pDbFd ;

  {
  pDbFd = (unixFile *)fd;
  p = pDbFd->pShm;
  if ((unsigned long )p == (unsigned long )((unixShm *)0)) {
    return (0);
  }
  pShmNode = p->pShmNode;
  pp = & pShmNode->pFirst;
  while ((unsigned long )*pp != (unsigned long )p) {
    pp = & (*pp)->pNext;
  }
  *pp = p->pNext;
  sqlite3_free((void *)p);
  pDbFd->pShm = (unixShm *)0;
  unixEnterMutex();
  (pShmNode->nRef) --;
  if (pShmNode->nRef == 0) {
    if (deleteFlag) {
      if (pShmNode->hShm >= 0) {
        (*((int (*)(char const   * ))aSyscall[16].pCurrent))((char const   *)pShmNode->zFilename);
      }
    }
    unixShmPurge(pDbFd);
  }
  unixLeaveMutex();
  return (0);
}
}
static void unixUnmapfile(unixFile *pFd ) 
{ 


  {
  if (pFd->pMapRegion) {
    (*((int (*)(void * , size_t  ))aSyscall[23].pCurrent))(pFd->pMapRegion, (size_t )pFd->mmapSizeActual);
    pFd->pMapRegion = (void *)0;
    pFd->mmapSize = (sqlite_int64 )0;
    pFd->mmapSizeActual = (sqlite_int64 )0;
  }
  return;
}
}
static void unixRemapfile(unixFile *pFd , i64 nNew ) 
{ 
  char const   *zErr ;
  int h ;
  u8 *pOrig ;
  i64 nOrig ;
  u8 *pNew ;
  int flags___0 ;
  i64 nReuse ;
  u8 *pReq ;
  void *tmp ;
  void *tmp___0 ;
  sqlite_int64 tmp___1 ;

  {
  zErr = "mmap";
  h = pFd->h;
  pOrig = (u8 *)pFd->pMapRegion;
  nOrig = pFd->mmapSizeActual;
  pNew = (u8 *)0;
  flags___0 = 1;
  if (pOrig) {
    nReuse = pFd->mmapSize;
    pReq = pOrig + nReuse;
    if (nReuse != nOrig) {
      (*((int (*)(void * , size_t  ))aSyscall[23].pCurrent))((void *)pReq, (size_t )(nOrig - nReuse));
    }
    tmp = (*((void *(*)(void * , size_t  , size_t  , int   , ...))aSyscall[24].pCurrent))((void *)pOrig,
                                                                                          (size_t )nReuse,
                                                                                          (size_t )nNew,
                                                                                          1);
    pNew = (u8 *)tmp;
    zErr = "mremap";
    if ((unsigned long )pNew == (unsigned long )((void *)-1)) {
      (*((int (*)(void * , size_t  ))aSyscall[23].pCurrent))((void *)pOrig, (size_t )nReuse);
    } else
    if ((unsigned long )pNew == (unsigned long )((u8 *)0)) {
      (*((int (*)(void * , size_t  ))aSyscall[23].pCurrent))((void *)pOrig, (size_t )nReuse);
    }
  }
  if ((unsigned long )pNew == (unsigned long )((u8 *)0)) {
    tmp___0 = (*((void *(*)(void * , size_t  , int  , int  , int  , off_t  ))aSyscall[22].pCurrent))((void *)0,
                                                                                                     (size_t )nNew,
                                                                                                     flags___0,
                                                                                                     1,
                                                                                                     h,
                                                                                                     (off_t )0);
    pNew = (u8 *)tmp___0;
  }
  if ((unsigned long )pNew == (unsigned long )((void *)-1)) {
    pNew = (u8 *)0;
    nNew = (i64 )0;
    unixLogErrorAtLine(0, zErr, pFd->zPath, 37743);
    pFd->mmapSizeMax = (sqlite_int64 )0;
  }
  pFd->pMapRegion = (void *)pNew;
  tmp___1 = nNew;
  pFd->mmapSizeActual = tmp___1;
  pFd->mmapSize = tmp___1;
  return;
}
}
static int unixMapfile(unixFile *pFd , i64 nMap ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
  if (pFd->nFetchOut > 0) {
    return (0);
  }
  if (nMap < 0LL) {
    tmp = (*((int (*)(int  , struct stat * ))aSyscall[5].pCurrent))(pFd->h, & statbuf);
    if (tmp) {
      return (10 | (7 << 8));
    }
    nMap = (i64 )statbuf.st_size;
  }
  if (nMap > pFd->mmapSizeMax) {
    nMap = pFd->mmapSizeMax;
  }
  if (nMap != pFd->mmapSize) {
    unixRemapfile(pFd, nMap);
  }
  return (0);
}
}
static int unixFetch(sqlite3_file *fd , i64 iOff , int nAmt , void **pp ) 
{ 
  unixFile *pFd ;
  int rc ;
  int tmp ;

  {
  pFd = (unixFile *)fd;
  *pp = (void *)0;
  if (pFd->mmapSizeMax > 0LL) {
    if ((unsigned long )pFd->pMapRegion == (unsigned long )((void *)0)) {
      tmp = unixMapfile(pFd, (i64 )-1);
      rc = tmp;
      if (rc != 0) {
        return (rc);
      }
    }
    if (pFd->mmapSize >= iOff + (i64 )nAmt) {
      *pp = (void *)((u8 *)pFd->pMapRegion + iOff);
      (pFd->nFetchOut) ++;
    }
  }
  return (0);
}
}
static int unixUnfetch(sqlite3_file *fd , i64 iOff , void *p ) 
{ 
  unixFile *pFd ;

  {
  pFd = (unixFile *)fd;
  if (p) {
    (pFd->nFetchOut) --;
  } else {
    unixUnmapfile(pFd);
  }
  return (0);
}
}
static struct sqlite3_io_methods  const  posixIoMethods  = 
     {3, & unixClose, & unixRead, & unixWrite, & unixTruncate, & unixSync, & unixFileSize,
    & unixLock, & unixUnlock, & unixCheckReservedLock, & unixFileControl, & unixSectorSize,
    & unixDeviceCharacteristics, & unixShmMap, & unixShmLock, & unixShmBarrier, & unixShmUnmap,
    & unixFetch, & unixUnfetch};
static sqlite3_io_methods const   *posixIoFinderImpl(char const   *z , unixFile *p ) 
{ 


  {
  return (& posixIoMethods);
}
}
static sqlite3_io_methods const   *(* const  posixIoFinder)(char const   * , unixFile *p )  =    (sqlite3_io_methods const   *(* const  )(char const   * ,
                                            unixFile *p ))(& posixIoFinderImpl);
static struct sqlite3_io_methods  const  nolockIoMethods  = 
     {3, & nolockClose, & unixRead, & unixWrite, & unixTruncate, & unixSync, & unixFileSize,
    & nolockLock, & nolockUnlock, & nolockCheckReservedLock, & unixFileControl, & unixSectorSize,
    & unixDeviceCharacteristics, (int (*)(sqlite3_file * , int iPg , int pgsz , int  ,
                                          void volatile   ** ))0, & unixShmLock, & unixShmBarrier,
    & unixShmUnmap, & unixFetch, & unixUnfetch};
static sqlite3_io_methods const   *nolockIoFinderImpl(char const   *z , unixFile *p ) 
{ 


  {
  return (& nolockIoMethods);
}
}
static sqlite3_io_methods const   *(* const  nolockIoFinder)(char const   * , unixFile *p )  =    (sqlite3_io_methods const   *(* const  )(char const   * ,
                                            unixFile *p ))(& nolockIoFinderImpl);
static struct sqlite3_io_methods  const  dotlockIoMethods  = 
     {1, & dotlockClose, & unixRead, & unixWrite, & unixTruncate, & unixSync, & unixFileSize,
    & dotlockLock, & dotlockUnlock, & dotlockCheckReservedLock, & unixFileControl,
    & unixSectorSize, & unixDeviceCharacteristics, (int (*)(sqlite3_file * , int iPg ,
                                                            int pgsz , int  , void volatile   ** ))0,
    & unixShmLock, & unixShmBarrier, & unixShmUnmap, & unixFetch, & unixUnfetch};
static sqlite3_io_methods const   *dotlockIoFinderImpl(char const   *z , unixFile *p ) 
{ 


  {
  return (& dotlockIoMethods);
}
}
static sqlite3_io_methods const   *(* const  dotlockIoFinder)(char const   * , unixFile *p )  =    (sqlite3_io_methods const   *(* const  )(char const   * ,
                                            unixFile *p ))(& dotlockIoFinderImpl);
static int fillInUnixFile(sqlite3_vfs *pVfs ,
                          int h , sqlite3_file *pId , char const   *zFilename , int ctrlFlags ) 
{ 
  sqlite3_io_methods const   *pLockingStyle ;
  unixFile *pNew ;
  int rc ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *zLockFile ;
  int nFilename ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  pNew = (unixFile *)pId;
  rc = 0;
  pNew->h = h;
  pNew->pVfs = pVfs;
  pNew->zPath = zFilename;
  pNew->ctrlFlags = (unsigned short )((u8 )ctrlFlags);
  pNew->mmapSizeMax = sqlite3Config.szMmap;
  if (ctrlFlags & 64) {
    tmp = zFilename;
  } else {
    tmp = (char const   *)0;
  }
  tmp___0 = sqlite3_uri_boolean(tmp, "psow", 1);
  if (tmp___0) {
    pNew->ctrlFlags = (unsigned short )((int )pNew->ctrlFlags | 16);
  }
  tmp___1 = strcmp(pVfs->zName, "unix-excl");
  if (tmp___1 == 0) {
    pNew->ctrlFlags = (unsigned short )((int )pNew->ctrlFlags | 1);
  }
  if (ctrlFlags & 128) {
    pLockingStyle = & nolockIoMethods;
  } else {
    pLockingStyle = (*(*((finder_type *)pVfs->pAppData)))(zFilename, pNew);
  }
  if ((unsigned long )pLockingStyle == (unsigned long )(& posixIoMethods)) {
    unixEnterMutex();
    rc = findInodeInfo(pNew, & pNew->pInode);
    if (rc != 0) {
      robust_close(pNew, h, 38246);
      h = -1;
    }
    unixLeaveMutex();
  } else
  if ((unsigned long )pLockingStyle == (unsigned long )(& dotlockIoMethods)) {
    tmp___2 = strlen(zFilename);
    nFilename = (int )tmp___2 + 6;
    tmp___3 = sqlite3_malloc64((sqlite_uint64 )nFilename);
    zLockFile = (char *)tmp___3;
    if ((unsigned long )zLockFile == (unsigned long )((char *)0)) {
      rc = 7;
    } else {
      sqlite3_snprintf(nFilename, zLockFile, "%s.lock", zFilename);
    }
    pNew->lockingContext = (void *)zLockFile;
  }
  storeLastErrno(pNew, 0);
  if (rc != 0) {
    if (h >= 0) {
      robust_close(pNew, h, 38331);
    }
  } else {
    pNew->pMethod = pLockingStyle;
    verifyDbFile(pNew);
  }
  return (rc);
}
}
static char const   *unixTempFileDir(void) ;
static char const   *azDirs[6]  = {      (char const   *)0,      (char const   *)0,      "/var/tmp",      "/usr/tmp", 
        "/tmp",      "."};
static char const   *unixTempFileDir(void) 
{ 
  unsigned int i ;
  struct stat buf ;
  char const   *zDir ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  i = 0U;
  zDir = (char const   *)sqlite3_temp_directory;
  if (! azDirs[0]) {
    tmp = getenv("SQLITE_TMPDIR");
    azDirs[0] = (char const   *)tmp;
  }
  if (! azDirs[1]) {
    tmp___0 = getenv("TMPDIR");
    azDirs[1] = (char const   *)tmp___0;
  }
  while (1) {
    if ((unsigned long )zDir != (unsigned long )((char const   *)0)) {
      tmp___1 = (*((int (*)(char const   * , struct stat * ))aSyscall[4].pCurrent))(zDir,
                                                                                    & buf);
      if (tmp___1 == 0) {
        if ((buf.st_mode & 61440U) == 16384U) {
          tmp___2 = (*((int (*)(char const   * , int  ))aSyscall[2].pCurrent))(zDir,
                                                                               3);
          if (tmp___2 == 0) {
            return (zDir);
          }
        }
      }
    }
    if ((unsigned long )i >= sizeof(azDirs) / sizeof(azDirs[0])) {
      break;
    }
    tmp___3 = i;
    i ++;
    zDir = azDirs[tmp___3];
  }
  return ((char const   *)0);
}
}
static int unixGetTempname(int nBuf , char *zBuf ) 
{ 
  char const   *zDir ;
  int iLimit ;
  u64 r ;
  int tmp ;
  int tmp___0 ;

  {
  iLimit = 0;
  *(zBuf + 0) = (char)0;
  zDir = unixTempFileDir();
  if ((unsigned long )zDir == (unsigned long )((char const   *)0)) {
    return (10 | (25 << 8));
  }
  while (1) {
    sqlite3_randomness((int )sizeof(r), (void *)(& r));
    *(zBuf + (nBuf - 2)) = (char)0;
    sqlite3_snprintf(nBuf, zBuf, "%s/etilqs_%llx%c", zDir, r, 0);
    if ((int )*(zBuf + (nBuf - 2)) != 0) {
      return (1);
    } else {
      tmp = iLimit;
      iLimit ++;
      if (tmp > 10) {
        return (1);
      }
    }
    tmp___0 = (*((int (*)(char const   * , int  ))aSyscall[2].pCurrent))((char const   *)zBuf,
                                                                         0);
    if (! (tmp___0 == 0)) {
      break;
    }
  }
  return (0);
}
}
static UnixUnusedFd *findReusableFd(char const   *zPath , int flags___0 ) 
{ 
  UnixUnusedFd *pUnused ;
  struct stat sStat ;
  unixInodeInfo *pInode ;
  UnixUnusedFd **pp ;
  int tmp ;

  {
  pUnused = (UnixUnusedFd *)0;
  unixEnterMutex();
  if ((unsigned long )inodeList != (unsigned long )((unixInodeInfo *)0)) {
    tmp = (*((int (*)(char const   * , struct stat * ))aSyscall[4].pCurrent))(zPath,
                                                                              & sStat);
    if (0 == tmp) {
      pInode = inodeList;
      while (1) {
        if (pInode) {
          if (! (pInode->fileId.dev != sStat.st_dev)) {
            if (! (pInode->fileId.ino != (u64 )sStat.st_ino)) {
              break;
            }
          }
        } else {
          break;
        }
        pInode = pInode->pNext;
      }
      if (pInode) {
        flags___0 &= 3;
        pp = & pInode->pUnused;
        while (1) {
          if (*pp) {
            if (! ((*pp)->flags != flags___0)) {
              break;
            }
          } else {
            break;
          }
          pp = & (*pp)->pNext;
        }
        pUnused = *pp;
        if (pUnused) {
          *pp = pUnused->pNext;
        }
      }
    }
  }
  unixLeaveMutex();
  return (pUnused);
}
}
static int getFileMode(char const   *zFile , mode_t *pMode , uid_t *pUid , gid_t *pGid ) 
{ 
  struct stat sStat ;
  int rc ;
  int tmp ;

  {
  rc = 0;
  tmp = (*((int (*)(char const   * , struct stat * ))aSyscall[4].pCurrent))(zFile,
                                                                            & sStat);
  if (0 == tmp) {
    *pMode = sStat.st_mode & 511U;
    *pUid = sStat.st_uid;
    *pGid = sStat.st_gid;
  } else {
    rc = 10 | (7 << 8);
  }
  return (rc);
}
}
static int findCreateFileMode(char const   *zPath , int flags___0 , mode_t *pMode ,
                              uid_t *pUid , gid_t *pGid ) 
{ 
  int rc ;
  char zDb[513] ;
  int nDb ;
  int tmp ;
  char const   *z ;
  char const   *tmp___0 ;

  {
  rc = 0;
  *pMode = (mode_t )0;
  *pUid = (uid_t )0;
  *pGid = (gid_t )0;
  if (flags___0 & 526336) {
    tmp = sqlite3Strlen30(zPath);
    nDb = tmp - 1;
    while ((int const   )*(zPath + nDb) != 45) {
      if (nDb == 0) {
        return (0);
      } else
      if ((int const   )*(zPath + nDb) == 46) {
        return (0);
      }
      nDb --;
    }
    memcpy((void * __restrict  )(zDb), (void const   * __restrict  )zPath, (size_t )nDb);
    zDb[nDb] = (char )'\000';
    rc = getFileMode((char const   *)(zDb), pMode, pUid, pGid);
  } else
  if (flags___0 & 8) {
    *pMode = (mode_t )384;
  } else
  if (flags___0 & 64) {
    tmp___0 = sqlite3_uri_parameter(zPath, "modeof");
    z = tmp___0;
    if (z) {
      rc = getFileMode(z, pMode, pUid, pGid);
    }
  }
  return (rc);
}
}
static int unixOpen(sqlite3_vfs *pVfs , char const   *zPath , sqlite3_file *pFile ,
                    int flags___0 , int *pOutFlags ) 
{ 
  unixFile *p ;
  int fd ;
  int openFlags ;
  int eType ;
  int noLock ;
  int rc ;
  int ctrlFlags ;
  int isExclusive ;
  int isDelete ;
  int isCreate ;
  int isReadonly ;
  int isReadWrite ;
  int isNewJrnl ;
  int tmp ;
  char zTmpname[514] ;
  char const   *zName ;
  __pid_t tmp___0 ;
  __pid_t tmp___1 ;
  UnixUnusedFd *pUnused ;
  void *tmp___2 ;
  mode_t openMode ;
  uid_t uid ;
  gid_t gid ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int rc2 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  p = (unixFile *)pFile;
  fd = -1;
  openFlags = 0;
  eType = (int )((unsigned int )flags___0 & 4294967040U);
  rc = 0;
  ctrlFlags = 0;
  isExclusive = flags___0 & 16;
  isDelete = flags___0 & 8;
  isCreate = flags___0 & 4;
  isReadonly = flags___0 & 1;
  isReadWrite = flags___0 & 2;
  if (isCreate) {
    if (eType == 16384) {
      tmp = 1;
    } else
    if (eType == 2048) {
      tmp = 1;
    } else
    if (eType == 524288) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  isNewJrnl = tmp;
  zName = zPath;
  tmp___1 = getpid();
  if (randomnessPid != tmp___1) {
    tmp___0 = getpid();
    randomnessPid = tmp___0;
    sqlite3_randomness(0, (void *)0);
  }
  memset((void *)p, 0, sizeof(unixFile ));
  if (eType == 256) {
    pUnused = findReusableFd(zName, flags___0);
    if (pUnused) {
      fd = pUnused->fd;
    } else {
      tmp___2 = sqlite3_malloc64((sqlite_uint64 )sizeof(*pUnused));
      pUnused = (UnixUnusedFd *)tmp___2;
      if (! pUnused) {
        return (7);
      }
    }
    p->pPreallocatedUnused = pUnused;
  } else
  if (! zName) {
    rc = unixGetTempname(pVfs->mxPathname, zTmpname);
    if (rc != 0) {
      return (rc);
    }
    zName = (char const   *)(zTmpname);
  }
  if (isReadonly) {
    openFlags = openFlags;
  }
  if (isReadWrite) {
    openFlags |= 2;
  }
  if (isCreate) {
    openFlags |= 64;
  }
  if (isExclusive) {
    openFlags |= 131200;
  }
  openFlags = openFlags;
  if (fd < 0) {
    rc = findCreateFileMode(zName, flags___0, & openMode, & uid, & gid);
    if (rc != 0) {
      return (rc);
    }
    fd = robust_open(zName, openFlags, openMode);
    if (fd < 0) {
      if (isNewJrnl) {
        tmp___4 = __errno_location();
        if (*tmp___4 == 13) {
          tmp___5 = (*((int (*)(char const   * , int  ))aSyscall[2].pCurrent))(zName,
                                                                               0);
          if (tmp___5) {
            rc = 8 | (6 << 8);
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        tmp___3 = __errno_location();
        if (*tmp___3 != 21) {
          if (isReadWrite) {
            flags___0 &= -7;
            openFlags &= -67;
            flags___0 |= 1;
            openFlags = openFlags;
            isReadonly = 1;
            fd = robust_open(zName, openFlags, openMode);
          }
        }
      }
    }
    if (fd < 0) {
      tmp___6 = sqlite3CantopenError(38745);
      tmp___7 = unixLogErrorAtLine(tmp___6, "open", zName, 38745);
      rc2 = tmp___7;
      if (rc == 0) {
        rc = rc2;
      }
      goto open_finished;
    }
    if (openMode) {
      if ((flags___0 & 526336) != 0) {
        robustFchown(fd, uid, gid);
      }
    }
  }
  if (pOutFlags) {
    *pOutFlags = flags___0;
  }
  if (p->pPreallocatedUnused) {
    (p->pPreallocatedUnused)->fd = fd;
    (p->pPreallocatedUnused)->flags = flags___0 & 3;
  }
  if (isDelete) {
    (*((int (*)(char const   * ))aSyscall[16].pCurrent))(zName);
  }
  if (isDelete) {
    ctrlFlags |= 32;
  }
  if (isReadonly) {
    ctrlFlags |= 2;
  }
  noLock = eType != 256;
  if (noLock) {
    ctrlFlags |= 128;
  }
  if (isNewJrnl) {
    ctrlFlags |= 8;
  }
  if (flags___0 & 64) {
    ctrlFlags |= 64;
  }
  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);
  open_finished: 
  if (rc != 0) {
    sqlite3_free((void *)p->pPreallocatedUnused);
  }
  return (rc);
}
}
static int unixDelete(sqlite3_vfs *NotUsed , char const   *zPath , int dirSync ) 
{ 
  int rc ;
  int *tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;

  {
  rc = 0;
  tmp___0 = (*((int (*)(char const   * ))aSyscall[16].pCurrent))(zPath);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    if (*tmp == 2) {
      rc = 10 | (23 << 8);
    } else {
      rc = unixLogErrorAtLine(10 | (10 << 8), "unlink", zPath, 38884);
    }
    return (rc);
  }
  if ((dirSync & 1) != 0) {
    rc = (*((int (*)(char const   * , int * ))aSyscall[17].pCurrent))(zPath, & fd);
    if (rc == 0) {
      tmp___1 = full_fsync(fd, 0, 0);
      if (tmp___1) {
        rc = unixLogErrorAtLine(10 | (5 << 8), "fsync", zPath, 38894);
      }
      robust_close((unixFile *)0, fd, 38896);
    } else {
      rc = 0;
    }
  }
  return (rc);
}
}
static int unixAccess(sqlite3_vfs *NotUsed , char const   *zPath , int flags___0 ,
                      int *pResOut ) 
{ 
  struct stat buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (flags___0 == 0) {
    tmp = (*((int (*)(char const   * , struct stat * ))aSyscall[4].pCurrent))(zPath,
                                                                              & buf);
    if (0 == tmp) {
      if (buf.st_size > 0L) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    *pResOut = tmp___0;
  } else {
    tmp___1 = (*((int (*)(char const   * , int  ))aSyscall[2].pCurrent))(zPath, 6);
    *pResOut = tmp___1 == 0;
  }
  return (0);
}
}
static int mkFullPathname(char const   *zPath , char *zOut , int nOut ) 
{ 
  int nPath ;
  int tmp ;
  int iOff ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = sqlite3Strlen30(zPath);
  nPath = tmp;
  iOff = 0;
  if ((int const   )*(zPath + 0) != 47) {
    tmp___2 = (*((char *(*)(char * , size_t  ))aSyscall[3].pCurrent))(zOut, (size_t )(nOut - 2));
    if ((unsigned long )tmp___2 == (unsigned long )((char *)0)) {
      tmp___0 = sqlite3CantopenError(38951);
      tmp___1 = unixLogErrorAtLine(tmp___0, "getcwd", zPath, 38951);
      return (tmp___1);
    }
    iOff = sqlite3Strlen30((char const   *)zOut);
    tmp___3 = iOff;
    iOff ++;
    *(zOut + tmp___3) = (char )'/';
  }
  if ((iOff + nPath) + 1 > nOut) {
    *(zOut + iOff) = (char )'\000';
    tmp___4 = sqlite3CantopenError(38960);
    return (tmp___4);
  }
  sqlite3_snprintf(nOut - iOff, zOut + iOff, "%s", zPath);
  return (0);
}
}
static int unixFullPathname(sqlite3_vfs *pVfs , char const   *zPath , int nOut , char *zOut ) 
{ 
  int rc ;
  int nByte ;
  int nLink ;
  char const   *zIn ;
  char *zDel ;
  int bLink ;
  struct stat buf ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int n ;

  {
  rc = 0;
  nLink = 1;
  zIn = zPath;
  zDel = (char *)0;
  while (1) {
    bLink = 0;
    tmp___1 = (*((int (*)(char const   * , struct stat * ))aSyscall[27].pCurrent))(zIn,
                                                                                   & buf);
    if (tmp___1 != 0) {
      tmp___0 = __errno_location();
      if (*tmp___0 != 2) {
        tmp = sqlite3CantopenError(39008);
        rc = unixLogErrorAtLine(tmp, "lstat", zIn, 39008);
      }
    } else {
      bLink = (buf.st_mode & 61440U) == 40960U;
    }
    if (bLink) {
      if ((unsigned long )zDel == (unsigned long )((char *)0)) {
        tmp___2 = sqlite3_malloc(nOut);
        zDel = (char *)tmp___2;
        if ((unsigned long )zDel == (unsigned long )((char *)0)) {
          rc = 7;
        }
      } else {
        nLink ++;
        if (nLink > 100) {
          rc = sqlite3CantopenError(39019);
        }
      }
      if (rc == 0) {
        tmp___3 = (*((ssize_t (*)(char const   * , char * , size_t  ))aSyscall[26].pCurrent))(zIn,
                                                                                              zDel,
                                                                                              (size_t )(nOut - 1));
        nByte = (int )tmp___3;
        if (nByte < 0) {
          tmp___4 = sqlite3CantopenError(39025);
          rc = unixLogErrorAtLine(tmp___4, "readlink", zIn, 39025);
        } else {
          if ((int )*(zDel + 0) != 47) {
            n = sqlite3Strlen30(zIn);
            while (1) {
              if (n > 0) {
                if (! ((int const   )*(zIn + (n - 1)) != 47)) {
                  break;
                }
              } else {
                break;
              }
              n --;
            }
            if ((nByte + n) + 1 > nOut) {
              rc = sqlite3CantopenError(39031);
            } else {
              memmove((void *)(zDel + n), (void const   *)zDel, (size_t )(nByte + 1));
              memcpy((void * __restrict  )zDel, (void const   * __restrict  )zIn,
                     (size_t )n);
              nByte += n;
            }
          }
          *(zDel + nByte) = (char )'\000';
        }
      }
      zIn = (char const   *)zDel;
    }
    if (rc == 0) {
      if ((unsigned long )zIn != (unsigned long )zOut) {
        rc = mkFullPathname(zIn, zOut, nOut);
      }
    }
    if (bLink == 0) {
      break;
    }
    zIn = (char const   *)zOut;
    if (! (rc == 0)) {
      break;
    }
  }
  sqlite3_free((void *)zDel);
  return (rc);
}
}
static int unixRandomness(sqlite3_vfs *NotUsed , int nBuf , char *zBuf ) 
{ 
  __pid_t tmp ;
  int fd ;
  int got ;
  time_t t ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  memset((void *)zBuf, 0, (size_t )nBuf);
  tmp = getpid();
  randomnessPid = tmp;
  fd = robust_open("/dev/urandom", 0, (mode_t )0);
  if (fd < 0) {
    time(& t);
    memcpy((void * __restrict  )zBuf, (void const   * __restrict  )(& t), sizeof(t));
    memcpy((void * __restrict  )(zBuf + sizeof(t)), (void const   * __restrict  )(& randomnessPid),
           sizeof(randomnessPid));
    nBuf = (int )(sizeof(t) + sizeof(randomnessPid));
  } else {
    while (1) {
      tmp___0 = (*((ssize_t (*)(int  , void * , size_t  ))aSyscall[8].pCurrent))(fd,
                                                                                 (void *)zBuf,
                                                                                 (size_t )nBuf);
      got = (int )tmp___0;
      if (got < 0) {
        tmp___1 = __errno_location();
        if (! (*tmp___1 == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    robust_close((unixFile *)0, fd, 39155);
  }
  return (nBuf);
}
}
static int unixSleep(sqlite3_vfs *NotUsed , int microseconds ) 
{ 
  int seconds ;

  {
  seconds = (microseconds + 999999) / 1000000;
  sleep((unsigned int )seconds);
  return (seconds * 1000000);
}
}
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed , sqlite_int64 *piNow ) ;
static long long const   unixEpoch  =    (sqlite_int64 const   )210866760000000LL;
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed , sqlite_int64 *piNow ) 
{ 
  int rc ;
  struct timeval sNow ;

  {
  rc = 0;
  gettimeofday((struct timeval * __restrict  )(& sNow), (__timezone_ptr_t )0);
  *piNow = (sqlite_int64 )((unixEpoch + (long long const   )(1000LL * (sqlite_int64 )sNow.tv_sec)) + (long long const   )(sNow.tv_usec / 1000L));
  return (rc);
}
}
static int unixCurrentTime(sqlite3_vfs *NotUsed , double *prNow ) 
{ 
  sqlite_int64 i ;
  int rc ;

  {
  i = (sqlite_int64 )0;
  rc = unixCurrentTimeInt64((sqlite3_vfs *)0, & i);
  *prNow = (double )i / 86400000.0;
  return (rc);
}
}
static int unixGetLastError(sqlite3_vfs *NotUsed , int NotUsed2 , char *NotUsed3 ) 
{ 
  int *tmp ;

  {
  tmp = __errno_location();
  return (*tmp);
}
}
static sqlite3_vfs aVfs[4]  = {      {3, (int )sizeof(unixFile ), 512, (sqlite3_vfs *)0, "unix", (void *)(& posixIoFinder),
      & unixOpen, & unixDelete, & unixAccess, & unixFullPathname, (void *(*)(sqlite3_vfs * ,
                                                                             char const   *zFilename ))0,
      (void (*)(sqlite3_vfs * , int nByte , char *zErrMsg ))0, (void (*(*)(sqlite3_vfs * ,
                                                                           void * ,
                                                                           char const   *zSymbol ))(void))0,
      (void (*)(sqlite3_vfs * , void * ))0, & unixRandomness, & unixSleep, & unixCurrentTime,
      & unixGetLastError, & unixCurrentTimeInt64, & unixSetSystemCall, & unixGetSystemCall,
      & unixNextSystemCall}, 
        {3, (int )sizeof(unixFile ), 512, (sqlite3_vfs *)0, "unix-none", (void *)(& nolockIoFinder),
      & unixOpen, & unixDelete, & unixAccess, & unixFullPathname, (void *(*)(sqlite3_vfs * ,
                                                                             char const   *zFilename ))0,
      (void (*)(sqlite3_vfs * , int nByte , char *zErrMsg ))0, (void (*(*)(sqlite3_vfs * ,
                                                                           void * ,
                                                                           char const   *zSymbol ))(void))0,
      (void (*)(sqlite3_vfs * , void * ))0, & unixRandomness, & unixSleep, & unixCurrentTime,
      & unixGetLastError, & unixCurrentTimeInt64, & unixSetSystemCall, & unixGetSystemCall,
      & unixNextSystemCall}, 
        {3, (int )sizeof(unixFile ), 512, (sqlite3_vfs *)0, "unix-dotfile", (void *)(& dotlockIoFinder),
      & unixOpen, & unixDelete, & unixAccess, & unixFullPathname, (void *(*)(sqlite3_vfs * ,
                                                                             char const   *zFilename ))0,
      (void (*)(sqlite3_vfs * , int nByte , char *zErrMsg ))0, (void (*(*)(sqlite3_vfs * ,
                                                                           void * ,
                                                                           char const   *zSymbol ))(void))0,
      (void (*)(sqlite3_vfs * , void * ))0, & unixRandomness, & unixSleep, & unixCurrentTime,
      & unixGetLastError, & unixCurrentTimeInt64, & unixSetSystemCall, & unixGetSystemCall,
      & unixNextSystemCall}, 
        {3, (int )sizeof(unixFile ), 512, (sqlite3_vfs *)0, "unix-excl", (void *)(& posixIoFinder),
      & unixOpen, & unixDelete, & unixAccess, & unixFullPathname, (void *(*)(sqlite3_vfs * ,
                                                                             char const   *zFilename ))0,
      (void (*)(sqlite3_vfs * , int nByte , char *zErrMsg ))0, (void (*(*)(sqlite3_vfs * ,
                                                                           void * ,
                                                                           char const   *zSymbol ))(void))0,
      (void (*)(sqlite3_vfs * , void * ))0, & unixRandomness, & unixSleep, & unixCurrentTime,
      & unixGetLastError, & unixCurrentTimeInt64, & unixSetSystemCall, & unixGetSystemCall,
      & unixNextSystemCall}};
int sqlite3_os_init(void) 
{ 
  unsigned int i ;

  {
  i = 0U;
  while ((unsigned long )i < sizeof(aVfs) / sizeof(sqlite3_vfs )) {
    sqlite3_vfs_register(& aVfs[i], i == 0U);
    i ++;
  }
  unixBigLock = (sqlite3_mutex *)8;
  return (0);
}
}
int sqlite3_os_end(void) 
{ 


  {
  unixBigLock = (sqlite3_mutex *)0;
  return (0);
}
}
static Bitvec *sqlite3BitvecCreate(u32 iSize ) 
{ 
  Bitvec *p ;
  void *tmp ;

  {
  tmp = sqlite3MallocZero((u64 )sizeof(*p));
  p = (Bitvec *)tmp;
  if (p) {
    p->iSize = iSize;
  }
  return (p);
}
}
static int sqlite3BitvecTestNotNull(Bitvec *p , u32 i ) 
{ 
  u32 bin ;
  u32 h ;
  u32 tmp ;

  {
  i --;
  if (i >= p->iSize) {
    return (0);
  }
  while (p->iDivisor) {
    bin = i / p->iDivisor;
    i %= p->iDivisor;
    p = p->u.apSub[bin];
    if (! p) {
      return (0);
    }
  }
  if ((unsigned long )p->iSize <= ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8UL) {
    return (((int )p->u.aBitmap[i / 8U] & (1 << (i & 7U))) != 0);
  } else {
    tmp = i;
    i ++;
    h = (u32 )((unsigned long )tmp % ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )));
    while (p->u.aHash[h]) {
      if (p->u.aHash[h] == i) {
        return (1);
      }
      h = (u32 )((unsigned long )(h + 1U) % ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )));
    }
    return (0);
  }
}
}
static int sqlite3BitvecTest(Bitvec *p , u32 i ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )p != (unsigned long )((Bitvec *)0)) {
    tmp = sqlite3BitvecTestNotNull(p, i);
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3BitvecSet(Bitvec *p , u32 i ) 
{ 
  u32 h ;
  u32 bin ;
  u32 tmp ;
  unsigned int j ;
  int rc ;
  u32 *aiValues ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )p == (unsigned long )((Bitvec *)0)) {
    return (0);
  }
  i --;
  while (1) {
    if ((unsigned long )p->iSize > ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8UL) {
      if (! p->iDivisor) {
        break;
      }
    } else {
      break;
    }
    bin = i / p->iDivisor;
    i %= p->iDivisor;
    if ((unsigned long )p->u.apSub[bin] == (unsigned long )((Bitvec *)0)) {
      p->u.apSub[bin] = sqlite3BitvecCreate(p->iDivisor);
      if ((unsigned long )p->u.apSub[bin] == (unsigned long )((Bitvec *)0)) {
        return (7);
      }
    }
    p = p->u.apSub[bin];
  }
  if ((unsigned long )p->iSize <= ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8UL) {
    p->u.aBitmap[i / 8U] = (u8 )((int )p->u.aBitmap[i / 8U] | (1 << (i & 7U)));
    return (0);
  }
  tmp = i;
  i ++;
  h = (u32 )((unsigned long )tmp % ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )));
  if (! p->u.aHash[h]) {
    if ((unsigned long )p->nSet < (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 ) - 1UL) {
      goto bitvec_set_end;
    } else {
      goto bitvec_set_rehash;
    }
  }
  while (1) {
    if (p->u.aHash[h] == i) {
      return (0);
    }
    h ++;
    if ((unsigned long )h >= (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) {
      h = (u32 )0;
    }
    if (! p->u.aHash[h]) {
      break;
    }
  }
  bitvec_set_rehash: 
  if ((unsigned long )p->nSet >= ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) / 2UL) {
    tmp___0 = sqlite3DbMallocRaw((sqlite3 *)0, (u64 )sizeof(p->u.aHash));
    aiValues = (u32 *)tmp___0;
    if ((unsigned long )aiValues == (unsigned long )((u32 *)0)) {
      return (7);
    } else {
      memcpy((void * __restrict  )aiValues, (void const   * __restrict  )(p->u.aHash),
             sizeof(p->u.aHash));
      memset((void *)(p->u.apSub), 0, sizeof(p->u.apSub));
      p->iDivisor = (u32 )((((unsigned long )p->iSize + (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)) - 1UL) / ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)));
      rc = sqlite3BitvecSet(p, i);
      j = 0U;
      while ((unsigned long )j < (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) {
        if (*(aiValues + j)) {
          tmp___1 = sqlite3BitvecSet(p, *(aiValues + j));
          rc |= tmp___1;
        }
        j ++;
      }
      sqlite3DbFree((sqlite3 *)0, (void *)aiValues);
      return (rc);
    }
  }
  bitvec_set_end: 
  (p->nSet) ++;
  p->u.aHash[h] = i;
  return (0);
}
}
static void sqlite3BitvecClear(Bitvec *p , u32 i , void *pBuf ) 
{ 
  u32 bin ;
  unsigned int j ;
  u32 *aiValues ;
  u32 h ;

  {
  if ((unsigned long )p == (unsigned long )((Bitvec *)0)) {
    return;
  }
  i --;
  while (p->iDivisor) {
    bin = i / p->iDivisor;
    i %= p->iDivisor;
    p = p->u.apSub[bin];
    if (! p) {
      return;
    }
  }
  if ((unsigned long )p->iSize <= ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8 )) * 8UL) {
    p->u.aBitmap[i / 8U] = (u8 )((int )p->u.aBitmap[i / 8U] & ~ (1 << (i & 7U)));
  } else {
    aiValues = (u32 *)pBuf;
    memcpy((void * __restrict  )aiValues, (void const   * __restrict  )(p->u.aHash),
           sizeof(p->u.aHash));
    memset((void *)(p->u.aHash), 0, sizeof(p->u.aHash));
    p->nSet = (u32 )0;
    j = 0U;
    while ((unsigned long )j < (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) {
      if (*(aiValues + j)) {
        if (*(aiValues + j) != i + 1U) {
          h = (u32 )((unsigned long )(*(aiValues + j) - 1U) % ((((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )));
          (p->nSet) ++;
          while (p->u.aHash[h]) {
            h ++;
            if ((unsigned long )h >= (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32 )) {
              h = (u32 )0;
            }
          }
          p->u.aHash[h] = *(aiValues + j);
        }
      }
      j ++;
    }
  }
  return;
}
}
static void sqlite3BitvecDestroy(Bitvec *p ) 
{ 
  unsigned int i ;

  {
  if ((unsigned long )p == (unsigned long )((Bitvec *)0)) {
    return;
  }
  if (p->iDivisor) {
    i = 0U;
    while ((unsigned long )i < (((512UL - 3UL * sizeof(u32 )) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)) {
      sqlite3BitvecDestroy(p->u.apSub[i]);
      i ++;
    }
  }
  sqlite3_free((void *)p);
  return;
}
}
static u32 sqlite3BitvecSize(Bitvec *p ) 
{ 


  {
  return (p->iSize);
}
}
static int sqlite3BitvecBuiltinTest(int sz , int *aOp___1 ) 
{ 
  Bitvec *pBitvec ;
  unsigned char *pV ;
  int rc ;
  int i ;
  int nx ;
  int pc ;
  int op ;
  void *pTmpSpace ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;

  {
  pBitvec = (Bitvec *)0;
  pV = (unsigned char *)0;
  rc = -1;
  pBitvec = sqlite3BitvecCreate((u32 )sz);
  tmp = sqlite3MallocZero((u64 )((sz + 7) / 8 + 1));
  pV = (unsigned char *)tmp;
  pTmpSpace = sqlite3_malloc64((sqlite_uint64 )512);
  if ((unsigned long )pBitvec == (unsigned long )((Bitvec *)0)) {
    goto bitvec_end;
  } else
  if ((unsigned long )pV == (unsigned long )((unsigned char *)0)) {
    goto bitvec_end;
  } else
  if ((unsigned long )pTmpSpace == (unsigned long )((void *)0)) {
    goto bitvec_end;
  }
  sqlite3BitvecSet((Bitvec *)0, (u32 )1);
  sqlite3BitvecClear((Bitvec *)0, (u32 )1, pTmpSpace);
  pc = 0;
  while (1) {
    op = *(aOp___1 + pc);
    if (! (op != 0)) {
      break;
    }
    switch (op) {
    case 5: 
    case 2: 
    case 1: 
    nx = 4;
    i = *(aOp___1 + (pc + 2)) - 1;
    *(aOp___1 + (pc + 2)) += *(aOp___1 + (pc + 3));
    break;
    default: 
    nx = 2;
    sqlite3_randomness((int )sizeof(i), (void *)(& i));
    break;
    }
    (*(aOp___1 + (pc + 1))) --;
    if (*(aOp___1 + (pc + 1)) > 0) {
      nx = 0;
    }
    pc += nx;
    i = (i & 2147483647) % sz;
    if ((op & 1) != 0) {
      *(pV + ((i + 1) >> 3)) = (unsigned char )((int )*(pV + ((i + 1) >> 3)) | (1 << ((i + 1) & 7)));
      if (op != 5) {
        tmp___0 = sqlite3BitvecSet(pBitvec, (u32 )(i + 1));
        if (tmp___0) {
          goto bitvec_end;
        }
      }
    } else {
      *(pV + ((i + 1) >> 3)) = (unsigned char )((int )*(pV + ((i + 1) >> 3)) & ~ (1 << ((i + 1) & 7)));
      sqlite3BitvecClear(pBitvec, (u32 )(i + 1), pTmpSpace);
    }
  }
  tmp___1 = sqlite3BitvecTest((Bitvec *)0, (u32 )0);
  tmp___2 = sqlite3BitvecTest(pBitvec, (u32 )(sz + 1));
  tmp___3 = sqlite3BitvecTest(pBitvec, (u32 )0);
  tmp___4 = sqlite3BitvecSize(pBitvec);
  rc = (int )((u32 )((tmp___1 + tmp___2) + tmp___3) + (tmp___4 - (u32 )sz));
  i = 1;
  while (i <= sz) {
    tmp___5 = sqlite3BitvecTest(pBitvec, (u32 )i);
    if ((((int )*(pV + (i >> 3)) & (1 << (i & 7))) != 0) != tmp___5) {
      rc = i;
      break;
    }
    i ++;
  }
  bitvec_end: 
  sqlite3_free(pTmpSpace);
  sqlite3_free((void *)pV);
  sqlite3BitvecDestroy(pBitvec);
  return (rc);
}
}
static void pcacheManageDirtyList(PgHdr *pPage , u8 addRemove ) 
{ 
  PCache *p ;

  {
  p = pPage->pCache;
  if ((int )addRemove & 1) {
    if ((unsigned long )p->pSynced == (unsigned long )pPage) {
      p->pSynced = pPage->pDirtyPrev;
    }
    if (pPage->pDirtyNext) {
      (pPage->pDirtyNext)->pDirtyPrev = pPage->pDirtyPrev;
    } else {
      p->pDirtyTail = pPage->pDirtyPrev;
    }
    if (pPage->pDirtyPrev) {
      (pPage->pDirtyPrev)->pDirtyNext = pPage->pDirtyNext;
    } else {
      p->pDirty = pPage->pDirtyNext;
      if ((unsigned long )p->pDirty == (unsigned long )((PgHdr *)0)) {
        p->eCreate = (u8 )2;
      }
    }
  }
  if ((int )addRemove & 2) {
    pPage->pDirtyPrev = (PgHdr *)0;
    pPage->pDirtyNext = p->pDirty;
    if (pPage->pDirtyNext) {
      (pPage->pDirtyNext)->pDirtyPrev = pPage;
    } else {
      p->pDirtyTail = pPage;
      if (p->bPurgeable) {
        p->eCreate = (u8 )1;
      }
    }
    p->pDirty = pPage;
    if (! p->pSynced) {
      if (0 == ((int )pPage->flags & 8)) {
        p->pSynced = pPage;
      }
    }
  }
  return;
}
}
static void pcacheUnpin(PgHdr *p ) 
{ 


  {
  if ((p->pCache)->bPurgeable) {
    (*(sqlite3Config.pcache2.xUnpin))((p->pCache)->pCache, p->pPage, 0);
  }
  return;
}
}
static int numberOfCachePages(PCache *p ) 
{ 


  {
  if (p->szCache >= 0) {
    return (p->szCache);
  } else {
    return ((int )((-1024LL * (i64 )p->szCache) / (i64 )(p->szPage + p->szExtra)));
  }
}
}
static int sqlite3PcacheInitialize(void) 
{ 
  int tmp ;

  {
  if ((unsigned long )sqlite3Config.pcache2.xInit == (unsigned long )((int (*)(void * ))0)) {
    sqlite3PCacheSetDefault();
  }
  tmp = (*(sqlite3Config.pcache2.xInit))(sqlite3Config.pcache2.pArg);
  return (tmp);
}
}
static void sqlite3PcacheShutdown(void) 
{ 


  {
  if (sqlite3Config.pcache2.xShutdown) {
    (*(sqlite3Config.pcache2.xShutdown))(sqlite3Config.pcache2.pArg);
  }
  return;
}
}
static int sqlite3PcacheSize(void) 
{ 


  {
  return ((int )sizeof(PCache ));
}
}
static int sqlite3PcacheOpen(int szPage , int szExtra , int bPurgeable , int (*xStress)(void * ,
                                                                                        PgHdr * ) ,
                             void *pStress , PCache *p ) 
{ 
  int tmp ;

  {
  memset((void *)p, 0, sizeof(PCache ));
  p->szPage = 1;
  p->szExtra = szExtra;
  p->bPurgeable = (u8 )bPurgeable;
  p->eCreate = (u8 )2;
  p->xStress = xStress;
  p->pStress = pStress;
  p->szCache = 100;
  p->szSpill = 1;
  tmp = sqlite3PcacheSetPageSize(p, szPage);
  return (tmp);
}
}
static int sqlite3PcacheSetPageSize(PCache *pCache , int szPage ) 
{ 
  sqlite3_pcache *pNew ;
  int tmp ;

  {
  if (pCache->szPage) {
    pNew = (*(sqlite3Config.pcache2.xCreate))(szPage, (int )((unsigned long )pCache->szExtra + ((sizeof(PgHdr ) + 7UL) & 0xfffffffffffffff8UL)),
                                              (int )pCache->bPurgeable);
    if ((unsigned long )pNew == (unsigned long )((sqlite3_pcache *)0)) {
      return (7);
    }
    tmp = numberOfCachePages(pCache);
    (*(sqlite3Config.pcache2.xCachesize))(pNew, tmp);
    if (pCache->pCache) {
      (*(sqlite3Config.pcache2.xDestroy))(pCache->pCache);
    }
    pCache->pCache = pNew;
    pCache->szPage = szPage;
  }
  return (0);
}
}
static sqlite3_pcache_page *sqlite3PcacheFetch(PCache *pCache , Pgno pgno , int createFlag ) 
{ 
  int eCreate ;
  sqlite3_pcache_page *pRes ;

  {
  eCreate = createFlag & (int )pCache->eCreate;
  pRes = (*(sqlite3Config.pcache2.xFetch))(pCache->pCache, pgno, eCreate);
  return (pRes);
}
}
static int sqlite3PcacheFetchStress(PCache *pCache , Pgno pgno , sqlite3_pcache_page **ppPage ) 
{ 
  PgHdr *pPg ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )pCache->eCreate == 2) {
    return (0);
  }
  tmp = sqlite3PcachePagecount(pCache);
  if (tmp > pCache->szSpill) {
    pPg = pCache->pSynced;
    while (1) {
      if (pPg) {
        if (! pPg->nRef) {
          if (! ((int )pPg->flags & 8)) {
            break;
          }
        }
      } else {
        break;
      }
      pPg = pPg->pDirtyPrev;
    }
    pCache->pSynced = pPg;
    if (! pPg) {
      pPg = pCache->pDirtyTail;
      while (1) {
        if (pPg) {
          if (! pPg->nRef) {
            break;
          }
        } else {
          break;
        }
        pPg = pPg->pDirtyPrev;
      }
    }
    if (pPg) {
      rc = (*(pCache->xStress))(pCache->pStress, pPg);
      if (rc != 0) {
        if (rc != 5) {
          return (rc);
        }
      }
    }
  }
  *ppPage = (*(sqlite3Config.pcache2.xFetch))(pCache->pCache, pgno, 2);
  if ((unsigned long )*ppPage == (unsigned long )((sqlite3_pcache_page *)0)) {
    tmp___0 = 7;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static PgHdr *( __attribute__((__noinline__)) pcacheFetchFinishWithInit)(PCache *pCache ,
                                                                         Pgno pgno ,
                                                                         sqlite3_pcache_page *pPage ) 
{ 
  PgHdr *pPgHdr ;
  PgHdr *tmp ;

  {
  pPgHdr = (PgHdr *)pPage->pExtra;
  memset((void *)(& pPgHdr->pDirty), 0, sizeof(PgHdr ) - (unsigned long )(& ((PgHdr *)0)->pDirty));
  pPgHdr->pPage = pPage;
  pPgHdr->pData = pPage->pBuf;
  pPgHdr->pExtra = (void *)(pPgHdr + 1);
  memset(pPgHdr->pExtra, 0, (size_t )8);
  pPgHdr->pCache = pCache;
  pPgHdr->pgno = pgno;
  pPgHdr->flags = (u16 )1;
  tmp = sqlite3PcacheFetchFinish(pCache, pgno, pPage);
  return (tmp);
}
}
static PgHdr *sqlite3PcacheFetchFinish(PCache *pCache , Pgno pgno , sqlite3_pcache_page *pPage ) 
{ 
  PgHdr *pPgHdr ;
  PgHdr *tmp ;

  {
  pPgHdr = (PgHdr *)pPage->pExtra;
  if (! pPgHdr->pPage) {
    tmp = pcacheFetchFinishWithInit(pCache, pgno, pPage);
    return (tmp);
  }
  (pCache->nRefSum) ++;
  pPgHdr->nRef = (i16 )((int )pPgHdr->nRef + 1);
  return (pPgHdr);
}
}
static void ( __attribute__((__noinline__)) sqlite3PcacheRelease)(PgHdr *p ) 
{ 


  {
  ((p->pCache)->nRefSum) --;
  p->nRef = (i16 )((int )p->nRef - 1);
  if ((int )p->nRef == 0) {
    if ((int )p->flags & 1) {
      pcacheUnpin(p);
    } else {
      pcacheManageDirtyList(p, (u8 )3);
    }
  }
  return;
}
}
static void sqlite3PcacheRef(PgHdr *p ) 
{ 


  {
  p->nRef = (i16 )((int )p->nRef + 1);
  ((p->pCache)->nRefSum) ++;
  return;
}
}
static void sqlite3PcacheDrop(PgHdr *p ) 
{ 


  {
  if ((int )p->flags & 2) {
    pcacheManageDirtyList(p, (u8 )1);
  }
  ((p->pCache)->nRefSum) --;
  (*(sqlite3Config.pcache2.xUnpin))((p->pCache)->pCache, p->pPage, 1);
  return;
}
}
static void sqlite3PcacheMakeDirty(PgHdr *p ) 
{ 


  {
  if ((int )p->flags & 17) {
    p->flags = (u16 )((int )p->flags & -17);
    if ((int )p->flags & 1) {
      p->flags = (u16 )((int )p->flags ^ 3);
      pcacheManageDirtyList(p, (u8 )2);
    }
  }
  return;
}
}
static void sqlite3PcacheMakeClean(PgHdr *p ) 
{ 


  {
  pcacheManageDirtyList(p, (u8 )1);
  p->flags = (u16 )((int )p->flags & -15);
  p->flags = (u16 )((int )p->flags | 1);
  if ((int )p->nRef == 0) {
    pcacheUnpin(p);
  }
  return;
}
}
static void sqlite3PcacheCleanAll(PCache *pCache ) 
{ 
  PgHdr *p ;

  {
  while (1) {
    p = pCache->pDirty;
    if (! ((unsigned long )p != (unsigned long )((PgHdr *)0))) {
      break;
    }
    sqlite3PcacheMakeClean(p);
  }
  return;
}
}
static void sqlite3PcacheClearWritable(PCache *pCache ) 
{ 
  PgHdr *p ;

  {
  p = pCache->pDirty;
  while (p) {
    p->flags = (u16 )((int )p->flags & -13);
    p = p->pDirtyNext;
  }
  pCache->pSynced = pCache->pDirtyTail;
  return;
}
}
static void sqlite3PcacheClearSyncFlags(PCache *pCache ) 
{ 
  PgHdr *p ;

  {
  p = pCache->pDirty;
  while (p) {
    p->flags = (u16 )((int )p->flags & -9);
    p = p->pDirtyNext;
  }
  pCache->pSynced = pCache->pDirtyTail;
  return;
}
}
static void sqlite3PcacheMove(PgHdr *p , Pgno newPgno ) 
{ 
  PCache *pCache ;

  {
  pCache = p->pCache;
  (*(sqlite3Config.pcache2.xRekey))(pCache->pCache, p->pPage, p->pgno, newPgno);
  p->pgno = newPgno;
  if ((int )p->flags & 2) {
    if ((int )p->flags & 8) {
      pcacheManageDirtyList(p, (u8 )3);
    }
  }
  return;
}
}
static void sqlite3PcacheTruncate(PCache *pCache , Pgno pgno ) 
{ 
  PgHdr *p ;
  PgHdr *pNext ;
  sqlite3_pcache_page *pPage1 ;

  {
  if (pCache->pCache) {
    p = pCache->pDirty;
    while (p) {
      pNext = p->pDirtyNext;
      if (p->pgno > pgno) {
        sqlite3PcacheMakeClean(p);
      }
      p = pNext;
    }
    if (pgno == 0U) {
      if (pCache->nRefSum) {
        pPage1 = (*(sqlite3Config.pcache2.xFetch))(pCache->pCache, 1U, 0);
        if (pPage1) {
          memset(pPage1->pBuf, 0, (size_t )pCache->szPage);
          pgno = (Pgno )1;
        }
      }
    }
    (*(sqlite3Config.pcache2.xTruncate))(pCache->pCache, pgno + 1U);
  }
  return;
}
}
static void sqlite3PcacheClose(PCache *pCache ) 
{ 


  {
  (*(sqlite3Config.pcache2.xDestroy))(pCache->pCache);
  return;
}
}
static void sqlite3PcacheClear(PCache *pCache ) 
{ 


  {
  sqlite3PcacheTruncate(pCache, (Pgno )0);
  return;
}
}
static PgHdr *pcacheMergeDirtyList(PgHdr *pA , PgHdr *pB ) 
{ 
  PgHdr result ;
  PgHdr *pTail ;

  {
  pTail = & result;
  while (1) {
    if (pA->pgno < pB->pgno) {
      pTail->pDirty = pA;
      pTail = pA;
      pA = pA->pDirty;
      if ((unsigned long )pA == (unsigned long )((PgHdr *)0)) {
        pTail->pDirty = pB;
        break;
      }
    } else {
      pTail->pDirty = pB;
      pTail = pB;
      pB = pB->pDirty;
      if ((unsigned long )pB == (unsigned long )((PgHdr *)0)) {
        pTail->pDirty = pA;
        break;
      }
    }
  }
  return (result.pDirty);
}
}
static PgHdr *pcacheSortDirtyList(PgHdr *pIn ) 
{ 
  PgHdr *a___0[32] ;
  PgHdr *p ;
  int i ;
  PgHdr *tmp ;

  {
  memset((void *)(a___0), 0, sizeof(a___0));
  while (pIn) {
    p = pIn;
    pIn = p->pDirty;
    p->pDirty = (PgHdr *)0;
    i = 0;
    while (i < 31) {
      if ((unsigned long )a___0[i] == (unsigned long )((PgHdr *)0)) {
        a___0[i] = p;
        break;
      } else {
        p = pcacheMergeDirtyList(a___0[i], p);
        a___0[i] = (PgHdr *)0;
      }
      i ++;
    }
    if (i == 31) {
      a___0[i] = pcacheMergeDirtyList(a___0[i], p);
    }
  }
  p = a___0[0];
  i = 1;
  while (i < 32) {
    if ((unsigned long )a___0[i] == (unsigned long )((PgHdr *)0)) {
      goto __Cont;
    }
    if (p) {
      tmp = pcacheMergeDirtyList(p, a___0[i]);
      p = tmp;
    } else {
      p = a___0[i];
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (p);
}
}
static PgHdr *sqlite3PcacheDirtyList(PCache *pCache ) 
{ 
  PgHdr *p ;
  PgHdr *tmp ;

  {
  p = pCache->pDirty;
  while (p) {
    p->pDirty = p->pDirtyNext;
    p = p->pDirtyNext;
  }
  tmp = pcacheSortDirtyList(pCache->pDirty);
  return (tmp);
}
}
static int sqlite3PcacheRefCount(PCache *pCache ) 
{ 


  {
  return (pCache->nRefSum);
}
}
static int sqlite3PcachePageRefcount(PgHdr *p ) 
{ 


  {
  return ((int )p->nRef);
}
}
static int sqlite3PcachePagecount(PCache *pCache ) 
{ 
  int tmp ;

  {
  tmp = (*(sqlite3Config.pcache2.xPagecount))(pCache->pCache);
  return (tmp);
}
}
static void sqlite3PcacheSetCachesize(PCache *pCache , int mxPage ) 
{ 
  int tmp ;

  {
  pCache->szCache = mxPage;
  tmp = numberOfCachePages(pCache);
  (*(sqlite3Config.pcache2.xCachesize))(pCache->pCache, tmp);
  return;
}
}
static int sqlite3PcacheSetSpillsize(PCache *p , int mxPage ) 
{ 
  int res ;

  {
  if (mxPage) {
    if (mxPage < 0) {
      mxPage = (int )((-1024LL * (i64 )mxPage) / (i64 )(p->szPage + p->szExtra));
    }
    p->szSpill = mxPage;
  }
  res = numberOfCachePages(p);
  if (res < p->szSpill) {
    res = p->szSpill;
  }
  return (res);
}
}
static void sqlite3PcacheShrink(PCache *pCache ) 
{ 


  {
  (*(sqlite3Config.pcache2.xShrink))(pCache->pCache);
  return;
}
}
static int sqlite3HeaderSizePcache(void) 
{ 


  {
  return ((int )((sizeof(PgHdr ) + 7UL) & 0xfffffffffffffff8UL));
}
}
static int sqlite3PCachePercentDirty(PCache *pCache ) 
{ 
  PgHdr *pDirty ;
  int nDirty ;
  int nCache ;
  int tmp ;
  int tmp___0 ;

  {
  nDirty = 0;
  tmp = numberOfCachePages(pCache);
  nCache = tmp;
  pDirty = pCache->pDirty;
  while (pDirty) {
    nDirty ++;
    pDirty = pDirty->pDirtyNext;
  }
  if (nCache) {
    tmp___0 = (int )(((i64 )nDirty * 100LL) / (i64 )nCache);
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static struct PCacheGlobal pcache1_g  ;
static void sqlite3PCacheBufferSetup(void *pBuf , int sz , int n ) 
{ 
  PgFreeslot *p ;
  int tmp ;

  {
  if (pcache1_g.isInit) {
    if ((unsigned long )pBuf == (unsigned long )((void *)0)) {
      n = 0;
      sz = n;
    }
    if (n == 0) {
      sz = 0;
    }
    sz &= -8;
    pcache1_g.szSlot = sz;
    pcache1_g.nFreeSlot = n;
    pcache1_g.nSlot = pcache1_g.nFreeSlot;
    if (n > 90) {
      pcache1_g.nReserve = 10;
    } else {
      pcache1_g.nReserve = n / 10 + 1;
    }
    pcache1_g.pStart = pBuf;
    pcache1_g.pFree = (PgFreeslot *)0;
    pcache1_g.bUnderPressure = 0;
    while (1) {
      tmp = n;
      n --;
      if (! tmp) {
        break;
      }
      p = (PgFreeslot *)pBuf;
      p->pNext = pcache1_g.pFree;
      pcache1_g.pFree = p;
      pBuf = (void *)((char *)pBuf + sz);
    }
    pcache1_g.pEnd = pBuf;
  }
  return;
}
}
static int pcache1InitBulk(PCache1 *pCache ) 
{ 
  i64 szBulk ;
  char *zBulk ;
  void *tmp ;
  int nBulk ;
  int tmp___0 ;
  PgHdr1 *pX ;

  {
  if (pcache1_g.nInitPage == 0) {
    return (0);
  }
  if (pCache->nMax < 3U) {
    return (0);
  }
  sqlite3BeginBenignMalloc();
  if (pcache1_g.nInitPage > 0) {
    szBulk = (i64 )pCache->szAlloc * (i64 )pcache1_g.nInitPage;
  } else {
    szBulk = -1024LL * (i64 )pcache1_g.nInitPage;
  }
  if (szBulk > (i64 )pCache->szAlloc * (i64 )pCache->nMax) {
    szBulk = (i64 )pCache->szAlloc * (i64 )pCache->nMax;
  }
  tmp = sqlite3Malloc((u64 )szBulk);
  pCache->pBulk = tmp;
  zBulk = (char *)tmp;
  sqlite3EndBenignMalloc();
  if (zBulk) {
    tmp___0 = sqlite3MallocSize((void *)zBulk);
    nBulk = tmp___0 / pCache->szAlloc;
    while (1) {
      pX = (PgHdr1 *)(zBulk + pCache->szPage);
      pX->page.pBuf = (void *)zBulk;
      pX->page.pExtra = (void *)(pX + 1);
      pX->isBulkLocal = (u16 )1;
      pX->isAnchor = (u16 )0;
      pX->pNext = pCache->pFree;
      pX->pLruPrev = (PgHdr1 *)0;
      pCache->pFree = pX;
      zBulk += pCache->szAlloc;
      nBulk --;
      if (! nBulk) {
        break;
      }
    }
  }
  return ((unsigned long )pCache->pFree != (unsigned long )((PgHdr1 *)0));
}
}
static void *pcache1Alloc(int nByte ) 
{ 
  void *p ;
  int sz ;
  int tmp ;

  {
  p = (void *)0;
  if (nByte <= pcache1_g.szSlot) {
    p = (void *)((PgHdr1 *)pcache1_g.pFree);
    if (p) {
      pcache1_g.pFree = (pcache1_g.pFree)->pNext;
      (pcache1_g.nFreeSlot) --;
      pcache1_g.bUnderPressure = pcache1_g.nFreeSlot < pcache1_g.nReserve;
      sqlite3StatusHighwater(7, nByte);
      sqlite3StatusUp(1, 1);
    }
  }
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    p = sqlite3Malloc((u64 )nByte);
    if (p) {
      tmp = sqlite3MallocSize(p);
      sz = tmp;
      sqlite3StatusHighwater(7, nByte);
      sqlite3StatusUp(2, sz);
    }
  }
  return (p);
}
}
static void pcache1Free(void *p ) 
{ 
  PgFreeslot *pSlot ;
  int nFreed ;

  {
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return;
  }
  if ((uptr )p >= (uptr )pcache1_g.pStart) {
    if ((uptr )p < (uptr )pcache1_g.pEnd) {
      sqlite3StatusDown(1, 1);
      pSlot = (PgFreeslot *)p;
      pSlot->pNext = pcache1_g.pFree;
      pcache1_g.pFree = pSlot;
      (pcache1_g.nFreeSlot) ++;
      pcache1_g.bUnderPressure = pcache1_g.nFreeSlot < pcache1_g.nReserve;
    } else {
      nFreed = 0;
      nFreed = sqlite3MallocSize(p);
      sqlite3StatusDown(2, nFreed);
      sqlite3_free(p);
    }
  } else {
    nFreed = 0;
    nFreed = sqlite3MallocSize(p);
    sqlite3StatusDown(2, nFreed);
    sqlite3_free(p);
  }
  return;
}
}
static PgHdr1 *pcache1AllocPage(PCache1 *pCache , int benignMalloc ) 
{ 
  PgHdr1 *p ;
  void *pPg ;
  int tmp ;

  {
  p = (PgHdr1 *)0;
  if (pCache->pFree) {
    p = pCache->pFree;
    pCache->pFree = p->pNext;
    p->pNext = (PgHdr1 *)0;
  } else
  if (pCache->nPage == 0U) {
    tmp = pcache1InitBulk(pCache);
    if (tmp) {
      p = pCache->pFree;
      pCache->pFree = p->pNext;
      p->pNext = (PgHdr1 *)0;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (benignMalloc) {
      sqlite3BeginBenignMalloc();
    }
    pPg = pcache1Alloc(pCache->szAlloc);
    p = (PgHdr1 *)((u8 *)pPg + pCache->szPage);
    if (benignMalloc) {
      sqlite3EndBenignMalloc();
    }
    if ((unsigned long )pPg == (unsigned long )((void *)0)) {
      return ((PgHdr1 *)0);
    }
    p->page.pBuf = pPg;
    p->page.pExtra = (void *)(p + 1);
    p->isBulkLocal = (u16 )0;
    p->isAnchor = (u16 )0;
  }
  (*(pCache->pnPurgeable)) ++;
  return (p);
}
}
static void pcache1FreePage(PgHdr1 *p ) 
{ 
  PCache1 *pCache ;

  {
  pCache = p->pCache;
  if (p->isBulkLocal) {
    p->pNext = pCache->pFree;
    pCache->pFree = p;
  } else {
    pcache1Free(p->page.pBuf);
  }
  (*(pCache->pnPurgeable)) --;
  return;
}
}
static void *sqlite3PageMalloc(int sz ) 
{ 
  void *tmp ;

  {
  tmp = pcache1Alloc(sz);
  return (tmp);
}
}
static void sqlite3PageFree(void *p ) 
{ 


  {
  pcache1Free(p);
  return;
}
}
static int pcache1UnderMemoryPressure(PCache1 *pCache ) 
{ 
  int tmp ;

  {
  if (pcache1_g.nSlot) {
    if (pCache->szPage + pCache->szExtra <= pcache1_g.szSlot) {
      return (pcache1_g.bUnderPressure);
    } else {
      tmp = sqlite3HeapNearlyFull();
      return (tmp);
    }
  } else {
    tmp = sqlite3HeapNearlyFull();
    return (tmp);
  }
}
}
static void pcache1ResizeHash(PCache1 *p ) 
{ 
  PgHdr1 **apNew ;
  unsigned int nNew ;
  unsigned int i ;
  void *tmp ;
  PgHdr1 *pPage ;
  PgHdr1 *pNext ;
  unsigned int h ;

  {
  nNew = p->nHash * 2U;
  if (nNew < 256U) {
    nNew = 256U;
  }
  if (p->nHash) {
    sqlite3BeginBenignMalloc();
  }
  tmp = sqlite3MallocZero((u64 )(sizeof(PgHdr1 *) * (unsigned long )nNew));
  apNew = (PgHdr1 **)tmp;
  if (p->nHash) {
    sqlite3EndBenignMalloc();
  }
  if (apNew) {
    i = 0U;
    while (i < p->nHash) {
      pNext = *(p->apHash + i);
      while (1) {
        pPage = pNext;
        if (! ((unsigned long )pPage != (unsigned long )((PgHdr1 *)0))) {
          break;
        }
        h = pPage->iKey % nNew;
        pNext = pPage->pNext;
        pPage->pNext = *(apNew + h);
        *(apNew + h) = pPage;
      }
      i ++;
    }
    sqlite3_free((void *)p->apHash);
    p->apHash = apNew;
    p->nHash = nNew;
  }
  return;
}
}
static PgHdr1 *pcache1PinPage(PgHdr1 *pPage ) 
{ 


  {
  (pPage->pLruPrev)->pLruNext = pPage->pLruNext;
  (pPage->pLruNext)->pLruPrev = pPage->pLruPrev;
  pPage->pLruNext = (PgHdr1 *)0;
  ((pPage->pCache)->nRecyclable) --;
  return (pPage);
}
}
static void pcache1RemoveFromHash(PgHdr1 *pPage , int freeFlag ) 
{ 
  unsigned int h ;
  PCache1 *pCache ;
  PgHdr1 **pp ;

  {
  pCache = pPage->pCache;
  h = pPage->iKey % pCache->nHash;
  pp = pCache->apHash + h;
  while ((unsigned long )*pp != (unsigned long )pPage) {
    pp = & (*pp)->pNext;
  }
  *pp = (*pp)->pNext;
  (pCache->nPage) --;
  if (freeFlag) {
    pcache1FreePage(pPage);
  }
  return;
}
}
static void pcache1EnforceMaxPage(PCache1 *pCache ) 
{ 
  PGroup *pGroup ;
  PgHdr1 *p ;
  PgHdr1 *tmp ;

  {
  pGroup = pCache->pGroup;
  while (1) {
    if (pGroup->nPurgeable > pGroup->nMaxPage) {
      p = pGroup->lru.pLruPrev;
      if (! ((int )p->isAnchor == 0)) {
        break;
      }
    } else {
      break;
    }
    pcache1PinPage(p);
    pcache1RemoveFromHash(p, 1);
  }
  if (pCache->nPage == 0U) {
    if (pCache->pBulk) {
      sqlite3_free(pCache->pBulk);
      tmp = (PgHdr1 *)0;
      pCache->pFree = tmp;
      pCache->pBulk = (void *)tmp;
    }
  }
  return;
}
}
static void pcache1TruncateUnsafe(PCache1 *pCache , unsigned int iLimit ) 
{ 
  unsigned int h ;
  unsigned int iStop ;
  PgHdr1 **pp ;
  PgHdr1 *pPage ;

  {
  if (pCache->iMaxKey - iLimit < pCache->nHash) {
    h = iLimit % pCache->nHash;
    iStop = pCache->iMaxKey % pCache->nHash;
  } else {
    h = pCache->nHash / 2U;
    iStop = h - 1U;
  }
  while (1) {
    pp = pCache->apHash + h;
    while (1) {
      pPage = *pp;
      if (! ((unsigned long )pPage != (unsigned long )((PgHdr1 *)0))) {
        break;
      }
      if (pPage->iKey >= iLimit) {
        (pCache->nPage) --;
        *pp = pPage->pNext;
        if ((unsigned long )pPage->pLruNext != (unsigned long )((PgHdr1 *)0)) {
          pcache1PinPage(pPage);
        }
        pcache1FreePage(pPage);
      } else {
        pp = & pPage->pNext;
      }
    }
    if (h == iStop) {
      break;
    }
    h = (h + 1U) % pCache->nHash;
  }
  return;
}
}
static int pcache1Init(void *NotUsed ) 
{ 


  {
  memset((void *)(& pcache1_g), 0, sizeof(pcache1_g));
  pcache1_g.separateCache = (unsigned long )sqlite3Config.pPage == (unsigned long )((void *)0);
  if (pcache1_g.separateCache) {
    if (sqlite3Config.nPage != 0) {
      if ((unsigned long )sqlite3Config.pPage == (unsigned long )((void *)0)) {
        pcache1_g.nInitPage = sqlite3Config.nPage;
      } else {
        pcache1_g.nInitPage = 0;
      }
    } else {
      pcache1_g.nInitPage = 0;
    }
  } else {
    pcache1_g.nInitPage = 0;
  }
  pcache1_g.grp.mxPinned = 10U;
  pcache1_g.isInit = 1;
  return (0);
}
}
static void pcache1Shutdown(void *NotUsed ) 
{ 


  {
  memset((void *)(& pcache1_g), 0, sizeof(pcache1_g));
  return;
}
}
static void pcache1Destroy(sqlite3_pcache *p ) ;
static sqlite3_pcache *pcache1Create(int szPage , int szExtra , int bPurgeable ) 
{ 
  PCache1 *pCache ;
  PGroup *pGroup ;
  int sz ;
  void *tmp ;
  PgHdr1 *tmp___0 ;

  {
  sz = (int )(sizeof(PCache1 ) + sizeof(PGroup ) * (unsigned long )pcache1_g.separateCache);
  tmp = sqlite3MallocZero((u64 )sz);
  pCache = (PCache1 *)tmp;
  if (pCache) {
    if (pcache1_g.separateCache) {
      pGroup = (PGroup *)(pCache + 1);
      pGroup->mxPinned = 10U;
    } else {
      pGroup = & pcache1_g.grp;
    }
    if ((int )pGroup->lru.isAnchor == 0) {
      pGroup->lru.isAnchor = (u16 )1;
      tmp___0 = & pGroup->lru;
      pGroup->lru.pLruNext = tmp___0;
      pGroup->lru.pLruPrev = tmp___0;
    }
    pCache->pGroup = pGroup;
    pCache->szPage = szPage;
    pCache->szExtra = szExtra;
    pCache->szAlloc = (int )((unsigned long )(szPage + szExtra) + ((sizeof(PgHdr1 ) + 7UL) & 0xfffffffffffffff8UL));
    if (bPurgeable) {
      pCache->bPurgeable = 1;
    } else {
      pCache->bPurgeable = 0;
    }
    pcache1ResizeHash(pCache);
    if (bPurgeable) {
      pCache->nMin = 10U;
      pGroup->nMinPage += pCache->nMin;
      pGroup->mxPinned = (pGroup->nMaxPage + 10U) - pGroup->nMinPage;
      pCache->pnPurgeable = & pGroup->nPurgeable;
    } else {
      pCache->pnPurgeable = & pCache->nPurgeableDummy;
    }
    if (pCache->nHash == 0U) {
      pcache1Destroy((sqlite3_pcache *)pCache);
      pCache = (PCache1 *)0;
    }
  }
  return ((sqlite3_pcache *)pCache);
}
}
static void pcache1Cachesize(sqlite3_pcache *p , int nMax ) 
{ 
  PCache1 *pCache ;
  PGroup *pGroup ;

  {
  pCache = (PCache1 *)p;
  if (pCache->bPurgeable) {
    pGroup = pCache->pGroup;
    pGroup->nMaxPage += (unsigned int )nMax - pCache->nMax;
    pGroup->mxPinned = (pGroup->nMaxPage + 10U) - pGroup->nMinPage;
    pCache->nMax = (unsigned int )nMax;
    pCache->n90pct = (pCache->nMax * 9U) / 10U;
    pcache1EnforceMaxPage(pCache);
  }
  return;
}
}
static void pcache1Shrink(sqlite3_pcache *p ) 
{ 
  PCache1 *pCache ;
  PGroup *pGroup ;
  int savedMaxPage ;

  {
  pCache = (PCache1 *)p;
  if (pCache->bPurgeable) {
    pGroup = pCache->pGroup;
    savedMaxPage = (int )pGroup->nMaxPage;
    pGroup->nMaxPage = 0U;
    pcache1EnforceMaxPage(pCache);
    pGroup->nMaxPage = (unsigned int )savedMaxPage;
  }
  return;
}
}
static int pcache1Pagecount(sqlite3_pcache *p ) 
{ 
  int n ;
  PCache1 *pCache ;

  {
  pCache = (PCache1 *)p;
  n = (int )pCache->nPage;
  return (n);
}
}
static PgHdr1 *( __attribute__((__noinline__)) pcache1FetchStage2)(PCache1 *pCache ,
                                                                   unsigned int iKey ,
                                                                   int createFlag ) 
{ 
  unsigned int nPinned ;
  PGroup *pGroup ;
  PgHdr1 *pPage ;
  int tmp ;
  PCache1 *pOther ;
  int tmp___0 ;
  unsigned int h ;

  {
  pGroup = pCache->pGroup;
  pPage = (PgHdr1 *)0;
  nPinned = pCache->nPage - pCache->nRecyclable;
  if (createFlag == 1) {
    if (nPinned >= pGroup->mxPinned) {
      return ((PgHdr1 *)0);
    } else
    if (nPinned >= pCache->n90pct) {
      return ((PgHdr1 *)0);
    } else {
      tmp = pcache1UnderMemoryPressure(pCache);
      if (tmp) {
        if (pCache->nRecyclable < nPinned) {
          return ((PgHdr1 *)0);
        }
      }
    }
  }
  if (pCache->nPage >= pCache->nHash) {
    pcache1ResizeHash(pCache);
  }
  if (pCache->bPurgeable) {
    if (! (pGroup->lru.pLruPrev)->isAnchor) {
      if (pCache->nPage + 1U >= pCache->nMax) {
        goto _L;
      } else {
        tmp___0 = pcache1UnderMemoryPressure(pCache);
        if (tmp___0) {
          _L: /* CIL Label */ 
          pPage = pGroup->lru.pLruPrev;
          pcache1RemoveFromHash(pPage, 0);
          pcache1PinPage(pPage);
          pOther = pPage->pCache;
          if (pOther->szAlloc != pCache->szAlloc) {
            pcache1FreePage(pPage);
            pPage = (PgHdr1 *)0;
          } else {
            pGroup->nPurgeable -= (unsigned int )(pOther->bPurgeable - pCache->bPurgeable);
          }
        }
      }
    }
  }
  if (! pPage) {
    pPage = pcache1AllocPage(pCache, createFlag == 1);
  }
  if (pPage) {
    h = iKey % pCache->nHash;
    (pCache->nPage) ++;
    pPage->iKey = iKey;
    pPage->pNext = *(pCache->apHash + h);
    pPage->pCache = pCache;
    pPage->pLruNext = (PgHdr1 *)0;
    *((void **)pPage->page.pExtra) = (void *)0;
    *(pCache->apHash + h) = pPage;
    if (iKey > pCache->iMaxKey) {
      pCache->iMaxKey = iKey;
    }
  }
  return (pPage);
}
}
static PgHdr1 *pcache1FetchNoMutex(sqlite3_pcache *p , unsigned int iKey , int createFlag ) 
{ 
  PCache1 *pCache ;
  PgHdr1 *pPage ;
  PgHdr1 *tmp ;
  PgHdr1 *tmp___0 ;

  {
  pCache = (PCache1 *)p;
  pPage = (PgHdr1 *)0;
  pPage = *(pCache->apHash + iKey % pCache->nHash);
  while (1) {
    if (pPage) {
      if (! (pPage->iKey != iKey)) {
        break;
      }
    } else {
      break;
    }
    pPage = pPage->pNext;
  }
  if (pPage) {
    if ((unsigned long )pPage->pLruNext != (unsigned long )((PgHdr1 *)0)) {
      tmp = pcache1PinPage(pPage);
      return (tmp);
    } else {
      return (pPage);
    }
  } else
  if (createFlag) {
    tmp___0 = pcache1FetchStage2(pCache, iKey, createFlag);
    return (tmp___0);
  } else {
    return ((PgHdr1 *)0);
  }
}
}
static sqlite3_pcache_page *pcache1Fetch(sqlite3_pcache *p , unsigned int iKey , int createFlag ) 
{ 
  PgHdr1 *tmp ;

  {
  tmp = pcache1FetchNoMutex(p, iKey, createFlag);
  return ((sqlite3_pcache_page *)tmp);
}
}
static void pcache1Unpin(sqlite3_pcache *p , sqlite3_pcache_page *pPg , int reuseUnlikely ) 
{ 
  PCache1 *pCache ;
  PgHdr1 *pPage ;
  PGroup *pGroup ;
  PgHdr1 **ppFirst ;
  PgHdr1 *tmp ;

  {
  pCache = (PCache1 *)p;
  pPage = (PgHdr1 *)pPg;
  pGroup = pCache->pGroup;
  if (reuseUnlikely) {
    pcache1RemoveFromHash(pPage, 1);
  } else
  if (pGroup->nPurgeable > pGroup->nMaxPage) {
    pcache1RemoveFromHash(pPage, 1);
  } else {
    ppFirst = & pGroup->lru.pLruNext;
    pPage->pLruPrev = & pGroup->lru;
    tmp = *ppFirst;
    pPage->pLruNext = tmp;
    tmp->pLruPrev = pPage;
    *ppFirst = pPage;
    (pCache->nRecyclable) ++;
  }
  return;
}
}
static void pcache1Rekey(sqlite3_pcache *p , sqlite3_pcache_page *pPg , unsigned int iOld ,
                         unsigned int iNew ) 
{ 
  PCache1 *pCache ;
  PgHdr1 *pPage ;
  PgHdr1 **pp ;
  unsigned int h ;

  {
  pCache = (PCache1 *)p;
  pPage = (PgHdr1 *)pPg;
  h = iOld % pCache->nHash;
  pp = pCache->apHash + h;
  while ((unsigned long )*pp != (unsigned long )pPage) {
    pp = & (*pp)->pNext;
  }
  *pp = pPage->pNext;
  h = iNew % pCache->nHash;
  pPage->iKey = iNew;
  pPage->pNext = *(pCache->apHash + h);
  *(pCache->apHash + h) = pPage;
  if (iNew > pCache->iMaxKey) {
    pCache->iMaxKey = iNew;
  }
  return;
}
}
static void pcache1Truncate(sqlite3_pcache *p , unsigned int iLimit ) 
{ 
  PCache1 *pCache ;

  {
  pCache = (PCache1 *)p;
  if (iLimit <= pCache->iMaxKey) {
    pcache1TruncateUnsafe(pCache, iLimit);
    pCache->iMaxKey = iLimit - 1U;
  }
  return;
}
}
static void pcache1Destroy(sqlite3_pcache *p ) 
{ 
  PCache1 *pCache ;
  PGroup *pGroup ;

  {
  pCache = (PCache1 *)p;
  pGroup = pCache->pGroup;
  if (pCache->nPage) {
    pcache1TruncateUnsafe(pCache, 0U);
  }
  pGroup->nMaxPage -= pCache->nMax;
  pGroup->nMinPage -= pCache->nMin;
  pGroup->mxPinned = (pGroup->nMaxPage + 10U) - pGroup->nMinPage;
  pcache1EnforceMaxPage(pCache);
  sqlite3_free(pCache->pBulk);
  sqlite3_free((void *)pCache->apHash);
  sqlite3_free((void *)pCache);
  return;
}
}
static struct sqlite3_pcache_methods2  const  defaultMethods___0  = 
     {1, (void *)0, & pcache1Init, & pcache1Shutdown, & pcache1Create, & pcache1Cachesize,
    & pcache1Pagecount, & pcache1Fetch, & pcache1Unpin, & pcache1Rekey, & pcache1Truncate,
    & pcache1Destroy, & pcache1Shrink};
static void sqlite3PCacheSetDefault(void) 
{ 


  {
  sqlite3_config(18, & defaultMethods___0);
  return;
}
}
static int sqlite3HeaderSizePcache1(void) 
{ 


  {
  return ((int )((sizeof(PgHdr1 ) + 7UL) & 0xfffffffffffffff8UL));
}
}
static sqlite3_mutex *sqlite3Pcache1Mutex(void) 
{ 


  {
  return (pcache1_g.mutex);
}
}
static RowSet *sqlite3RowSetInit(sqlite3 *db ) 
{ 
  RowSet *p ;
  void *tmp ;
  int N ;
  int tmp___0 ;

  {
  tmp = sqlite3DbMallocRawNN(db, (u64 )sizeof(*p));
  p = (RowSet *)tmp;
  if (p) {
    tmp___0 = sqlite3DbMallocSize(db, (void *)p);
    N = tmp___0;
    p->pChunk = (struct RowSetChunk *)0;
    p->db = db;
    p->pEntry = (struct RowSetEntry *)0;
    p->pLast = (struct RowSetEntry *)0;
    p->pForest = (struct RowSetEntry *)0;
    p->pFresh = (struct RowSetEntry *)((char *)p + ((sizeof(*p) + 7UL) & 0xfffffffffffffff8UL));
    p->nFresh = (u16 )(((unsigned long )N - ((sizeof(*p) + 7UL) & 0xfffffffffffffff8UL)) / sizeof(struct RowSetEntry ));
    p->rsFlags = (u16 )1;
    p->iBatch = 0;
  }
  return (p);
}
}
static void sqlite3RowSetClear(void *pArg ) 
{ 
  RowSet *p ;
  struct RowSetChunk *pChunk ;
  struct RowSetChunk *pNextChunk ;

  {
  p = (RowSet *)pArg;
  pChunk = p->pChunk;
  while (pChunk) {
    pNextChunk = pChunk->pNextChunk;
    sqlite3DbFree(p->db, (void *)pChunk);
    pChunk = pNextChunk;
  }
  p->pChunk = (struct RowSetChunk *)0;
  p->nFresh = (u16 )0;
  p->pEntry = (struct RowSetEntry *)0;
  p->pLast = (struct RowSetEntry *)0;
  p->pForest = (struct RowSetEntry *)0;
  p->rsFlags = (u16 )1;
  return;
}
}
static void sqlite3RowSetDelete(void *pArg ) 
{ 


  {
  sqlite3RowSetClear(pArg);
  sqlite3DbFree(((RowSet *)pArg)->db, pArg);
  return;
}
}
static struct RowSetEntry *rowSetEntryAlloc(RowSet *p ) 
{ 
  struct RowSetChunk *pNew ;
  void *tmp ;
  struct RowSetEntry *tmp___0 ;

  {
  if ((int )p->nFresh == 0) {
    tmp = sqlite3DbMallocRawNN(p->db, (u64 )sizeof(*pNew));
    pNew = (struct RowSetChunk *)tmp;
    if ((unsigned long )pNew == (unsigned long )((struct RowSetChunk *)0)) {
      return ((struct RowSetEntry *)0);
    }
    pNew->pNextChunk = p->pChunk;
    p->pChunk = pNew;
    p->pFresh = pNew->aEntry;
    p->nFresh = (u16 )(1016UL / sizeof(struct RowSetEntry ));
  }
  p->nFresh = (u16 )((int )p->nFresh - 1);
  tmp___0 = p->pFresh;
  (p->pFresh) ++;
  return (tmp___0);
}
}
static void sqlite3RowSetInsert(RowSet *p , i64 rowid ) 
{ 
  struct RowSetEntry *pEntry ;
  struct RowSetEntry *pLast ;

  {
  pEntry = rowSetEntryAlloc(p);
  if ((unsigned long )pEntry == (unsigned long )((struct RowSetEntry *)0)) {
    return;
  }
  pEntry->v = rowid;
  pEntry->pRight = (struct RowSetEntry *)0;
  pLast = p->pLast;
  if (pLast) {
    if (rowid <= pLast->v) {
      p->rsFlags = (u16 )((int )p->rsFlags & -2);
    }
    pLast->pRight = pEntry;
  } else {
    p->pEntry = pEntry;
  }
  p->pLast = pEntry;
  return;
}
}
static struct RowSetEntry *rowSetEntryMerge(struct RowSetEntry *pA , struct RowSetEntry *pB ) 
{ 
  struct RowSetEntry head ;
  struct RowSetEntry *pTail ;
  struct RowSetEntry *tmp ;
  struct RowSetEntry *tmp___0 ;

  {
  pTail = & head;
  while (1) {
    if (pA->v <= pB->v) {
      if (pA->v < pB->v) {
        tmp = pA;
        pTail->pRight = tmp;
        pTail = tmp;
      }
      pA = pA->pRight;
      if ((unsigned long )pA == (unsigned long )((struct RowSetEntry *)0)) {
        pTail->pRight = pB;
        break;
      }
    } else {
      tmp___0 = pB;
      pTail->pRight = tmp___0;
      pTail = tmp___0;
      pB = pB->pRight;
      if ((unsigned long )pB == (unsigned long )((struct RowSetEntry *)0)) {
        pTail->pRight = pA;
        break;
      }
    }
  }
  return (head.pRight);
}
}
static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn ) 
{ 
  unsigned int i ;
  struct RowSetEntry *pNext ;
  struct RowSetEntry *aBucket[40] ;
  struct RowSetEntry *tmp ;

  {
  memset((void *)(aBucket), 0, sizeof(aBucket));
  while (pIn) {
    pNext = pIn->pRight;
    pIn->pRight = (struct RowSetEntry *)0;
    i = 0U;
    while (aBucket[i]) {
      pIn = rowSetEntryMerge(aBucket[i], pIn);
      aBucket[i] = (struct RowSetEntry *)0;
      i ++;
    }
    aBucket[i] = pIn;
    pIn = pNext;
  }
  pIn = aBucket[0];
  i = 1U;
  while ((unsigned long )i < sizeof(aBucket) / sizeof(aBucket[0])) {
    if ((unsigned long )aBucket[i] == (unsigned long )((struct RowSetEntry *)0)) {
      goto __Cont;
    }
    if (pIn) {
      tmp = rowSetEntryMerge(pIn, aBucket[i]);
      pIn = tmp;
    } else {
      pIn = aBucket[i];
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (pIn);
}
}
static void rowSetTreeToList(struct RowSetEntry *pIn , struct RowSetEntry **ppFirst ,
                             struct RowSetEntry **ppLast ) 
{ 
  struct RowSetEntry *p ;

  {
  if (pIn->pLeft) {
    rowSetTreeToList(pIn->pLeft, ppFirst, & p);
    p->pRight = pIn;
  } else {
    *ppFirst = pIn;
  }
  if (pIn->pRight) {
    rowSetTreeToList(pIn->pRight, & pIn->pRight, ppLast);
  } else {
    *ppLast = pIn;
  }
  return;
}
}
static struct RowSetEntry *rowSetNDeepTree(struct RowSetEntry **ppList , int iDepth ) 
{ 
  struct RowSetEntry *p ;
  struct RowSetEntry *pLeft ;
  struct RowSetEntry *tmp ;

  {
  if ((unsigned long )*ppList == (unsigned long )((struct RowSetEntry *)0)) {
    return ((struct RowSetEntry *)0);
  }
  if (iDepth > 1) {
    pLeft = rowSetNDeepTree(ppList, iDepth - 1);
    p = *ppList;
    if ((unsigned long )p == (unsigned long )((struct RowSetEntry *)0)) {
      return (pLeft);
    }
    p->pLeft = pLeft;
    *ppList = p->pRight;
    p->pRight = rowSetNDeepTree(ppList, iDepth - 1);
  } else {
    p = *ppList;
    *ppList = p->pRight;
    tmp = (struct RowSetEntry *)0;
    p->pRight = tmp;
    p->pLeft = tmp;
  }
  return (p);
}
}
static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList ) 
{ 
  int iDepth ;
  struct RowSetEntry *p ;
  struct RowSetEntry *pLeft ;
  struct RowSetEntry *tmp ;

  {
  p = pList;
  pList = p->pRight;
  tmp = (struct RowSetEntry *)0;
  p->pRight = tmp;
  p->pLeft = tmp;
  iDepth = 1;
  while (pList) {
    pLeft = p;
    p = pList;
    pList = p->pRight;
    p->pLeft = pLeft;
    p->pRight = rowSetNDeepTree(& pList, iDepth);
    iDepth ++;
  }
  return (p);
}
}
static int sqlite3RowSetNext(RowSet *p , i64 *pRowid ) 
{ 


  {
  if (((int )p->rsFlags & 2) == 0) {
    if (((int )p->rsFlags & 1) == 0) {
      p->pEntry = rowSetEntrySort(p->pEntry);
    }
    p->rsFlags = (u16 )((int )p->rsFlags | 3);
  }
  if (p->pEntry) {
    *pRowid = (p->pEntry)->v;
    p->pEntry = (p->pEntry)->pRight;
    if ((unsigned long )p->pEntry == (unsigned long )((struct RowSetEntry *)0)) {
      sqlite3RowSetClear((void *)p);
    }
    return (1);
  } else {
    return (0);
  }
}
}
static int sqlite3RowSetTest(RowSet *pRowSet , int iBatch , long long iRowid ) 
{ 
  struct RowSetEntry *p ;
  struct RowSetEntry *pTree ;
  struct RowSetEntry **ppPrevTree ;
  struct RowSetEntry *pAux ;
  struct RowSetEntry *pTail ;

  {
  if (iBatch != pRowSet->iBatch) {
    p = pRowSet->pEntry;
    if (p) {
      ppPrevTree = & pRowSet->pForest;
      if (((int )pRowSet->rsFlags & 1) == 0) {
        p = rowSetEntrySort(p);
      }
      pTree = pRowSet->pForest;
      while (pTree) {
        ppPrevTree = & pTree->pRight;
        if ((unsigned long )pTree->pLeft == (unsigned long )((struct RowSetEntry *)0)) {
          pTree->pLeft = rowSetListToTree(p);
          break;
        } else {
          rowSetTreeToList(pTree->pLeft, & pAux, & pTail);
          pTree->pLeft = (struct RowSetEntry *)0;
          p = rowSetEntryMerge(pAux, p);
        }
        pTree = pTree->pRight;
      }
      if ((unsigned long )pTree == (unsigned long )((struct RowSetEntry *)0)) {
        pTree = rowSetEntryAlloc(pRowSet);
        *ppPrevTree = pTree;
        if (pTree) {
          pTree->v = (i64 )0;
          pTree->pRight = (struct RowSetEntry *)0;
          pTree->pLeft = rowSetListToTree(p);
        }
      }
      pRowSet->pEntry = (struct RowSetEntry *)0;
      pRowSet->pLast = (struct RowSetEntry *)0;
      pRowSet->rsFlags = (u16 )((int )pRowSet->rsFlags | 1);
    }
    pRowSet->iBatch = iBatch;
  }
  pTree = pRowSet->pForest;
  while (pTree) {
    p = pTree->pLeft;
    while (p) {
      if (p->v < iRowid) {
        p = p->pRight;
      } else
      if (p->v > iRowid) {
        p = p->pLeft;
      } else {
        return (1);
      }
    }
    pTree = pTree->pRight;
  }
  return (0);
}
}
static int sqlite3WalOpen(sqlite3_vfs *pVfs , sqlite3_file *pDbFd , char const   *zWalName ,
                          int bNoShm , i64 mxWalSize , Wal **ppWal ) ;
static int sqlite3WalClose(Wal *pWal , sqlite3 *db , int sync_flags , int nBuf , u8 *zBuf ) ;
static void sqlite3WalLimit(Wal *pWal , i64 iLimit ) ;
static int sqlite3WalBeginReadTransaction(Wal *pWal , int *pChanged ) ;
static void sqlite3WalEndReadTransaction(Wal *pWal ) ;
static int sqlite3WalFindFrame(Wal *pWal , Pgno pgno , u32 *piRead ) ;
static int sqlite3WalReadFrame(Wal *pWal , u32 iRead , int nOut , u8 *pOut ) ;
static Pgno sqlite3WalDbsize(Wal *pWal ) ;
static int sqlite3WalBeginWriteTransaction(Wal *pWal ) ;
static int sqlite3WalEndWriteTransaction(Wal *pWal ) ;
static int sqlite3WalUndo(Wal *pWal , int (*xUndo)(void * , Pgno  ) , void *pUndoCtx ) ;
static void sqlite3WalSavepoint(Wal *pWal , u32 *aWalData ) ;
static int sqlite3WalSavepointUndo(Wal *pWal , u32 *aWalData ) ;
static int sqlite3WalFrames(Wal *pWal , int szPage , PgHdr *pList , Pgno nTruncate ,
                            int isCommit , int sync_flags ) ;
static int sqlite3WalCheckpoint(Wal *pWal , sqlite3 *db , int eMode , int (*xBusy)(void * ) ,
                                void *pBusyArg , int sync_flags , int nBuf , u8 *zBuf ,
                                int *pnLog , int *pnCkpt ) ;
static int sqlite3WalCallback(Wal *pWal ) ;
static int sqlite3WalExclusiveMode(Wal *pWal , int op ) ;
static int sqlite3WalHeapMemory(Wal *pWal ) ;
static sqlite3_file *sqlite3WalFile(Wal *pWal ) ;
static unsigned char const   aJournalMagic[8]  = 
  {      (unsigned char const   )217,      (unsigned char const   )213,      (unsigned char const   )5,      (unsigned char const   )249, 
        (unsigned char const   )32,      (unsigned char const   )161,      (unsigned char const   )99,      (unsigned char const   )215};
static int getPageNormal(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) ;
static int getPageError(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) ;
static int getPageMMap(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) ;
static void setGetterMethod(Pager *pPager ) 
{ 


  {
  if (pPager->errCode) {
    pPager->xGet = & getPageError;
  } else
  if (pPager->bUseFetch) {
    pPager->xGet = & getPageMMap;
  } else {
    pPager->xGet = & getPageNormal;
  }
  return;
}
}
static int subjRequiresPage(PgHdr *pPg ) 
{ 
  Pager *pPager ;
  PagerSavepoint *p ;
  Pgno pgno ;
  int i ;
  int tmp ;

  {
  pPager = pPg->pPager;
  pgno = pPg->pgno;
  i = 0;
  while (i < pPager->nSavepoint) {
    p = pPager->aSavepoint + i;
    if (p->nOrig >= pgno) {
      tmp = sqlite3BitvecTestNotNull(p->pInSavepoint, pgno);
      if (0 == tmp) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static int read32bits(sqlite3_file *fd , i64 offset , u32 *pRes ) 
{ 
  unsigned char ac[4] ;
  int rc ;
  int tmp ;

  {
  tmp = sqlite3OsRead(fd, (void *)(ac), (int )sizeof(ac), offset);
  rc = tmp;
  if (rc == 0) {
    *pRes = sqlite3Get4byte((u8 const   *)(ac));
  }
  return (rc);
}
}
static int write32bits(sqlite3_file *fd , i64 offset , u32 val ) 
{ 
  char ac[4] ;
  int tmp ;

  {
  sqlite3Put4byte((u8 *)(ac), val);
  tmp = sqlite3OsWrite(fd, (void const   *)(ac), 4, offset);
  return (tmp);
}
}
static int pagerUnlockDb(Pager *pPager , int eLock ) 
{ 
  int rc ;
  int tmp ;

  {
  rc = 0;
  if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    if (pPager->noLock) {
      rc = 0;
    } else {
      tmp = sqlite3OsUnlock(pPager->fd, eLock);
      rc = tmp;
    }
    if ((int )pPager->eLock != 5) {
      pPager->eLock = (u8 )eLock;
    }
  }
  return (rc);
}
}
static int pagerLockDb(Pager *pPager , int eLock ) 
{ 
  int rc ;
  int tmp ;

  {
  rc = 0;
  if ((int )pPager->eLock < eLock) {
    goto _L;
  } else
  if ((int )pPager->eLock == 5) {
    _L: /* CIL Label */ 
    if (pPager->noLock) {
      rc = 0;
    } else {
      tmp = sqlite3OsLock(pPager->fd, eLock);
      rc = tmp;
    }
    if (rc == 0) {
      if ((int )pPager->eLock != 5) {
        pPager->eLock = (u8 )eLock;
      } else
      if (eLock == 4) {
        pPager->eLock = (u8 )eLock;
      }
    }
  }
  return (rc);
}
}
static int jrnlBufferSize(Pager *pPager ) 
{ 


  {
  return (0);
}
}
static int readMasterJournal(sqlite3_file *pJrnl , char *zMaster , u32 nMaster ) 
{ 
  int rc ;
  u32 len ;
  i64 szJ ;
  u32 cksum ;
  u32 u ;
  unsigned char aMagic[8] ;
  int tmp ;

  {
  *(zMaster + 0) = (char )'\000';
  rc = sqlite3OsFileSize(pJrnl, & szJ);
  if (0 != rc) {
    return (rc);
  } else
  if (szJ < 16LL) {
    return (rc);
  } else {
    rc = read32bits(pJrnl, szJ - 16LL, & len);
    if (0 != rc) {
      return (rc);
    } else
    if (len >= nMaster) {
      return (rc);
    } else
    if ((i64 )len > szJ - 16LL) {
      return (rc);
    } else
    if (len == 0U) {
      return (rc);
    } else {
      rc = read32bits(pJrnl, szJ - 12LL, & cksum);
      if (0 != rc) {
        return (rc);
      } else {
        rc = sqlite3OsRead(pJrnl, (void *)(aMagic), 8, szJ - 8LL);
        if (0 != rc) {
          return (rc);
        } else {
          tmp = memcmp((void const   *)(aMagic), (void const   *)(aJournalMagic),
                       (size_t )8);
          if (tmp) {
            return (rc);
          } else {
            rc = sqlite3OsRead(pJrnl, (void *)zMaster, (int )len, (szJ - 16LL) - (i64 )len);
            if (0 != rc) {
              return (rc);
            }
          }
        }
      }
    }
  }
  u = (u32 )0;
  while (u < len) {
    cksum -= (u32 )*(zMaster + u);
    u ++;
  }
  if (cksum) {
    len = (u32 )0;
  }
  *(zMaster + len) = (char )'\000';
  return (0);
}
}
static i64 journalHdrOffset(Pager *pPager ) 
{ 
  i64 offset ;
  i64 c ;

  {
  offset = (i64 )0;
  c = pPager->journalOff;
  if (c) {
    offset = ((c - 1LL) / (i64 )pPager->sectorSize + 1LL) * (i64 )pPager->sectorSize;
  }
  return (offset);
}
}
static int zeroJournalHdr(Pager *pPager , int doTruncate ) ;
static char const   zeroHdr[28]  = {      (char const   )0};
static int zeroJournalHdr(Pager *pPager , int doTruncate ) 
{ 
  int rc ;
  i64 iLimit ;
  i64 sz ;

  {
  rc = 0;
  if (pPager->journalOff) {
    iLimit = pPager->journalSizeLimit;
    if (doTruncate) {
      rc = sqlite3OsTruncate(pPager->jfd, (i64 )0);
    } else
    if (iLimit == 0LL) {
      rc = sqlite3OsTruncate(pPager->jfd, (i64 )0);
    } else {
      rc = sqlite3OsWrite(pPager->jfd, (void const   *)(zeroHdr), (int )sizeof(zeroHdr),
                          (i64 )0);
    }
    if (rc == 0) {
      if (! pPager->noSync) {
        rc = sqlite3OsSync(pPager->jfd, 16 | (int )pPager->syncFlags);
      }
    }
    if (rc == 0) {
      if (iLimit > 0LL) {
        rc = sqlite3OsFileSize(pPager->jfd, & sz);
        if (rc == 0) {
          if (sz > iLimit) {
            rc = sqlite3OsTruncate(pPager->jfd, iLimit);
          }
        }
      }
    }
  }
  return (rc);
}
}
static int writeJournalHdr(Pager *pPager ) 
{ 
  int rc ;
  char *zHeader ;
  u32 nHeader ;
  u32 nWrite ;
  int ii ;
  i64 tmp ;
  int tmp___0 ;

  {
  rc = 0;
  zHeader = pPager->pTmpSpace;
  nHeader = (u32 )pPager->pageSize;
  if (nHeader > pPager->sectorSize) {
    nHeader = pPager->sectorSize;
  }
  ii = 0;
  while (ii < pPager->nSavepoint) {
    if ((pPager->aSavepoint + ii)->iHdrOffset == 0LL) {
      (pPager->aSavepoint + ii)->iHdrOffset = pPager->journalOff;
    }
    ii ++;
  }
  tmp = journalHdrOffset(pPager);
  pPager->journalOff = tmp;
  pPager->journalHdr = tmp;
  if (pPager->noSync) {
    memcpy((void * __restrict  )zHeader, (void const   * __restrict  )(aJournalMagic),
           sizeof(aJournalMagic));
    sqlite3Put4byte((u8 *)(zHeader + sizeof(aJournalMagic)), 4294967295U);
  } else
  if ((int )pPager->journalMode == 4) {
    memcpy((void * __restrict  )zHeader, (void const   * __restrict  )(aJournalMagic),
           sizeof(aJournalMagic));
    sqlite3Put4byte((u8 *)(zHeader + sizeof(aJournalMagic)), 4294967295U);
  } else {
    tmp___0 = sqlite3OsDeviceCharacteristics(pPager->fd);
    if (tmp___0 & 512) {
      memcpy((void * __restrict  )zHeader, (void const   * __restrict  )(aJournalMagic),
             sizeof(aJournalMagic));
      sqlite3Put4byte((u8 *)(zHeader + sizeof(aJournalMagic)), 4294967295U);
    } else {
      memset((void *)zHeader, 0, sizeof(aJournalMagic) + 4UL);
    }
  }
  sqlite3_randomness((int )sizeof(pPager->cksumInit), (void *)(& pPager->cksumInit));
  sqlite3Put4byte((u8 *)(zHeader + (sizeof(aJournalMagic) + 4UL)), pPager->cksumInit);
  sqlite3Put4byte((u8 *)(zHeader + (sizeof(aJournalMagic) + 8UL)), pPager->dbOrigSize);
  sqlite3Put4byte((u8 *)(zHeader + (sizeof(aJournalMagic) + 12UL)), pPager->sectorSize);
  sqlite3Put4byte((u8 *)(zHeader + (sizeof(aJournalMagic) + 16UL)), (u32 )pPager->pageSize);
  memset((void *)(zHeader + (sizeof(aJournalMagic) + 20UL)), 0, (unsigned long )nHeader - (sizeof(aJournalMagic) + 20UL));
  nWrite = (u32 )0;
  while (1) {
    if (rc == 0) {
      if (! (nWrite < pPager->sectorSize)) {
        break;
      }
    } else {
      break;
    }
    rc = sqlite3OsWrite(pPager->jfd, (void const   *)zHeader, (int )nHeader, pPager->journalOff);
    pPager->journalOff += (i64 )nHeader;
    nWrite += nHeader;
  }
  return (rc);
}
}
static int readJournalHdr(Pager *pPager , int isHot , i64 journalSize , u32 *pNRec ,
                          u32 *pDbSize ) 
{ 
  int rc ;
  unsigned char aMagic[8] ;
  i64 iHdrOff ;
  int tmp ;
  u32 iPageSize ;
  u32 iSectorSize ;

  {
  pPager->journalOff = journalHdrOffset(pPager);
  if (pPager->journalOff + (i64 )pPager->sectorSize > journalSize) {
    return (101);
  }
  iHdrOff = pPager->journalOff;
  if (isHot) {
    goto _L;
  } else
  if (iHdrOff != pPager->journalHdr) {
    _L: /* CIL Label */ 
    rc = sqlite3OsRead(pPager->jfd, (void *)(aMagic), (int )sizeof(aMagic), iHdrOff);
    if (rc) {
      return (rc);
    }
    tmp = memcmp((void const   *)(aMagic), (void const   *)(aJournalMagic), sizeof(aMagic));
    if (tmp != 0) {
      return (101);
    }
  }
  rc = read32bits(pPager->jfd, iHdrOff + 8LL, pNRec);
  if (0 != rc) {
    return (rc);
  } else {
    rc = read32bits(pPager->jfd, iHdrOff + 12LL, & pPager->cksumInit);
    if (0 != rc) {
      return (rc);
    } else {
      rc = read32bits(pPager->jfd, iHdrOff + 16LL, pDbSize);
      if (0 != rc) {
        return (rc);
      }
    }
  }
  if (pPager->journalOff == 0LL) {
    rc = read32bits(pPager->jfd, iHdrOff + 20LL, & iSectorSize);
    if (0 != rc) {
      return (rc);
    } else {
      rc = read32bits(pPager->jfd, iHdrOff + 24LL, & iPageSize);
      if (0 != rc) {
        return (rc);
      }
    }
    if (iPageSize == 0U) {
      iPageSize = (u32 )pPager->pageSize;
    }
    if (iPageSize < 512U) {
      return (101);
    } else
    if (iSectorSize < 32U) {
      return (101);
    } else
    if (iPageSize > 65536U) {
      return (101);
    } else
    if (iSectorSize > 65536U) {
      return (101);
    } else
    if (((iPageSize - 1U) & iPageSize) != 0U) {
      return (101);
    } else
    if (((iSectorSize - 1U) & iSectorSize) != 0U) {
      return (101);
    }
    rc = sqlite3PagerSetPagesize(pPager, & iPageSize, -1);
    pPager->sectorSize = iSectorSize;
  }
  pPager->journalOff += (i64 )pPager->sectorSize;
  return (rc);
}
}
static int writeMasterJournal(Pager *pPager , char const   *zMaster ) 
{ 
  int rc ;
  int nMaster ;
  i64 iHdrOff ;
  i64 jrnlSize ;
  u32 cksum ;

  {
  cksum = (u32 )0;
  if (! zMaster) {
    return (0);
  } else
  if ((int )pPager->journalMode == 4) {
    return (0);
  } else
  if (! ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
    return (0);
  }
  pPager->setMaster = (u8 )1;
  nMaster = 0;
  while (*(zMaster + nMaster)) {
    cksum += (u32 )*(zMaster + nMaster);
    nMaster ++;
  }
  if (pPager->fullSync) {
    pPager->journalOff = journalHdrOffset(pPager);
  }
  iHdrOff = pPager->journalOff;
  rc = write32bits(pPager->jfd, iHdrOff, (Pgno )(sqlite3PendingByte / pPager->pageSize + 1));
  if (0 != rc) {
    return (rc);
  } else {
    rc = sqlite3OsWrite(pPager->jfd, (void const   *)zMaster, nMaster, iHdrOff + 4LL);
    if (0 != rc) {
      return (rc);
    } else {
      rc = write32bits(pPager->jfd, (iHdrOff + 4LL) + (i64 )nMaster, (u32 )nMaster);
      if (0 != rc) {
        return (rc);
      } else {
        rc = write32bits(pPager->jfd, ((iHdrOff + 4LL) + (i64 )nMaster) + 4LL, cksum);
        if (0 != rc) {
          return (rc);
        } else {
          rc = sqlite3OsWrite(pPager->jfd, (void const   *)(aJournalMagic), 8, ((iHdrOff + 4LL) + (i64 )nMaster) + 8LL);
          if (0 != rc) {
            return (rc);
          }
        }
      }
    }
  }
  pPager->journalOff += (i64 )(nMaster + 20);
  rc = sqlite3OsFileSize(pPager->jfd, & jrnlSize);
  if (0 == rc) {
    if (jrnlSize > pPager->journalOff) {
      rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
    }
  }
  return (rc);
}
}
static void pager_reset(Pager *pPager ) 
{ 


  {
  (pPager->iDataVersion) ++;
  sqlite3BackupRestart(pPager->pBackup);
  sqlite3PcacheClear(pPager->pPCache);
  return;
}
}
static u32 sqlite3PagerDataVersion(Pager *pPager ) 
{ 


  {
  return (pPager->iDataVersion);
}
}
static void releaseAllSavepoints(Pager *pPager ) 
{ 
  int ii ;
  int tmp ;

  {
  ii = 0;
  while (ii < pPager->nSavepoint) {
    sqlite3BitvecDestroy((pPager->aSavepoint + ii)->pInSavepoint);
    ii ++;
  }
  if (! pPager->exclusiveMode) {
    sqlite3OsClose(pPager->sjfd);
  } else {
    tmp = sqlite3JournalIsInMemory(pPager->sjfd);
    if (tmp) {
      sqlite3OsClose(pPager->sjfd);
    }
  }
  sqlite3_free((void *)pPager->aSavepoint);
  pPager->aSavepoint = (PagerSavepoint *)0;
  pPager->nSavepoint = 0;
  pPager->nSubRec = (u32 )0;
  return;
}
}
static int addToSavepointBitvecs(Pager *pPager , Pgno pgno ) 
{ 
  int ii ;
  int rc ;
  PagerSavepoint *p ;
  int tmp ;

  {
  rc = 0;
  ii = 0;
  while (ii < pPager->nSavepoint) {
    p = pPager->aSavepoint + ii;
    if (pgno <= p->nOrig) {
      tmp = sqlite3BitvecSet(p->pInSavepoint, pgno);
      rc |= tmp;
    }
    ii ++;
  }
  return (rc);
}
}
static void pager_unlock(Pager *pPager ) 
{ 
  int rc ;
  int iDc ;
  int tmp ;
  int tmp___0 ;

  {
  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = (Bitvec *)0;
  releaseAllSavepoints(pPager);
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    sqlite3WalEndReadTransaction(pPager->pWal);
    pPager->eState = (u8 )0;
  } else
  if (! pPager->exclusiveMode) {
    if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      tmp = sqlite3OsDeviceCharacteristics(pPager->fd);
      tmp___0 = tmp;
    } else {
      tmp___0 = 0;
    }
    iDc = tmp___0;
    if (0 == (iDc & 2048)) {
      sqlite3OsClose(pPager->jfd);
    } else
    if (1 != ((int )pPager->journalMode & 5)) {
      sqlite3OsClose(pPager->jfd);
    }
    rc = pagerUnlockDb(pPager, 0);
    if (rc != 0) {
      if ((int )pPager->eState == 6) {
        pPager->eLock = (u8 )5;
      }
    }
    pPager->changeCountDone = (u8 )0;
    pPager->eState = (u8 )0;
  }
  if (pPager->errCode) {
    if ((int )pPager->tempFile == 0) {
      pager_reset(pPager);
      pPager->changeCountDone = (u8 )0;
      pPager->eState = (u8 )0;
    } else
    if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      pPager->eState = (u8 )0;
    } else {
      pPager->eState = (u8 )1;
    }
    if (pPager->bUseFetch) {
      sqlite3OsUnfetch(pPager->fd, (i64 )0, (void *)0);
    }
    pPager->errCode = 0;
    setGetterMethod(pPager);
  }
  pPager->journalOff = (i64 )0;
  pPager->journalHdr = (i64 )0;
  pPager->setMaster = (u8 )0;
  return;
}
}
static int pager_error(Pager *pPager , int rc ) 
{ 
  int rc2 ;

  {
  rc2 = rc & 255;
  if (rc2 == 13) {
    pPager->errCode = rc;
    pPager->eState = (u8 )6;
    setGetterMethod(pPager);
  } else
  if (rc2 == 10) {
    pPager->errCode = rc;
    pPager->eState = (u8 )6;
    setGetterMethod(pPager);
  }
  return (rc);
}
}
static int pager_truncate(Pager *pPager , Pgno nPage ) ;
static int pagerFlushOnCommit(Pager *pPager , int bCommit ) 
{ 
  int tmp ;

  {
  if ((int )pPager->tempFile == 0) {
    return (1);
  }
  if (! bCommit) {
    return (0);
  }
  if (! ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
    return (0);
  }
  tmp = sqlite3PCachePercentDirty(pPager->pPCache);
  return (tmp >= 25);
}
}
static int pager_end_transaction(Pager *pPager , int hasMaster , int bCommit ) 
{ 
  int rc ;
  int rc2 ;
  int tmp ;
  int bDelete ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  rc = 0;
  rc2 = 0;
  if ((int )pPager->eState < 2) {
    if ((int )pPager->eLock < 2) {
      return (0);
    }
  }
  releaseAllSavepoints(pPager);
  if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    tmp___0 = sqlite3JournalIsInMemory(pPager->jfd);
    if (tmp___0) {
      sqlite3OsClose(pPager->jfd);
    } else
    if ((int )pPager->journalMode == 3) {
      if (pPager->journalOff == 0LL) {
        rc = 0;
      } else {
        rc = sqlite3OsTruncate(pPager->jfd, (i64 )0);
        if (rc == 0) {
          if (pPager->fullSync) {
            rc = sqlite3OsSync(pPager->jfd, (int )pPager->syncFlags);
          }
        }
      }
      pPager->journalOff = (i64 )0;
    } else
    if ((int )pPager->journalMode == 1) {
      goto _L;
    } else
    if (pPager->exclusiveMode) {
      if ((int )pPager->journalMode != 5) {
        _L: /* CIL Label */ 
        if (hasMaster) {
          tmp = 1;
        } else
        if (pPager->tempFile) {
          tmp = 1;
        } else {
          tmp = 0;
        }
        rc = zeroJournalHdr(pPager, tmp);
        pPager->journalOff = (i64 )0;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      bDelete = ! pPager->tempFile;
      sqlite3OsClose(pPager->jfd);
      if (bDelete) {
        rc = sqlite3OsDelete(pPager->pVfs, (char const   *)pPager->zJournal, (int )pPager->extraSync);
      }
    }
  }
  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = (Bitvec *)0;
  pPager->nRec = 0;
  if (rc == 0) {
    if (pPager->memDb) {
      sqlite3PcacheCleanAll(pPager->pPCache);
    } else {
      tmp___1 = pagerFlushOnCommit(pPager, bCommit);
      if (tmp___1) {
        sqlite3PcacheCleanAll(pPager->pPCache);
      } else {
        sqlite3PcacheClearWritable(pPager->pPCache);
      }
    }
    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
  }
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
  } else
  if (rc == 0) {
    if (bCommit) {
      if (pPager->dbFileSize > pPager->dbSize) {
        rc = pager_truncate(pPager, pPager->dbSize);
      }
    }
  }
  if (rc == 0) {
    if (bCommit) {
      rc = sqlite3OsFileControl(pPager->fd, 22, (void *)0);
      if (rc == 12) {
        rc = 0;
      }
    }
  }
  if (! pPager->exclusiveMode) {
    if (! ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0))) {
      rc2 = pagerUnlockDb(pPager, 1);
      pPager->changeCountDone = (u8 )0;
    } else {
      tmp___2 = sqlite3WalExclusiveMode(pPager->pWal, 0);
      if (tmp___2) {
        rc2 = pagerUnlockDb(pPager, 1);
        pPager->changeCountDone = (u8 )0;
      }
    }
  }
  pPager->eState = (u8 )1;
  pPager->setMaster = (u8 )0;
  if (rc == 0) {
    tmp___3 = rc2;
  } else {
    tmp___3 = rc;
  }
  return (tmp___3);
}
}
static void pagerUnlockAndRollback(Pager *pPager ) 
{ 


  {
  if ((int )pPager->eState != 6) {
    if ((int )pPager->eState != 0) {
      if ((int )pPager->eState >= 2) {
        sqlite3BeginBenignMalloc();
        sqlite3PagerRollback(pPager);
        sqlite3EndBenignMalloc();
      } else
      if (! pPager->exclusiveMode) {
        pager_end_transaction(pPager, 0, 0);
      }
    }
  }
  pager_unlock(pPager);
  return;
}
}
static u32 pager_cksum(Pager *pPager , u8 const   *aData ) 
{ 
  u32 cksum ;
  int i ;

  {
  cksum = pPager->cksumInit;
  i = pPager->pageSize - 200;
  while (i > 0) {
    cksum += (u32 )*(aData + i);
    i -= 200;
  }
  return (cksum);
}
}
static int pager_playback_one_page(Pager *pPager , i64 *pOffset , Bitvec *pDone ,
                                   int isMainJrnl , int isSavepnt ) 
{ 
  int rc ;
  PgHdr *pPg ;
  Pgno pgno ;
  u32 cksum ;
  char *aData ;
  sqlite3_file *jfd ;
  int isSynced ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  i64 ofst ;
  void *pData ;

  {
  aData = pPager->pTmpSpace;
  if (isMainJrnl) {
    jfd = pPager->jfd;
  } else {
    jfd = pPager->sjfd;
  }
  rc = read32bits(jfd, *pOffset, & pgno);
  if (rc != 0) {
    return (rc);
  }
  rc = sqlite3OsRead(jfd, (void *)((u8 *)aData), pPager->pageSize, *pOffset + 4LL);
  if (rc != 0) {
    return (rc);
  }
  *pOffset += (i64 )((pPager->pageSize + 4) + isMainJrnl * 4);
  if (pgno == 0U) {
    return (101);
  } else
  if (pgno == (Pgno )(sqlite3PendingByte / pPager->pageSize + 1)) {
    return (101);
  }
  if (pgno > pPager->dbSize) {
    return (0);
  } else {
    tmp = sqlite3BitvecTest(pDone, pgno);
    if (tmp) {
      return (0);
    }
  }
  if (isMainJrnl) {
    rc = read32bits(jfd, *pOffset - 4LL, & cksum);
    if (rc) {
      return (rc);
    }
    if (! isSavepnt) {
      tmp___0 = pager_cksum(pPager, (u8 const   *)((u8 *)aData));
      if (tmp___0 != cksum) {
        return (101);
      }
    }
  }
  if (pDone) {
    rc = sqlite3BitvecSet(pDone, pgno);
    if (rc != 0) {
      return (rc);
    }
  }
  if (pgno == 1U) {
    if ((int )pPager->nReserve != (int )*((u8 *)aData + 20)) {
      pPager->nReserve = (i16 )*((u8 *)aData + 20);
    }
  }
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    pPg = (PgHdr *)0;
  } else {
    pPg = sqlite3PagerLookup(pPager, pgno);
  }
  if (isMainJrnl) {
    if (pPager->noSync) {
      tmp___1 = 1;
    } else
    if (*pOffset <= pPager->journalHdr) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    isSynced = tmp___1;
  } else {
    if ((unsigned long )pPg == (unsigned long )((PgHdr *)0)) {
      tmp___2 = 1;
    } else
    if (0 == ((int )pPg->flags & 8)) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    isSynced = tmp___2;
  }
  if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    if ((int )pPager->eState >= 4) {
      goto _L___1;
    } else
    if ((int )pPager->eState == 0) {
      _L___1: /* CIL Label */ 
      if (isSynced) {
        ofst = (i64 )(pgno - 1U) * (i64 )pPager->pageSize;
        rc = sqlite3OsWrite(pPager->fd, (void const   *)((u8 *)aData), pPager->pageSize,
                            ofst);
        if (pgno > pPager->dbFileSize) {
          pPager->dbFileSize = pgno;
        }
        if (pPager->pBackup) {
          sqlite3BackupUpdate(pPager->pBackup, pgno, (u8 const   *)((u8 *)aData));
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (! isMainJrnl) {
    if ((unsigned long )pPg == (unsigned long )((PgHdr *)0)) {
      pPager->doNotSpill = (u8 )((int )pPager->doNotSpill | 2);
      rc = sqlite3PagerGet(pPager, pgno, & pPg, 1);
      pPager->doNotSpill = (u8 )((int )pPager->doNotSpill & -3);
      if (rc != 0) {
        return (rc);
      }
      sqlite3PcacheMakeDirty(pPg);
    }
  }
  if (pPg) {
    pData = pPg->pData;
    memcpy((void * __restrict  )pData, (void const   * __restrict  )((u8 *)aData),
           (size_t )pPager->pageSize);
    (*(pPager->xReiniter))(pPg);
    if (pgno == 1U) {
      memcpy((void * __restrict  )(& pPager->dbFileVers), (void const   * __restrict  )((u8 *)pData + 24),
             sizeof(pPager->dbFileVers));
    }
    sqlite3PcacheRelease(pPg);
  }
  return (rc);
}
}
static int pager_delmaster(Pager *pPager , char const   *zMaster ) 
{ 
  sqlite3_vfs *pVfs ;
  int rc ;
  sqlite3_file *pMaster ;
  sqlite3_file *pJournal ;
  char *zMasterJournal ;
  i64 nMasterJournal ;
  char *zJournal ;
  char *zMasterPtr ;
  int nMasterPtr ;
  void *tmp ;
  int flags___0 ;
  void *tmp___0 ;
  int exists ;
  int c ;
  int flags___1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pVfs = pPager->pVfs;
  zMasterJournal = (char *)0;
  tmp = sqlite3MallocZero((u64 )(pVfs->szOsFile * 2));
  pMaster = (sqlite3_file *)tmp;
  pJournal = (sqlite3_file *)((u8 *)pMaster + pVfs->szOsFile);
  if (! pMaster) {
    rc = 7;
  } else {
    flags___0 = 16385;
    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags___0, (int *)0);
  }
  if (rc != 0) {
    goto delmaster_out;
  }
  rc = sqlite3OsFileSize(pMaster, & nMasterJournal);
  if (rc != 0) {
    goto delmaster_out;
  }
  nMasterPtr = pVfs->mxPathname + 1;
  tmp___0 = sqlite3Malloc((u64 )((nMasterJournal + (i64 )nMasterPtr) + 1LL));
  zMasterJournal = (char *)tmp___0;
  if (! zMasterJournal) {
    rc = 7;
    goto delmaster_out;
  }
  zMasterPtr = zMasterJournal + (nMasterJournal + 1LL);
  rc = sqlite3OsRead(pMaster, (void *)zMasterJournal, (int )nMasterJournal, (i64 )0);
  if (rc != 0) {
    goto delmaster_out;
  }
  *(zMasterJournal + nMasterJournal) = (char)0;
  zJournal = zMasterJournal;
  while ((i64 )(zJournal - zMasterJournal) < nMasterJournal) {
    rc = sqlite3OsAccess(pVfs, (char const   *)zJournal, 0, & exists);
    if (rc != 0) {
      goto delmaster_out;
    }
    if (exists) {
      flags___1 = 2049;
      rc = sqlite3OsOpen(pVfs, (char const   *)zJournal, pJournal, flags___1, (int *)0);
      if (rc != 0) {
        goto delmaster_out;
      }
      rc = readMasterJournal(pJournal, zMasterPtr, (u32 )nMasterPtr);
      sqlite3OsClose(pJournal);
      if (rc != 0) {
        goto delmaster_out;
      }
      if ((int )*(zMasterPtr + 0) != 0) {
        tmp___1 = strcmp((char const   *)zMasterPtr, zMaster);
        if (tmp___1 == 0) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      c = tmp___2;
      if (c) {
        goto delmaster_out;
      }
    }
    tmp___3 = sqlite3Strlen30((char const   *)zJournal);
    zJournal += tmp___3 + 1;
  }
  sqlite3OsClose(pMaster);
  rc = sqlite3OsDelete(pVfs, zMaster, 0);
  delmaster_out: 
  sqlite3_free((void *)zMasterJournal);
  if (pMaster) {
    sqlite3OsClose(pMaster);
    sqlite3_free((void *)pMaster);
  }
  return (rc);
}
}
static int pager_truncate(Pager *pPager , Pgno nPage ) 
{ 
  int rc ;
  i64 currentSize ;
  i64 newSize ;
  int szPage ;
  char *pTmp ;

  {
  rc = 0;
  if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    if ((int )pPager->eState >= 4) {
      goto _L;
    } else
    if ((int )pPager->eState == 0) {
      _L: /* CIL Label */ 
      szPage = pPager->pageSize;
      rc = sqlite3OsFileSize(pPager->fd, & currentSize);
      newSize = (i64 )szPage * (i64 )nPage;
      if (rc == 0) {
        if (currentSize != newSize) {
          if (currentSize > newSize) {
            rc = sqlite3OsTruncate(pPager->fd, newSize);
          } else
          if (currentSize + (i64 )szPage <= newSize) {
            pTmp = pPager->pTmpSpace;
            memset((void *)pTmp, 0, (size_t )szPage);
            rc = sqlite3OsWrite(pPager->fd, (void const   *)pTmp, szPage, newSize - (i64 )szPage);
          }
          if (rc == 0) {
            pPager->dbFileSize = nPage;
          }
        }
      }
    }
  }
  return (rc);
}
}
static int sqlite3SectorSize(sqlite3_file *pFile ) 
{ 
  int iRet ;
  int tmp ;

  {
  tmp = sqlite3OsSectorSize(pFile);
  iRet = tmp;
  if (iRet < 32) {
    iRet = 512;
  } else
  if (iRet > 65536) {
    iRet = 65536;
  }
  return (iRet);
}
}
static void setSectorSize(Pager *pPager ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (pPager->tempFile) {
    pPager->sectorSize = (u32 )512;
  } else {
    tmp___0 = sqlite3OsDeviceCharacteristics(pPager->fd);
    if ((tmp___0 & 4096) != 0) {
      pPager->sectorSize = (u32 )512;
    } else {
      tmp = sqlite3SectorSize(pPager->fd);
      pPager->sectorSize = (u32 )tmp;
    }
  }
  return;
}
}
static int pager_playback(Pager *pPager , int isHot ) 
{ 
  sqlite3_vfs *pVfs ;
  i64 szJ ;
  u32 nRec ;
  u32 u ;
  Pgno mxPg ;
  int rc ;
  int res ;
  char *zMaster ;
  int needPagerReset ;
  int nPlayback ;
  u32 savedPageSize ;

  {
  pVfs = pPager->pVfs;
  mxPg = (Pgno )0;
  res = 1;
  zMaster = (char *)0;
  nPlayback = 0;
  savedPageSize = (u32 )pPager->pageSize;
  rc = sqlite3OsFileSize(pPager->jfd, & szJ);
  if (rc != 0) {
    goto end_playback;
  }
  zMaster = pPager->pTmpSpace;
  rc = readMasterJournal(pPager->jfd, zMaster, (u32 )((pPager->pVfs)->mxPathname + 1));
  if (rc == 0) {
    if (*(zMaster + 0)) {
      rc = sqlite3OsAccess(pVfs, (char const   *)zMaster, 0, & res);
    }
  }
  zMaster = (char *)0;
  if (rc != 0) {
    goto end_playback;
  } else
  if (! res) {
    goto end_playback;
  }
  pPager->journalOff = (i64 )0;
  needPagerReset = isHot;
  while (1) {
    rc = readJournalHdr(pPager, isHot, szJ, & nRec, & mxPg);
    if (rc != 0) {
      if (rc == 101) {
        rc = 0;
      }
      goto end_playback;
    }
    if (nRec == 4294967295U) {
      nRec = (u32 )((int )((szJ - (i64 )pPager->sectorSize) / (i64 )(pPager->pageSize + 8)));
    }
    if (nRec == 0U) {
      if (! isHot) {
        if (pPager->journalHdr + (i64 )pPager->sectorSize == pPager->journalOff) {
          nRec = (u32 )((int )((szJ - pPager->journalOff) / (i64 )(pPager->pageSize + 8)));
        }
      }
    }
    if (pPager->journalOff == (i64 )pPager->sectorSize) {
      rc = pager_truncate(pPager, mxPg);
      if (rc != 0) {
        goto end_playback;
      }
      pPager->dbSize = mxPg;
    }
    u = (u32 )0;
    while (u < nRec) {
      if (needPagerReset) {
        pager_reset(pPager);
        needPagerReset = 0;
      }
      rc = pager_playback_one_page(pPager, & pPager->journalOff, (Bitvec *)0, 1, 0);
      if (rc == 0) {
        nPlayback ++;
      } else
      if (rc == 101) {
        pPager->journalOff = szJ;
        break;
      } else
      if (rc == (10 | (2 << 8))) {
        rc = 0;
        goto end_playback;
      } else {
        goto end_playback;
      }
      u ++;
    }
  }
  end_playback: 
  if (rc == 0) {
    rc = sqlite3PagerSetPagesize(pPager, & savedPageSize, -1);
  }
  pPager->changeCountDone = pPager->tempFile;
  if (rc == 0) {
    zMaster = pPager->pTmpSpace;
    rc = readMasterJournal(pPager->jfd, zMaster, (u32 )((pPager->pVfs)->mxPathname + 1));
  }
  if (rc == 0) {
    if ((int )pPager->eState >= 4) {
      rc = sqlite3PagerSync(pPager, (char const   *)0);
    } else
    if ((int )pPager->eState == 0) {
      rc = sqlite3PagerSync(pPager, (char const   *)0);
    }
  }
  if (rc == 0) {
    rc = pager_end_transaction(pPager, (int )*(zMaster + 0) != 0, 0);
  }
  if (rc == 0) {
    if (*(zMaster + 0)) {
      if (res) {
        rc = pager_delmaster(pPager, (char const   *)zMaster);
      }
    }
  }
  if (isHot) {
    if (nPlayback) {
      sqlite3_log(27 | (2 << 8), "recovered %d pages from %s", nPlayback, pPager->zJournal);
    }
  }
  setSectorSize(pPager);
  return (rc);
}
}
static int readDbPage(PgHdr *pPg ) 
{ 
  Pager *pPager ;
  int rc ;
  u32 iFrame ;
  i64 iOffset___0 ;
  u8 *dbFileVers ;

  {
  pPager = pPg->pPager;
  rc = 0;
  iFrame = (u32 )0;
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, & iFrame);
    if (rc) {
      return (rc);
    }
  }
  if (iFrame) {
    rc = sqlite3WalReadFrame(pPager->pWal, iFrame, pPager->pageSize, (u8 *)pPg->pData);
  } else {
    iOffset___0 = (i64 )(pPg->pgno - 1U) * (i64 )pPager->pageSize;
    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset___0);
    if (rc == (10 | (2 << 8))) {
      rc = 0;
    }
  }
  if (pPg->pgno == 1U) {
    if (rc) {
      memset((void *)(pPager->dbFileVers), 255, sizeof(pPager->dbFileVers));
    } else {
      dbFileVers = (u8 *)pPg->pData + 24;
      memcpy((void * __restrict  )(& pPager->dbFileVers), (void const   * __restrict  )dbFileVers,
             sizeof(pPager->dbFileVers));
    }
  }
  return (rc);
}
}
static void pager_write_changecounter(PgHdr *pPg ) 
{ 
  u32 change_counter ;
  u32 tmp ;

  {
  tmp = sqlite3Get4byte((u8 const   *)((u8 *)((pPg->pPager)->dbFileVers)));
  change_counter = tmp + 1U;
  sqlite3Put4byte((u8 *)((char *)pPg->pData) + 24, change_counter);
  sqlite3Put4byte((u8 *)((char *)pPg->pData) + 92, change_counter);
  sqlite3Put4byte((u8 *)((char *)pPg->pData) + 96, (u32 )3030000);
  return;
}
}
static int pagerUndoCallback(void *pCtx , Pgno iPg ) 
{ 
  int rc ;
  Pager *pPager ;
  PgHdr *pPg ;
  int tmp ;

  {
  rc = 0;
  pPager = (Pager *)pCtx;
  pPg = sqlite3PagerLookup(pPager, iPg);
  if (pPg) {
    tmp = sqlite3PcachePageRefcount(pPg);
    if (tmp == 1) {
      sqlite3PcacheDrop(pPg);
    } else {
      rc = readDbPage(pPg);
      if (rc == 0) {
        (*(pPager->xReiniter))(pPg);
      }
      sqlite3PagerUnrefNotNull(pPg);
    }
  }
  sqlite3BackupRestart(pPager->pBackup);
  return (rc);
}
}
static int pagerRollbackWal(Pager *pPager ) 
{ 
  int rc ;
  PgHdr *pList ;
  PgHdr *pNext ;

  {
  pPager->dbSize = pPager->dbOrigSize;
  rc = sqlite3WalUndo(pPager->pWal, & pagerUndoCallback, (void *)pPager);
  pList = sqlite3PcacheDirtyList(pPager->pPCache);
  while (1) {
    if (pList) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    pNext = pList->pDirty;
    rc = pagerUndoCallback((void *)pPager, pList->pgno);
    pList = pNext;
  }
  return (rc);
}
}
static int pagerWalFrames(Pager *pPager , PgHdr *pList , Pgno nTruncate , int isCommit ) 
{ 
  int rc ;
  int nList ;
  PgHdr *p ;
  PgHdr **ppNext ;
  PgHdr *tmp ;

  {
  if (isCommit) {
    ppNext = & pList;
    nList = 0;
    p = pList;
    while (1) {
      tmp = p;
      *ppNext = tmp;
      if (! ((unsigned long )tmp != (unsigned long )((PgHdr *)0))) {
        break;
      }
      if (p->pgno <= nTruncate) {
        ppNext = & p->pDirty;
        nList ++;
      }
      p = p->pDirty;
    }
  } else {
    nList = 1;
  }
  pPager->aStat[2] += nList;
  if (pList->pgno == 1U) {
    pager_write_changecounter(pList);
  }
  rc = sqlite3WalFrames(pPager->pWal, pPager->pageSize, pList, nTruncate, isCommit,
                        (int )pPager->walSyncFlags);
  if (rc == 0) {
    if (pPager->pBackup) {
      p = pList;
      while (p) {
        sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 const   *)((u8 *)p->pData));
        p = p->pDirty;
      }
    }
  }
  return (rc);
}
}
static int pagerBeginReadTransaction(Pager *pPager ) 
{ 
  int rc ;
  int changed ;

  {
  changed = 0;
  sqlite3WalEndReadTransaction(pPager->pWal);
  rc = sqlite3WalBeginReadTransaction(pPager->pWal, & changed);
  if (rc != 0) {
    goto _L;
  } else
  if (changed) {
    _L: /* CIL Label */ 
    pager_reset(pPager);
    if (pPager->bUseFetch) {
      sqlite3OsUnfetch(pPager->fd, (i64 )0, (void *)0);
    }
  }
  return (rc);
}
}
static int pagerPagecount(Pager *pPager , Pgno *pnPage ) 
{ 
  Pgno nPage ;
  i64 n ;
  int rc ;
  int tmp ;

  {
  nPage = sqlite3WalDbsize(pPager->pWal);
  if (nPage == 0U) {
    if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      n = (i64 )0;
      tmp = sqlite3OsFileSize(pPager->fd, & n);
      rc = tmp;
      if (rc != 0) {
        return (rc);
      }
      nPage = (Pgno )(((n + (i64 )pPager->pageSize) - 1LL) / (i64 )pPager->pageSize);
    }
  }
  if (nPage > pPager->mxPgno) {
    pPager->mxPgno = nPage;
  }
  *pnPage = nPage;
  return (0);
}
}
static int pagerOpenWalIfPresent(Pager *pPager ) 
{ 
  int rc ;
  int isWal ;
  Pgno nPage ;

  {
  rc = 0;
  if (! pPager->tempFile) {
    rc = sqlite3OsAccess(pPager->pVfs, (char const   *)pPager->zWal, 0, & isWal);
    if (rc == 0) {
      if (isWal) {
        rc = pagerPagecount(pPager, & nPage);
        if (rc) {
          return (rc);
        }
        if (nPage == 0U) {
          rc = sqlite3OsDelete(pPager->pVfs, (char const   *)pPager->zWal, 0);
        } else {
          rc = sqlite3PagerOpenWal(pPager, (int *)0);
        }
      } else
      if ((int )pPager->journalMode == 5) {
        pPager->journalMode = (u8 )0;
      }
    }
  }
  return (rc);
}
}
static int pagerPlaybackSavepoint(Pager *pPager , PagerSavepoint *pSavepoint ) 
{ 
  i64 szJ ;
  i64 iHdrOff ;
  int rc ;
  Bitvec *pDone ;
  int tmp ;
  u32 ii ;
  u32 nJRec ;
  u32 dummy___0 ;
  u32 ii___0 ;
  i64 offset ;

  {
  rc = 0;
  pDone = (Bitvec *)0;
  if (pSavepoint) {
    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);
    if (! pDone) {
      return (7);
    }
  }
  if (pSavepoint) {
    pPager->dbSize = pSavepoint->nOrig;
  } else {
    pPager->dbSize = pPager->dbOrigSize;
  }
  pPager->changeCountDone = pPager->tempFile;
  if (! pSavepoint) {
    if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
      tmp = pagerRollbackWal(pPager);
      return (tmp);
    }
  }
  szJ = pPager->journalOff;
  if (pSavepoint) {
    if (! ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0))) {
      if (pSavepoint->iHdrOffset) {
        iHdrOff = pSavepoint->iHdrOffset;
      } else {
        iHdrOff = szJ;
      }
      pPager->journalOff = pSavepoint->iOffset;
      while (1) {
        if (rc == 0) {
          if (! (pPager->journalOff < iHdrOff)) {
            break;
          }
        } else {
          break;
        }
        rc = pager_playback_one_page(pPager, & pPager->journalOff, pDone, 1, 1);
      }
    } else {
      pPager->journalOff = (i64 )0;
    }
  } else {
    pPager->journalOff = (i64 )0;
  }
  while (1) {
    if (rc == 0) {
      if (! (pPager->journalOff < szJ)) {
        break;
      }
    } else {
      break;
    }
    nJRec = (u32 )0;
    rc = readJournalHdr(pPager, 0, szJ, & nJRec, & dummy___0);
    if (nJRec == 0U) {
      if (pPager->journalHdr + (i64 )pPager->sectorSize == pPager->journalOff) {
        nJRec = (u32 )((szJ - pPager->journalOff) / (i64 )(pPager->pageSize + 8));
      }
    }
    ii = (u32 )0;
    while (1) {
      if (rc == 0) {
        if (ii < nJRec) {
          if (! (pPager->journalOff < szJ)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      rc = pager_playback_one_page(pPager, & pPager->journalOff, pDone, 1, 1);
      ii ++;
    }
  }
  if (pSavepoint) {
    offset = (i64 )pSavepoint->iSubRec * (i64 )(4 + pPager->pageSize);
    if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
    }
    ii___0 = pSavepoint->iSubRec;
    while (1) {
      if (rc == 0) {
        if (! (ii___0 < pPager->nSubRec)) {
          break;
        }
      } else {
        break;
      }
      rc = pager_playback_one_page(pPager, & offset, pDone, 0, 1);
      ii___0 ++;
    }
  }
  sqlite3BitvecDestroy(pDone);
  if (rc == 0) {
    pPager->journalOff = szJ;
  }
  return (rc);
}
}
static void sqlite3PagerSetCachesize(Pager *pPager , int mxPage ) 
{ 


  {
  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
  return;
}
}
static int sqlite3PagerSetSpillsize(Pager *pPager , int mxPage ) 
{ 
  int tmp ;

  {
  tmp = sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
  return (tmp);
}
}
static void pagerFixMaplimit(Pager *pPager ) 
{ 
  sqlite3_file *fd ;
  sqlite_int64 sz ;

  {
  fd = pPager->fd;
  if ((unsigned long )fd->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    if ((fd->pMethods)->iVersion >= 3) {
      sz = pPager->szMmap;
      pPager->bUseFetch = (u8 )(sz > 0LL);
      setGetterMethod(pPager);
      sqlite3OsFileControlHint(pPager->fd, 18, (void *)(& sz));
    }
  }
  return;
}
}
static void sqlite3PagerSetMmapLimit(Pager *pPager , sqlite_int64 szMmap ) 
{ 


  {
  pPager->szMmap = szMmap;
  pagerFixMaplimit(pPager);
  return;
}
}
static void sqlite3PagerShrink(Pager *pPager ) 
{ 


  {
  sqlite3PcacheShrink(pPager->pPCache);
  return;
}
}
static void sqlite3PagerSetFlags(Pager *pPager , unsigned int pgFlags ) 
{ 
  unsigned int level ;

  {
  level = pgFlags & 7U;
  if (pPager->tempFile) {
    pPager->noSync = (u8 )1;
    pPager->fullSync = (u8 )0;
    pPager->extraSync = (u8 )0;
  } else {
    if (level == 1U) {
      pPager->noSync = (u8 )1;
    } else {
      pPager->noSync = (u8 )0;
    }
    if (level >= 3U) {
      pPager->fullSync = (u8 )1;
    } else {
      pPager->fullSync = (u8 )0;
    }
    if (level == 4U) {
      pPager->extraSync = (u8 )1;
    } else {
      pPager->extraSync = (u8 )0;
    }
  }
  if (pPager->noSync) {
    pPager->syncFlags = (u8 )0;
  } else
  if (pgFlags & 8U) {
    pPager->syncFlags = (u8 )3;
  } else {
    pPager->syncFlags = (u8 )2;
  }
  pPager->walSyncFlags = (u8 )((int )pPager->syncFlags << 2);
  if (pPager->fullSync) {
    pPager->walSyncFlags = (u8 )((int )pPager->walSyncFlags | (int )pPager->syncFlags);
  }
  if (pgFlags & 16U) {
    if (! pPager->noSync) {
      pPager->walSyncFlags = (u8 )((int )pPager->walSyncFlags | (3 << 2));
    }
  }
  if (pgFlags & 32U) {
    pPager->doNotSpill = (u8 )((int )pPager->doNotSpill & -2);
  } else {
    pPager->doNotSpill = (u8 )((int )pPager->doNotSpill | 1);
  }
  return;
}
}
static int pagerOpentemp(Pager *pPager , sqlite3_file *pFile , int vfsFlags___0 ) 
{ 
  int rc ;

  {
  vfsFlags___0 |= 30;
  rc = sqlite3OsOpen(pPager->pVfs, (char const   *)0, pFile, vfsFlags___0, (int *)0);
  return (rc);
}
}
static void sqlite3PagerSetBusyHandler(Pager *pPager , int (*xBusyHandler)(void * ) ,
                                       void *pBusyHandlerArg ) 
{ 
  void **ap ;

  {
  pPager->xBusyHandler = xBusyHandler;
  pPager->pBusyHandlerArg = pBusyHandlerArg;
  ap = (void **)(& pPager->xBusyHandler);
  sqlite3OsFileControlHint(pPager->fd, 15, (void *)ap);
  return;
}
}
static int sqlite3PagerSetPagesize(Pager *pPager , u32 *pPageSize , int nReserve ) 
{ 
  int rc ;
  u32 pageSize ;
  char *pNew ;
  i64 nByte ;
  void *tmp ;
  int tmp___0 ;

  {
  rc = 0;
  pageSize = *pPageSize;
  if ((int )pPager->memDb == 0) {
    goto _L;
  } else
  if (pPager->dbSize == 0U) {
    _L: /* CIL Label */ 
    tmp___0 = sqlite3PcacheRefCount(pPager->pPCache);
    if (tmp___0 == 0) {
      if (pageSize) {
        if (pageSize != (u32 )pPager->pageSize) {
          pNew = (char *)((void *)0);
          nByte = (i64 )0;
          if ((int )pPager->eState > 0) {
            if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
              rc = sqlite3OsFileSize(pPager->fd, & nByte);
            }
          }
          if (rc == 0) {
            tmp = sqlite3PageMalloc((int )(pageSize + 8U));
            pNew = (char *)tmp;
            if (! pNew) {
              rc = 7;
            } else {
              memset((void *)(pNew + pageSize), 0, (size_t )8);
            }
          }
          if (rc == 0) {
            pager_reset(pPager);
            rc = sqlite3PcacheSetPageSize(pPager->pPCache, (int )pageSize);
          }
          if (rc == 0) {
            sqlite3PageFree((void *)pPager->pTmpSpace);
            pPager->pTmpSpace = pNew;
            pPager->dbSize = (Pgno )(((nByte + (i64 )pageSize) - 1LL) / (i64 )pageSize);
            pPager->pageSize = (int )pageSize;
          } else {
            sqlite3PageFree((void *)pNew);
          }
        }
      }
    }
  }
  *pPageSize = (u32 )pPager->pageSize;
  if (rc == 0) {
    if (nReserve < 0) {
      nReserve = (int )pPager->nReserve;
    }
    pPager->nReserve = (i16 )nReserve;
    pagerFixMaplimit(pPager);
  }
  return (rc);
}
}
static void *sqlite3PagerTempSpace(Pager *pPager ) 
{ 


  {
  return ((void *)pPager->pTmpSpace);
}
}
static int sqlite3PagerMaxPageCount(Pager *pPager , int mxPage ) 
{ 


  {
  if (mxPage > 0) {
    pPager->mxPgno = (Pgno )mxPage;
  }
  return ((int )pPager->mxPgno);
}
}
static int sqlite3PagerReadFileheader(Pager *pPager , int N , unsigned char *pDest ) 
{ 
  int rc ;

  {
  rc = 0;
  memset((void *)pDest, 0, (size_t )N);
  if ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    rc = sqlite3OsRead(pPager->fd, (void *)pDest, N, (i64 )0);
    if (rc == (10 | (2 << 8))) {
      rc = 0;
    }
  }
  return (rc);
}
}
static void sqlite3PagerPagecount(Pager *pPager , int *pnPage ) 
{ 


  {
  *pnPage = (int )pPager->dbSize;
  return;
}
}
static int pager_wait_on_lock(Pager *pPager , int locktype ) 
{ 
  int rc ;
  int tmp ;

  {
  while (1) {
    rc = pagerLockDb(pPager, locktype);
    if (rc == 5) {
      tmp = (*(pPager->xBusyHandler))(pPager->pBusyHandlerArg);
      if (! tmp) {
        break;
      }
    } else {
      break;
    }
  }
  return (rc);
}
}
static void sqlite3PagerTruncateImage(Pager *pPager , Pgno nPage ) 
{ 


  {
  pPager->dbSize = nPage;
  return;
}
}
static int pagerSyncHotJournal(Pager *pPager ) 
{ 
  int rc ;

  {
  rc = 0;
  if (! pPager->noSync) {
    rc = sqlite3OsSync(pPager->jfd, 2);
  }
  if (rc == 0) {
    rc = sqlite3OsFileSize(pPager->jfd, & pPager->journalHdr);
  }
  return (rc);
}
}
static int pagerAcquireMapPage(Pager *pPager , Pgno pgno , void *pData , PgHdr **ppPage ) 
{ 
  PgHdr *p ;
  void *tmp ;

  {
  if (pPager->pMmapFreelist) {
    p = pPager->pMmapFreelist;
    *ppPage = p;
    pPager->pMmapFreelist = p->pDirty;
    p->pDirty = (PgHdr *)0;
    memset(p->pExtra, 0, (size_t )8);
  } else {
    tmp = sqlite3MallocZero((u64 )(sizeof(PgHdr ) + (unsigned long )pPager->nExtra));
    p = (PgHdr *)tmp;
    *ppPage = p;
    if ((unsigned long )p == (unsigned long )((PgHdr *)0)) {
      sqlite3OsUnfetch(pPager->fd, (i64 )(pgno - 1U) * (i64 )pPager->pageSize, pData);
      return (7);
    }
    p->pExtra = (void *)(p + 1);
    p->flags = (u16 )32;
    p->nRef = (i16 )1;
    p->pPager = pPager;
  }
  p->pgno = pgno;
  p->pData = pData;
  (pPager->nMmapOut) ++;
  return (0);
}
}
static void pagerReleaseMapPage(PgHdr *pPg ) 
{ 
  Pager *pPager ;

  {
  pPager = pPg->pPager;
  (pPager->nMmapOut) --;
  pPg->pDirty = pPager->pMmapFreelist;
  pPager->pMmapFreelist = pPg;
  sqlite3OsUnfetch(pPager->fd, (i64 )(pPg->pgno - 1U) * (i64 )pPager->pageSize, pPg->pData);
  return;
}
}
static void pagerFreeMapHdrs(Pager *pPager ) 
{ 
  PgHdr *p ;
  PgHdr *pNext ;

  {
  p = pPager->pMmapFreelist;
  while (p) {
    pNext = p->pDirty;
    sqlite3_free((void *)p);
    p = pNext;
  }
  return;
}
}
static int databaseIsUnmoved(Pager *pPager ) 
{ 
  int bHasMoved ;
  int rc ;

  {
  bHasMoved = 0;
  if (pPager->tempFile) {
    return (0);
  }
  if (pPager->dbSize == 0U) {
    return (0);
  }
  rc = sqlite3OsFileControl(pPager->fd, 20, (void *)(& bHasMoved));
  if (rc == 12) {
    rc = 0;
  } else
  if (rc == 0) {
    if (bHasMoved) {
      rc = 8 | (4 << 8);
    }
  }
  return (rc);
}
}
static int sqlite3PagerClose(Pager *pPager , sqlite3 *db ) 
{ 
  u8 *pTmp ;
  u8 *a___0 ;
  int tmp ;
  int tmp___0 ;

  {
  pTmp = (u8 *)pPager->pTmpSpace;
  sqlite3BeginBenignMalloc();
  pagerFreeMapHdrs(pPager);
  pPager->exclusiveMode = (u8 )0;
  a___0 = (u8 *)0;
  if (db) {
    if (0ULL == (db->flags & 2048ULL)) {
      tmp = databaseIsUnmoved(pPager);
      if (0 == tmp) {
        a___0 = pTmp;
      }
    }
  }
  sqlite3WalClose(pPager->pWal, db, (int )pPager->walSyncFlags, pPager->pageSize,
                  a___0);
  pPager->pWal = (Wal *)0;
  pager_reset(pPager);
  if (pPager->memDb) {
    pager_unlock(pPager);
  } else {
    if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      tmp___0 = pagerSyncHotJournal(pPager);
      pager_error(pPager, tmp___0);
    }
    pagerUnlockAndRollback(pPager);
  }
  sqlite3EndBenignMalloc();
  sqlite3OsClose(pPager->jfd);
  sqlite3OsClose(pPager->fd);
  sqlite3PageFree((void *)pTmp);
  sqlite3PcacheClose(pPager->pPCache);
  sqlite3_free((void *)pPager);
  return (0);
}
}
static void sqlite3PagerRef(DbPage *pPg ) 
{ 


  {
  sqlite3PcacheRef(pPg);
  return;
}
}
static int syncJournal(Pager *pPager , int newHdr ) ;
static unsigned char const   zerobyte  =    (u8 const   )0;
static int syncJournal(Pager *pPager , int newHdr ) 
{ 
  int rc ;
  int iDc ;
  int tmp ;
  i64 iNextHdrOffset ;
  u8 aMagic[8] ;
  u8 zHeader[sizeof(aJournalMagic) + 4UL] ;
  int tmp___0 ;
  int tmp___1 ;

  {
  rc = sqlite3PagerExclusiveLock(pPager);
  if (rc != 0) {
    return (rc);
  }
  if (! pPager->noSync) {
    if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      if ((int )pPager->journalMode != 4) {
        tmp = sqlite3OsDeviceCharacteristics(pPager->fd);
        iDc = tmp;
        if (0 == (iDc & 512)) {
          memcpy((void * __restrict  )(zHeader), (void const   * __restrict  )(aJournalMagic),
                 sizeof(aJournalMagic));
          sqlite3Put4byte(& zHeader[sizeof(aJournalMagic)], (u32 )pPager->nRec);
          iNextHdrOffset = journalHdrOffset(pPager);
          rc = sqlite3OsRead(pPager->jfd, (void *)(aMagic), 8, iNextHdrOffset);
          if (rc == 0) {
            tmp___0 = memcmp((void const   *)(aMagic), (void const   *)(aJournalMagic),
                             (size_t )8);
            if (0 == tmp___0) {
              rc = sqlite3OsWrite(pPager->jfd, (void const   *)(& zerobyte), 1, iNextHdrOffset);
            }
          }
          if (rc != 0) {
            if (rc != (10 | (2 << 8))) {
              return (rc);
            }
          }
          if (pPager->fullSync) {
            if (0 == (iDc & 1024)) {
              rc = sqlite3OsSync(pPager->jfd, (int )pPager->syncFlags);
              if (rc != 0) {
                return (rc);
              }
            }
          }
          rc = sqlite3OsWrite(pPager->jfd, (void const   *)(zHeader), (int )sizeof(zHeader),
                              pPager->journalHdr);
          if (rc != 0) {
            return (rc);
          }
        }
        if (0 == (iDc & 1024)) {
          if ((int )pPager->syncFlags == 3) {
            tmp___1 = 16;
          } else {
            tmp___1 = 0;
          }
          rc = sqlite3OsSync(pPager->jfd, (int )pPager->syncFlags | tmp___1);
          if (rc != 0) {
            return (rc);
          }
        }
        pPager->journalHdr = pPager->journalOff;
        if (newHdr) {
          if (0 == (iDc & 512)) {
            pPager->nRec = 0;
            rc = writeJournalHdr(pPager);
            if (rc != 0) {
              return (rc);
            }
          }
        }
      } else {
        pPager->journalHdr = pPager->journalOff;
      }
    } else {
      pPager->journalHdr = pPager->journalOff;
    }
  }
  sqlite3PcacheClearSyncFlags(pPager->pPCache);
  pPager->eState = (u8 )4;
  return (0);
}
}
static int pager_write_pagelist(Pager *pPager , PgHdr *pList ) 
{ 
  int rc ;
  sqlite_int64 szFile ;
  Pgno pgno ;
  i64 offset ;
  char *pData ;

  {
  rc = 0;
  if (! ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
    rc = pagerOpentemp(pPager, pPager->fd, (int )pPager->vfsFlags);
  }
  if (rc == 0) {
    if (pPager->dbHintSize < pPager->dbSize) {
      if (pList->pDirty) {
        szFile = (sqlite_int64 )pPager->pageSize * (sqlite_int64 )pPager->dbSize;
        sqlite3OsFileControlHint(pPager->fd, 5, (void *)(& szFile));
        pPager->dbHintSize = pPager->dbSize;
      } else
      if (pList->pgno > pPager->dbHintSize) {
        szFile = (sqlite_int64 )pPager->pageSize * (sqlite_int64 )pPager->dbSize;
        sqlite3OsFileControlHint(pPager->fd, 5, (void *)(& szFile));
        pPager->dbHintSize = pPager->dbSize;
      }
    }
  }
  while (1) {
    if (rc == 0) {
      if (! pList) {
        break;
      }
    } else {
      break;
    }
    pgno = pList->pgno;
    if (pgno <= pPager->dbSize) {
      if (0 == ((int )pList->flags & 16)) {
        offset = (i64 )(pgno - 1U) * (i64 )pPager->pageSize;
        if (pList->pgno == 1U) {
          pager_write_changecounter(pList);
        }
        pData = (char *)pList->pData;
        rc = sqlite3OsWrite(pPager->fd, (void const   *)pData, pPager->pageSize, offset);
        if (pgno == 1U) {
          memcpy((void * __restrict  )(& pPager->dbFileVers), (void const   * __restrict  )(pData + 24),
                 sizeof(pPager->dbFileVers));
        }
        if (pgno > pPager->dbFileSize) {
          pPager->dbFileSize = pgno;
        }
        (pPager->aStat[2]) ++;
        sqlite3BackupUpdate(pPager->pBackup, pgno, (u8 const   *)((u8 *)pList->pData));
      }
    }
    pList = pList->pDirty;
  }
  return (rc);
}
}
static int openSubJournal(Pager *pPager ) 
{ 
  int rc ;
  int flags___0 ;
  int nStmtSpill ;

  {
  rc = 0;
  if (! ((unsigned long )(pPager->sjfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
    flags___0 = 8222;
    nStmtSpill = sqlite3Config.nStmtSpill;
    if ((int )pPager->journalMode == 4) {
      nStmtSpill = -1;
    } else
    if (pPager->subjInMemory) {
      nStmtSpill = -1;
    }
    rc = sqlite3JournalOpen(pPager->pVfs, (char const   *)0, pPager->sjfd, flags___0,
                            nStmtSpill);
  }
  return (rc);
}
}
static int subjournalPage(PgHdr *pPg ) 
{ 
  int rc ;
  Pager *pPager ;
  void *pData ;
  i64 offset ;
  char *pData2 ;

  {
  rc = 0;
  pPager = pPg->pPager;
  if ((int )pPager->journalMode != 2) {
    rc = openSubJournal(pPager);
    if (rc == 0) {
      pData = pPg->pData;
      offset = (i64 )pPager->nSubRec * (i64 )(4 + pPager->pageSize);
      pData2 = (char *)pData;
      rc = write32bits(pPager->sjfd, offset, pPg->pgno);
      if (rc == 0) {
        rc = sqlite3OsWrite(pPager->sjfd, (void const   *)pData2, pPager->pageSize,
                            offset + 4LL);
      }
    }
  }
  if (rc == 0) {
    (pPager->nSubRec) ++;
    rc = addToSavepointBitvecs(pPager, pPg->pgno);
  }
  return (rc);
}
}
static int subjournalPageIfRequired(PgHdr *pPg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = subjRequiresPage(pPg);
  if (tmp___0) {
    tmp = subjournalPage(pPg);
    return (tmp);
  } else {
    return (0);
  }
}
}
static int pagerStress(void *p , PgHdr *pPg ) 
{ 
  Pager *pPager ;
  int rc ;
  int tmp ;

  {
  pPager = (Pager *)p;
  rc = 0;
  if (pPager->errCode) {
    return (0);
  }
  if (pPager->doNotSpill) {
    if (((int )pPager->doNotSpill & 3) != 0) {
      return (0);
    } else
    if (((int )pPg->flags & 8) != 0) {
      return (0);
    }
  }
  (pPager->aStat[3]) ++;
  pPg->pDirty = (PgHdr *)0;
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    rc = subjournalPageIfRequired(pPg);
    if (rc == 0) {
      rc = pagerWalFrames(pPager, pPg, (Pgno )0, 0);
    }
  } else {
    if ((int )pPg->flags & 8) {
      rc = syncJournal(pPager, 1);
    } else
    if ((int )pPager->eState == 3) {
      rc = syncJournal(pPager, 1);
    }
    if (rc == 0) {
      rc = pager_write_pagelist(pPager, pPg);
    }
  }
  if (rc == 0) {
    sqlite3PcacheMakeClean(pPg);
  }
  tmp = pager_error(pPager, rc);
  return (tmp);
}
}
static int sqlite3PagerFlush(Pager *pPager ) 
{ 
  int rc ;
  PgHdr *pList ;
  PgHdr *tmp ;
  PgHdr *pNext ;

  {
  rc = pPager->errCode;
  if (! pPager->memDb) {
    tmp = sqlite3PcacheDirtyList(pPager->pPCache);
    pList = tmp;
    while (1) {
      if (rc == 0) {
        if (! pList) {
          break;
        }
      } else {
        break;
      }
      pNext = pList->pDirty;
      if ((int )pList->nRef == 0) {
        rc = pagerStress((void *)pPager, pList);
      }
      pList = pNext;
    }
  }
  return (rc);
}
}
static int sqlite3PagerOpen(sqlite3_vfs *pVfs , Pager **ppPager , char const   *zFilename ,
                            int nExtra , int flags___0 , int vfsFlags___0 , void (*xReinit)(DbPage * ) ) 
{ 
  u8 *pPtr ;
  Pager *pPager ;
  int rc ;
  int tempFile ;
  int memDb ;
  int readOnly ;
  int journalFileSize ;
  char *zPathname ;
  int nPathname ;
  int useJournal ;
  int pcacheSize ;
  int tmp ;
  u32 szPageDflt ;
  char const   *zUri ;
  int nUri ;
  int tmp___0 ;
  char const   *z ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int fout ;
  int iDc ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int (*tmp___9)(void *p , PgHdr *pPg ) ;

  {
  pPager = (Pager *)0;
  rc = 0;
  tempFile = 0;
  memDb = 0;
  readOnly = 0;
  zPathname = (char *)0;
  nPathname = 0;
  useJournal = (flags___0 & 1) == 0;
  tmp = sqlite3PcacheSize();
  pcacheSize = tmp;
  szPageDflt = (u32 )4096;
  zUri = (char const   *)0;
  nUri = 0;
  tmp___0 = sqlite3JournalSize(pVfs);
  journalFileSize = (tmp___0 + 7) & -8;
  *ppPager = (Pager *)0;
  if (flags___0 & 2) {
    memDb = 1;
    if (zFilename) {
      if (*(zFilename + 0)) {
        zPathname = sqlite3DbStrDup((sqlite3 *)0, zFilename);
        if ((unsigned long )zPathname == (unsigned long )((char *)0)) {
          return (7);
        }
        nPathname = sqlite3Strlen30((char const   *)zPathname);
        zFilename = (char const   *)0;
      }
    }
  }
  if (zFilename) {
    if (*(zFilename + 0)) {
      nPathname = pVfs->mxPathname + 1;
      tmp___1 = sqlite3DbMallocRaw((sqlite3 *)0, (u64 )(nPathname * 2));
      zPathname = (char *)tmp___1;
      if ((unsigned long )zPathname == (unsigned long )((char *)0)) {
        return (7);
      }
      *(zPathname + 0) = (char)0;
      rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
      nPathname = sqlite3Strlen30((char const   *)zPathname);
      tmp___2 = sqlite3Strlen30(zFilename);
      zUri = zFilename + (tmp___2 + 1);
      z = zUri;
      while (*z) {
        tmp___3 = sqlite3Strlen30(z);
        z += tmp___3 + 1;
        tmp___4 = sqlite3Strlen30(z);
        z += tmp___4 + 1;
      }
      nUri = (int )((z + 1) - zUri);
      if (rc == 0) {
        if (nPathname + 8 > pVfs->mxPathname) {
          rc = sqlite3CantopenError(55584);
        }
      }
      if (rc != 0) {
        sqlite3DbFree((sqlite3 *)0, (void *)zPathname);
        return (rc);
      }
    }
  }
  tmp___5 = sqlite3MallocZero((u64 )((((((((((((((sizeof(*pPager) + 7UL) & 0xfffffffffffffff8UL) + (unsigned long )((pcacheSize + 7) & -8)) + (unsigned long )((pVfs->szOsFile + 7) & -8)) + (unsigned long )(journalFileSize * 2)) + (unsigned long )nPathname) + 1UL) + (unsigned long )nUri) + (unsigned long )nPathname) + 8UL) + 2UL) + (unsigned long )nPathname) + 4UL) + 2UL));
  pPtr = (u8 *)tmp___5;
  if (! pPtr) {
    sqlite3DbFree((sqlite3 *)0, (void *)zPathname);
    return (7);
  }
  pPager = (Pager *)pPtr;
  pPtr += (sizeof(*pPager) + 7UL) & 0xfffffffffffffff8UL;
  pPager->pPCache = (PCache *)pPtr;
  pPtr += (pcacheSize + 7) & -8;
  pPager->fd = (sqlite3_file *)pPtr;
  pPtr += (pVfs->szOsFile + 7) & -8;
  pPager->sjfd = (sqlite3_file *)pPtr;
  pPtr += journalFileSize;
  pPager->jfd = (sqlite3_file *)pPtr;
  pPtr += journalFileSize;
  pPager->zFilename = (char *)pPtr;
  if (zPathname) {
    pPtr += (nPathname + 1) + nUri;
    pPager->zJournal = (char *)pPtr;
    memcpy((void * __restrict  )pPager->zFilename, (void const   * __restrict  )zPathname,
           (size_t )nPathname);
    if (nUri) {
      memcpy((void * __restrict  )(pPager->zFilename + (nPathname + 1)), (void const   * __restrict  )zUri,
             (size_t )nUri);
    }
    memcpy((void * __restrict  )pPager->zJournal, (void const   * __restrict  )zPathname,
           (size_t )nPathname);
    memcpy((void * __restrict  )(pPager->zJournal + nPathname), (void const   * __restrict  )"-journal\000",
           (size_t )10);
    pPager->zWal = pPager->zJournal + ((nPathname + 8) + 1);
    memcpy((void * __restrict  )pPager->zWal, (void const   * __restrict  )zPathname,
           (size_t )nPathname);
    memcpy((void * __restrict  )(pPager->zWal + nPathname), (void const   * __restrict  )"-wal\000",
           (size_t )5);
    sqlite3DbFree((sqlite3 *)0, (void *)zPathname);
  }
  pPager->pVfs = pVfs;
  pPager->vfsFlags = (u32 )vfsFlags___0;
  if (zFilename) {
    if (*(zFilename + 0)) {
      fout = 0;
      rc = sqlite3OsOpen(pVfs, (char const   *)pPager->zFilename, pPager->fd, vfsFlags___0,
                         & fout);
      readOnly = (fout & 1) != 0;
      if (rc == 0) {
        tmp___6 = sqlite3OsDeviceCharacteristics(pPager->fd);
        iDc = tmp___6;
        if (! readOnly) {
          setSectorSize(pPager);
          if (szPageDflt < pPager->sectorSize) {
            if (pPager->sectorSize > 8192U) {
              szPageDflt = (u32 )8192;
            } else {
              szPageDflt = pPager->sectorSize;
            }
          }
        }
        tmp___7 = sqlite3_uri_boolean(zFilename, "nolock", 0);
        pPager->noLock = (u8 )tmp___7;
        if ((iDc & 8192) != 0) {
          vfsFlags___0 |= 1;
          goto act_like_temp_file;
        } else {
          tmp___8 = sqlite3_uri_boolean(zFilename, "immutable", 0);
          if (tmp___8) {
            vfsFlags___0 |= 1;
            goto act_like_temp_file;
          }
        }
      }
    } else {
      goto act_like_temp_file;
    }
  } else {
    act_like_temp_file: 
    tempFile = 1;
    pPager->eState = (u8 )1;
    pPager->eLock = (u8 )4;
    pPager->noLock = (u8 )1;
    readOnly = vfsFlags___0 & 1;
  }
  if (rc == 0) {
    rc = sqlite3PagerSetPagesize(pPager, & szPageDflt, -1);
  }
  if (rc == 0) {
    nExtra = (nExtra + 7) & -8;
    if (! memDb) {
      tmp___9 = & pagerStress;
    } else {
      tmp___9 = (int (*)(void *p , PgHdr *pPg ))0;
    }
    rc = sqlite3PcacheOpen((int )szPageDflt, nExtra, ! memDb, tmp___9, (void *)pPager,
                           pPager->pPCache);
  }
  if (rc != 0) {
    sqlite3OsClose(pPager->fd);
    sqlite3PageFree((void *)pPager->pTmpSpace);
    sqlite3_free((void *)pPager);
    return (rc);
  }
  pPager->useJournal = (u8 )useJournal;
  pPager->mxPgno = (Pgno )1073741823;
  pPager->tempFile = (u8 )tempFile;
  pPager->exclusiveMode = (u8 )tempFile;
  pPager->changeCountDone = pPager->tempFile;
  pPager->memDb = (u8 )memDb;
  pPager->readOnly = (u8 )readOnly;
  pPager->noSync = pPager->tempFile;
  if (! pPager->noSync) {
    pPager->fullSync = (u8 )1;
    pPager->extraSync = (u8 )0;
    pPager->syncFlags = (u8 )2;
    pPager->walSyncFlags = (u8 )(2 | (2 << 2));
  }
  pPager->nExtra = (u16 )nExtra;
  pPager->journalSizeLimit = (i64 )-1;
  setSectorSize(pPager);
  if (! useJournal) {
    pPager->journalMode = (u8 )2;
  } else
  if (memDb) {
    pPager->journalMode = (u8 )4;
  }
  pPager->xReiniter = xReinit;
  setGetterMethod(pPager);
  *ppPager = pPager;
  return (0);
}
}
static int hasHotJournal(Pager *pPager , int *pExists ) 
{ 
  sqlite3_vfs *pVfs ;
  int rc ;
  int exists ;
  int jrnlOpen ;
  int locked ;
  Pgno nPage ;
  int tmp ;
  int f ;
  u8 first ;

  {
  pVfs = pPager->pVfs;
  rc = 0;
  exists = 1;
  jrnlOpen = ! (! ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)));
  *pExists = 0;
  if (! jrnlOpen) {
    rc = sqlite3OsAccess(pVfs, (char const   *)pPager->zJournal, 0, & exists);
  }
  if (rc == 0) {
    if (exists) {
      locked = 0;
      rc = sqlite3OsCheckReservedLock(pPager->fd, & locked);
      if (rc == 0) {
        if (! locked) {
          rc = pagerPagecount(pPager, & nPage);
          if (rc == 0) {
            if (nPage == 0U) {
              if (! jrnlOpen) {
                sqlite3BeginBenignMalloc();
                tmp = pagerLockDb(pPager, 2);
                if (tmp == 0) {
                  sqlite3OsDelete(pVfs, (char const   *)pPager->zJournal, 0);
                  if (! pPager->exclusiveMode) {
                    pagerUnlockDb(pPager, 1);
                  }
                }
                sqlite3EndBenignMalloc();
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (! jrnlOpen) {
                f = 2049;
                rc = sqlite3OsOpen(pVfs, (char const   *)pPager->zJournal, pPager->jfd,
                                   f, & f);
              }
              if (rc == 0) {
                first = (u8 )0;
                rc = sqlite3OsRead(pPager->jfd, (void *)(& first), 1, (i64 )0);
                if (rc == (10 | (2 << 8))) {
                  rc = 0;
                }
                if (! jrnlOpen) {
                  sqlite3OsClose(pPager->jfd);
                }
                *pExists = (int )first != 0;
              } else
              if (rc == 14) {
                *pExists = 1;
                rc = 0;
              }
            }
          }
        }
      }
    }
  }
  return (rc);
}
}
static int sqlite3PagerSharedLock(Pager *pPager ) 
{ 
  int rc ;
  int bHotJournal ;
  sqlite3_vfs *pVfs ;
  int bExists ;
  int fout ;
  int f ;
  char dbFileVers[sizeof(pPager->dbFileVers)] ;
  int tmp ;

  {
  rc = 0;
  if (! ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0))) {
    if ((int )pPager->eState == 0) {
      bHotJournal = 1;
      rc = pager_wait_on_lock(pPager, 1);
      if (rc != 0) {
        goto failed;
      }
      if ((int )pPager->eLock <= 1) {
        rc = hasHotJournal(pPager, & bHotJournal);
      }
      if (rc != 0) {
        goto failed;
      }
      if (bHotJournal) {
        if (pPager->readOnly) {
          rc = 8 | (3 << 8);
          goto failed;
        }
        rc = pagerLockDb(pPager, 4);
        if (rc != 0) {
          goto failed;
        }
        if (! ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
          pVfs = pPager->pVfs;
          rc = sqlite3OsAccess(pVfs, (char const   *)pPager->zJournal, 0, & bExists);
          if (rc == 0) {
            if (bExists) {
              fout = 0;
              f = 2050;
              rc = sqlite3OsOpen(pVfs, (char const   *)pPager->zJournal, pPager->jfd,
                                 f, & fout);
              if (rc == 0) {
                if (fout & 1) {
                  rc = sqlite3CantopenError(56039);
                  sqlite3OsClose(pPager->jfd);
                }
              }
            }
          }
        }
        if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
          rc = pagerSyncHotJournal(pPager);
          if (rc == 0) {
            rc = pager_playback(pPager, ! pPager->tempFile);
            pPager->eState = (u8 )0;
          }
        } else
        if (! pPager->exclusiveMode) {
          pagerUnlockDb(pPager, 1);
        }
        if (rc != 0) {
          pager_error(pPager, rc);
          goto failed;
        }
      }
      if (! pPager->tempFile) {
        if (pPager->hasHeldSharedLock) {
          rc = sqlite3OsRead(pPager->fd, (void *)(& dbFileVers), (int )sizeof(dbFileVers),
                             (i64 )24);
          if (rc != 0) {
            if (rc != (10 | (2 << 8))) {
              goto failed;
            }
            memset((void *)(dbFileVers), 0, sizeof(dbFileVers));
          }
          tmp = memcmp((void const   *)(pPager->dbFileVers), (void const   *)(dbFileVers),
                       sizeof(dbFileVers));
          if (tmp != 0) {
            pager_reset(pPager);
            if (pPager->bUseFetch) {
              sqlite3OsUnfetch(pPager->fd, (i64 )0, (void *)0);
            }
          }
        }
      }
      rc = pagerOpenWalIfPresent(pPager);
    }
  }
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    rc = pagerBeginReadTransaction(pPager);
  }
  if ((int )pPager->tempFile == 0) {
    if ((int )pPager->eState == 0) {
      if (rc == 0) {
        rc = pagerPagecount(pPager, & pPager->dbSize);
      }
    }
  }
  failed: 
  if (rc != 0) {
    pager_unlock(pPager);
  } else {
    pPager->eState = (u8 )1;
    pPager->hasHeldSharedLock = (u8 )1;
  }
  return (rc);
}
}
static void pagerUnlockIfUnused(Pager *pPager ) 
{ 
  int tmp ;

  {
  tmp = sqlite3PcacheRefCount(pPager->pPCache);
  if (tmp == 0) {
    pagerUnlockAndRollback(pPager);
  }
  return;
}
}
static int getPageNormal(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) 
{ 
  int rc ;
  PgHdr *pPg ;
  u8 noContent ;
  sqlite3_pcache_page *pBase ;
  int tmp ;
  DbPage *tmp___0 ;

  {
  rc = 0;
  if (pgno == 0U) {
    tmp = sqlite3CorruptError(56252);
    return (tmp);
  }
  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);
  if ((unsigned long )pBase == (unsigned long )((sqlite3_pcache_page *)0)) {
    pPg = (PgHdr *)0;
    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, & pBase);
    if (rc != 0) {
      goto pager_acquire_err;
    }
    if ((unsigned long )pBase == (unsigned long )((sqlite3_pcache_page *)0)) {
      rc = 7;
      goto pager_acquire_err;
    }
  }
  tmp___0 = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);
  *ppPage = tmp___0;
  pPg = tmp___0;
  noContent = (u8 )((flags___0 & 1) != 0);
  if (pPg->pPager) {
    if (! noContent) {
      (pPager->aStat[0]) ++;
      return (0);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (pgno > 2147483647U) {
      rc = sqlite3CorruptError(56284);
      goto pager_acquire_err;
    } else
    if (pgno == (Pgno )(sqlite3PendingByte / pPager->pageSize + 1)) {
      rc = sqlite3CorruptError(56284);
      goto pager_acquire_err;
    }
    pPg->pPager = pPager;
    if (! ((unsigned long )(pPager->fd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
      goto _L;
    } else
    if (pPager->dbSize < pgno) {
      goto _L;
    } else
    if (noContent) {
      _L: /* CIL Label */ 
      if (pgno > pPager->mxPgno) {
        rc = 13;
        goto pager_acquire_err;
      }
      if (noContent) {
        sqlite3BeginBenignMalloc();
        if (pgno <= pPager->dbOrigSize) {
          sqlite3BitvecSet(pPager->pInJournal, pgno);
        }
        addToSavepointBitvecs(pPager, pgno);
        sqlite3EndBenignMalloc();
      }
      memset(pPg->pData, 0, (size_t )pPager->pageSize);
    } else {
      (pPager->aStat[1]) ++;
      rc = readDbPage(pPg);
      if (rc != 0) {
        goto pager_acquire_err;
      }
    }
  }
  return (0);
  pager_acquire_err: ;
  if (pPg) {
    sqlite3PcacheDrop(pPg);
  }
  pagerUnlockIfUnused(pPager);
  *ppPage = (DbPage *)0;
  return (rc);
}
}
static int getPageMMap(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) 
{ 
  int rc ;
  PgHdr *pPg ;
  u32 iFrame ;
  int bMmapOk ;
  int tmp ;
  int tmp___0 ;
  void *pData ;
  int tmp___1 ;

  {
  rc = 0;
  pPg = (PgHdr *)0;
  iFrame = (u32 )0;
  if (pgno > 1U) {
    if ((int )pPager->eState == 1) {
      tmp = 1;
    } else
    if (flags___0 & 2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  bMmapOk = tmp;
  if (pgno <= 1U) {
    if (pgno == 0U) {
      tmp___0 = sqlite3CorruptError(56366);
      return (tmp___0);
    }
  }
  if (bMmapOk) {
    if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
      rc = sqlite3WalFindFrame(pPager->pWal, pgno, & iFrame);
      if (rc != 0) {
        *ppPage = (DbPage *)0;
        return (rc);
      }
    }
  }
  if (bMmapOk) {
    if (iFrame == 0U) {
      pData = (void *)0;
      rc = sqlite3OsFetch(pPager->fd, (i64 )(pgno - 1U) * (i64 )pPager->pageSize,
                          pPager->pageSize, & pData);
      if (rc == 0) {
        if (pData) {
          if ((int )pPager->eState > 1) {
            pPg = sqlite3PagerLookup(pPager, pgno);
          } else
          if (pPager->tempFile) {
            pPg = sqlite3PagerLookup(pPager, pgno);
          }
          if ((unsigned long )pPg == (unsigned long )((PgHdr *)0)) {
            rc = pagerAcquireMapPage(pPager, pgno, pData, & pPg);
          } else {
            sqlite3OsUnfetch(pPager->fd, (i64 )(pgno - 1U) * (i64 )pPager->pageSize,
                             pData);
          }
          if (pPg) {
            *ppPage = pPg;
            return (0);
          }
        }
      }
      if (rc != 0) {
        *ppPage = (DbPage *)0;
        return (rc);
      }
    }
  }
  tmp___1 = getPageNormal(pPager, pgno, ppPage, flags___0);
  return (tmp___1);
}
}
static int getPageError(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) 
{ 


  {
  *ppPage = (DbPage *)0;
  return (pPager->errCode);
}
}
static int sqlite3PagerGet(Pager *pPager , Pgno pgno , DbPage **ppPage , int flags___0 ) 
{ 
  int tmp ;

  {
  tmp = (*(pPager->xGet))(pPager, pgno, ppPage, flags___0);
  return (tmp);
}
}
static DbPage *sqlite3PagerLookup(Pager *pPager , Pgno pgno ) 
{ 
  sqlite3_pcache_page *pPage ;
  PgHdr *tmp ;

  {
  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
  if ((unsigned long )pPage == (unsigned long )((sqlite3_pcache_page *)0)) {
    return ((DbPage *)0);
  }
  tmp = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
  return (tmp);
}
}
static void sqlite3PagerUnrefNotNull(DbPage *pPg ) 
{ 


  {
  if ((int )pPg->flags & 32) {
    pagerReleaseMapPage(pPg);
  } else {
    sqlite3PcacheRelease(pPg);
  }
  return;
}
}
static void sqlite3PagerUnref(DbPage *pPg ) 
{ 


  {
  if (pPg) {
    sqlite3PagerUnrefNotNull(pPg);
  }
  return;
}
}
static void sqlite3PagerUnrefPageOne(DbPage *pPg ) 
{ 
  Pager *pPager ;

  {
  pPager = pPg->pPager;
  sqlite3PcacheRelease(pPg);
  pagerUnlockIfUnused(pPager);
  return;
}
}
static int pager_open_journal(Pager *pPager ) 
{ 
  int rc ;
  sqlite3_vfs *pVfs ;
  int flags___0 ;
  int nSpill ;

  {
  rc = 0;
  pVfs = pPager->pVfs;
  if (pPager->errCode) {
    return (pPager->errCode);
  }
  if (! ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0))) {
    if ((int )pPager->journalMode != 2) {
      pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
      if ((unsigned long )pPager->pInJournal == (unsigned long )((Bitvec *)0)) {
        return (7);
      }
      if (! ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
        if ((int )pPager->journalMode == 4) {
          sqlite3MemJournalOpen(pPager->jfd);
        } else {
          flags___0 = 6;
          if (pPager->tempFile) {
            flags___0 |= 4104;
            nSpill = sqlite3Config.nStmtSpill;
          } else {
            flags___0 |= 2048;
            nSpill = jrnlBufferSize(pPager);
          }
          rc = databaseIsUnmoved(pPager);
          if (rc == 0) {
            rc = sqlite3JournalOpen(pVfs, (char const   *)pPager->zJournal, pPager->jfd,
                                    flags___0, nSpill);
          }
        }
      }
      if (rc == 0) {
        pPager->nRec = 0;
        pPager->journalOff = (i64 )0;
        pPager->setMaster = (u8 )0;
        pPager->journalHdr = (i64 )0;
        rc = writeJournalHdr(pPager);
      }
    }
  }
  if (rc != 0) {
    sqlite3BitvecDestroy(pPager->pInJournal);
    pPager->pInJournal = (Bitvec *)0;
  } else {
    pPager->eState = (u8 )3;
  }
  return (rc);
}
}
static int sqlite3PagerBegin(Pager *pPager , int exFlag , int subjInMemory ) 
{ 
  int rc ;
  int tmp ;

  {
  rc = 0;
  if (pPager->errCode) {
    return (pPager->errCode);
  }
  pPager->subjInMemory = (u8 )subjInMemory;
  if ((int )pPager->eState == 1) {
    if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
      if (pPager->exclusiveMode) {
        tmp = sqlite3WalExclusiveMode(pPager->pWal, -1);
        if (tmp) {
          rc = pagerLockDb(pPager, 4);
          if (rc != 0) {
            return (rc);
          }
          sqlite3WalExclusiveMode(pPager->pWal, 1);
        }
      }
      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
    } else {
      rc = pagerLockDb(pPager, 2);
      if (rc == 0) {
        if (exFlag) {
          rc = pager_wait_on_lock(pPager, 4);
        }
      }
    }
    if (rc == 0) {
      pPager->eState = (u8 )2;
      pPager->dbHintSize = pPager->dbSize;
      pPager->dbFileSize = pPager->dbSize;
      pPager->dbOrigSize = pPager->dbSize;
      pPager->journalOff = (i64 )0;
    }
  }
  return (rc);
}
}
static int ( __attribute__((__noinline__)) pagerAddPageToRollbackJournal)(PgHdr *pPg ) 
{ 
  Pager *pPager ;
  int rc ;
  u32 cksum ;
  char *pData2 ;
  i64 iOff ;
  int tmp ;

  {
  pPager = pPg->pPager;
  iOff = pPager->journalOff;
  pData2 = (char *)pPg->pData;
  cksum = pager_cksum(pPager, (u8 const   *)((u8 *)pData2));
  pPg->flags = (u16 )((int )pPg->flags | 8);
  rc = write32bits(pPager->jfd, iOff, pPg->pgno);
  if (rc != 0) {
    return (rc);
  }
  rc = sqlite3OsWrite(pPager->jfd, (void const   *)pData2, pPager->pageSize, iOff + 4LL);
  if (rc != 0) {
    return (rc);
  }
  rc = write32bits(pPager->jfd, (iOff + (i64 )pPager->pageSize) + 4LL, cksum);
  if (rc != 0) {
    return (rc);
  }
  pPager->journalOff += (i64 )(8 + pPager->pageSize);
  (pPager->nRec) ++;
  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
  tmp = addToSavepointBitvecs(pPager, pPg->pgno);
  rc |= tmp;
  return (rc);
}
}
static int pager_write(PgHdr *pPg ) 
{ 
  Pager *pPager ;
  int rc ;
  int tmp ;

  {
  pPager = pPg->pPager;
  rc = 0;
  if ((int )pPager->eState == 2) {
    rc = pager_open_journal(pPager);
    if (rc != 0) {
      return (rc);
    }
  }
  sqlite3PcacheMakeDirty(pPg);
  if ((unsigned long )pPager->pInJournal != (unsigned long )((Bitvec *)0)) {
    tmp = sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno);
    if (tmp == 0) {
      if (pPg->pgno <= pPager->dbOrigSize) {
        rc = pagerAddPageToRollbackJournal(pPg);
        if (rc != 0) {
          return (rc);
        }
      } else
      if ((int )pPager->eState != 4) {
        pPg->flags = (u16 )((int )pPg->flags | 8);
      }
    }
  }
  pPg->flags = (u16 )((int )pPg->flags | 4);
  if (pPager->nSavepoint > 0) {
    rc = subjournalPageIfRequired(pPg);
  }
  if (pPager->dbSize < pPg->pgno) {
    pPager->dbSize = pPg->pgno;
  }
  return (rc);
}
}
static int ( __attribute__((__noinline__)) pagerWriteLargeSector)(PgHdr *pPg ) 
{ 
  int rc ;
  Pgno nPageCount ;
  Pgno pg1 ;
  int nPage ;
  int ii ;
  int needSync ;
  Pager *pPager ;
  Pgno nPagePerSector ;
  Pgno pg ;
  PgHdr *pPage ;
  int tmp ;
  PgHdr *pPage___0 ;
  DbPage *tmp___0 ;

  {
  rc = 0;
  nPage = 0;
  needSync = 0;
  pPager = pPg->pPager;
  nPagePerSector = pPager->sectorSize / (u32 )pPager->pageSize;
  pPager->doNotSpill = (u8 )((int )pPager->doNotSpill | 4);
  pg1 = ((pPg->pgno - 1U) & ~ (nPagePerSector - 1U)) + 1U;
  nPageCount = pPager->dbSize;
  if (pPg->pgno > nPageCount) {
    nPage = (int )((pPg->pgno - pg1) + 1U);
  } else
  if ((pg1 + nPagePerSector) - 1U > nPageCount) {
    nPage = (int )((nPageCount + 1U) - pg1);
  } else {
    nPage = (int )nPagePerSector;
  }
  ii = 0;
  while (1) {
    if (ii < nPage) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    pg = pg1 + (Pgno )ii;
    if (pg == pPg->pgno) {
      goto _L;
    } else {
      tmp = sqlite3BitvecTest(pPager->pInJournal, pg);
      if (tmp) {
        pPage = sqlite3PagerLookup(pPager, pg);
        if ((unsigned long )pPage != (unsigned long )((PgHdr *)0)) {
          if ((int )pPage->flags & 8) {
            needSync = 1;
          }
          sqlite3PagerUnrefNotNull(pPage);
        }
      } else
      _L: /* CIL Label */ 
      if (pg != (Pgno )(sqlite3PendingByte / pPager->pageSize + 1)) {
        rc = sqlite3PagerGet(pPager, pg, & pPage, 0);
        if (rc == 0) {
          rc = pager_write(pPage);
          if ((int )pPage->flags & 8) {
            needSync = 1;
          }
          sqlite3PagerUnrefNotNull(pPage);
        }
      }
    }
    ii ++;
  }
  if (rc == 0) {
    if (needSync) {
      ii = 0;
      while (ii < nPage) {
        tmp___0 = sqlite3PagerLookup(pPager, pg1 + (Pgno )ii);
        pPage___0 = tmp___0;
        if (pPage___0) {
          pPage___0->flags = (u16 )((int )pPage___0->flags | 8);
          sqlite3PagerUnrefNotNull(pPage___0);
        }
        ii ++;
      }
    }
  }
  pPager->doNotSpill = (u8 )((int )pPager->doNotSpill & -5);
  return (rc);
}
}
static int sqlite3PagerWrite(struct PgHdr *pPg ) 
{ 
  Pager *pPager ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pPager = pPg->pPager;
  if (((int )pPg->flags & 4) != 0) {
    if (pPager->dbSize >= pPg->pgno) {
      if (pPager->nSavepoint) {
        tmp = subjournalPageIfRequired(pPg);
        return (tmp);
      }
      return (0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (pPager->errCode) {
    return (pPager->errCode);
  } else
  if (pPager->sectorSize > (u32 )pPager->pageSize) {
    tmp___0 = pagerWriteLargeSector(pPg);
    return (tmp___0);
  } else {
    tmp___1 = pager_write(pPg);
    return (tmp___1);
  }
}
}
static void sqlite3PagerDontWrite(struct PgHdr *pPg ) 
{ 
  Pager *pPager ;

  {
  pPager = pPg->pPager;
  if (! pPager->tempFile) {
    if ((int )pPg->flags & 2) {
      if (pPager->nSavepoint == 0) {
        pPg->flags = (u16 )((int )pPg->flags | 16);
        pPg->flags = (u16 )((int )pPg->flags & -5);
      }
    }
  }
  return;
}
}
static int pager_incr_changecounter(Pager *pPager , int isDirectMode ) 
{ 
  int rc ;
  PgHdr *pPgHdr ;

  {
  rc = 0;
  if (! pPager->changeCountDone) {
    if (pPager->dbSize > 0U) {
      rc = sqlite3PagerGet(pPager, (Pgno )1, & pPgHdr, 0);
      if (rc == 0) {
        rc = sqlite3PagerWrite(pPgHdr);
      }
      if (rc == 0) {
        pager_write_changecounter(pPgHdr);
        pPager->changeCountDone = (u8 )1;
      }
      sqlite3PagerUnref(pPgHdr);
    }
  }
  return (rc);
}
}
static int sqlite3PagerSync(Pager *pPager , char const   *zMaster ) 
{ 
  int rc ;
  void *pArg ;

  {
  rc = 0;
  pArg = (void *)zMaster;
  rc = sqlite3OsFileControl(pPager->fd, 21, pArg);
  if (rc == 12) {
    rc = 0;
  }
  if (rc == 0) {
    if (! pPager->noSync) {
      rc = sqlite3OsSync(pPager->fd, (int )pPager->syncFlags);
    }
  }
  return (rc);
}
}
static int sqlite3PagerExclusiveLock(Pager *pPager ) 
{ 
  int rc ;

  {
  rc = pPager->errCode;
  if (rc == 0) {
    if (0 == ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0))) {
      rc = pager_wait_on_lock(pPager, 4);
    }
  }
  return (rc);
}
}
static int sqlite3PagerCommitPhaseOne(Pager *pPager , char const   *zMaster , int noSync ) 
{ 
  int rc ;
  int tmp ;
  PgHdr *pList ;
  PgHdr *pPageOne ;
  Pgno nNew ;
  int tmp___0 ;

  {
  rc = 0;
  if (pPager->errCode) {
    return (pPager->errCode);
  }
  tmp = sqlite3FaultSim(400);
  if (tmp) {
    return (10);
  }
  if ((int )pPager->eState < 3) {
    return (0);
  }
  tmp___0 = pagerFlushOnCommit(pPager, 1);
  if (0 == tmp___0) {
    sqlite3BackupRestart(pPager->pBackup);
  } else
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    pPageOne = (PgHdr *)0;
    pList = sqlite3PcacheDirtyList(pPager->pPCache);
    if ((unsigned long )pList == (unsigned long )((PgHdr *)0)) {
      rc = sqlite3PagerGet(pPager, (Pgno )1, & pPageOne, 0);
      pList = pPageOne;
      pList->pDirty = (PgHdr *)0;
    }
    if (pList) {
      rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
    }
    sqlite3PagerUnref(pPageOne);
    if (rc == 0) {
      sqlite3PcacheCleanAll(pPager->pPCache);
    }
  } else {
    rc = pager_incr_changecounter(pPager, 0);
    if (rc != 0) {
      goto commit_phase_one_exit;
    }
    rc = writeMasterJournal(pPager, zMaster);
    if (rc != 0) {
      goto commit_phase_one_exit;
    }
    rc = syncJournal(pPager, 0);
    if (rc != 0) {
      goto commit_phase_one_exit;
    }
    pList = sqlite3PcacheDirtyList(pPager->pPCache);
    rc = pager_write_pagelist(pPager, pList);
    if (rc != 0) {
      goto commit_phase_one_exit;
    }
    sqlite3PcacheCleanAll(pPager->pPCache);
    if (pPager->dbSize > pPager->dbFileSize) {
      nNew = pPager->dbSize - (Pgno )(pPager->dbSize == (Pgno )(sqlite3PendingByte / pPager->pageSize + 1));
      rc = pager_truncate(pPager, nNew);
      if (rc != 0) {
        goto commit_phase_one_exit;
      }
    }
    if (! noSync) {
      rc = sqlite3PagerSync(pPager, zMaster);
    }
  }
  commit_phase_one_exit: 
  if (rc == 0) {
    if (! ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0))) {
      pPager->eState = (u8 )5;
    }
  }
  return (rc);
}
}
static int sqlite3PagerCommitPhaseTwo(Pager *pPager ) 
{ 
  int rc ;
  int tmp ;

  {
  rc = 0;
  if (pPager->errCode) {
    return (pPager->errCode);
  }
  if ((int )pPager->eState == 2) {
    if (pPager->exclusiveMode) {
      if ((int )pPager->journalMode == 1) {
        pPager->eState = (u8 )1;
        return (0);
      }
    }
  }
  (pPager->iDataVersion) ++;
  rc = pager_end_transaction(pPager, (int )pPager->setMaster, 1);
  tmp = pager_error(pPager, rc);
  return (tmp);
}
}
static int sqlite3PagerRollback(Pager *pPager ) 
{ 
  int rc ;
  int rc2 ;
  int eState ;
  int tmp ;

  {
  rc = 0;
  if ((int )pPager->eState == 6) {
    return (pPager->errCode);
  }
  if ((int )pPager->eState <= 1) {
    return (0);
  }
  if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
    rc = sqlite3PagerSavepoint(pPager, 2, -1);
    rc2 = pager_end_transaction(pPager, (int )pPager->setMaster, 0);
    if (rc == 0) {
      rc = rc2;
    }
  } else
  if (! ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0))) {
    goto _L;
  } else
  if ((int )pPager->eState == 2) {
    _L: /* CIL Label */ 
    eState = (int )pPager->eState;
    rc = pager_end_transaction(pPager, 0, 0);
    if (! pPager->memDb) {
      if (eState > 2) {
        pPager->errCode = 4;
        pPager->eState = (u8 )6;
        setGetterMethod(pPager);
        return (rc);
      }
    }
  } else {
    rc = pager_playback(pPager, 0);
  }
  tmp = pager_error(pPager, rc);
  return (tmp);
}
}
static u8 sqlite3PagerIsreadonly(Pager *pPager ) 
{ 


  {
  return (pPager->readOnly);
}
}
static int sqlite3PagerMemUsed(Pager *pPager ) 
{ 
  int perPageSize ;
  int tmp ;
  int tmp___0 ;

  {
  perPageSize = (int )(((unsigned long )(pPager->pageSize + (int )pPager->nExtra) + sizeof(PgHdr )) + 5UL * sizeof(void *));
  tmp = sqlite3PcachePagecount(pPager->pPCache);
  tmp___0 = sqlite3MallocSize((void *)pPager);
  return ((perPageSize * tmp + tmp___0) + pPager->pageSize);
}
}
static int sqlite3PagerPageRefcount(DbPage *pPage ) 
{ 
  int tmp ;

  {
  tmp = sqlite3PcachePageRefcount(pPage);
  return (tmp);
}
}
static void sqlite3PagerCacheStat(Pager *pPager , int eStat , int reset , int *pnVal ) 
{ 


  {
  eStat -= 7;
  *pnVal += pPager->aStat[eStat];
  if (reset) {
    pPager->aStat[eStat] = 0;
  }
  return;
}
}
static int sqlite3PagerIsMemdb(Pager *pPager ) 
{ 


  {
  return ((int )pPager->tempFile);
}
}
static int ( __attribute__((__noinline__)) pagerOpenSavepoint)(Pager *pPager , int nSavepoint ) 
{ 
  int rc ;
  int nCurrent ;
  int ii ;
  PagerSavepoint *aNew ;
  void *tmp ;

  {
  rc = 0;
  nCurrent = pPager->nSavepoint;
  tmp = sqlite3Realloc((void *)pPager->aSavepoint, (u64 )(sizeof(PagerSavepoint ) * (unsigned long )nSavepoint));
  aNew = (PagerSavepoint *)tmp;
  if (! aNew) {
    return (7);
  }
  memset((void *)(aNew + nCurrent), 0, (unsigned long )(nSavepoint - nCurrent) * sizeof(PagerSavepoint ));
  pPager->aSavepoint = aNew;
  ii = nCurrent;
  while (ii < nSavepoint) {
    (aNew + ii)->nOrig = pPager->dbSize;
    if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      if (pPager->journalOff > 0LL) {
        (aNew + ii)->iOffset = pPager->journalOff;
      } else {
        (aNew + ii)->iOffset = (i64 )pPager->sectorSize;
      }
    } else {
      (aNew + ii)->iOffset = (i64 )pPager->sectorSize;
    }
    (aNew + ii)->iSubRec = pPager->nSubRec;
    (aNew + ii)->pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
    if (! (aNew + ii)->pInSavepoint) {
      return (7);
    }
    if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
      sqlite3WalSavepoint(pPager->pWal, (aNew + ii)->aWalData);
    }
    pPager->nSavepoint = ii + 1;
    ii ++;
  }
  return (rc);
}
}
static int sqlite3PagerOpenSavepoint(Pager *pPager , int nSavepoint ) 
{ 
  int tmp ;

  {
  if (nSavepoint > pPager->nSavepoint) {
    if (pPager->useJournal) {
      tmp = pagerOpenSavepoint(pPager, nSavepoint);
      return (tmp);
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
static int sqlite3PagerSavepoint(Pager *pPager , int op , int iSavepoint ) 
{ 
  int rc ;
  int ii ;
  int nNew ;
  int tmp ;
  int tmp___0 ;
  PagerSavepoint *pSavepoint ;
  PagerSavepoint *tmp___1 ;

  {
  rc = pPager->errCode;
  if (rc == 0) {
    if (iSavepoint < pPager->nSavepoint) {
      if (op == 1) {
        tmp = 0;
      } else {
        tmp = 1;
      }
      nNew = iSavepoint + tmp;
      ii = nNew;
      while (ii < pPager->nSavepoint) {
        sqlite3BitvecDestroy((pPager->aSavepoint + ii)->pInSavepoint);
        ii ++;
      }
      pPager->nSavepoint = nNew;
      if (op == 1) {
        if (nNew == 0) {
          if ((unsigned long )(pPager->sjfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
            tmp___0 = sqlite3JournalIsInMemory(pPager->sjfd);
            if (tmp___0) {
              rc = sqlite3OsTruncate(pPager->sjfd, (i64 )0);
            }
            pPager->nSubRec = (u32 )0;
          }
        }
      } else
      if ((unsigned long )pPager->pWal != (unsigned long )((Wal *)0)) {
        goto _L;
      } else
      if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
        _L: /* CIL Label */ 
        if (nNew == 0) {
          tmp___1 = (PagerSavepoint *)0;
        } else {
          tmp___1 = pPager->aSavepoint + (nNew - 1);
        }
        pSavepoint = tmp___1;
        rc = pagerPlaybackSavepoint(pPager, pSavepoint);
      }
    }
  }
  return (rc);
}
}
static char const   *sqlite3PagerFilename(Pager *pPager , int nullIfMemDb ) 
{ 
  char const   *tmp ;

  {
  if (nullIfMemDb) {
    if (pPager->memDb) {
      tmp = "";
    } else {
      tmp = (char const   *)pPager->zFilename;
    }
  } else {
    tmp = (char const   *)pPager->zFilename;
  }
  return (tmp);
}
}
static sqlite3_vfs *sqlite3PagerVfs(Pager *pPager ) 
{ 


  {
  return (pPager->pVfs);
}
}
static sqlite3_file *sqlite3PagerFile(Pager *pPager ) 
{ 


  {
  return (pPager->fd);
}
}
static sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager ) 
{ 
  sqlite3_file *tmp ;
  sqlite3_file *tmp___0 ;

  {
  if (pPager->pWal) {
    tmp = sqlite3WalFile(pPager->pWal);
    tmp___0 = tmp;
  } else {
    tmp___0 = pPager->jfd;
  }
  return (tmp___0);
}
}
static char const   *sqlite3PagerJournalname(Pager *pPager ) 
{ 


  {
  return ((char const   *)pPager->zJournal);
}
}
static int sqlite3PagerMovepage(Pager *pPager , DbPage *pPg , Pgno pgno , int isCommit ) 
{ 
  PgHdr *pPgOld ;
  Pgno needSyncPgno ;
  int rc ;
  Pgno origPgno ;
  int tmp ;
  PgHdr *pPgHdr ;

  {
  needSyncPgno = (Pgno )0;
  if (pPager->tempFile) {
    rc = sqlite3PagerWrite(pPg);
    if (rc) {
      return (rc);
    }
  }
  if (((int )pPg->flags & 2) != 0) {
    rc = subjournalPageIfRequired(pPg);
    if (0 != rc) {
      return (rc);
    }
  }
  if ((int )pPg->flags & 8) {
    if (! isCommit) {
      needSyncPgno = pPg->pgno;
    }
  }
  pPg->flags = (u16 )((int )pPg->flags & -9);
  pPgOld = sqlite3PagerLookup(pPager, pgno);
  if (pPgOld) {
    if ((int )pPgOld->nRef > 1) {
      sqlite3PagerUnrefNotNull(pPgOld);
      tmp = sqlite3CorruptError(57956);
      return (tmp);
    }
    pPg->flags = (u16 )((int )pPg->flags | ((int )pPgOld->flags & 8));
    if (pPager->tempFile) {
      sqlite3PcacheMove(pPgOld, pPager->dbSize + 1U);
    } else {
      sqlite3PcacheDrop(pPgOld);
    }
  }
  origPgno = pPg->pgno;
  sqlite3PcacheMove(pPg, pgno);
  sqlite3PcacheMakeDirty(pPg);
  if (pPager->tempFile) {
    if (pPgOld) {
      sqlite3PcacheMove(pPgOld, origPgno);
      sqlite3PagerUnrefNotNull(pPgOld);
    }
  }
  if (needSyncPgno) {
    rc = sqlite3PagerGet(pPager, needSyncPgno, & pPgHdr, 0);
    if (rc != 0) {
      if (needSyncPgno <= pPager->dbOrigSize) {
        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, (void *)pPager->pTmpSpace);
      }
      return (rc);
    }
    pPgHdr->flags = (u16 )((int )pPgHdr->flags | 8);
    sqlite3PcacheMakeDirty(pPgHdr);
    sqlite3PagerUnrefNotNull(pPgHdr);
  }
  return (0);
}
}
static void sqlite3PagerRekey(DbPage *pPg , Pgno iNew , u16 flags___0 ) 
{ 


  {
  pPg->flags = flags___0;
  sqlite3PcacheMove(pPg, iNew);
  return;
}
}
static void *sqlite3PagerGetData(DbPage *pPg ) 
{ 


  {
  return (pPg->pData);
}
}
static void *sqlite3PagerGetExtra(DbPage *pPg ) 
{ 


  {
  return (pPg->pExtra);
}
}
static int sqlite3PagerLockingMode(Pager *pPager , int eMode ) 
{ 
  int tmp ;

  {
  if (eMode >= 0) {
    if (! pPager->tempFile) {
      tmp = sqlite3WalHeapMemory(pPager->pWal);
      if (! tmp) {
        pPager->exclusiveMode = (u8 )eMode;
      }
    }
  }
  return ((int )pPager->exclusiveMode);
}
}
static int sqlite3PagerSetJournalMode(Pager *pPager , int eMode ) 
{ 
  u8 eOld ;
  int rc ;
  int state ;

  {
  eOld = pPager->journalMode;
  if (pPager->memDb) {
    if (eMode != 4) {
      if (eMode != 2) {
        eMode = (int )eOld;
      }
    }
  }
  if (eMode != (int )eOld) {
    pPager->journalMode = (u8 )eMode;
    if (! pPager->exclusiveMode) {
      if (((int )eOld & 5) == 1) {
        if ((eMode & 1) == 0) {
          sqlite3OsClose(pPager->jfd);
          if ((int )pPager->eLock >= 2) {
            sqlite3OsDelete(pPager->pVfs, (char const   *)pPager->zJournal, 0);
          } else {
            rc = 0;
            state = (int )pPager->eState;
            if (state == 0) {
              rc = sqlite3PagerSharedLock(pPager);
            }
            if ((int )pPager->eState == 1) {
              rc = pagerLockDb(pPager, 2);
            }
            if (rc == 0) {
              sqlite3OsDelete(pPager->pVfs, (char const   *)pPager->zJournal, 0);
            }
            if (rc == 0) {
              if (state == 1) {
                pagerUnlockDb(pPager, 1);
              } else {
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
            if (state == 0) {
              pager_unlock(pPager);
            }
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (eMode == 2) {
      sqlite3OsClose(pPager->jfd);
    }
  }
  return ((int )pPager->journalMode);
}
}
static int sqlite3PagerGetJournalMode(Pager *pPager ) 
{ 


  {
  return ((int )pPager->journalMode);
}
}
static int sqlite3PagerOkToChangeJournalMode(Pager *pPager ) 
{ 


  {
  if ((int )pPager->eState >= 3) {
    return (0);
  }
  if ((unsigned long )(pPager->jfd)->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
    if (pPager->journalOff > 0LL) {
      return (0);
    }
  }
  return (1);
}
}
static i64 sqlite3PagerJournalSizeLimit(Pager *pPager , i64 iLimit ) 
{ 


  {
  if (iLimit >= -1LL) {
    pPager->journalSizeLimit = iLimit;
    sqlite3WalLimit(pPager->pWal, iLimit);
  }
  return (pPager->journalSizeLimit);
}
}
static sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager ) 
{ 


  {
  return (& pPager->pBackup);
}
}
static void sqlite3PagerClearCache(Pager *pPager ) 
{ 


  {
  if ((int )pPager->tempFile == 0) {
    pager_reset(pPager);
  }
  return;
}
}
static int sqlite3PagerCheckpoint(Pager *pPager , sqlite3 *db , int eMode , int *pnLog ,
                                  int *pnCkpt ) 
{ 
  int rc ;
  int (*tmp)(void * ) ;

  {
  rc = 0;
  if (pPager->pWal) {
    if (eMode == 0) {
      tmp = (int (*)(void * ))0;
    } else {
      tmp = pPager->xBusyHandler;
    }
    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode, tmp, pPager->pBusyHandlerArg,
                              (int )pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
                              pnLog, pnCkpt);
  }
  return (rc);
}
}
static int sqlite3PagerWalCallback(Pager *pPager ) 
{ 
  int tmp ;

  {
  tmp = sqlite3WalCallback(pPager->pWal);
  return (tmp);
}
}
static int sqlite3PagerWalSupported(Pager *pPager ) 
{ 
  sqlite3_io_methods const   *pMethods ;
  int tmp ;

  {
  pMethods = (pPager->fd)->pMethods;
  if (pPager->noLock) {
    return (0);
  }
  if (pPager->exclusiveMode) {
    tmp = 1;
  } else
  if (pMethods->iVersion >= 2) {
    if (pMethods->xShmMap) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int pagerExclusiveLock(Pager *pPager ) 
{ 
  int rc ;

  {
  rc = pagerLockDb(pPager, 4);
  if (rc != 0) {
    pagerUnlockDb(pPager, 1);
  }
  return (rc);
}
}
static int pagerOpenWal(Pager *pPager ) 
{ 
  int rc ;

  {
  rc = 0;
  if (pPager->exclusiveMode) {
    rc = pagerExclusiveLock(pPager);
  }
  if (rc == 0) {
    rc = sqlite3WalOpen(pPager->pVfs, pPager->fd, (char const   *)pPager->zWal, (int )pPager->exclusiveMode,
                        pPager->journalSizeLimit, & pPager->pWal);
  }
  pagerFixMaplimit(pPager);
  return (rc);
}
}
static int sqlite3PagerOpenWal(Pager *pPager , int *pbOpen ) 
{ 
  int rc ;
  int tmp ;

  {
  rc = 0;
  if (! pPager->tempFile) {
    if (! pPager->pWal) {
      tmp = sqlite3PagerWalSupported(pPager);
      if (! tmp) {
        return (14);
      }
      sqlite3OsClose(pPager->jfd);
      rc = pagerOpenWal(pPager);
      if (rc == 0) {
        pPager->journalMode = (u8 )5;
        pPager->eState = (u8 )0;
      }
    } else {
      *pbOpen = 1;
    }
  } else {
    *pbOpen = 1;
  }
  return (rc);
}
}
static int sqlite3PagerCloseWal(Pager *pPager , sqlite3 *db ) 
{ 
  int rc ;
  int logexists ;

  {
  rc = 0;
  if (! pPager->pWal) {
    logexists = 0;
    rc = pagerLockDb(pPager, 1);
    if (rc == 0) {
      rc = sqlite3OsAccess(pPager->pVfs, (char const   *)pPager->zWal, 0, & logexists);
    }
    if (rc == 0) {
      if (logexists) {
        rc = pagerOpenWal(pPager);
      }
    }
  }
  if (rc == 0) {
    if (pPager->pWal) {
      rc = pagerExclusiveLock(pPager);
      if (rc == 0) {
        rc = sqlite3WalClose(pPager->pWal, db, (int )pPager->walSyncFlags, pPager->pageSize,
                             (u8 *)pPager->pTmpSpace);
        pPager->pWal = (Wal *)0;
        pagerFixMaplimit(pPager);
        if (rc) {
          if (! pPager->exclusiveMode) {
            pagerUnlockDb(pPager, 1);
          }
        }
      }
    }
  }
  return (rc);
}
}
static int ( __attribute__((__noinline__)) walIndexPageRealloc)(Wal *pWal , int iPage ,
                                                                u32 volatile   **ppPage ) 
{ 
  int rc ;
  sqlite_int64 nByte ;
  u32 volatile   **apNew ;
  void *tmp ;
  void *tmp___0 ;

  {
  rc = 0;
  if (pWal->nWiData <= iPage) {
    nByte = (sqlite_int64 )(sizeof(u32 *) * (unsigned long )(iPage + 1));
    tmp = sqlite3_realloc64((void *)pWal->apWiData, (sqlite_uint64 )nByte);
    apNew = (u32 volatile   **)tmp;
    if (! apNew) {
      *ppPage = (u32 volatile   *)0;
      return (7);
    }
    memset((void *)(apNew + pWal->nWiData), 0, sizeof(u32 *) * (unsigned long )((iPage + 1) - pWal->nWiData));
    pWal->apWiData = apNew;
    pWal->nWiData = iPage + 1;
  }
  if ((int )pWal->exclusiveMode == 2) {
    tmp___0 = sqlite3MallocZero((u64 )(sizeof(ht_slot ) * 8192UL + 4096UL * sizeof(u32 )));
    *(pWal->apWiData + iPage) = (u32 volatile   *)tmp___0;
    if (! *(pWal->apWiData + iPage)) {
      rc = 7;
    }
  } else {
    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, (int )(sizeof(ht_slot ) * 8192UL + 4096UL * sizeof(u32 )),
                         (int )pWal->writeLock, (void volatile   **)(pWal->apWiData + iPage));
    if ((rc & 255) == 8) {
      pWal->readOnly = (u8 )((int )pWal->readOnly | 2);
      if (rc == 8) {
        rc = 0;
      }
    }
  }
  *ppPage = *(pWal->apWiData + iPage);
  return (rc);
}
}
static int walIndexPage(Wal *pWal , int iPage , u32 volatile   **ppPage ) 
{ 
  int tmp ;
  u32 volatile   *tmp___0 ;

  {
  if (pWal->nWiData <= iPage) {
    tmp = walIndexPageRealloc(pWal, iPage, ppPage);
    return (tmp);
  } else {
    tmp___0 = *(pWal->apWiData + iPage);
    *ppPage = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((u32 volatile   *)0)) {
      tmp = walIndexPageRealloc(pWal, iPage, ppPage);
      return (tmp);
    }
  }
  return (0);
}
}
static WalCkptInfo volatile   *walCkptInfo(Wal *pWal ) 
{ 


  {
  return ((WalCkptInfo volatile   *)(*(pWal->apWiData + 0) + sizeof(WalIndexHdr ) / 2UL));
}
}
static WalIndexHdr volatile   *walIndexHdr(Wal *pWal ) 
{ 


  {
  return ((WalIndexHdr volatile   *)*(pWal->apWiData + 0));
}
}
static void walChecksumBytes(int nativeCksum , u8 *a___0 , int nByte , u32 const   *aIn ,
                             u32 *aOut ) 
{ 
  u32 s1 ;
  u32 s2 ;
  u32 *aData ;
  u32 *aEnd ;
  u32 *tmp ;
  u32 *tmp___0 ;

  {
  aData = (u32 *)a___0;
  aEnd = (u32 *)(a___0 + nByte);
  if (aIn) {
    s1 = (u32 )*(aIn + 0);
    s2 = (u32 )*(aIn + 1);
  } else {
    s2 = (u32 )0;
    s1 = s2;
  }
  if (nativeCksum) {
    while (1) {
      tmp = aData;
      aData ++;
      s1 += *tmp + s2;
      tmp___0 = aData;
      aData ++;
      s2 += *tmp___0 + s1;
      if (! ((unsigned long )aData < (unsigned long )aEnd)) {
        break;
      }
    }
  } else {
    while (1) {
      s1 += (((((*(aData + 0) & 255U) << 24) + ((*(aData + 0) & 65280U) << 8)) + ((*(aData + 0) & 16711680U) >> 8)) + ((*(aData + 0) & 4278190080U) >> 24)) + s2;
      s2 += (((((*(aData + 1) & 255U) << 24) + ((*(aData + 1) & 65280U) << 8)) + ((*(aData + 1) & 16711680U) >> 8)) + ((*(aData + 1) & 4278190080U) >> 24)) + s1;
      aData += 2;
      if (! ((unsigned long )aData < (unsigned long )aEnd)) {
        break;
      }
    }
  }
  *(aOut + 0) = s1;
  *(aOut + 1) = s2;
  return;
}
}
static void walShmBarrier(Wal *pWal ) 
{ 


  {
  if ((int )pWal->exclusiveMode != 2) {
    sqlite3OsShmBarrier(pWal->pDbFd);
  }
  return;
}
}
static void walIndexWriteHdr(Wal *pWal ) 
{ 
  WalIndexHdr volatile   *aHdr ;
  WalIndexHdr volatile   *tmp ;
  int nCksum ;

  {
  tmp = walIndexHdr(pWal);
  aHdr = tmp;
  nCksum = (int )((unsigned long )(& ((WalIndexHdr *)0)->aCksum));
  pWal->hdr.isInit = (u8 )1;
  pWal->hdr.iVersion = (u32 )3007000;
  walChecksumBytes(1, (u8 *)(& pWal->hdr), nCksum, (u32 const   *)0, pWal->hdr.aCksum);
  memcpy((void * __restrict  )((void *)(aHdr + 1)), (void const   * __restrict  )((void const   *)(& pWal->hdr)),
         sizeof(WalIndexHdr ));
  walShmBarrier(pWal);
  memcpy((void * __restrict  )((void *)(aHdr + 0)), (void const   * __restrict  )((void const   *)(& pWal->hdr)),
         sizeof(WalIndexHdr ));
  return;
}
}
static void walEncodeFrame(Wal *pWal , u32 iPage , u32 nTruncate , u8 *aData , u8 *aFrame ) 
{ 
  int nativeCksum ;
  u32 *aCksum ;

  {
  aCksum = pWal->hdr.aFrameCksum;
  sqlite3Put4byte(aFrame + 0, iPage);
  sqlite3Put4byte(aFrame + 4, nTruncate);
  if (pWal->iReCksum == 0U) {
    memcpy((void * __restrict  )(aFrame + 8), (void const   * __restrict  )(pWal->hdr.aSalt),
           (size_t )8);
    nativeCksum = (int )pWal->hdr.bigEndCksum == 0;
    walChecksumBytes(nativeCksum, aFrame, 8, (u32 const   *)aCksum, aCksum);
    walChecksumBytes(nativeCksum, aData, (int )pWal->szPage, (u32 const   *)aCksum,
                     aCksum);
    sqlite3Put4byte(aFrame + 16, *(aCksum + 0));
    sqlite3Put4byte(aFrame + 20, *(aCksum + 1));
  } else {
    memset((void *)(aFrame + 8), 0, (size_t )16);
  }
  return;
}
}
static int walDecodeFrame(Wal *pWal , u32 *piPage , u32 *pnTruncate , u8 *aData ,
                          u8 *aFrame ) 
{ 
  int nativeCksum ;
  u32 *aCksum ;
  u32 pgno ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
  aCksum = pWal->hdr.aFrameCksum;
  tmp = memcmp((void const   *)(& pWal->hdr.aSalt), (void const   *)(aFrame + 8),
               (size_t )8);
  if (tmp != 0) {
    return (0);
  }
  pgno = sqlite3Get4byte((u8 const   *)(aFrame + 0));
  if (pgno == 0U) {
    return (0);
  }
  nativeCksum = (int )pWal->hdr.bigEndCksum == 0;
  walChecksumBytes(nativeCksum, aFrame, 8, (u32 const   *)aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, (int )pWal->szPage, (u32 const   *)aCksum,
                   aCksum);
  tmp___0 = sqlite3Get4byte((u8 const   *)(aFrame + 16));
  if (*(aCksum + 0) != tmp___0) {
    return (0);
  } else {
    tmp___1 = sqlite3Get4byte((u8 const   *)(aFrame + 20));
    if (*(aCksum + 1) != tmp___1) {
      return (0);
    }
  }
  *piPage = pgno;
  *pnTruncate = sqlite3Get4byte((u8 const   *)(aFrame + 4));
  return (1);
}
}
static int walLockShared(Wal *pWal , int lockIdx ) 
{ 
  int rc ;

  {
  if (pWal->exclusiveMode) {
    return (0);
  }
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1, 6);
  return (rc);
}
}
static void walUnlockShared(Wal *pWal , int lockIdx ) 
{ 


  {
  if (pWal->exclusiveMode) {
    return;
  }
  sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1, 5);
  return;
}
}
static int walLockExclusive(Wal *pWal , int lockIdx , int n ) 
{ 
  int rc ;

  {
  if (pWal->exclusiveMode) {
    return (0);
  }
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n, 10);
  return (rc);
}
}
static void walUnlockExclusive(Wal *pWal , int lockIdx , int n ) 
{ 


  {
  if (pWal->exclusiveMode) {
    return;
  }
  sqlite3OsShmLock(pWal->pDbFd, lockIdx, n, 9);
  return;
}
}
static int walHash(u32 iPage ) 
{ 


  {
  return ((int )(iPage * 383U & 8191U));
}
}
static int walNextHash(int iPriorHash ) 
{ 


  {
  return ((iPriorHash + 1) & 8191);
}
}
static int walHashGet(Wal *pWal , int iHash , WalHashLoc *pLoc ) 
{ 
  int rc ;

  {
  rc = walIndexPage(pWal, iHash, & pLoc->aPgno);
  if (rc == 0) {
    pLoc->aHash = (ht_slot volatile   *)(pLoc->aPgno + 4096);
    if (iHash == 0) {
      pLoc->aPgno += (sizeof(WalIndexHdr ) * 2UL + sizeof(WalCkptInfo )) / sizeof(u32 );
      pLoc->iZero = (u32 )0;
    } else {
      pLoc->iZero = (u32 )((4096UL - (sizeof(WalIndexHdr ) * 2UL + sizeof(WalCkptInfo )) / sizeof(u32 )) + (unsigned long )((iHash - 1) * 4096));
    }
    (pLoc->aPgno) --;
  }
  return (rc);
}
}
static int walFramePage(u32 iFrame ) 
{ 
  int iHash ;

  {
  iHash = (int )((((unsigned long )(iFrame + 4096U) - (4096UL - (sizeof(WalIndexHdr ) * 2UL + sizeof(WalCkptInfo )) / sizeof(u32 ))) - 1UL) / 4096UL);
  return (iHash);
}
}
static u32 walFramePgno(Wal *pWal , u32 iFrame ) 
{ 
  int iHash ;
  int tmp ;

  {
  tmp = walFramePage(iFrame);
  iHash = tmp;
  if (iHash == 0) {
    return ((u32 )*(*(pWal->apWiData + 0) + (((sizeof(WalIndexHdr ) * 2UL + sizeof(WalCkptInfo )) / sizeof(u32 ) + (unsigned long )iFrame) - 1UL)));
  }
  return ((u32 )*(*(pWal->apWiData + iHash) + ((unsigned long )(iFrame - 1U) - (4096UL - (sizeof(WalIndexHdr ) * 2UL + sizeof(WalCkptInfo )) / sizeof(u32 ))) % 4096UL));
}
}
static void walCleanupHash(Wal *pWal ) 
{ 
  WalHashLoc sLoc ;
  int iLimit ;
  int nByte ;
  int i ;
  int rc ;
  int tmp ;

  {
  iLimit = 0;
  if (pWal->hdr.mxFrame == 0U) {
    return;
  }
  tmp = walFramePage(pWal->hdr.mxFrame);
  rc = walHashGet(pWal, tmp, & sLoc);
  if (rc) {
    return;
  }
  iLimit = (int )(pWal->hdr.mxFrame - sLoc.iZero);
  i = 0;
  while (i < 8192) {
    if ((int volatile   )*(sLoc.aHash + i) > (int volatile   )iLimit) {
      *(sLoc.aHash + i) = (ht_slot volatile   )0;
    }
    i ++;
  }
  nByte = (int )((char *)sLoc.aHash - (char *)(sLoc.aPgno + (iLimit + 1)));
  memset((void *)(sLoc.aPgno + (iLimit + 1)), 0, (size_t )nByte);
  return;
}
}
static int walIndexAppend(Wal *pWal , u32 iFrame , u32 iPage ) 
{ 
  int rc ;
  WalHashLoc sLoc ;
  int tmp ;
  int iKey ;
  int idx ;
  int nCollide ;
  int nByte ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = walFramePage(iFrame);
  rc = walHashGet(pWal, tmp, & sLoc);
  if (rc == 0) {
    idx = (int )(iFrame - sLoc.iZero);
    if (idx == 1) {
      nByte = (int )((u8 *)(sLoc.aHash + 8192) - (u8 *)(sLoc.aPgno + 1));
      memset((void *)(sLoc.aPgno + 1), 0, (size_t )nByte);
    }
    if (*(sLoc.aPgno + idx)) {
      walCleanupHash(pWal);
    }
    nCollide = idx;
    iKey = walHash(iPage);
    while (*(sLoc.aHash + iKey)) {
      tmp___1 = nCollide;
      nCollide --;
      if (tmp___1 == 0) {
        tmp___0 = sqlite3CorruptError(59595);
        return (tmp___0);
      }
      iKey = walNextHash(iKey);
    }
    *(sLoc.aPgno + idx) = (u32 volatile   )iPage;
    *(sLoc.aHash + iKey) = (ht_slot volatile   )((ht_slot )idx);
  }
  return (rc);
}
}
static int walIndexRecover(Wal *pWal ) 
{ 
  int rc ;
  i64 nSize ;
  u32 aFrameCksum[2] ;
  int iLock ;
  u8 aBuf[32] ;
  u8 *aFrame ;
  int szFrame ;
  u8 *aData ;
  int iFrame ;
  i64 iOffset___0 ;
  int szPage ;
  u32 magic ;
  u32 version ;
  int isValid ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  void *tmp___2 ;
  u32 pgno ;
  u32 nTruncate ;
  WalCkptInfo volatile   *pInfo ;
  int i ;

  {
  aFrameCksum[0] = (u32 )0;
  aFrameCksum[1] = (u32 )0;
  iLock = 1 + (int )pWal->ckptLock;
  rc = walLockExclusive(pWal, iLock, 3 - iLock);
  if (rc == 0) {
    rc = walLockExclusive(pWal, 4, 4);
    if (rc != 0) {
      walUnlockExclusive(pWal, iLock, 3 - iLock);
    }
  }
  if (rc) {
    return (rc);
  }
  memset((void *)(& pWal->hdr), 0, sizeof(WalIndexHdr ));
  rc = sqlite3OsFileSize(pWal->pWalFd, & nSize);
  if (rc != 0) {
    goto recovery_error;
  }
  if (nSize > 32LL) {
    aFrame = (u8 *)0;
    rc = sqlite3OsRead(pWal->pWalFd, (void *)(aBuf), 32, (i64 )0);
    if (rc != 0) {
      goto recovery_error;
    }
    magic = sqlite3Get4byte((u8 const   *)(& aBuf[0]));
    tmp = sqlite3Get4byte((u8 const   *)(& aBuf[8]));
    szPage = (int )tmp;
    if ((magic & 4294967294U) != 931071618U) {
      goto finished;
    } else
    if (szPage & (szPage - 1)) {
      goto finished;
    } else
    if (szPage > 65536) {
      goto finished;
    } else
    if (szPage < 512) {
      goto finished;
    }
    pWal->hdr.bigEndCksum = (u8 )(magic & 1U);
    pWal->szPage = (u32 )szPage;
    pWal->nCkpt = sqlite3Get4byte((u8 const   *)(& aBuf[12]));
    memcpy((void * __restrict  )(& pWal->hdr.aSalt), (void const   * __restrict  )(& aBuf[16]),
           (size_t )8);
    walChecksumBytes((int )pWal->hdr.bigEndCksum == 0, aBuf, 24, (u32 const   *)0,
                     pWal->hdr.aFrameCksum);
    tmp___0 = sqlite3Get4byte((u8 const   *)(& aBuf[24]));
    if (pWal->hdr.aFrameCksum[0] != tmp___0) {
      goto finished;
    } else {
      tmp___1 = sqlite3Get4byte((u8 const   *)(& aBuf[28]));
      if (pWal->hdr.aFrameCksum[1] != tmp___1) {
        goto finished;
      }
    }
    version = sqlite3Get4byte((u8 const   *)(& aBuf[4]));
    if (version != 3007000U) {
      rc = sqlite3CantopenError(59733);
      goto finished;
    }
    szFrame = szPage + 24;
    tmp___2 = sqlite3_malloc64((sqlite_uint64 )szFrame);
    aFrame = (u8 *)tmp___2;
    if (! aFrame) {
      rc = 7;
      goto recovery_error;
    }
    aData = aFrame + 24;
    iFrame = 0;
    iOffset___0 = (i64 )32;
    while (iOffset___0 + (i64 )szFrame <= nSize) {
      iFrame ++;
      rc = sqlite3OsRead(pWal->pWalFd, (void *)aFrame, szFrame, iOffset___0);
      if (rc != 0) {
        break;
      }
      isValid = walDecodeFrame(pWal, & pgno, & nTruncate, aData, aFrame);
      if (! isValid) {
        break;
      }
      rc = walIndexAppend(pWal, (u32 )iFrame, pgno);
      if (rc != 0) {
        break;
      }
      if (nTruncate) {
        pWal->hdr.mxFrame = (u32 )iFrame;
        pWal->hdr.nPage = nTruncate;
        pWal->hdr.szPage = (u16 )((szPage & 65280) | (szPage >> 16));
        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];
        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];
      }
      iOffset___0 += (i64 )szFrame;
    }
    sqlite3_free((void *)aFrame);
  }
  finished: 
  if (rc == 0) {
    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];
    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];
    walIndexWriteHdr(pWal);
    pInfo = walCkptInfo(pWal);
    pInfo->nBackfill = (u32 volatile   )0;
    pInfo->nBackfillAttempted = (u32 volatile   )pWal->hdr.mxFrame;
    pInfo->aReadMark[0] = (u32 )0;
    i = 1;
    while (i < 5) {
      pInfo->aReadMark[i] = 4294967295U;
      i ++;
    }
    if (pWal->hdr.mxFrame) {
      pInfo->aReadMark[1] = pWal->hdr.mxFrame;
    }
    if (pWal->hdr.nPage) {
      sqlite3_log(27 | (1 << 8), "recovered %d frames from WAL file %s", pWal->hdr.mxFrame,
                  pWal->zWalName);
    }
  }
  recovery_error: 
  walUnlockExclusive(pWal, iLock, 3 - iLock);
  walUnlockExclusive(pWal, 4, 4);
  return (rc);
}
}
static void walIndexClose(Wal *pWal , int isDelete ) 
{ 
  int i ;

  {
  if ((int )pWal->exclusiveMode == 2) {
    goto _L;
  } else
  if (pWal->bShmUnreliable) {
    _L: /* CIL Label */ 
    i = 0;
    while (i < pWal->nWiData) {
      sqlite3_free((void *)*(pWal->apWiData + i));
      *(pWal->apWiData + i) = (u32 volatile   *)0;
      i ++;
    }
  }
  if ((int )pWal->exclusiveMode != 2) {
    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);
  }
  return;
}
}
static int sqlite3WalOpen(sqlite3_vfs *pVfs , sqlite3_file *pDbFd , char const   *zWalName ,
                          int bNoShm , i64 mxWalSize , Wal **ppWal ) 
{ 
  int rc ;
  Wal *pRet ;
  int flags___0 ;
  void *tmp ;
  int iDC ;
  int tmp___0 ;

  {
  *ppWal = (Wal *)0;
  tmp = sqlite3MallocZero((u64 )(sizeof(Wal ) + (unsigned long )pVfs->szOsFile));
  pRet = (Wal *)tmp;
  if (! pRet) {
    return (7);
  }
  pRet->pVfs = pVfs;
  pRet->pWalFd = (sqlite3_file *)(pRet + 1);
  pRet->pDbFd = pDbFd;
  pRet->readLock = (i16 )-1;
  pRet->mxWalSize = mxWalSize;
  pRet->zWalName = zWalName;
  pRet->syncHeader = (u8 )1;
  pRet->padToSectorBoundary = (u8 )1;
  if (bNoShm) {
    pRet->exclusiveMode = (u8 )2;
  } else {
    pRet->exclusiveMode = (u8 )0;
  }
  flags___0 = 524294;
  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags___0, & flags___0);
  if (rc == 0) {
    if (flags___0 & 1) {
      pRet->readOnly = (u8 )1;
    }
  }
  if (rc != 0) {
    walIndexClose(pRet, 0);
    sqlite3OsClose(pRet->pWalFd);
    sqlite3_free((void *)pRet);
  } else {
    tmp___0 = sqlite3OsDeviceCharacteristics(pDbFd);
    iDC = tmp___0;
    if (iDC & 1024) {
      pRet->syncHeader = (u8 )0;
    }
    if (iDC & 4096) {
      pRet->padToSectorBoundary = (u8 )0;
    }
    *ppWal = pRet;
  }
  return (rc);
}
}
static void sqlite3WalLimit(Wal *pWal , i64 iLimit ) 
{ 


  {
  if (pWal) {
    pWal->mxWalSize = iLimit;
  }
  return;
}
}
static int walIteratorNext(WalIterator *p , u32 *piPage , u32 *piFrame ) 
{ 
  u32 iMin ;
  u32 iRet ;
  int i ;
  struct WalSegment *pSegment ;
  u32 iPg ;
  int tmp ;

  {
  iRet = 4294967295U;
  iMin = (u32 )p->iPrior;
  i = p->nSegment - 1;
  while (i >= 0) {
    pSegment = & p->aSegment[i];
    while (pSegment->iNext < pSegment->nEntry) {
      iPg = *(pSegment->aPgno + *(pSegment->aIndex + pSegment->iNext));
      if (iPg > iMin) {
        if (iPg < iRet) {
          iRet = iPg;
          *piFrame = (u32 )(pSegment->iZero + (int )*(pSegment->aIndex + pSegment->iNext));
        }
        break;
      }
      (pSegment->iNext) ++;
    }
    i --;
  }
  tmp = (int )iRet;
  p->iPrior = tmp;
  *piPage = (u32 )tmp;
  return (iRet == 4294967295U);
}
}
static void walMerge(u32 const   *aContent , ht_slot *aLeft , int nLeft , ht_slot **paRight ,
                     int *pnRight , ht_slot *aTmp ) 
{ 
  int iLeft ;
  int iRight ;
  int iOut ;
  int nRight ;
  ht_slot *aRight ;
  ht_slot logpage ;
  Pgno dbpage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  iLeft = 0;
  iRight = 0;
  iOut = 0;
  nRight = *pnRight;
  aRight = *paRight;
  while (1) {
    if (! (iRight < nRight)) {
      if (! (iLeft < nLeft)) {
        break;
      }
    }
    if (iLeft < nLeft) {
      if (iRight >= nRight) {
        tmp = iLeft;
        iLeft ++;
        logpage = *(aLeft + tmp);
      } else
      if (*(aContent + *(aLeft + iLeft)) < *(aContent + *(aRight + iRight))) {
        tmp = iLeft;
        iLeft ++;
        logpage = *(aLeft + tmp);
      } else {
        tmp___0 = iRight;
        iRight ++;
        logpage = *(aRight + tmp___0);
      }
    } else {
      tmp___0 = iRight;
      iRight ++;
      logpage = *(aRight + tmp___0);
    }
    dbpage = (Pgno )*(aContent + logpage);
    tmp___1 = iOut;
    iOut ++;
    *(aTmp + tmp___1) = logpage;
    if (iLeft < nLeft) {
      if (*(aContent + *(aLeft + iLeft)) == (u32 const   )dbpage) {
        iLeft ++;
      }
    }
  }
  *paRight = aLeft;
  *pnRight = iOut;
  memcpy((void * __restrict  )aLeft, (void const   * __restrict  )aTmp, sizeof(*(aTmp + 0)) * (unsigned long )iOut);
  return;
}
}
static void walMergesort(u32 const   *aContent , ht_slot *aBuffer , ht_slot *aList ,
                         int *pnList ) 
{ 
  int nList ;
  int nMerge ;
  ht_slot *aMerge ;
  int iList ;
  u32 iSub ;
  struct Sublist aSub[13] ;
  struct Sublist *p ;
  struct Sublist *p___0 ;

  {
  nList = *pnList;
  nMerge = 0;
  aMerge = (ht_slot *)0;
  iSub = (u32 )0;
  memset((void *)(aSub), 0, sizeof(aSub));
  iList = 0;
  while (iList < nList) {
    nMerge = 1;
    aMerge = aList + iList;
    iSub = (u32 )0;
    while (iList & (1 << iSub)) {
      p = & aSub[iSub];
      walMerge(aContent, p->aList, p->nList, & aMerge, & nMerge, aBuffer);
      iSub ++;
    }
    aSub[iSub].aList = aMerge;
    aSub[iSub].nList = nMerge;
    iList ++;
  }
  iSub ++;
  while (iSub < (u32 )((int )(sizeof(aSub) / sizeof(aSub[0])))) {
    if (nList & (1 << iSub)) {
      p___0 = & aSub[iSub];
      walMerge(aContent, p___0->aList, p___0->nList, & aMerge, & nMerge, aBuffer);
    }
    iSub ++;
  }
  *pnList = nMerge;
  return;
}
}
static void walIteratorFree(WalIterator *p ) 
{ 


  {
  sqlite3_free((void *)p);
  return;
}
}
static int walIteratorInit(Wal *pWal , u32 nBackfill , WalIterator **pp ) 
{ 
  WalIterator *p ;
  int nSegment ;
  u32 iLast ;
  sqlite_int64 nByte ;
  int i ;
  ht_slot *aTmp ;
  int rc ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  void *tmp___2 ;
  WalHashLoc sLoc ;
  int j ;
  int nEntry ;
  ht_slot *aIndex ;

  {
  rc = 0;
  iLast = pWal->hdr.mxFrame;
  tmp = walFramePage(iLast);
  nSegment = tmp + 1;
  nByte = (sqlite_int64 )((sizeof(WalIterator ) + (unsigned long )(nSegment - 1) * sizeof(struct WalSegment )) + (unsigned long )iLast * sizeof(ht_slot ));
  tmp___0 = sqlite3_malloc64((sqlite_uint64 )nByte);
  p = (WalIterator *)tmp___0;
  if (! p) {
    return (7);
  }
  memset((void *)p, 0, (size_t )nByte);
  p->nSegment = nSegment;
  if (iLast > 4096U) {
    tmp___1 = (u32 )4096;
  } else {
    tmp___1 = iLast;
  }
  tmp___2 = sqlite3_malloc64((sqlite_uint64 )(sizeof(ht_slot ) * (unsigned long )tmp___1));
  aTmp = (ht_slot *)tmp___2;
  if (! aTmp) {
    rc = 7;
  }
  i = walFramePage(nBackfill + 1U);
  while (1) {
    if (rc == 0) {
      if (! (i < nSegment)) {
        break;
      }
    } else {
      break;
    }
    rc = walHashGet(pWal, i, & sLoc);
    if (rc == 0) {
      (sLoc.aPgno) ++;
      if (i + 1 == nSegment) {
        nEntry = (int )(iLast - sLoc.iZero);
      } else {
        nEntry = (int )((u32 *)sLoc.aHash - (u32 *)sLoc.aPgno);
      }
      aIndex = (ht_slot *)(& p->aSegment[p->nSegment]) + sLoc.iZero;
      (sLoc.iZero) ++;
      j = 0;
      while (j < nEntry) {
        *(aIndex + j) = (ht_slot )j;
        j ++;
      }
      walMergesort((u32 const   *)((u32 *)sLoc.aPgno), aTmp, aIndex, & nEntry);
      p->aSegment[i].iZero = (int )sLoc.iZero;
      p->aSegment[i].nEntry = nEntry;
      p->aSegment[i].aIndex = aIndex;
      p->aSegment[i].aPgno = (u32 *)sLoc.aPgno;
    }
    i ++;
  }
  sqlite3_free((void *)aTmp);
  if (rc != 0) {
    walIteratorFree(p);
    p = (WalIterator *)0;
  }
  *pp = p;
  return (rc);
}
}
static int walBusyLock(Wal *pWal , int (*xBusy)(void * ) , void *pBusyArg , int lockIdx ,
                       int n ) 
{ 
  int rc ;
  int tmp ;

  {
  while (1) {
    rc = walLockExclusive(pWal, lockIdx, n);
    if (xBusy) {
      if (rc == 5) {
        tmp = (*xBusy)(pBusyArg);
        if (! tmp) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  return (rc);
}
}
static int walPagesize(Wal *pWal ) 
{ 


  {
  return (((int )pWal->hdr.szPage & 65024) + (((int )pWal->hdr.szPage & 1) << 16));
}
}
static void walRestartHdr(Wal *pWal , u32 salt1 ) 
{ 
  WalCkptInfo volatile   *pInfo ;
  WalCkptInfo volatile   *tmp ;
  int i ;
  u32 *aSalt ;
  u32 tmp___0 ;

  {
  tmp = walCkptInfo(pWal);
  pInfo = tmp;
  aSalt = pWal->hdr.aSalt;
  (pWal->nCkpt) ++;
  pWal->hdr.mxFrame = (u32 )0;
  tmp___0 = sqlite3Get4byte((u8 const   *)((u8 *)(aSalt + 0)));
  sqlite3Put4byte((u8 *)(aSalt + 0), 1U + tmp___0);
  memcpy((void * __restrict  )(& pWal->hdr.aSalt[1]), (void const   * __restrict  )(& salt1),
         (size_t )4);
  walIndexWriteHdr(pWal);
  pInfo->nBackfill = (u32 volatile   )0;
  pInfo->nBackfillAttempted = (u32 volatile   )0;
  pInfo->aReadMark[1] = (u32 )0;
  i = 2;
  while (i < 5) {
    pInfo->aReadMark[i] = 4294967295U;
    i ++;
  }
  return;
}
}
static int walCheckpoint(Wal *pWal , sqlite3 *db , int eMode , int (*xBusy)(void * ) ,
                         void *pBusyArg , int sync_flags , u8 *zBuf ) 
{ 
  int rc ;
  int szPage ;
  WalIterator *pIter ;
  u32 iDbpage ;
  u32 iFrame ;
  u32 mxSafeFrame ;
  u32 mxPage ;
  int i ;
  WalCkptInfo volatile   *pInfo ;
  u32 y ;
  u32 nBackfill ;
  i64 nReq ;
  i64 nSize ;
  i64 iOffset___0 ;
  int tmp ;
  i64 szDb ;
  WalIndexHdr volatile   *tmp___0 ;
  u32 salt1 ;

  {
  rc = 0;
  pIter = (WalIterator *)0;
  iDbpage = (u32 )0;
  iFrame = (u32 )0;
  szPage = walPagesize(pWal);
  pInfo = walCkptInfo(pWal);
  if (pInfo->nBackfill < (u32 volatile   )pWal->hdr.mxFrame) {
    mxSafeFrame = pWal->hdr.mxFrame;
    mxPage = pWal->hdr.nPage;
    i = 1;
    while (i < 5) {
      y = pInfo->aReadMark[i];
      if (mxSafeFrame > y) {
        rc = walBusyLock(pWal, xBusy, pBusyArg, 3 + i, 1);
        if (rc == 0) {
          if (i == 1) {
            pInfo->aReadMark[i] = mxSafeFrame;
          } else {
            pInfo->aReadMark[i] = 4294967295U;
          }
          walUnlockExclusive(pWal, 3 + i, 1);
        } else
        if (rc == 5) {
          mxSafeFrame = y;
          xBusy = (int (*)(void * ))0;
        } else {
          goto walcheckpoint_out;
        }
      }
      i ++;
    }
    if (pInfo->nBackfill < (u32 volatile   )mxSafeFrame) {
      rc = walIteratorInit(pWal, (u32 )pInfo->nBackfill, & pIter);
    }
    if (pIter) {
      rc = walBusyLock(pWal, xBusy, pBusyArg, 3, 1);
      if (rc == 0) {
        nBackfill = (u32 )pInfo->nBackfill;
        pInfo->nBackfillAttempted = (u32 volatile   )mxSafeFrame;
        rc = sqlite3OsSync(pWal->pWalFd, (sync_flags >> 2) & 3);
        if (rc == 0) {
          nReq = (i64 )mxPage * (i64 )szPage;
          rc = sqlite3OsFileSize(pWal->pDbFd, & nSize);
          if (rc == 0) {
            if (nSize < nReq) {
              sqlite3OsFileControlHint(pWal->pDbFd, 5, (void *)(& nReq));
            }
          }
        }
        while (1) {
          if (rc == 0) {
            tmp = walIteratorNext(pIter, & iDbpage, & iFrame);
            if (! (0 == tmp)) {
              break;
            }
          } else {
            break;
          }
          if (db->u1.isInterrupted) {
            if (db->mallocFailed) {
              rc = 7;
            } else {
              rc = 9;
            }
            break;
          }
          if (iFrame <= nBackfill) {
            continue;
          } else
          if (iFrame > mxSafeFrame) {
            continue;
          } else
          if (iDbpage > mxPage) {
            continue;
          }
          iOffset___0 = (32LL + (i64 )(iFrame - 1U) * (i64 )(szPage + 24)) + 24LL;
          rc = sqlite3OsRead(pWal->pWalFd, (void *)zBuf, szPage, iOffset___0);
          if (rc != 0) {
            break;
          }
          iOffset___0 = (i64 )(iDbpage - 1U) * (i64 )szPage;
          rc = sqlite3OsWrite(pWal->pDbFd, (void const   *)zBuf, szPage, iOffset___0);
          if (rc != 0) {
            break;
          }
        }
        if (rc == 0) {
          tmp___0 = walIndexHdr(pWal);
          if (mxSafeFrame == (u32 )tmp___0->mxFrame) {
            szDb = (i64 )pWal->hdr.nPage * (i64 )szPage;
            rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
            if (rc == 0) {
              rc = sqlite3OsSync(pWal->pDbFd, (sync_flags >> 2) & 3);
            }
          }
          if (rc == 0) {
            pInfo->nBackfill = (u32 volatile   )mxSafeFrame;
          }
        }
        walUnlockExclusive(pWal, 3, 1);
      }
    }
    if (rc == 5) {
      rc = 0;
    }
  }
  if (rc == 0) {
    if (eMode != 0) {
      if (pInfo->nBackfill < (u32 volatile   )pWal->hdr.mxFrame) {
        rc = 5;
      } else
      if (eMode >= 2) {
        sqlite3_randomness(4, (void *)(& salt1));
        rc = walBusyLock(pWal, xBusy, pBusyArg, 4, 4);
        if (rc == 0) {
          if (eMode == 3) {
            walRestartHdr(pWal, salt1);
            rc = sqlite3OsTruncate(pWal->pWalFd, (i64 )0);
          }
          walUnlockExclusive(pWal, 4, 4);
        }
      }
    }
  }
  walcheckpoint_out: 
  walIteratorFree(pIter);
  return (rc);
}
}
static void walLimitSize(Wal *pWal , i64 nMax ) 
{ 
  i64 sz ;
  int rx ;

  {
  sqlite3BeginBenignMalloc();
  rx = sqlite3OsFileSize(pWal->pWalFd, & sz);
  if (rx == 0) {
    if (sz > nMax) {
      rx = sqlite3OsTruncate(pWal->pWalFd, nMax);
    }
  }
  sqlite3EndBenignMalloc();
  if (rx) {
    sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);
  }
  return;
}
}
static int sqlite3WalClose(Wal *pWal , sqlite3 *db , int sync_flags , int nBuf , u8 *zBuf ) 
{ 
  int rc ;
  int isDelete ;
  int bPersist ;

  {
  rc = 0;
  if (pWal) {
    isDelete = 0;
    if ((unsigned long )zBuf != (unsigned long )((u8 *)0)) {
      rc = sqlite3OsLock(pWal->pDbFd, 4);
      if (0 == rc) {
        if ((int )pWal->exclusiveMode == 0) {
          pWal->exclusiveMode = (u8 )1;
        }
        rc = sqlite3WalCheckpoint(pWal, db, 0, (int (*)(void * ))0, (void *)0, sync_flags,
                                  nBuf, zBuf, (int *)0, (int *)0);
        if (rc == 0) {
          bPersist = -1;
          sqlite3OsFileControlHint(pWal->pDbFd, 10, (void *)(& bPersist));
          if (bPersist != 1) {
            isDelete = 1;
          } else
          if (pWal->mxWalSize >= 0LL) {
            walLimitSize(pWal, (i64 )0);
          }
        }
      }
    }
    walIndexClose(pWal, isDelete);
    sqlite3OsClose(pWal->pWalFd);
    if (isDelete) {
      sqlite3BeginBenignMalloc();
      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);
      sqlite3EndBenignMalloc();
    }
    sqlite3_free((void *)pWal->apWiData);
    sqlite3_free((void *)pWal);
  }
  return (rc);
}
}
static int walIndexTryHdr(Wal *pWal , int *pChanged ) 
{ 
  u32 aCksum[2] ;
  WalIndexHdr h1 ;
  WalIndexHdr h2 ;
  WalIndexHdr volatile   *aHdr ;
  int tmp ;
  int tmp___0 ;

  {
  aHdr = walIndexHdr(pWal);
  memcpy((void * __restrict  )(& h1), (void const   * __restrict  )((void *)(aHdr + 0)),
         sizeof(h1));
  walShmBarrier(pWal);
  memcpy((void * __restrict  )(& h2), (void const   * __restrict  )((void *)(aHdr + 1)),
         sizeof(h2));
  tmp = memcmp((void const   *)(& h1), (void const   *)(& h2), sizeof(h1));
  if (tmp != 0) {
    return (1);
  }
  if ((int )h1.isInit == 0) {
    return (1);
  }
  walChecksumBytes(1, (u8 *)(& h1), (int )(sizeof(h1) - sizeof(h1.aCksum)), (u32 const   *)0,
                   aCksum);
  if (aCksum[0] != h1.aCksum[0]) {
    return (1);
  } else
  if (aCksum[1] != h1.aCksum[1]) {
    return (1);
  }
  tmp___0 = memcmp((void const   *)(& pWal->hdr), (void const   *)(& h1), sizeof(WalIndexHdr ));
  if (tmp___0) {
    *pChanged = 1;
    memcpy((void * __restrict  )(& pWal->hdr), (void const   * __restrict  )(& h1),
           sizeof(WalIndexHdr ));
    pWal->szPage = (u32 )(((int )pWal->hdr.szPage & 65024) + (((int )pWal->hdr.szPage & 1) << 16));
  }
  return (0);
}
}
static int walIndexReadHdr(Wal *pWal , int *pChanged ) 
{ 
  int rc ;
  int badHdr ;
  u32 volatile   *page0 ;
  int tmp ;

  {
  rc = walIndexPage(pWal, 0, & page0);
  if (rc != 0) {
    if (rc == (8 | (5 << 8))) {
      pWal->bShmUnreliable = (u8 )1;
      pWal->exclusiveMode = (u8 )2;
      *pChanged = 1;
    } else {
      return (rc);
    }
  }
  if (page0) {
    tmp = walIndexTryHdr(pWal, pChanged);
    badHdr = tmp;
  } else {
    badHdr = 1;
  }
  if (badHdr) {
    if ((int )pWal->bShmUnreliable == 0) {
      if ((int )pWal->readOnly & 2) {
        rc = walLockShared(pWal, 0);
        if (0 == rc) {
          walUnlockShared(pWal, 0);
          rc = 8 | (1 << 8);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      rc = walLockExclusive(pWal, 0, 1);
      if (0 == rc) {
        pWal->writeLock = (u8 )1;
        rc = walIndexPage(pWal, 0, & page0);
        if (0 == rc) {
          badHdr = walIndexTryHdr(pWal, pChanged);
          if (badHdr) {
            rc = walIndexRecover(pWal);
            *pChanged = 1;
          }
        }
        pWal->writeLock = (u8 )0;
        walUnlockExclusive(pWal, 0, 1);
      }
    }
  }
  if (badHdr == 0) {
    if (pWal->hdr.iVersion != 3007000U) {
      rc = sqlite3CantopenError(60711);
    }
  }
  if (pWal->bShmUnreliable) {
    if (rc != 0) {
      walIndexClose(pWal, 0);
      pWal->bShmUnreliable = (u8 )0;
      if (rc == (10 | (2 << 8))) {
        rc = -1;
      }
    }
    pWal->exclusiveMode = (u8 )0;
  }
  return (rc);
}
}
static int walBeginShmUnreliable(Wal *pWal , int *pChanged ) 
{ 
  i64 szWal ;
  i64 iOffset___0 ;
  u8 aBuf[32] ;
  u8 *aFrame ;
  int szFrame ;
  u8 *aData ;
  void volatile   *pDummy ;
  int rc ;
  u32 aSaveCksum[2] ;
  WalIndexHdr volatile   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u32 pgno ;
  u32 nTruncate ;
  int tmp___2 ;
  int i ;

  {
  aFrame = (u8 *)0;
  rc = walLockShared(pWal, 3);
  if (rc != 0) {
    if (rc == 5) {
      rc = -1;
    }
    goto begin_unreliable_shm_out;
  }
  pWal->readLock = (i16 )0;
  rc = sqlite3OsShmMap(pWal->pDbFd, 0, (int )(sizeof(ht_slot ) * 8192UL + 4096UL * sizeof(u32 )),
                       0, & pDummy);
  if (rc != (8 | (5 << 8))) {
    if (rc == 8) {
      rc = -1;
    } else {
      rc = rc;
    }
    goto begin_unreliable_shm_out;
  }
  tmp = walIndexHdr(pWal);
  memcpy((void * __restrict  )(& pWal->hdr), (void const   * __restrict  )((void *)tmp),
         sizeof(WalIndexHdr ));
  rc = sqlite3OsFileSize(pWal->pWalFd, & szWal);
  if (rc != 0) {
    goto begin_unreliable_shm_out;
  }
  if (szWal < 32LL) {
    *pChanged = 1;
    if (pWal->hdr.mxFrame == 0U) {
      rc = 0;
    } else {
      rc = -1;
    }
    goto begin_unreliable_shm_out;
  }
  rc = sqlite3OsRead(pWal->pWalFd, (void *)(aBuf), 32, (i64 )0);
  if (rc != 0) {
    goto begin_unreliable_shm_out;
  }
  tmp___0 = memcmp((void const   *)(& pWal->hdr.aSalt), (void const   *)(& aBuf[16]),
                   (size_t )8);
  if (tmp___0) {
    rc = -1;
    goto begin_unreliable_shm_out;
  }
  szFrame = (int )pWal->hdr.szPage + 24;
  tmp___1 = sqlite3_malloc64((sqlite_uint64 )szFrame);
  aFrame = (u8 *)tmp___1;
  if ((unsigned long )aFrame == (unsigned long )((u8 *)0)) {
    rc = 7;
    goto begin_unreliable_shm_out;
  }
  aData = aFrame + 24;
  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];
  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];
  iOffset___0 = 32LL + (i64 )((pWal->hdr.mxFrame + 1U) - 1U) * (i64 )((int )pWal->hdr.szPage + 24);
  while (iOffset___0 + (i64 )szFrame <= szWal) {
    rc = sqlite3OsRead(pWal->pWalFd, (void *)aFrame, szFrame, iOffset___0);
    if (rc != 0) {
      break;
    }
    tmp___2 = walDecodeFrame(pWal, & pgno, & nTruncate, aData, aFrame);
    if (! tmp___2) {
      break;
    }
    if (nTruncate) {
      rc = -1;
      break;
    }
    iOffset___0 += (i64 )szFrame;
  }
  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];
  pWal->hdr.aFrameCksum[1] = aSaveCksum[1];
  begin_unreliable_shm_out: 
  sqlite3_free((void *)aFrame);
  if (rc != 0) {
    i = 0;
    while (i < pWal->nWiData) {
      sqlite3_free((void *)*(pWal->apWiData + i));
      *(pWal->apWiData + i) = (u32 volatile   *)0;
      i ++;
    }
    pWal->bShmUnreliable = (u8 )0;
    sqlite3WalEndReadTransaction(pWal);
    *pChanged = 1;
  }
  return (rc);
}
}
static int walTryBeginRead(Wal *pWal , int *pChanged , int useWal , int cnt ) 
{ 
  WalCkptInfo volatile   *pInfo ;
  u32 mxReadMark ;
  int mxI ;
  int i ;
  int rc ;
  u32 mxFrame ;
  int nDelay ;
  int tmp ;
  WalIndexHdr volatile   *tmp___0 ;
  int tmp___1 ;
  u32 thisMark ;
  u32 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  WalIndexHdr volatile   *tmp___5 ;
  int tmp___6 ;

  {
  rc = 0;
  if (cnt > 5) {
    nDelay = 1;
    if (cnt > 100) {
      return (15);
    }
    if (cnt >= 10) {
      nDelay = ((cnt - 9) * (cnt - 9)) * 39;
    }
    sqlite3OsSleep(pWal->pVfs, nDelay);
  }
  if (! useWal) {
    if ((int )pWal->bShmUnreliable == 0) {
      rc = walIndexReadHdr(pWal, pChanged);
    }
    if (rc == 5) {
      if ((unsigned long )*(pWal->apWiData + 0) == (unsigned long )((u32 volatile   *)0)) {
        rc = -1;
      } else {
        rc = walLockShared(pWal, 2);
        if (0 == rc) {
          walUnlockShared(pWal, 2);
          rc = -1;
        } else
        if (rc == 5) {
          rc = 5 | (1 << 8);
        }
      }
    }
    if (rc != 0) {
      return (rc);
    } else
    if (pWal->bShmUnreliable) {
      tmp = walBeginShmUnreliable(pWal, pChanged);
      return (tmp);
    }
  }
  pInfo = walCkptInfo(pWal);
  if (! useWal) {
    if (pInfo->nBackfill == (u32 volatile   )pWal->hdr.mxFrame) {
      rc = walLockShared(pWal, 3);
      walShmBarrier(pWal);
      if (rc == 0) {
        tmp___0 = walIndexHdr(pWal);
        tmp___1 = memcmp((void const   *)((void *)tmp___0), (void const   *)(& pWal->hdr),
                         sizeof(WalIndexHdr ));
        if (tmp___1) {
          walUnlockShared(pWal, 3);
          return (-1);
        }
        pWal->readLock = (i16 )0;
        return (0);
      } else
      if (rc != 5) {
        return (rc);
      }
    }
  }
  mxReadMark = (u32 )0;
  mxI = 0;
  mxFrame = pWal->hdr.mxFrame;
  i = 1;
  while (i < 5) {
    thisMark = *(pInfo->aReadMark + i);
    if (mxReadMark <= thisMark) {
      if (thisMark <= mxFrame) {
        mxReadMark = thisMark;
        mxI = i;
      }
    }
    i ++;
  }
  if (((int )pWal->readOnly & 2) == 0) {
    if (mxReadMark < mxFrame) {
      goto _L;
    } else
    if (mxI == 0) {
      _L: /* CIL Label */ 
      i = 1;
      while (i < 5) {
        rc = walLockExclusive(pWal, 3 + i, 1);
        if (rc == 0) {
          tmp___2 = mxFrame;
          *(pInfo->aReadMark + i) = tmp___2;
          mxReadMark = tmp___2;
          mxI = i;
          walUnlockExclusive(pWal, 3 + i, 1);
          break;
        } else
        if (rc != 5) {
          return (rc);
        }
        i ++;
      }
    }
  }
  if (mxI == 0) {
    if (rc == 5) {
      tmp___3 = -1;
    } else {
      tmp___3 = 8 | (5 << 8);
    }
    return (tmp___3);
  }
  rc = walLockShared(pWal, 3 + mxI);
  if (rc) {
    if (rc == 5) {
      tmp___4 = -1;
    } else {
      tmp___4 = rc;
    }
    return (tmp___4);
  }
  pWal->minFrame = (u32 )(pInfo->nBackfill + (u32 volatile   )1);
  walShmBarrier(pWal);
  if (*(pInfo->aReadMark + mxI) != mxReadMark) {
    walUnlockShared(pWal, 3 + mxI);
    return (-1);
  } else {
    tmp___5 = walIndexHdr(pWal);
    tmp___6 = memcmp((void const   *)((void *)tmp___5), (void const   *)(& pWal->hdr),
                     sizeof(WalIndexHdr ));
    if (tmp___6) {
      walUnlockShared(pWal, 3 + mxI);
      return (-1);
    } else {
      pWal->readLock = (i16 )mxI;
    }
  }
  return (rc);
}
}
static int sqlite3WalBeginReadTransaction(Wal *pWal , int *pChanged ) 
{ 
  int rc ;
  int cnt ;

  {
  cnt = 0;
  while (1) {
    cnt ++;
    rc = walTryBeginRead(pWal, pChanged, 0, cnt);
    if (! (rc == -1)) {
      break;
    }
  }
  return (rc);
}
}
static void sqlite3WalEndReadTransaction(Wal *pWal ) 
{ 


  {
  sqlite3WalEndWriteTransaction(pWal);
  if ((int )pWal->readLock >= 0) {
    walUnlockShared(pWal, 3 + (int )pWal->readLock);
    pWal->readLock = (i16 )-1;
  }
  return;
}
}
static int sqlite3WalFindFrame(Wal *pWal , Pgno pgno , u32 *piRead ) 
{ 
  u32 iRead ;
  u32 iLast ;
  int iHash ;
  int iMinHash ;
  WalHashLoc sLoc ;
  int iKey ;
  int nCollide ;
  int rc ;
  u32 iH ;
  u32 iFrame ;
  int tmp ;
  int tmp___0 ;

  {
  iRead = (u32 )0;
  iLast = pWal->hdr.mxFrame;
  if (iLast == 0U) {
    *piRead = (u32 )0;
    return (0);
  } else
  if ((int )pWal->readLock == 0) {
    if ((int )pWal->bShmUnreliable == 0) {
      *piRead = (u32 )0;
      return (0);
    }
  }
  iMinHash = walFramePage(pWal->minFrame);
  iHash = walFramePage(iLast);
  while (iHash >= iMinHash) {
    rc = walHashGet(pWal, iHash, & sLoc);
    if (rc != 0) {
      return (rc);
    }
    nCollide = 8192;
    iKey = walHash(pgno);
    while (*(sLoc.aHash + iKey)) {
      iH = (u32 )*(sLoc.aHash + iKey);
      iFrame = iH + sLoc.iZero;
      if (iFrame <= iLast) {
        if (iFrame >= pWal->minFrame) {
          if (*(sLoc.aPgno + iH) == (u32 volatile   )pgno) {
            iRead = iFrame;
          }
        }
      }
      tmp___0 = nCollide;
      nCollide --;
      if (tmp___0 == 0) {
        tmp = sqlite3CorruptError(61426);
        return (tmp);
      }
      iKey = walNextHash(iKey);
    }
    if (iRead) {
      break;
    }
    iHash --;
  }
  *piRead = iRead;
  return (0);
}
}
static int sqlite3WalReadFrame(Wal *pWal , u32 iRead , int nOut , u8 *pOut ) 
{ 
  int sz ;
  i64 iOffset___0 ;
  int tmp ;
  int tmp___0 ;

  {
  sz = (int )pWal->hdr.szPage;
  sz = (sz & 65024) + ((sz & 1) << 16);
  iOffset___0 = (32LL + (i64 )(iRead - 1U) * (i64 )(sz + 24)) + 24LL;
  if (nOut > sz) {
    tmp = sz;
  } else {
    tmp = nOut;
  }
  tmp___0 = sqlite3OsRead(pWal->pWalFd, (void *)pOut, tmp, iOffset___0);
  return (tmp___0);
}
}
static Pgno sqlite3WalDbsize(Wal *pWal ) 
{ 


  {
  if (pWal) {
    if ((int )pWal->readLock >= 0) {
      return (pWal->hdr.nPage);
    }
  }
  return ((Pgno )0);
}
}
static int sqlite3WalBeginWriteTransaction(Wal *pWal ) 
{ 
  int rc ;
  WalIndexHdr volatile   *tmp ;
  int tmp___0 ;

  {
  if (pWal->readOnly) {
    return (8);
  }
  rc = walLockExclusive(pWal, 0, 1);
  if (rc) {
    return (rc);
  }
  pWal->writeLock = (u8 )1;
  tmp = walIndexHdr(pWal);
  tmp___0 = memcmp((void const   *)(& pWal->hdr), (void const   *)((void *)tmp), sizeof(WalIndexHdr ));
  if (tmp___0 != 0) {
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = (u8 )0;
    rc = 5 | (2 << 8);
  }
  return (rc);
}
}
static int sqlite3WalEndWriteTransaction(Wal *pWal ) 
{ 


  {
  if (pWal->writeLock) {
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = (u8 )0;
    pWal->iReCksum = (u32 )0;
    pWal->truncateOnCommit = (u8 )0;
  }
  return (0);
}
}
static int sqlite3WalUndo(Wal *pWal , int (*xUndo)(void * , Pgno  ) , void *pUndoCtx ) 
{ 
  int rc ;
  Pgno iMax ;
  Pgno iFrame ;
  WalIndexHdr volatile   *tmp ;
  u32 tmp___0 ;

  {
  rc = 0;
  if (pWal->writeLock) {
    iMax = pWal->hdr.mxFrame;
    tmp = walIndexHdr(pWal);
    memcpy((void * __restrict  )(& pWal->hdr), (void const   * __restrict  )((void *)tmp),
           sizeof(WalIndexHdr ));
    iFrame = pWal->hdr.mxFrame + 1U;
    while (1) {
      if (rc == 0) {
        if (! (iFrame <= iMax)) {
          break;
        }
      } else {
        break;
      }
      tmp___0 = walFramePgno(pWal, iFrame);
      rc = (*xUndo)(pUndoCtx, tmp___0);
      iFrame ++;
    }
    if (iMax != pWal->hdr.mxFrame) {
      walCleanupHash(pWal);
    }
  }
  return (rc);
}
}
static void sqlite3WalSavepoint(Wal *pWal , u32 *aWalData ) 
{ 


  {
  *(aWalData + 0) = pWal->hdr.mxFrame;
  *(aWalData + 1) = pWal->hdr.aFrameCksum[0];
  *(aWalData + 2) = pWal->hdr.aFrameCksum[1];
  *(aWalData + 3) = pWal->nCkpt;
  return;
}
}
static int sqlite3WalSavepointUndo(Wal *pWal , u32 *aWalData ) 
{ 
  int rc ;

  {
  rc = 0;
  if (*(aWalData + 3) != pWal->nCkpt) {
    *(aWalData + 0) = (u32 )0;
    *(aWalData + 3) = pWal->nCkpt;
  }
  if (*(aWalData + 0) < pWal->hdr.mxFrame) {
    pWal->hdr.mxFrame = *(aWalData + 0);
    pWal->hdr.aFrameCksum[0] = *(aWalData + 1);
    pWal->hdr.aFrameCksum[1] = *(aWalData + 2);
    walCleanupHash(pWal);
  }
  return (rc);
}
}
static int walRestartLog(Wal *pWal ) 
{ 
  int rc ;
  int cnt ;
  WalCkptInfo volatile   *pInfo ;
  WalCkptInfo volatile   *tmp ;
  u32 salt1 ;
  int notUsed ;

  {
  rc = 0;
  if ((int )pWal->readLock == 0) {
    tmp = walCkptInfo(pWal);
    pInfo = tmp;
    if (pInfo->nBackfill > (u32 volatile   )0) {
      sqlite3_randomness(4, (void *)(& salt1));
      rc = walLockExclusive(pWal, 4, 4);
      if (rc == 0) {
        walRestartHdr(pWal, salt1);
        walUnlockExclusive(pWal, 4, 4);
      } else
      if (rc != 5) {
        return (rc);
      }
    }
    walUnlockShared(pWal, 3);
    pWal->readLock = (i16 )-1;
    cnt = 0;
    while (1) {
      cnt ++;
      rc = walTryBeginRead(pWal, & notUsed, 1, cnt);
      if (! (rc == -1)) {
        break;
      }
    }
  }
  return (rc);
}
}
static int walWriteToLog(WalWriter *p , void *pContent , int iAmt , sqlite_int64 iOffset___0 ) 
{ 
  int rc ;
  int iFirstAmt ;

  {
  if (iOffset___0 < p->iSyncPoint) {
    if (iOffset___0 + (sqlite_int64 )iAmt >= p->iSyncPoint) {
      iFirstAmt = (int )(p->iSyncPoint - iOffset___0);
      rc = sqlite3OsWrite(p->pFd, (void const   *)pContent, iFirstAmt, iOffset___0);
      if (rc) {
        return (rc);
      }
      iOffset___0 += (sqlite_int64 )iFirstAmt;
      iAmt -= iFirstAmt;
      pContent = (void *)((char *)pContent + iFirstAmt);
      rc = sqlite3OsSync(p->pFd, p->syncFlags & 3);
      if (iAmt == 0) {
        return (rc);
      } else
      if (rc) {
        return (rc);
      }
    }
  }
  rc = sqlite3OsWrite(p->pFd, (void const   *)pContent, iAmt, iOffset___0);
  return (rc);
}
}
static int walWriteOneFrame(WalWriter *p , PgHdr *pPage , int nTruncate , sqlite_int64 iOffset___0 ) 
{ 
  int rc ;
  void *pData ;
  u8 aFrame[24] ;

  {
  pData = pPage->pData;
  walEncodeFrame(p->pWal, pPage->pgno, (u32 )nTruncate, (u8 *)pData, aFrame);
  rc = walWriteToLog(p, (void *)(aFrame), (int )sizeof(aFrame), iOffset___0);
  if (rc) {
    return (rc);
  }
  rc = walWriteToLog(p, pData, p->szPage, (sqlite_int64 )((unsigned long long )iOffset___0 + (unsigned long long )sizeof(aFrame)));
  return (rc);
}
}
static int walRewriteChecksums(Wal *pWal , u32 iLast ) 
{ 
  int szPage ;
  int rc ;
  u8 *aBuf ;
  u8 aFrame[24] ;
  u32 iRead ;
  i64 iCksumOff ;
  void *tmp ;
  i64 iOff ;
  u32 iPgno ;
  u32 nDbSize ;

  {
  szPage = (int )pWal->szPage;
  rc = 0;
  tmp = sqlite3_malloc(szPage + 24);
  aBuf = (u8 *)tmp;
  if ((unsigned long )aBuf == (unsigned long )((u8 *)0)) {
    return (7);
  }
  if (pWal->iReCksum == 1U) {
    iCksumOff = (i64 )24;
  } else {
    iCksumOff = (32LL + (i64 )((pWal->iReCksum - 1U) - 1U) * (i64 )(szPage + 24)) + 16LL;
  }
  rc = sqlite3OsRead(pWal->pWalFd, (void *)aBuf, (int )(sizeof(u32 ) * 2UL), iCksumOff);
  pWal->hdr.aFrameCksum[0] = sqlite3Get4byte((u8 const   *)aBuf);
  pWal->hdr.aFrameCksum[1] = sqlite3Get4byte((u8 const   *)(aBuf + sizeof(u32 )));
  iRead = pWal->iReCksum;
  pWal->iReCksum = (u32 )0;
  while (1) {
    if (rc == 0) {
      if (! (iRead <= iLast)) {
        break;
      }
    } else {
      break;
    }
    iOff = 32LL + (i64 )(iRead - 1U) * (i64 )(szPage + 24);
    rc = sqlite3OsRead(pWal->pWalFd, (void *)aBuf, szPage + 24, iOff);
    if (rc == 0) {
      iPgno = sqlite3Get4byte((u8 const   *)aBuf);
      nDbSize = sqlite3Get4byte((u8 const   *)(aBuf + 4));
      walEncodeFrame(pWal, iPgno, nDbSize, aBuf + 24, aFrame);
      rc = sqlite3OsWrite(pWal->pWalFd, (void const   *)(aFrame), (int )sizeof(aFrame),
                          iOff);
    }
    iRead ++;
  }
  sqlite3_free((void *)aBuf);
  return (rc);
}
}
static int sqlite3WalFrames(Wal *pWal , int szPage , PgHdr *pList , Pgno nTruncate ,
                            int isCommit , int sync_flags ) 
{ 
  int rc ;
  u32 iFrame ;
  PgHdr *p ;
  PgHdr *pLast ;
  int nExtra ;
  int szFrame ;
  i64 iOffset___0 ;
  WalWriter w ;
  u32 iFirst ;
  WalIndexHdr *pLive ;
  WalIndexHdr volatile   *tmp ;
  int tmp___0 ;
  u8 aWalHdr[32] ;
  u32 aCksum[2] ;
  int nDbSize ;
  u32 iWrite ;
  i64 iOff ;
  void *pData ;
  int bSync ;
  int sectorSize ;
  int tmp___1 ;
  i64 sz ;

  {
  pLast = (PgHdr *)0;
  nExtra = 0;
  iFirst = (u32 )0;
  tmp = walIndexHdr(pWal);
  pLive = (WalIndexHdr *)tmp;
  tmp___0 = memcmp((void const   *)(& pWal->hdr), (void const   *)((void *)pLive),
                   sizeof(WalIndexHdr ));
  if (tmp___0 != 0) {
    iFirst = pLive->mxFrame + 1U;
  }
  rc = walRestartLog(pWal);
  if (0 != rc) {
    return (rc);
  }
  iFrame = pWal->hdr.mxFrame;
  if (iFrame == 0U) {
    sqlite3Put4byte(& aWalHdr[0], (u32 )931071618);
    sqlite3Put4byte(& aWalHdr[4], (u32 )3007000);
    sqlite3Put4byte(& aWalHdr[8], (u32 )szPage);
    sqlite3Put4byte(& aWalHdr[12], pWal->nCkpt);
    if (pWal->nCkpt == 0U) {
      sqlite3_randomness(8, (void *)(pWal->hdr.aSalt));
    }
    memcpy((void * __restrict  )(& aWalHdr[16]), (void const   * __restrict  )(pWal->hdr.aSalt),
           (size_t )8);
    walChecksumBytes(1, aWalHdr, 24, (u32 const   *)0, aCksum);
    sqlite3Put4byte(& aWalHdr[24], aCksum[0]);
    sqlite3Put4byte(& aWalHdr[28], aCksum[1]);
    pWal->szPage = (u32 )szPage;
    pWal->hdr.bigEndCksum = (u8 )0;
    pWal->hdr.aFrameCksum[0] = aCksum[0];
    pWal->hdr.aFrameCksum[1] = aCksum[1];
    pWal->truncateOnCommit = (u8 )1;
    rc = sqlite3OsWrite(pWal->pWalFd, (void const   *)(aWalHdr), (int )sizeof(aWalHdr),
                        (i64 )0);
    if (rc != 0) {
      return (rc);
    }
    if (pWal->syncHeader) {
      rc = sqlite3OsSync(pWal->pWalFd, (sync_flags >> 2) & 3);
      if (rc) {
        return (rc);
      }
    }
  }
  w.pWal = pWal;
  w.pFd = pWal->pWalFd;
  w.iSyncPoint = (sqlite_int64 )0;
  w.syncFlags = sync_flags;
  w.szPage = szPage;
  iOffset___0 = 32LL + (i64 )((iFrame + 1U) - 1U) * (i64 )(szPage + 24);
  szFrame = szPage + 24;
  p = pList;
  while (p) {
    if (iFirst) {
      if (p->pDirty) {
        goto _L;
      } else
      if (isCommit == 0) {
        _L: /* CIL Label */ 
        iWrite = (u32 )0;
        sqlite3WalFindFrame(pWal, p->pgno, & iWrite);
        if (iWrite >= iFirst) {
          iOff = (32LL + (i64 )(iWrite - 1U) * (i64 )(szPage + 24)) + 24LL;
          if (pWal->iReCksum == 0U) {
            pWal->iReCksum = iWrite;
          } else
          if (iWrite < pWal->iReCksum) {
            pWal->iReCksum = iWrite;
          }
          pData = p->pData;
          rc = sqlite3OsWrite(pWal->pWalFd, (void const   *)pData, szPage, iOff);
          if (rc) {
            return (rc);
          }
          p->flags = (u16 )((int )p->flags & -65);
          goto __Cont;
        }
      }
    }
    iFrame ++;
    if (isCommit) {
      if ((unsigned long )p->pDirty == (unsigned long )((PgHdr *)0)) {
        nDbSize = (int )nTruncate;
      } else {
        nDbSize = 0;
      }
    } else {
      nDbSize = 0;
    }
    rc = walWriteOneFrame(& w, p, nDbSize, iOffset___0);
    if (rc) {
      return (rc);
    }
    pLast = p;
    iOffset___0 += (i64 )szFrame;
    p->flags = (u16 )((int )p->flags | 64);
    __Cont: /* CIL Label */ 
    p = p->pDirty;
  }
  if (isCommit) {
    if (pWal->iReCksum) {
      rc = walRewriteChecksums(pWal, iFrame);
      if (rc) {
        return (rc);
      }
    }
  }
  if (isCommit) {
    if ((sync_flags & 3) != 0) {
      bSync = 1;
      if (pWal->padToSectorBoundary) {
        tmp___1 = sqlite3SectorSize(pWal->pWalFd);
        sectorSize = tmp___1;
        w.iSyncPoint = (((iOffset___0 + (i64 )sectorSize) - 1LL) / (i64 )sectorSize) * (i64 )sectorSize;
        bSync = w.iSyncPoint == iOffset___0;
        while (iOffset___0 < w.iSyncPoint) {
          rc = walWriteOneFrame(& w, pLast, (int )nTruncate, iOffset___0);
          if (rc) {
            return (rc);
          }
          iOffset___0 += (i64 )szFrame;
          nExtra ++;
        }
      }
      if (bSync) {
        rc = sqlite3OsSync(w.pFd, sync_flags & 3);
      }
    }
  }
  if (isCommit) {
    if (pWal->truncateOnCommit) {
      if (pWal->mxWalSize >= 0LL) {
        sz = pWal->mxWalSize;
        if (32LL + (i64 )(((iFrame + (u32 )nExtra) + 1U) - 1U) * (i64 )(szPage + 24) > pWal->mxWalSize) {
          sz = 32LL + (i64 )(((iFrame + (u32 )nExtra) + 1U) - 1U) * (i64 )(szPage + 24);
        }
        walLimitSize(pWal, sz);
        pWal->truncateOnCommit = (u8 )0;
      }
    }
  }
  iFrame = pWal->hdr.mxFrame;
  p = pList;
  while (1) {
    if (p) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    if (((int )p->flags & 64) == 0) {
      goto __Cont___0;
    }
    iFrame ++;
    rc = walIndexAppend(pWal, iFrame, p->pgno);
    __Cont___0: /* CIL Label */ 
    p = p->pDirty;
  }
  while (1) {
    if (rc == 0) {
      if (! (nExtra > 0)) {
        break;
      }
    } else {
      break;
    }
    iFrame ++;
    nExtra --;
    rc = walIndexAppend(pWal, iFrame, pLast->pgno);
  }
  if (rc == 0) {
    pWal->hdr.szPage = (u16 )((szPage & 65280) | (szPage >> 16));
    pWal->hdr.mxFrame = iFrame;
    if (isCommit) {
      (pWal->hdr.iChange) ++;
      pWal->hdr.nPage = nTruncate;
    }
    if (isCommit) {
      walIndexWriteHdr(pWal);
      pWal->iCallback = iFrame;
    }
  }
  return (rc);
}
}
static int sqlite3WalCheckpoint(Wal *pWal , sqlite3 *db , int eMode , int (*xBusy)(void * ) ,
                                void *pBusyArg , int sync_flags , int nBuf , u8 *zBuf ,
                                int *pnLog , int *pnCkpt ) 
{ 
  int rc ;
  int isChanged ;
  int eMode2 ;
  int (*xBusy2)(void * ) ;
  int tmp ;
  WalCkptInfo volatile   *tmp___0 ;
  int tmp___1 ;

  {
  isChanged = 0;
  eMode2 = eMode;
  xBusy2 = xBusy;
  if (pWal->readOnly) {
    return (8);
  }
  rc = walLockExclusive(pWal, 1, 1);
  if (rc) {
    return (rc);
  }
  pWal->ckptLock = (u8 )1;
  if (eMode != 0) {
    rc = walBusyLock(pWal, xBusy, pBusyArg, 0, 1);
    if (rc == 0) {
      pWal->writeLock = (u8 )1;
    } else
    if (rc == 5) {
      eMode2 = 0;
      xBusy2 = (int (*)(void * ))0;
      rc = 0;
    }
  }
  if (rc == 0) {
    rc = walIndexReadHdr(pWal, & isChanged);
    if (isChanged) {
      if (((pWal->pDbFd)->pMethods)->iVersion >= 3) {
        sqlite3OsUnfetch(pWal->pDbFd, (i64 )0, (void *)0);
      }
    }
  }
  if (rc == 0) {
    if (pWal->hdr.mxFrame) {
      tmp = walPagesize(pWal);
      if (tmp != nBuf) {
        rc = sqlite3CorruptError(62135);
      } else {
        rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);
      }
    } else {
      rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);
    }
    if (rc == 0) {
      goto _L;
    } else
    if (rc == 5) {
      _L: /* CIL Label */ 
      if (pnLog) {
        *pnLog = (int )pWal->hdr.mxFrame;
      }
      if (pnCkpt) {
        tmp___0 = walCkptInfo(pWal);
        *pnCkpt = (int )tmp___0->nBackfill;
      }
    }
  }
  if (isChanged) {
    memset((void *)(& pWal->hdr), 0, sizeof(WalIndexHdr ));
  }
  sqlite3WalEndWriteTransaction(pWal);
  walUnlockExclusive(pWal, 1, 1);
  pWal->ckptLock = (u8 )0;
  if (rc == 0) {
    if (eMode != eMode2) {
      tmp___1 = 5;
    } else {
      tmp___1 = rc;
    }
  } else {
    tmp___1 = rc;
  }
  return (tmp___1);
}
}
static int sqlite3WalCallback(Wal *pWal ) 
{ 
  u32 ret ;

  {
  ret = (u32 )0;
  if (pWal) {
    ret = pWal->iCallback;
    pWal->iCallback = (u32 )0;
  }
  return ((int )ret);
}
}
static int sqlite3WalExclusiveMode(Wal *pWal , int op ) 
{ 
  int rc ;
  int tmp ;

  {
  if (op == 0) {
    if ((int )pWal->exclusiveMode != 0) {
      pWal->exclusiveMode = (u8 )0;
      tmp = walLockShared(pWal, 3 + (int )pWal->readLock);
      if (tmp != 0) {
        pWal->exclusiveMode = (u8 )1;
      }
      rc = (int )pWal->exclusiveMode == 0;
    } else {
      rc = 0;
    }
  } else
  if (op > 0) {
    walUnlockShared(pWal, 3 + (int )pWal->readLock);
    pWal->exclusiveMode = (u8 )1;
    rc = 1;
  } else {
    rc = (int )pWal->exclusiveMode == 0;
  }
  return (rc);
}
}
static int sqlite3WalHeapMemory(Wal *pWal ) 
{ 
  int tmp ;

  {
  if (pWal) {
    if ((int )pWal->exclusiveMode == 2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static sqlite3_file *sqlite3WalFile(Wal *pWal ) 
{ 


  {
  return (pWal->pWalFd);
}
}
static void sqlite3BtreeEnter(Btree *p ) 
{ 


  {
  (p->pBt)->db = p->db;
  return;
}
}
static void sqlite3BtreeEnterAll(sqlite3 *db ) 
{ 
  int i ;
  Btree *p ;

  {
  i = 0;
  while (i < db->nDb) {
    p = (db->aDb + i)->pBt;
    if (p) {
      (p->pBt)->db = p->db;
    }
    i ++;
  }
  return;
}
}
static void sqlite3BtreeEnterCursor(BtCursor *pCur ) 
{ 


  {
  sqlite3BtreeEnter(pCur->pBtree);
  return;
}
}
static char const   zMagicHeader[16]  = 
  {      (char const   )'S',      (char const   )'Q',      (char const   )'L',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )' ',      (char const   )'3',      (char const   )'\000'};
static BtShared *sqlite3SharedCacheList  =    (BtShared *)0;
int sqlite3_enable_shared_cache(int enable ) 
{ 


  {
  sqlite3Config.sharedCacheEnabled = enable;
  return (0);
}
}
static int querySharedCacheTableLock(Btree *p , Pgno iTab , u8 eLock ) 
{ 
  BtShared *pBt ;
  BtLock *pIter ;

  {
  pBt = p->pBt;
  if (! p->sharable) {
    return (0);
  }
  if ((unsigned long )pBt->pWriter != (unsigned long )p) {
    if (((int )pBt->btsFlags & 64) != 0) {
      return (6 | (1 << 8));
    }
  }
  pIter = pBt->pLock;
  while (pIter) {
    if ((unsigned long )pIter->pBtree != (unsigned long )p) {
      if (pIter->iTable == iTab) {
        if ((int )pIter->eLock != (int )eLock) {
          if ((int )eLock == 2) {
            pBt->btsFlags = (u16 )((int )pBt->btsFlags | 128);
          }
          return (6 | (1 << 8));
        }
      }
    }
    pIter = pIter->pNext;
  }
  return (0);
}
}
static int setSharedCacheTableLock(Btree *p , Pgno iTable , u8 eLock ) 
{ 
  BtShared *pBt ;
  BtLock *pLock ;
  BtLock *pIter ;
  void *tmp ;

  {
  pBt = p->pBt;
  pLock = (BtLock *)0;
  pIter = pBt->pLock;
  while (pIter) {
    if (pIter->iTable == iTable) {
      if ((unsigned long )pIter->pBtree == (unsigned long )p) {
        pLock = pIter;
        break;
      }
    }
    pIter = pIter->pNext;
  }
  if (! pLock) {
    tmp = sqlite3MallocZero((u64 )sizeof(BtLock ));
    pLock = (BtLock *)tmp;
    if (! pLock) {
      return (7);
    }
    pLock->iTable = iTable;
    pLock->pBtree = p;
    pLock->pNext = pBt->pLock;
    pBt->pLock = pLock;
  }
  if ((int )eLock > (int )pLock->eLock) {
    pLock->eLock = eLock;
  }
  return (0);
}
}
static void clearAllSharedCacheTableLocks(Btree *p ) 
{ 
  BtShared *pBt ;
  BtLock **ppIter ;
  BtLock *pLock ;

  {
  pBt = p->pBt;
  ppIter = & pBt->pLock;
  while (*ppIter) {
    pLock = *ppIter;
    if ((unsigned long )pLock->pBtree == (unsigned long )p) {
      *ppIter = pLock->pNext;
      if (pLock->iTable != 1U) {
        sqlite3_free((void *)pLock);
      }
    } else {
      ppIter = & pLock->pNext;
    }
  }
  if ((unsigned long )pBt->pWriter == (unsigned long )p) {
    pBt->pWriter = (Btree *)0;
    pBt->btsFlags = (u16 )((int )pBt->btsFlags & -193);
  } else
  if (pBt->nTransaction == 2) {
    pBt->btsFlags = (u16 )((int )pBt->btsFlags & -129);
  }
  return;
}
}
static void downgradeAllSharedCacheTableLocks(Btree *p ) 
{ 
  BtShared *pBt ;
  BtLock *pLock ;

  {
  pBt = p->pBt;
  if ((unsigned long )pBt->pWriter == (unsigned long )p) {
    pBt->pWriter = (Btree *)0;
    pBt->btsFlags = (u16 )((int )pBt->btsFlags & -193);
    pLock = pBt->pLock;
    while (pLock) {
      pLock->eLock = (u8 )1;
      pLock = pLock->pNext;
    }
  }
  return;
}
}
static void releasePage(MemPage *pPage ) ;
static void releasePageOne(MemPage *pPage ) ;
static void releasePageNotNull(MemPage *pPage ) ;
static void invalidateAllOverflowCache(BtShared *pBt ) 
{ 
  BtCursor *p ;

  {
  p = pBt->pCursor;
  while (p) {
    p->curFlags = (u8 )((int )p->curFlags & -5);
    p = p->pNext;
  }
  return;
}
}
static void invalidateIncrblobCursors(Btree *pBtree , Pgno pgnoRoot , i64 iRow , int isClearTable ) 
{ 
  BtCursor *p ;

  {
  if ((int )pBtree->hasIncrblobCur == 0) {
    return;
  }
  pBtree->hasIncrblobCur = (u8 )0;
  p = (pBtree->pBt)->pCursor;
  while (p) {
    if (((int )p->curFlags & 16) != 0) {
      pBtree->hasIncrblobCur = (u8 )1;
      if (p->pgnoRoot == pgnoRoot) {
        if (isClearTable) {
          p->eState = (u8 )1;
        } else
        if (p->info.nKey == iRow) {
          p->eState = (u8 )1;
        }
      }
    }
    p = p->pNext;
  }
  return;
}
}
static int btreeSetHasContent(BtShared *pBt , Pgno pgno ) 
{ 
  int rc ;
  u32 tmp ;

  {
  rc = 0;
  if (! pBt->pHasContent) {
    pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);
    if (! pBt->pHasContent) {
      rc = 7;
    }
  }
  if (rc == 0) {
    tmp = sqlite3BitvecSize(pBt->pHasContent);
    if (pgno <= tmp) {
      rc = sqlite3BitvecSet(pBt->pHasContent, pgno);
    }
  }
  return (rc);
}
}
static int btreeGetHasContent(BtShared *pBt , Pgno pgno ) 
{ 
  Bitvec *p ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  p = pBt->pHasContent;
  if (p) {
    tmp = sqlite3BitvecSize(p);
    if (pgno > tmp) {
      tmp___1 = 1;
    } else {
      tmp___0 = sqlite3BitvecTest(p, pgno);
      if (tmp___0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
static void btreeClearHasContent(BtShared *pBt ) 
{ 


  {
  sqlite3BitvecDestroy(pBt->pHasContent);
  pBt->pHasContent = (Bitvec *)0;
  return;
}
}
static void btreeReleaseAllCursorPages(BtCursor *pCur ) 
{ 
  int i ;

  {
  if ((int )pCur->iPage >= 0) {
    i = 0;
    while (i < (int )pCur->iPage) {
      releasePageNotNull(pCur->apPage[i]);
      i ++;
    }
    releasePageNotNull(pCur->pPage);
    pCur->iPage = (i8 )-1;
  }
  return;
}
}
static int saveCursorKey(BtCursor *pCur ) 
{ 
  int rc ;
  void *pKey ;
  u32 tmp ;

  {
  rc = 0;
  if (pCur->curIntKey) {
    pCur->nKey = sqlite3BtreeIntegerKey(pCur);
  } else {
    tmp = sqlite3BtreePayloadSize(pCur);
    pCur->nKey = (i64 )tmp;
    pKey = sqlite3Malloc((u64 )((pCur->nKey + 9LL) + 8LL));
    if (pKey) {
      rc = sqlite3BtreePayload(pCur, (u32 )0, (u32 )((int )pCur->nKey), pKey);
      if (rc == 0) {
        memset((void *)((u8 *)pKey + pCur->nKey), 0, (size_t )17);
        pCur->pKey = pKey;
      } else {
        sqlite3_free(pKey);
      }
    } else {
      rc = 7;
    }
  }
  return (rc);
}
}
static int saveCursorPosition(BtCursor *pCur ) 
{ 
  int rc ;

  {
  if ((int )pCur->eState == 2) {
    pCur->eState = (u8 )0;
  } else {
    pCur->skipNext = 0;
  }
  rc = saveCursorKey(pCur);
  if (rc == 0) {
    btreeReleaseAllCursorPages(pCur);
    pCur->eState = (u8 )3;
  }
  pCur->curFlags = (u8 )((int )pCur->curFlags & -15);
  return (rc);
}
}
static int ( __attribute__((__noinline__)) saveCursorsOnList)(BtCursor *p , Pgno iRoot ,
                                                              BtCursor *pExcept ) ;
static int saveAllCursors(BtShared *pBt , Pgno iRoot , BtCursor *pExcept ) 
{ 
  BtCursor *p ;
  int tmp ;

  {
  p = pBt->pCursor;
  while (p) {
    if ((unsigned long )p != (unsigned long )pExcept) {
      if (0U == iRoot) {
        break;
      } else
      if (p->pgnoRoot == iRoot) {
        break;
      }
    }
    p = p->pNext;
  }
  if (p) {
    tmp = saveCursorsOnList(p, iRoot, pExcept);
    return (tmp);
  }
  if (pExcept) {
    pExcept->curFlags = (u8 )((int )pExcept->curFlags & -33);
  }
  return (0);
}
}
static int ( __attribute__((__noinline__)) saveCursorsOnList)(BtCursor *p , Pgno iRoot ,
                                                              BtCursor *pExcept ) 
{ 
  int rc ;
  int tmp ;

  {
  while (1) {
    if ((unsigned long )p != (unsigned long )pExcept) {
      if (0U == iRoot) {
        goto _L___0;
      } else
      if (p->pgnoRoot == iRoot) {
        _L___0: /* CIL Label */ 
        if ((int )p->eState == 0) {
          goto _L;
        } else
        if ((int )p->eState == 2) {
          _L: /* CIL Label */ 
          tmp = saveCursorPosition(p);
          rc = tmp;
          if (0 != rc) {
            return (rc);
          }
        } else {
          btreeReleaseAllCursorPages(p);
        }
      }
    }
    p = p->pNext;
    if (! p) {
      break;
    }
  }
  return (0);
}
}
static void sqlite3BtreeClearCursor(BtCursor *pCur ) 
{ 


  {
  sqlite3_free(pCur->pKey);
  pCur->pKey = (void *)0;
  pCur->eState = (u8 )1;
  return;
}
}
static int btreeMoveto(BtCursor *pCur , void const   *pKey , i64 nKey , int bias ,
                       int *pRes ) 
{ 
  int rc ;
  UnpackedRecord *pIdxKey ;
  KeyInfo *pKeyInfo ;

  {
  if (pKey) {
    pKeyInfo = pCur->pKeyInfo;
    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    if ((unsigned long )pIdxKey == (unsigned long )((UnpackedRecord *)0)) {
      return (7);
    }
    sqlite3VdbeRecordUnpack(pKeyInfo, (int )nKey, pKey, pIdxKey);
    if ((int )pIdxKey->nField == 0) {
      rc = sqlite3CorruptError(64197);
      goto moveto_done;
    } else
    if ((int )pIdxKey->nField > (int )pKeyInfo->nAllField) {
      rc = sqlite3CorruptError(64197);
      goto moveto_done;
    }
  } else {
    pIdxKey = (UnpackedRecord *)0;
  }
  rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes);
  moveto_done: 
  if (pIdxKey) {
    sqlite3DbFree((pCur->pKeyInfo)->db, (void *)pIdxKey);
  }
  return (rc);
}
}
static int btreeRestoreCursorPosition(BtCursor *pCur ) 
{ 
  int rc ;
  int skipNext ;
  int tmp ;

  {
  skipNext = 0;
  if ((int )pCur->eState == 4) {
    return (pCur->skipNext);
  }
  pCur->eState = (u8 )1;
  tmp = sqlite3FaultSim(410);
  if (tmp) {
    rc = 10;
  } else {
    rc = btreeMoveto(pCur, (void const   *)pCur->pKey, pCur->nKey, 0, & skipNext);
  }
  if (rc == 0) {
    sqlite3_free(pCur->pKey);
    pCur->pKey = (void *)0;
    if (skipNext) {
      pCur->skipNext = skipNext;
    }
    if (pCur->skipNext) {
      if ((int )pCur->eState == 0) {
        pCur->eState = (u8 )2;
      }
    }
  }
  return (rc);
}
}
static int sqlite3BtreeCursorHasMoved(BtCursor *pCur ) 
{ 


  {
  return (0 != (int )*((u8 *)pCur));
}
}
static u8 fakeCursor  =    (u8 )0;
static BtCursor *sqlite3BtreeFakeValidCursor(void) 
{ 


  {
  return ((BtCursor *)(& fakeCursor));
}
}
static int sqlite3BtreeCursorRestore(BtCursor *pCur , int *pDifferentRow ) 
{ 
  int rc ;
  int tmp ;

  {
  if ((int )pCur->eState >= 3) {
    tmp = btreeRestoreCursorPosition(pCur);
    rc = tmp;
  } else {
    rc = 0;
  }
  if (rc) {
    *pDifferentRow = 1;
    return (rc);
  }
  if ((int )pCur->eState != 0) {
    *pDifferentRow = 1;
  } else {
    *pDifferentRow = 0;
  }
  return (0);
}
}
static void sqlite3BtreeCursorHintFlags(BtCursor *pCur , unsigned int x___0 ) 
{ 


  {
  pCur->hints = (u8 )x___0;
  return;
}
}
static Pgno ptrmapPageno(BtShared *pBt , Pgno pgno ) 
{ 
  int nPagesPerMapPage ;
  Pgno iPtrMap ;
  Pgno ret ;

  {
  if (pgno < 2U) {
    return ((Pgno )0);
  }
  nPagesPerMapPage = (int )(pBt->usableSize / 5U + 1U);
  iPtrMap = (pgno - 2U) / (Pgno )nPagesPerMapPage;
  ret = iPtrMap * (Pgno )nPagesPerMapPage + 2U;
  if (ret == (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
    ret ++;
  }
  return (ret);
}
}
static void ptrmapPut(BtShared *pBt , Pgno key , u8 eType , Pgno parent , int *pRC ) 
{ 
  DbPage *pDbPage ;
  u8 *pPtrmap ;
  Pgno iPtrmap ;
  int offset ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;

  {
  if (*pRC) {
    return;
  }
  if (key == 0U) {
    *pRC = sqlite3CorruptError(64380);
    return;
  }
  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, & pDbPage, 0);
  if (rc != 0) {
    *pRC = rc;
    return;
  }
  tmp = sqlite3PagerGetExtra(pDbPage);
  if ((int )*((char *)tmp + 0) != 0) {
    *pRC = sqlite3CorruptError(64393);
    goto ptrmap_exit;
  }
  offset = (int )(5U * ((key - iPtrmap) - 1U));
  if (offset < 0) {
    *pRC = sqlite3CorruptError(64398);
    goto ptrmap_exit;
  }
  tmp___0 = sqlite3PagerGetData(pDbPage);
  pPtrmap = (u8 *)tmp___0;
  if ((int )eType != (int )*(pPtrmap + offset)) {
    goto _L;
  } else {
    tmp___1 = sqlite3Get4byte((u8 const   *)(pPtrmap + (offset + 1)));
    if (tmp___1 != parent) {
      _L: /* CIL Label */ 
      rc = sqlite3PagerWrite(pDbPage);
      *pRC = rc;
      if (rc == 0) {
        *(pPtrmap + offset) = eType;
        sqlite3Put4byte(pPtrmap + (offset + 1), parent);
      }
    }
  }
  ptrmap_exit: 
  sqlite3PagerUnref(pDbPage);
  return;
}
}
static int ptrmapGet(BtShared *pBt , Pgno key , u8 *pEType , Pgno *pPgno ) 
{ 
  DbPage *pDbPage ;
  int iPtrmap ;
  u8 *pPtrmap ;
  int offset ;
  int rc ;
  Pgno tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = ptrmapPageno(pBt, key);
  iPtrmap = (int )tmp;
  rc = sqlite3PagerGet(pBt->pPager, (Pgno )iPtrmap, & pDbPage, 0);
  if (rc != 0) {
    return (rc);
  }
  tmp___0 = sqlite3PagerGetData(pDbPage);
  pPtrmap = (u8 *)tmp___0;
  offset = (int )(5U * ((key - (Pgno )iPtrmap) - 1U));
  if (offset < 0) {
    sqlite3PagerUnref(pDbPage);
    tmp___1 = sqlite3CorruptError(64443);
    return (tmp___1);
  }
  *pEType = *(pPtrmap + offset);
  if (pPgno) {
    *pPgno = sqlite3Get4byte((u8 const   *)(pPtrmap + (offset + 1)));
  }
  sqlite3PagerUnref(pDbPage);
  if ((int )*pEType < 1) {
    tmp___2 = sqlite3CorruptError(64451);
    return (tmp___2);
  } else
  if ((int )*pEType > 5) {
    tmp___2 = sqlite3CorruptError(64451);
    return (tmp___2);
  }
  return (0);
}
}
static void ( __attribute__((__noinline__)) btreeParseCellAdjustSizeForOverflow)(MemPage *pPage ,
                                                                                 u8 *pCell ,
                                                                                 CellInfo *pInfo ) 
{ 
  int minLocal ;
  int maxLocal ;
  int surplus ;

  {
  minLocal = (int )pPage->minLocal;
  maxLocal = (int )pPage->maxLocal;
  surplus = (int )((unsigned int )minLocal + (pInfo->nPayload - (u32 )minLocal) % ((pPage->pBt)->usableSize - 4U));
  if (surplus <= maxLocal) {
    pInfo->nLocal = (u16 )surplus;
  } else {
    pInfo->nLocal = (u16 )minLocal;
  }
  pInfo->nSize = (u16 )((int )((u16 )((pInfo->pPayload + pInfo->nLocal) - pCell)) + 4);
  return;
}
}
static void btreeParseCellPtrNoPayload(MemPage *pPage , u8 *pCell , CellInfo *pInfo ) 
{ 
  u8 tmp ;

  {
  tmp = sqlite3GetVarint((unsigned char const   *)(pCell + 4), (u64 *)(& pInfo->nKey));
  pInfo->nSize = (u16 )(4 + (int )tmp);
  pInfo->nPayload = (u32 )0;
  pInfo->nLocal = (u16 )0;
  pInfo->pPayload = (u8 *)0;
  return;
}
}
static void btreeParseCellPtr(MemPage *pPage , u8 *pCell , CellInfo *pInfo ) 
{ 
  u8 *pIter ;
  u32 nPayload ;
  u64 iKey ;
  u8 *pEnd ;
  u8 *pEnd___0 ;

  {
  pIter = pCell;
  nPayload = (u32 )*pIter;
  if (nPayload >= 128U) {
    pEnd = pIter + 8;
    nPayload &= 127U;
    while (1) {
      pIter ++;
      nPayload = (nPayload << 7) | (unsigned int )((int )*pIter & 127);
      if ((int )*pIter >= 128) {
        if (! ((unsigned long )pIter < (unsigned long )pEnd)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  pIter ++;
  iKey = (u64 )*pIter;
  if (iKey >= 128ULL) {
    pEnd___0 = pIter + 7;
    iKey &= 127ULL;
    while (1) {
      pIter ++;
      iKey = (iKey << 7) | (unsigned long long )((int )*pIter & 127);
      if ((int )*pIter < 128) {
        break;
      }
      if ((unsigned long )pIter >= (unsigned long )pEnd___0) {
        pIter ++;
        iKey = (iKey << 8) | (unsigned long long )*pIter;
        break;
      }
    }
  }
  pIter ++;
  pInfo->nKey = *((i64 *)(& iKey));
  pInfo->nPayload = nPayload;
  pInfo->pPayload = pIter;
  if (nPayload <= (u32 )pPage->maxLocal) {
    pInfo->nSize = (u16 )(nPayload + (u32 )((u16 )(pIter - pCell)));
    if ((int )pInfo->nSize < 4) {
      pInfo->nSize = (u16 )4;
    }
    pInfo->nLocal = (u16 )nPayload;
  } else {
    btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
  }
  return;
}
}
static void btreeParseCellPtrIndex(MemPage *pPage , u8 *pCell , CellInfo *pInfo ) 
{ 
  u8 *pIter ;
  u32 nPayload ;
  u8 *pEnd ;

  {
  pIter = pCell + (int )pPage->childPtrSize;
  nPayload = (u32 )*pIter;
  if (nPayload >= 128U) {
    pEnd = pIter + 8;
    nPayload &= 127U;
    while (1) {
      pIter ++;
      nPayload = (nPayload << 7) | (unsigned int )((int )*pIter & 127);
      if ((int )*pIter >= 128) {
        if (! ((unsigned long )pIter < (unsigned long )pEnd)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  pIter ++;
  pInfo->nKey = (i64 )nPayload;
  pInfo->nPayload = nPayload;
  pInfo->pPayload = pIter;
  if (nPayload <= (u32 )pPage->maxLocal) {
    pInfo->nSize = (u16 )(nPayload + (u32 )((u16 )(pIter - pCell)));
    if ((int )pInfo->nSize < 4) {
      pInfo->nSize = (u16 )4;
    }
    pInfo->nLocal = (u16 )nPayload;
  } else {
    btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
  }
  return;
}
}
static void btreeParseCell(MemPage *pPage , int iCell , CellInfo *pInfo ) 
{ 
  short tmp ;

  {
  tmp = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * iCell)));
  (*(pPage->xParseCell))(pPage, pPage->aData + ((int )pPage->maskPage & (int )tmp),
                         pInfo);
  return;
}
}
static u16 cellSizePtr(MemPage *pPage , u8 *pCell ) 
{ 
  u8 *pIter ;
  u8 *pEnd ;
  u32 nSize ;
  u8 *tmp ;
  int minLocal ;

  {
  pIter = pCell + (int )pPage->childPtrSize;
  nSize = (u32 )*pIter;
  if (nSize >= 128U) {
    pEnd = pIter + 8;
    nSize &= 127U;
    while (1) {
      pIter ++;
      nSize = (nSize << 7) | (unsigned int )((int )*pIter & 127);
      if ((int )*pIter >= 128) {
        if (! ((unsigned long )pIter < (unsigned long )pEnd)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  pIter ++;
  if (pPage->intKey) {
    pEnd = pIter + 9;
    while (1) {
      tmp = pIter;
      pIter ++;
      if ((int )*tmp & 128) {
        if (! ((unsigned long )pIter < (unsigned long )pEnd)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  if (nSize <= (u32 )pPage->maxLocal) {
    nSize += (u32 )(pIter - pCell);
    if (nSize < 4U) {
      nSize = (u32 )4;
    }
  } else {
    minLocal = (int )pPage->minLocal;
    nSize = (unsigned int )minLocal + (nSize - (u32 )minLocal) % ((pPage->pBt)->usableSize - 4U);
    if (nSize > (u32 )pPage->maxLocal) {
      nSize = (u32 )minLocal;
    }
    nSize += (u32 )(4 + (int )((u16 )(pIter - pCell)));
  }
  return ((u16 )nSize);
}
}
static u16 cellSizePtrNoPayload(MemPage *pPage , u8 *pCell ) 
{ 
  u8 *pIter ;
  u8 *pEnd ;
  u8 *tmp ;

  {
  pIter = pCell + 4;
  pEnd = pIter + 9;
  while (1) {
    tmp = pIter;
    pIter ++;
    if ((int )*tmp & 128) {
      if (! ((unsigned long )pIter < (unsigned long )pEnd)) {
        break;
      }
    } else {
      break;
    }
  }
  return ((u16 )(pIter - pCell));
}
}
static void ptrmapPutOvflPtr(MemPage *pPage , MemPage *pSrc , u8 *pCell , int *pRC ) 
{ 
  CellInfo info ;
  Pgno ovfl ;

  {
  if (*pRC) {
    return;
  }
  (*(pPage->xParseCell))(pPage, pCell, & info);
  if ((u32 )info.nLocal < info.nPayload) {
    if ((uptr )pSrc->aDataEnd >= (uptr )pCell) {
      if ((uptr )pSrc->aDataEnd < (uptr )(pCell + (int )info.nLocal)) {
        *pRC = sqlite3CorruptError(64765);
        return;
      }
    }
    ovfl = sqlite3Get4byte((u8 const   *)(pCell + ((int )info.nSize - 4)));
    ptrmapPut(pPage->pBt, ovfl, (u8 )3, pPage->pgno, pRC);
  }
  return;
}
}
static int defragmentPage(MemPage *pPage , int nMaxFrag ) 
{ 
  int i ;
  int pc ;
  int hdr ;
  int size ;
  int usableSize ;
  int cellOffset ;
  int cbrk ;
  int nCell ;
  unsigned char *data ;
  unsigned char *temp ;
  unsigned char *src ;
  int iCellFirst ;
  int iCellLast ;
  int iFree ;
  int tmp ;
  int iFree2 ;
  int tmp___0 ;
  u8 *pEnd ;
  u8 *pAddr ;
  int sz2 ;
  int sz ;
  int top ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u8 *pAddr___0 ;
  int tmp___5 ;
  u16 tmp___6 ;
  int tmp___7 ;
  int x___0 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  temp = (unsigned char *)0;
  data = pPage->aData;
  src = data;
  hdr = (int )pPage->hdrOffset;
  cellOffset = (int )pPage->cellOffset;
  nCell = (int )pPage->nCell;
  iCellFirst = cellOffset + 2 * nCell;
  usableSize = (int )(pPage->pBt)->usableSize;
  if ((int )*(data + (hdr + 7)) <= nMaxFrag) {
    iFree = ((int )*((data + (hdr + 1)) + 0) << 8) | (int )*((data + (hdr + 1)) + 1);
    if (iFree > usableSize - 4) {
      tmp = sqlite3CorruptError(64823);
      return (tmp);
    }
    if (iFree) {
      iFree2 = ((int )*((data + iFree) + 0) << 8) | (int )*((data + iFree) + 1);
      if (iFree2 > usableSize - 4) {
        tmp___0 = sqlite3CorruptError(64826);
        return (tmp___0);
      }
      if (0 == iFree2) {
        goto _L;
      } else
      if ((int )*(data + iFree2) == 0) {
        if ((int )*(data + (iFree2 + 1)) == 0) {
          _L: /* CIL Label */ 
          pEnd = data + (cellOffset + nCell * 2);
          sz2 = 0;
          sz = ((int )*((data + (iFree + 2)) + 0) << 8) | (int )*((data + (iFree + 2)) + 1);
          top = ((int )*((data + (hdr + 5)) + 0) << 8) | (int )*((data + (hdr + 5)) + 1);
          if (top >= iFree) {
            tmp___1 = sqlite3CorruptError(64834);
            return (tmp___1);
          }
          if (iFree2) {
            if (iFree + sz > iFree2) {
              tmp___2 = sqlite3CorruptError(64837);
              return (tmp___2);
            }
            sz2 = ((int )*((data + (iFree2 + 2)) + 0) << 8) | (int )*((data + (iFree2 + 2)) + 1);
            if (iFree2 + sz2 > usableSize) {
              tmp___3 = sqlite3CorruptError(64839);
              return (tmp___3);
            }
            memmove((void *)(data + ((iFree + sz) + sz2)), (void const   *)(data + (iFree + sz)),
                    (size_t )(iFree2 - (iFree + sz)));
            sz += sz2;
          } else
          if (iFree + sz > usableSize) {
            tmp___4 = sqlite3CorruptError(64843);
            return (tmp___4);
          }
          cbrk = top + sz;
          memmove((void *)(data + cbrk), (void const   *)(data + top), (size_t )(iFree - top));
          pAddr = data + cellOffset;
          while ((unsigned long )pAddr < (unsigned long )pEnd) {
            pc = ((int )*(pAddr + 0) << 8) | (int )*(pAddr + 1);
            if (pc < iFree) {
              *(pAddr + 0) = (u8 )((pc + sz) >> 8);
              *(pAddr + 1) = (u8 )(pc + sz);
            } else
            if (pc < iFree2) {
              *(pAddr + 0) = (u8 )((pc + sz2) >> 8);
              *(pAddr + 1) = (u8 )(pc + sz2);
            }
            pAddr += 2;
          }
          goto defragment_out;
        }
      }
    }
  }
  cbrk = usableSize;
  iCellLast = usableSize - 4;
  i = 0;
  while (i < nCell) {
    pAddr___0 = data + (cellOffset + i * 2);
    pc = ((int )*(pAddr___0 + 0) << 8) | (int )*(pAddr___0 + 1);
    if (pc < iCellFirst) {
      tmp___5 = sqlite3CorruptError(64871);
      return (tmp___5);
    } else
    if (pc > iCellLast) {
      tmp___5 = sqlite3CorruptError(64871);
      return (tmp___5);
    }
    tmp___6 = (*(pPage->xCellSize))(pPage, src + pc);
    size = (int )tmp___6;
    cbrk -= size;
    if (cbrk < iCellFirst) {
      tmp___7 = sqlite3CorruptError(64877);
      return (tmp___7);
    } else
    if (pc + size > usableSize) {
      tmp___7 = sqlite3CorruptError(64877);
      return (tmp___7);
    }
    *(pAddr___0 + 0) = (u8 )(cbrk >> 8);
    *(pAddr___0 + 1) = (u8 )cbrk;
    if ((unsigned long )temp == (unsigned long )((unsigned char *)0)) {
      if (cbrk == pc) {
        goto __Cont;
      }
      tmp___8 = sqlite3PagerTempSpace((pPage->pBt)->pPager);
      temp = (unsigned char *)tmp___8;
      x___0 = ((int )*((data + (hdr + 5)) + 0) << 8) | (int )*((data + (hdr + 5)) + 1);
      memcpy((void * __restrict  )(temp + x___0), (void const   * __restrict  )(data + x___0),
             (size_t )((cbrk + size) - x___0));
      src = temp;
    }
    memcpy((void * __restrict  )(data + cbrk), (void const   * __restrict  )(src + pc),
           (size_t )size);
    __Cont: /* CIL Label */ 
    i ++;
  }
  *(data + (hdr + 7)) = (unsigned char)0;
  defragment_out: ;
  if (((int )*(data + (hdr + 7)) + cbrk) - iCellFirst != pPage->nFree) {
    tmp___9 = sqlite3CorruptError(64898);
    return (tmp___9);
  }
  *((data + (hdr + 5)) + 0) = (u8 )(cbrk >> 8);
  *((data + (hdr + 5)) + 1) = (u8 )cbrk;
  *(data + (hdr + 1)) = (unsigned char)0;
  *(data + (hdr + 2)) = (unsigned char)0;
  memset((void *)(data + iCellFirst), 0, (size_t )(cbrk - iCellFirst));
  return (0);
}
}
static u8 *pageFindSlot(MemPage *pPg , int nByte , int *pRc ) 
{ 
  int hdr ;
  u8 *aData ;
  int iAddr ;
  int pc ;
  int x___0 ;
  int maxPC ;
  int size ;

  {
  hdr = (int )pPg->hdrOffset;
  aData = pPg->aData;
  iAddr = hdr + 1;
  pc = ((int )*((aData + iAddr) + 0) << 8) | (int )*((aData + iAddr) + 1);
  maxPC = (int )((pPg->pBt)->usableSize - (u32 )nByte);
  while (pc <= maxPC) {
    size = ((int )*((aData + (pc + 2)) + 0) << 8) | (int )*((aData + (pc + 2)) + 1);
    x___0 = size - nByte;
    if (x___0 >= 0) {
      if (x___0 < 4) {
        if ((int )*(aData + (hdr + 7)) > 57) {
          return ((u8 *)0);
        }
        memcpy((void * __restrict  )(aData + iAddr), (void const   * __restrict  )(aData + pc),
               (size_t )2);
        *(aData + (hdr + 7)) = (u8 )((int )*(aData + (hdr + 7)) + (int )((u8 )x___0));
      } else
      if (x___0 + pc > maxPC) {
        *pRc = sqlite3CorruptError(64952);
        return ((u8 *)0);
      } else {
        *((aData + (pc + 2)) + 0) = (u8 )(x___0 >> 8);
        *((aData + (pc + 2)) + 1) = (u8 )x___0;
      }
      return (aData + (pc + x___0));
    }
    iAddr = pc;
    pc = ((int )*((aData + pc) + 0) << 8) | (int )*((aData + pc) + 1);
    if (pc <= iAddr + size) {
      if (pc) {
        *pRc = sqlite3CorruptError(64966);
      }
      return ((u8 *)0);
    }
  }
  if (pc > (maxPC + nByte) - 4) {
    *pRc = sqlite3CorruptError(64973);
  }
  return ((u8 *)0);
}
}
static int allocateSpace(MemPage *pPage , int nByte , int *pIdx ) 
{ 
  int hdr ;
  u8 *data ;
  int top ;
  int rc ;
  int gap ;
  int tmp ;
  u8 *pSpace ;
  u8 *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  hdr = (int )pPage->hdrOffset;
  data = pPage->aData;
  rc = 0;
  gap = (int )pPage->cellOffset + 2 * (int )pPage->nCell;
  top = ((int )*((data + (hdr + 5)) + 0) << 8) | (int )*((data + (hdr + 5)) + 1);
  if (gap > top) {
    if (top == 0) {
      if ((pPage->pBt)->usableSize == 65536U) {
        top = 65536;
      } else {
        tmp = sqlite3CorruptError(65020);
        return (tmp);
      }
    } else {
      tmp = sqlite3CorruptError(65020);
      return (tmp);
    }
  }
  if (*(data + (hdr + 2))) {
    goto _L;
  } else
  if (*(data + (hdr + 1))) {
    _L: /* CIL Label */ 
    if (gap + 2 <= top) {
      tmp___0 = pageFindSlot(pPage, nByte, & rc);
      pSpace = tmp___0;
      if (pSpace) {
        tmp___2 = (int )(pSpace - data);
        *pIdx = tmp___2;
        if (tmp___2 <= gap) {
          tmp___1 = sqlite3CorruptError(65036);
          return (tmp___1);
        } else {
          return (0);
        }
      } else
      if (rc) {
        return (rc);
      }
    }
  }
  if ((gap + 2) + nByte > top) {
    if (4 < pPage->nFree - (2 + nByte)) {
      tmp___3 = 4;
    } else {
      tmp___3 = pPage->nFree - (2 + nByte);
    }
    rc = defragmentPage(pPage, tmp___3);
    if (rc) {
      return (rc);
    }
    top = (((((int )*((data + (hdr + 5)) + 0) << 8) | (int )*((data + (hdr + 5)) + 1)) - 1) & 65535) + 1;
  }
  top -= nByte;
  *((data + (hdr + 5)) + 0) = (u8 )(top >> 8);
  *((data + (hdr + 5)) + 1) = (u8 )top;
  *pIdx = top;
  return (0);
}
}
static int freeSpace(MemPage *pPage , u16 iStart , u16 iSize ) 
{ 
  u16 iPtr ;
  u16 iFreeBlk ;
  u8 hdr ;
  u8 nFrag ;
  u16 iOrigSize ;
  u16 x___0 ;
  u32 iEnd ;
  unsigned char *data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int iPtrEnd ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  nFrag = (u8 )0;
  iOrigSize = iSize;
  iEnd = (u32 )((int )iStart + (int )iSize);
  data = pPage->aData;
  hdr = pPage->hdrOffset;
  iPtr = (u16 )((int )hdr + 1);
  if ((int )*(data + ((int )iPtr + 1)) == 0) {
    if ((int )*(data + iPtr) == 0) {
      iFreeBlk = (u16 )0;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    while (1) {
      iFreeBlk = (u16 )(((int )*((data + iPtr) + 0) << 8) | (int )*((data + iPtr) + 1));
      if (! ((int )iFreeBlk < (int )iStart)) {
        break;
      }
      if ((int )iFreeBlk < (int )iPtr + 4) {
        if ((int )iFreeBlk == 0) {
          break;
        }
        tmp = sqlite3CorruptError(65114);
        return (tmp);
      }
      iPtr = iFreeBlk;
    }
    if ((u32 )iFreeBlk > (pPage->pBt)->usableSize - 4U) {
      tmp___0 = sqlite3CorruptError(65119);
      return (tmp___0);
    }
    if (iFreeBlk) {
      if (iEnd + 3U >= (u32 )iFreeBlk) {
        nFrag = (u8 )((u32 )iFreeBlk - iEnd);
        if (iEnd > (u32 )iFreeBlk) {
          tmp___1 = sqlite3CorruptError(65131);
          return (tmp___1);
        }
        iEnd = (u32 )((int )iFreeBlk + (((int )*((data + ((int )iFreeBlk + 2)) + 0) << 8) | (int )*((data + ((int )iFreeBlk + 2)) + 1)));
        if (iEnd > (pPage->pBt)->usableSize) {
          tmp___2 = sqlite3CorruptError(65134);
          return (tmp___2);
        }
        iSize = (u16 )(iEnd - (u32 )iStart);
        iFreeBlk = (u16 )(((int )*((data + iFreeBlk) + 0) << 8) | (int )*((data + iFreeBlk) + 1));
      }
    }
    if ((int )iPtr > (int )hdr + 1) {
      iPtrEnd = (int )iPtr + (((int )*((data + ((int )iPtr + 2)) + 0) << 8) | (int )*((data + ((int )iPtr + 2)) + 1));
      if (iPtrEnd + 3 >= (int )iStart) {
        if (iPtrEnd > (int )iStart) {
          tmp___3 = sqlite3CorruptError(65147);
          return (tmp___3);
        }
        nFrag = (u8 )((int )nFrag + ((int )iStart - iPtrEnd));
        iSize = (u16 )(iEnd - (u32 )iPtr);
        iStart = iPtr;
      }
    }
    if ((int )nFrag > (int )*(data + ((int )hdr + 7))) {
      tmp___4 = sqlite3CorruptError(65153);
      return (tmp___4);
    }
    *(data + ((int )hdr + 7)) = (unsigned char )((int )*(data + ((int )hdr + 7)) - (int )nFrag);
  }
  x___0 = (u16 )(((int )*((data + ((int )hdr + 5)) + 0) << 8) | (int )*((data + ((int )hdr + 5)) + 1));
  if ((int )iStart <= (int )x___0) {
    if ((int )iStart < (int )x___0) {
      tmp___5 = sqlite3CorruptError(65161);
      return (tmp___5);
    } else
    if ((int )iPtr != (int )hdr + 1) {
      tmp___5 = sqlite3CorruptError(65161);
      return (tmp___5);
    }
    *((data + ((int )hdr + 1)) + 0) = (u8 )((int )iFreeBlk >> 8);
    *((data + ((int )hdr + 1)) + 1) = (u8 )iFreeBlk;
    *((data + ((int )hdr + 5)) + 0) = (u8 )(iEnd >> 8);
    *((data + ((int )hdr + 5)) + 1) = (u8 )iEnd;
  } else {
    *((data + iPtr) + 0) = (u8 )((int )iStart >> 8);
    *((data + iPtr) + 1) = (u8 )iStart;
  }
  if ((int )(pPage->pBt)->btsFlags & 12) {
    memset((void *)(data + iStart), 0, (size_t )iSize);
  }
  *((data + iStart) + 0) = (u8 )((int )iFreeBlk >> 8);
  *((data + iStart) + 1) = (u8 )iFreeBlk;
  *((data + ((int )iStart + 2)) + 0) = (u8 )((int )iSize >> 8);
  *((data + ((int )iStart + 2)) + 1) = (u8 )iSize;
  pPage->nFree += (int )iOrigSize;
  return (0);
}
}
static int decodeFlags(MemPage *pPage , int flagByte ) 
{ 
  BtShared *pBt ;
  int tmp ;

  {
  pPage->leaf = (u8 )(flagByte >> 3);
  flagByte &= -9;
  pPage->childPtrSize = (u8 )(4 - 4 * (int )pPage->leaf);
  pPage->xCellSize = & cellSizePtr;
  pBt = pPage->pBt;
  if (flagByte == 5) {
    pPage->intKey = (u8 )1;
    if (pPage->leaf) {
      pPage->intKeyLeaf = (u8 )1;
      pPage->xParseCell = & btreeParseCellPtr;
    } else {
      pPage->intKeyLeaf = (u8 )0;
      pPage->xCellSize = & cellSizePtrNoPayload;
      pPage->xParseCell = & btreeParseCellPtrNoPayload;
    }
    pPage->maxLocal = pBt->maxLeaf;
    pPage->minLocal = pBt->minLeaf;
  } else
  if (flagByte == 2) {
    pPage->intKey = (u8 )0;
    pPage->intKeyLeaf = (u8 )0;
    pPage->xParseCell = & btreeParseCellPtrIndex;
    pPage->maxLocal = pBt->maxLocal;
    pPage->minLocal = pBt->minLocal;
  } else {
    tmp = sqlite3CorruptError(65234);
    return (tmp);
  }
  pPage->max1bytePayload = pBt->max1bytePayload;
  return (0);
}
}
static int btreeComputeFreeSpace(MemPage *pPage ) 
{ 
  int pc ;
  u8 hdr ;
  u8 *data ;
  int usableSize ;
  int nFree ;
  int top ;
  int iCellFirst ;
  int iCellLast ;
  u32 next ;
  u32 size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  usableSize = (int )(pPage->pBt)->usableSize;
  hdr = pPage->hdrOffset;
  data = pPage->aData;
  top = (((((int )*((data + ((int )hdr + 5)) + 0) << 8) | (int )*((data + ((int )hdr + 5)) + 1)) - 1) & 65535) + 1;
  iCellFirst = (((int )hdr + 8) + (int )pPage->childPtrSize) + 2 * (int )pPage->nCell;
  iCellLast = usableSize - 4;
  pc = ((int )*((data + ((int )hdr + 1)) + 0) << 8) | (int )*((data + ((int )hdr + 1)) + 1);
  nFree = (int )*(data + ((int )hdr + 7)) + top;
  if (pc > 0) {
    if (pc < iCellFirst) {
      tmp = sqlite3CorruptError(65285);
      return (tmp);
    }
    while (1) {
      if (pc > iCellLast) {
        tmp___0 = sqlite3CorruptError(65290);
        return (tmp___0);
      }
      next = (u32 )(((int )*((data + pc) + 0) << 8) | (int )*((data + pc) + 1));
      size = (u32 )(((int )*((data + (pc + 2)) + 0) << 8) | (int )*((data + (pc + 2)) + 1));
      nFree = (int )((u32 )nFree + size);
      if (next <= ((u32 )pc + size) + 3U) {
        break;
      }
      pc = (int )next;
    }
    if (next > 0U) {
      tmp___1 = sqlite3CorruptError(65300);
      return (tmp___1);
    }
    if ((u32 )pc + size > (unsigned int )usableSize) {
      tmp___2 = sqlite3CorruptError(65304);
      return (tmp___2);
    }
  }
  if (nFree > usableSize) {
    tmp___3 = sqlite3CorruptError(65316);
    return (tmp___3);
  } else
  if (nFree < iCellFirst) {
    tmp___3 = sqlite3CorruptError(65316);
    return (tmp___3);
  }
  pPage->nFree = (int )((u16 )(nFree - iCellFirst));
  return (0);
}
}
static int ( __attribute__((__noinline__)) btreeCellSizeCheck)(MemPage *pPage ) 
{ 
  int iCellFirst ;
  int iCellLast ;
  int i ;
  int sz ;
  int pc ;
  u8 *data ;
  int usableSize ;
  int cellOffset ;
  short tmp ;
  int tmp___0 ;
  u16 tmp___1 ;
  int tmp___2 ;

  {
  iCellFirst = (int )pPage->cellOffset + 2 * (int )pPage->nCell;
  usableSize = (int )(pPage->pBt)->usableSize;
  iCellLast = usableSize - 4;
  data = pPage->aData;
  cellOffset = (int )pPage->cellOffset;
  if (! pPage->leaf) {
    iCellLast --;
  }
  i = 0;
  while (i < (int )pPage->nCell) {
    tmp = __builtin_bswap16((short )*((u16 *)(data + (cellOffset + i * 2))));
    pc = (int )tmp;
    if (pc < iCellFirst) {
      tmp___0 = sqlite3CorruptError(65347);
      return (tmp___0);
    } else
    if (pc > iCellLast) {
      tmp___0 = sqlite3CorruptError(65347);
      return (tmp___0);
    }
    tmp___1 = (*(pPage->xCellSize))(pPage, data + pc);
    sz = (int )tmp___1;
    if (pc + sz > usableSize) {
      tmp___2 = sqlite3CorruptError(65352);
      return (tmp___2);
    }
    i ++;
  }
  return (0);
}
}
static int btreeInitPage(MemPage *pPage ) 
{ 
  u8 *data ;
  BtShared *pBt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pBt = pPage->pBt;
  data = pPage->aData + (int )pPage->hdrOffset;
  tmp___0 = decodeFlags(pPage, (int )*(data + 0));
  if (tmp___0) {
    tmp = sqlite3CorruptError(65384);
    return (tmp);
  }
  pPage->maskPage = (u16 )(pBt->pageSize - 1U);
  pPage->nOverflow = (u8 )0;
  pPage->cellOffset = (u16 )(((int )pPage->hdrOffset + 8) + (int )pPage->childPtrSize);
  pPage->aCellIdx = (data + (int )pPage->childPtrSize) + 8;
  pPage->aDataEnd = pPage->aData + pBt->usableSize;
  pPage->aDataOfst = pPage->aData + (int )pPage->childPtrSize;
  pPage->nCell = (u16 )(((int )*((data + 3) + 0) << 8) | (int )*((data + 3) + 1));
  if ((u32 )pPage->nCell > (pBt->pageSize - 8U) / 6U) {
    tmp___1 = sqlite3CorruptError(65398);
    return (tmp___1);
  }
  pPage->nFree = -1;
  pPage->isInit = (u8 )1;
  if ((pBt->db)->flags & 2097152ULL) {
    tmp___2 = btreeCellSizeCheck(pPage);
    return (tmp___2);
  }
  return (0);
}
}
static void zeroPage(MemPage *pPage , int flags___0 ) 
{ 
  unsigned char *data ;
  BtShared *pBt ;
  u8 hdr ;
  u16 first ;
  int tmp ;

  {
  data = pPage->aData;
  pBt = pPage->pBt;
  hdr = pPage->hdrOffset;
  if ((int )pBt->btsFlags & 12) {
    memset((void *)(data + hdr), 0, (size_t )(pBt->usableSize - (u32 )hdr));
  }
  *(data + hdr) = (unsigned char )((char )flags___0);
  if ((flags___0 & 8) == 0) {
    tmp = 12;
  } else {
    tmp = 8;
  }
  first = (u16 )((int )hdr + tmp);
  memset((void *)(data + ((int )hdr + 1)), 0, (size_t )4);
  *(data + ((int )hdr + 7)) = (unsigned char)0;
  *((data + ((int )hdr + 5)) + 0) = (u8 )(pBt->usableSize >> 8);
  *((data + ((int )hdr + 5)) + 1) = (u8 )pBt->usableSize;
  pPage->nFree = (int )((u16 )(pBt->usableSize - (u32 )first));
  decodeFlags(pPage, flags___0);
  pPage->cellOffset = first;
  pPage->aDataEnd = data + pBt->usableSize;
  pPage->aCellIdx = data + first;
  pPage->aDataOfst = data + pPage->childPtrSize;
  pPage->nOverflow = (u8 )0;
  pPage->maskPage = (u16 )(pBt->pageSize - 1U);
  pPage->nCell = (u16 )0;
  pPage->isInit = (u8 )1;
  return;
}
}
static MemPage *btreePageFromDbPage(DbPage *pDbPage , Pgno pgno , BtShared *pBt ) 
{ 
  MemPage *pPage ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3PagerGetExtra(pDbPage);
  pPage = (MemPage *)tmp;
  if (pgno != pPage->pgno) {
    tmp___0 = sqlite3PagerGetData(pDbPage);
    pPage->aData = (u8 *)tmp___0;
    pPage->pDbPage = pDbPage;
    pPage->pBt = pBt;
    pPage->pgno = pgno;
    if (pgno == 1U) {
      pPage->hdrOffset = (u8 )100;
    } else {
      pPage->hdrOffset = (u8 )0;
    }
  }
  return (pPage);
}
}
static int btreeGetPage(BtShared *pBt , Pgno pgno , MemPage **ppPage , int flags___0 ) 
{ 
  int rc ;
  DbPage *pDbPage ;

  {
  rc = sqlite3PagerGet(pBt->pPager, pgno, & pDbPage, flags___0);
  if (rc) {
    return (rc);
  }
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return (0);
}
}
static MemPage *btreePageLookup(BtShared *pBt , Pgno pgno ) 
{ 
  DbPage *pDbPage ;
  MemPage *tmp ;

  {
  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
  if (pDbPage) {
    tmp = btreePageFromDbPage(pDbPage, pgno, pBt);
    return (tmp);
  }
  return ((MemPage *)0);
}
}
static Pgno btreePagecount(BtShared *pBt ) 
{ 


  {
  return (pBt->nPage);
}
}
static u32 sqlite3BtreeLastPage(Btree *p ) 
{ 
  Pgno tmp ;

  {
  tmp = btreePagecount(p->pBt);
  return (tmp);
}
}
static int getAndInitPage(BtShared *pBt , Pgno pgno , MemPage **ppPage , BtCursor *pCur ,
                          int bReadOnly ) 
{ 
  int rc ;
  DbPage *pDbPage ;
  Pgno tmp ;
  void *tmp___0 ;

  {
  tmp = btreePagecount(pBt);
  if (pgno > tmp) {
    rc = sqlite3CorruptError(65554);
    goto getAndInitPage_error1;
  }
  rc = sqlite3PagerGet(pBt->pPager, pgno, & pDbPage, bReadOnly);
  if (rc) {
    goto getAndInitPage_error1;
  }
  tmp___0 = sqlite3PagerGetExtra(pDbPage);
  *ppPage = (MemPage *)tmp___0;
  if ((int )(*ppPage)->isInit == 0) {
    btreePageFromDbPage(pDbPage, pgno, pBt);
    rc = btreeInitPage(*ppPage);
    if (rc != 0) {
      goto getAndInitPage_error2;
    }
  }
  if (pCur) {
    if ((int )(*ppPage)->nCell < 1) {
      rc = sqlite3CorruptError(65575);
      goto getAndInitPage_error2;
    } else
    if ((int )(*ppPage)->intKey != (int )pCur->curIntKey) {
      rc = sqlite3CorruptError(65575);
      goto getAndInitPage_error2;
    }
  }
  return (0);
  getAndInitPage_error2: 
  releasePage(*ppPage);
  getAndInitPage_error1: 
  if (pCur) {
    pCur->iPage = (i8 )((int )pCur->iPage - 1);
    pCur->pPage = pCur->apPage[pCur->iPage];
  }
  return (rc);
}
}
static void releasePageNotNull(MemPage *pPage ) 
{ 


  {
  sqlite3PagerUnrefNotNull(pPage->pDbPage);
  return;
}
}
static void releasePage(MemPage *pPage ) 
{ 


  {
  if (pPage) {
    releasePageNotNull(pPage);
  }
  return;
}
}
static void releasePageOne(MemPage *pPage ) 
{ 


  {
  sqlite3PagerUnrefPageOne(pPage->pDbPage);
  return;
}
}
static int btreeGetUnusedPage(BtShared *pBt , Pgno pgno , MemPage **ppPage , int flags___0 ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = btreeGetPage(pBt, pgno, ppPage, flags___0);
  rc = tmp;
  if (rc == 0) {
    tmp___1 = sqlite3PagerPageRefcount((*ppPage)->pDbPage);
    if (tmp___1 > 1) {
      releasePage(*ppPage);
      *ppPage = (MemPage *)0;
      tmp___0 = sqlite3CorruptError(65641);
      return (tmp___0);
    }
    (*ppPage)->isInit = (u8 )0;
  } else {
    *ppPage = (MemPage *)0;
  }
  return (rc);
}
}
static void pageReinit(DbPage *pData ) 
{ 
  MemPage *pPage ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3PagerGetExtra(pData);
  pPage = (MemPage *)tmp;
  if (pPage->isInit) {
    pPage->isInit = (u8 )0;
    tmp___0 = sqlite3PagerPageRefcount(pData);
    if (tmp___0 > 1) {
      btreeInitPage(pPage);
    }
  }
  return;
}
}
static int btreeInvokeBusyHandler(void *pArg ) 
{ 
  BtShared *pBt ;
  sqlite3_file *tmp ;
  int tmp___0 ;

  {
  pBt = (BtShared *)pArg;
  tmp = sqlite3PagerFile(pBt->pPager);
  tmp___0 = sqlite3InvokeBusyHandler(& (pBt->db)->busyHandler, tmp);
  return (tmp___0);
}
}
static int sqlite3BtreeOpen(sqlite3_vfs *pVfs , char const   *zFilename , sqlite3 *db ,
                            Btree **ppBtree , int flags___0 , int vfsFlags___0 ) 
{ 
  BtShared *pBt ;
  Btree *p ;
  sqlite3_mutex *mutexOpen ;
  int rc ;
  u8 nReserve ;
  unsigned char zDbHeader[100] ;
  int isTempDb ;
  int tmp ;
  int isMemdb ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int nFilename ;
  int tmp___4 ;
  int nFullPathname ;
  char *zFullPathname ;
  int tmp___5 ;
  void *tmp___6 ;
  int iDb ;
  Btree *pExisting ;
  char const   *tmp___7 ;
  int tmp___8 ;
  sqlite3_vfs *tmp___9 ;
  void *tmp___10 ;
  u8 tmp___11 ;
  u32 tmp___13 ;
  u32 tmp___15 ;
  int i ;
  Btree *pSib ;
  sqlite3_file *pFile ;
  void *tmp___16 ;

  {
  pBt = (BtShared *)0;
  mutexOpen = (sqlite3_mutex *)0;
  rc = 0;
  if ((unsigned long )zFilename == (unsigned long )((char const   *)0)) {
    tmp = 1;
  } else
  if ((int const   )*(zFilename + 0) == 0) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  isTempDb = tmp;
  if (zFilename) {
    tmp___0 = strcmp(zFilename, ":memory:");
    if (tmp___0 == 0) {
      tmp___2 = 1;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (isTempDb) {
    tmp___1 = sqlite3TempInMemory((sqlite3 const   *)db);
    if (tmp___1) {
      tmp___2 = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((vfsFlags___0 & 128) != 0) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  isMemdb = tmp___2;
  if (isMemdb) {
    flags___0 |= 2;
  }
  if ((vfsFlags___0 & 256) != 0) {
    if (isMemdb) {
      vfsFlags___0 = (vfsFlags___0 & -257) | 512;
    } else
    if (isTempDb) {
      vfsFlags___0 = (vfsFlags___0 & -257) | 512;
    }
  }
  tmp___3 = sqlite3MallocZero((u64 )sizeof(Btree ));
  p = (Btree *)tmp___3;
  if (! p) {
    return (7);
  }
  p->inTrans = (u8 )0;
  p->db = db;
  p->lock.pBtree = p;
  p->lock.iTable = (Pgno )1;
  if (isTempDb == 0) {
    if (isMemdb == 0) {
      goto _L___1;
    } else
    if ((vfsFlags___0 & 64) != 0) {
      _L___1: /* CIL Label */ 
      if (vfsFlags___0 & 131072) {
        tmp___4 = sqlite3Strlen30(zFilename);
        nFilename = tmp___4 + 1;
        nFullPathname = pVfs->mxPathname + 1;
        if (nFullPathname > nFilename) {
          tmp___5 = nFullPathname;
        } else {
          tmp___5 = nFilename;
        }
        tmp___6 = sqlite3Malloc((u64 )tmp___5);
        zFullPathname = (char *)tmp___6;
        p->sharable = (u8 )1;
        if (! zFullPathname) {
          sqlite3_free((void *)p);
          return (7);
        }
        if (isMemdb) {
          memcpy((void * __restrict  )zFullPathname, (void const   * __restrict  )zFilename,
                 (size_t )nFilename);
        } else {
          rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);
          if (rc) {
            sqlite3_free((void *)zFullPathname);
            sqlite3_free((void *)p);
            return (rc);
          }
        }
        pBt = sqlite3SharedCacheList;
        while (pBt) {
          tmp___7 = sqlite3PagerFilename(pBt->pPager, 0);
          tmp___8 = strcmp((char const   *)zFullPathname, tmp___7);
          if (0 == tmp___8) {
            tmp___9 = sqlite3PagerVfs(pBt->pPager);
            if ((unsigned long )tmp___9 == (unsigned long )pVfs) {
              iDb = db->nDb - 1;
              while (iDb >= 0) {
                pExisting = (db->aDb + iDb)->pBt;
                if (pExisting) {
                  if ((unsigned long )pExisting->pBt == (unsigned long )pBt) {
                    sqlite3_free((void *)zFullPathname);
                    sqlite3_free((void *)p);
                    return (19);
                  }
                }
                iDb --;
              }
              p->pBt = pBt;
              (pBt->nRef) ++;
              break;
            }
          }
          pBt = pBt->pNext;
        }
        sqlite3_free((void *)zFullPathname);
      }
    }
  }
  if ((unsigned long )pBt == (unsigned long )((BtShared *)0)) {
    tmp___10 = sqlite3MallocZero((u64 )sizeof(*pBt));
    pBt = (BtShared *)tmp___10;
    if ((unsigned long )pBt == (unsigned long )((BtShared *)0)) {
      rc = 7;
      goto btree_open_out;
    }
    rc = sqlite3PagerOpen(pVfs, & pBt->pPager, zFilename, (int )sizeof(MemPage ),
                          flags___0, vfsFlags___0, & pageReinit);
    if (rc == 0) {
      sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);
      rc = sqlite3PagerReadFileheader(pBt->pPager, (int )sizeof(zDbHeader), zDbHeader);
    }
    if (rc != 0) {
      goto btree_open_out;
    }
    pBt->openFlags = (u8 )flags___0;
    pBt->db = db;
    sqlite3PagerSetBusyHandler(pBt->pPager, & btreeInvokeBusyHandler, (void *)pBt);
    p->pBt = pBt;
    pBt->pCursor = (BtCursor *)0;
    pBt->pPage1 = (MemPage *)0;
    tmp___11 = sqlite3PagerIsreadonly(pBt->pPager);
    if (tmp___11) {
      pBt->btsFlags = (u16 )((int )pBt->btsFlags | 1);
    }
    pBt->pageSize = (u32 )(((int )zDbHeader[16] << 8) | ((int )zDbHeader[17] << 16));
    if (pBt->pageSize < 512U) {
      goto _L___2;
    } else
    if (pBt->pageSize > 65536U) {
      goto _L___2;
    } else
    if (((pBt->pageSize - 1U) & pBt->pageSize) != 0U) {
      _L___2: /* CIL Label */ 
      pBt->pageSize = (u32 )0;
      if (zFilename) {
        if (! isMemdb) {
          pBt->autoVacuum = (u8 )0;
          pBt->incrVacuum = (u8 )0;
        }
      }
      nReserve = (u8 )0;
    } else {
      nReserve = zDbHeader[20];
      pBt->btsFlags = (u16 )((int )pBt->btsFlags | 2);
      tmp___13 = sqlite3Get4byte((u8 const   *)(& zDbHeader[52]));
      if (tmp___13) {
        pBt->autoVacuum = (u8 )1;
      } else {
        pBt->autoVacuum = (u8 )0;
      }
      tmp___15 = sqlite3Get4byte((u8 const   *)(& zDbHeader[64]));
      if (tmp___15) {
        pBt->incrVacuum = (u8 )1;
      } else {
        pBt->incrVacuum = (u8 )0;
      }
    }
    rc = sqlite3PagerSetPagesize(pBt->pPager, & pBt->pageSize, (int )nReserve);
    if (rc) {
      goto btree_open_out;
    }
    pBt->usableSize = pBt->pageSize - (u32 )nReserve;
    pBt->nRef = 1;
    if (p->sharable) {
      pBt->pNext = sqlite3SharedCacheList;
      sqlite3SharedCacheList = pBt;
    }
  }
  if (p->sharable) {
    i = 0;
    while (i < db->nDb) {
      pSib = (db->aDb + i)->pBt;
      if ((unsigned long )pSib != (unsigned long )((Btree *)0)) {
        if (pSib->sharable) {
          while (pSib->pPrev) {
            pSib = pSib->pPrev;
          }
          if ((uptr )p->pBt < (uptr )pSib->pBt) {
            p->pNext = pSib;
            p->pPrev = (Btree *)0;
            pSib->pPrev = p;
          } else {
            while (1) {
              if (pSib->pNext) {
                if (! ((uptr )(pSib->pNext)->pBt < (uptr )p->pBt)) {
                  break;
                }
              } else {
                break;
              }
              pSib = pSib->pNext;
            }
            p->pNext = pSib->pNext;
            p->pPrev = pSib;
            if (p->pNext) {
              (p->pNext)->pPrev = p;
            }
            pSib->pNext = p;
          }
          break;
        }
      }
      i ++;
    }
  }
  *ppBtree = p;
  btree_open_out: 
  if (rc != 0) {
    if (pBt) {
      if (pBt->pPager) {
        sqlite3PagerClose(pBt->pPager, (sqlite3 *)0);
      }
    }
    sqlite3_free((void *)pBt);
    sqlite3_free((void *)p);
    *ppBtree = (Btree *)0;
  } else {
    tmp___16 = sqlite3BtreeSchema(p, 0, (void (*)(void * ))0);
    if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
      sqlite3PagerSetCachesize((p->pBt)->pPager, -2000);
    }
    pFile = sqlite3PagerFile(pBt->pPager);
    if (pFile->pMethods) {
      sqlite3OsFileControlHint(pFile, 30, (void *)(& pBt->db));
    }
  }
  return (rc);
}
}
static int removeFromSharingList(BtShared *pBt ) 
{ 
  BtShared *pList ;
  int removed ;

  {
  removed = 0;
  (pBt->nRef) --;
  if (pBt->nRef <= 0) {
    if ((unsigned long )sqlite3SharedCacheList == (unsigned long )pBt) {
      sqlite3SharedCacheList = pBt->pNext;
    } else {
      pList = sqlite3SharedCacheList;
      while (1) {
        if (pList) {
          if (! ((unsigned long )pList->pNext != (unsigned long )pBt)) {
            break;
          }
        } else {
          break;
        }
        pList = pList->pNext;
      }
      if (pList) {
        pList->pNext = pBt->pNext;
      }
    }
    removed = 1;
  }
  return (removed);
}
}
static void allocateTempSpace(BtShared *pBt ) 
{ 
  void *tmp ;

  {
  if (! pBt->pTmpSpace) {
    tmp = sqlite3PageMalloc((int )pBt->pageSize);
    pBt->pTmpSpace = (u8 *)tmp;
    if (pBt->pTmpSpace) {
      memset((void *)pBt->pTmpSpace, 0, (size_t )8);
      pBt->pTmpSpace += 4;
    }
  }
  return;
}
}
static void freeTempSpace(BtShared *pBt ) 
{ 


  {
  if (pBt->pTmpSpace) {
    pBt->pTmpSpace -= 4;
    sqlite3PageFree((void *)pBt->pTmpSpace);
    pBt->pTmpSpace = (u8 *)0;
  }
  return;
}
}
static int sqlite3BtreeClose(Btree *p ) 
{ 
  BtShared *pBt ;
  BtCursor *pCur ;
  BtCursor *pTmp ;
  int tmp ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  pCur = pBt->pCursor;
  while (pCur) {
    pTmp = pCur;
    pCur = pCur->pNext;
    if ((unsigned long )pTmp->pBtree == (unsigned long )p) {
      sqlite3BtreeCloseCursor(pTmp);
    }
  }
  sqlite3BtreeRollback(p, 0, 0);
  if (! p->sharable) {
    goto _L;
  } else {
    tmp = removeFromSharingList(pBt);
    if (tmp) {
      _L: /* CIL Label */ 
      sqlite3PagerClose(pBt->pPager, p->db);
      if (pBt->xFreeSchema) {
        if (pBt->pSchema) {
          (*(pBt->xFreeSchema))(pBt->pSchema);
        }
      }
      sqlite3DbFree((sqlite3 *)0, pBt->pSchema);
      freeTempSpace(pBt);
      sqlite3_free((void *)pBt);
    }
  }
  if (p->pPrev) {
    (p->pPrev)->pNext = p->pNext;
  }
  if (p->pNext) {
    (p->pNext)->pPrev = p->pPrev;
  }
  sqlite3_free((void *)p);
  return (0);
}
}
static int sqlite3BtreeSetCacheSize(Btree *p , int mxPage ) 
{ 
  BtShared *pBt ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  sqlite3PagerSetCachesize(pBt->pPager, mxPage);
  return (0);
}
}
static int sqlite3BtreeSetSpillSize(Btree *p , int mxPage ) 
{ 
  BtShared *pBt ;
  int res ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  res = sqlite3PagerSetSpillsize(pBt->pPager, mxPage);
  return (res);
}
}
static int sqlite3BtreeSetMmapLimit(Btree *p , sqlite_int64 szMmap ) 
{ 
  BtShared *pBt ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  sqlite3PagerSetMmapLimit(pBt->pPager, szMmap);
  return (0);
}
}
static int sqlite3BtreeSetPagerFlags(Btree *p , unsigned int pgFlags ) 
{ 
  BtShared *pBt ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  sqlite3PagerSetFlags(pBt->pPager, pgFlags);
  return (0);
}
}
static int sqlite3BtreeSetPageSize(Btree *p , int pageSize , int nReserve , int iFix ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  rc = 0;
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if ((int )pBt->btsFlags & 2) {
    return (8);
  }
  if (nReserve < 0) {
    nReserve = (int )(pBt->pageSize - pBt->usableSize);
  }
  if (pageSize >= 512) {
    if (pageSize <= 65536) {
      if (((pageSize - 1) & pageSize) == 0) {
        pBt->pageSize = (u32 )pageSize;
        freeTempSpace(pBt);
      }
    }
  }
  rc = sqlite3PagerSetPagesize(pBt->pPager, & pBt->pageSize, nReserve);
  pBt->usableSize = pBt->pageSize - (u32 )((u16 )nReserve);
  if (iFix) {
    pBt->btsFlags = (u16 )((int )pBt->btsFlags | 2);
  }
  return (rc);
}
}
static int sqlite3BtreeGetPageSize(Btree *p ) 
{ 


  {
  return ((int )(p->pBt)->pageSize);
}
}
static int sqlite3BtreeGetReserveNoMutex(Btree *p ) 
{ 
  int n ;

  {
  n = (int )((p->pBt)->pageSize - (p->pBt)->usableSize);
  return (n);
}
}
static int sqlite3BtreeGetOptimalReserve(Btree *p ) 
{ 
  int n ;

  {
  sqlite3BtreeEnter(p);
  n = sqlite3BtreeGetReserveNoMutex(p);
  return (n);
}
}
static int sqlite3BtreeMaxPageCount(Btree *p , int mxPage ) 
{ 
  int n ;

  {
  sqlite3BtreeEnter(p);
  n = sqlite3PagerMaxPageCount((p->pBt)->pPager, mxPage);
  return (n);
}
}
static int sqlite3BtreeSecureDelete(Btree *p , int newFlag ) 
{ 
  int b ;

  {
  if ((unsigned long )p == (unsigned long )((Btree *)0)) {
    return (0);
  }
  sqlite3BtreeEnter(p);
  if (newFlag >= 0) {
    (p->pBt)->btsFlags = (u16 )((int )(p->pBt)->btsFlags & -13);
    (p->pBt)->btsFlags = (u16 )((int )(p->pBt)->btsFlags | 4 * newFlag);
  }
  b = ((int )(p->pBt)->btsFlags & 12) / 4;
  return (b);
}
}
static int sqlite3BtreeSetAutoVacuum(Btree *p , int autoVacuum ) 
{ 
  BtShared *pBt ;
  int rc ;
  u8 av ;
  int tmp ;

  {
  pBt = p->pBt;
  rc = 0;
  av = (u8 )autoVacuum;
  sqlite3BtreeEnter(p);
  if (((int )pBt->btsFlags & 2) != 0) {
    if (av) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    if (tmp != (int )pBt->autoVacuum) {
      rc = 8;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (av) {
      pBt->autoVacuum = (u8 )1;
    } else {
      pBt->autoVacuum = (u8 )0;
    }
    if ((int )av == 2) {
      pBt->incrVacuum = (u8 )1;
    } else {
      pBt->incrVacuum = (u8 )0;
    }
  }
  return (rc);
}
}
static int sqlite3BtreeGetAutoVacuum(Btree *p ) 
{ 
  int rc ;
  int tmp ;

  {
  sqlite3BtreeEnter(p);
  if (! (p->pBt)->autoVacuum) {
    rc = 0;
  } else {
    if (! (p->pBt)->incrVacuum) {
      tmp = 1;
    } else {
      tmp = 2;
    }
    rc = tmp;
  }
  return (rc);
}
}
static int newDatabase(BtShared *pBt ) ;
static int lockBtree(BtShared *pBt ) 
{ 
  int rc ;
  MemPage *pPage1 ;
  u32 nPage ;
  u32 nPageFile ;
  u32 nPageHeader ;
  int tmp ;
  u32 pageSize ;
  u32 usableSize ;
  u8 *page1 ;
  int tmp___0 ;
  int isOpen ;
  int tmp___1 ;
  int tmp___2 ;
  u32 tmp___4 ;
  u32 tmp___6 ;

  {
  nPageFile = (u32 )0;
  rc = sqlite3PagerSharedLock(pBt->pPager);
  if (rc != 0) {
    return (rc);
  }
  rc = btreeGetPage(pBt, (Pgno )1, & pPage1, 0);
  if (rc != 0) {
    return (rc);
  }
  nPageHeader = sqlite3Get4byte((u8 const   *)(pPage1->aData + 28));
  nPage = nPageHeader;
  sqlite3PagerPagecount(pBt->pPager, (int *)(& nPageFile));
  if (nPage == 0U) {
    nPage = nPageFile;
  } else {
    tmp = memcmp((void const   *)(pPage1->aData + 24), (void const   *)(pPage1->aData + 92),
                 (size_t )4);
    if (tmp != 0) {
      nPage = nPageFile;
    }
  }
  if (((pBt->db)->flags & 33554432ULL) != 0ULL) {
    nPage = (u32 )0;
  }
  if (nPage > 0U) {
    page1 = pPage1->aData;
    rc = 26;
    tmp___0 = memcmp((void const   *)page1, (void const   *)(zMagicHeader), (size_t )16);
    if (tmp___0 != 0) {
      goto page1_init_failed;
    }
    if ((int )*(page1 + 18) > 2) {
      pBt->btsFlags = (u16 )((int )pBt->btsFlags | 1);
    }
    if ((int )*(page1 + 19) > 2) {
      goto page1_init_failed;
    }
    if ((int )*(page1 + 19) == 2) {
      if (((int )pBt->btsFlags & 32) == 0) {
        isOpen = 0;
        rc = sqlite3PagerOpenWal(pBt->pPager, & isOpen);
        if (rc != 0) {
          goto page1_init_failed;
        } else
        if (isOpen == 0) {
          releasePageOne(pPage1);
          return (0);
        }
        rc = 26;
      }
    }
    tmp___1 = memcmp((void const   *)(page1 + 21), (void const   *)"@  ", (size_t )3);
    if (tmp___1 != 0) {
      goto page1_init_failed;
    }
    pageSize = (u32 )(((int )*(page1 + 16) << 8) | ((int )*(page1 + 17) << 16));
    if (((pageSize - 1U) & pageSize) != 0U) {
      goto page1_init_failed;
    } else
    if (pageSize > 65536U) {
      goto page1_init_failed;
    } else
    if (pageSize <= 256U) {
      goto page1_init_failed;
    }
    pBt->btsFlags = (u16 )((int )pBt->btsFlags | 2);
    usableSize = pageSize - (u32 )*(page1 + 20);
    if (pageSize != pBt->pageSize) {
      releasePageOne(pPage1);
      pBt->usableSize = usableSize;
      pBt->pageSize = pageSize;
      freeTempSpace(pBt);
      rc = sqlite3PagerSetPagesize(pBt->pPager, & pBt->pageSize, (int )(pageSize - usableSize));
      return (rc);
    }
    tmp___2 = sqlite3WritableSchema(pBt->db);
    if (tmp___2 == 0) {
      if (nPage > nPageFile) {
        rc = sqlite3CorruptError(66564);
        goto page1_init_failed;
      }
    }
    if (usableSize < 480U) {
      goto page1_init_failed;
    }
    pBt->pageSize = pageSize;
    pBt->usableSize = usableSize;
    tmp___4 = sqlite3Get4byte((u8 const   *)(page1 + 52));
    if (tmp___4) {
      pBt->autoVacuum = (u8 )1;
    } else {
      pBt->autoVacuum = (u8 )0;
    }
    tmp___6 = sqlite3Get4byte((u8 const   *)(page1 + 64));
    if (tmp___6) {
      pBt->incrVacuum = (u8 )1;
    } else {
      pBt->incrVacuum = (u8 )0;
    }
  }
  pBt->maxLocal = (u16 )(((pBt->usableSize - 12U) * 64U) / 255U - 23U);
  pBt->minLocal = (u16 )(((pBt->usableSize - 12U) * 32U) / 255U - 23U);
  pBt->maxLeaf = (u16 )(pBt->usableSize - 35U);
  pBt->minLeaf = (u16 )(((pBt->usableSize - 12U) * 32U) / 255U - 23U);
  if ((int )pBt->maxLocal > 127) {
    pBt->max1bytePayload = (u8 )127;
  } else {
    pBt->max1bytePayload = (u8 )pBt->maxLocal;
  }
  pBt->pPage1 = pPage1;
  pBt->nPage = nPage;
  return (0);
  page1_init_failed: 
  releasePageOne(pPage1);
  pBt->pPage1 = (MemPage *)0;
  return (rc);
}
}
static void unlockBtreeIfUnused(BtShared *pBt ) 
{ 
  MemPage *pPage1 ;

  {
  if ((int )pBt->inTransaction == 0) {
    if ((unsigned long )pBt->pPage1 != (unsigned long )((MemPage *)0)) {
      pPage1 = pBt->pPage1;
      pBt->pPage1 = (MemPage *)0;
      releasePageOne(pPage1);
    }
  }
  return;
}
}
static int newDatabase(BtShared *pBt ) 
{ 
  MemPage *pP1 ;
  unsigned char *data ;
  int rc ;

  {
  if (pBt->nPage > 0U) {
    return (0);
  }
  pP1 = pBt->pPage1;
  data = pP1->aData;
  rc = sqlite3PagerWrite(pP1->pDbPage);
  if (rc) {
    return (rc);
  }
  memcpy((void * __restrict  )data, (void const   * __restrict  )(zMagicHeader), sizeof(zMagicHeader));
  *(data + 16) = (u8 )((pBt->pageSize >> 8) & 255U);
  *(data + 17) = (u8 )((pBt->pageSize >> 16) & 255U);
  *(data + 18) = (unsigned char)1;
  *(data + 19) = (unsigned char)1;
  *(data + 20) = (u8 )(pBt->pageSize - pBt->usableSize);
  *(data + 21) = (unsigned char)64;
  *(data + 22) = (unsigned char)32;
  *(data + 23) = (unsigned char)32;
  memset((void *)(data + 24), 0, (size_t )76);
  zeroPage(pP1, 13);
  pBt->btsFlags = (u16 )((int )pBt->btsFlags | 2);
  sqlite3Put4byte(data + 52, (u32 )pBt->autoVacuum);
  sqlite3Put4byte(data + 64, (u32 )pBt->incrVacuum);
  pBt->nPage = (u32 )1;
  *(data + 31) = (unsigned char)1;
  return (0);
}
}
static int sqlite3BtreeNewDb(Btree *p ) 
{ 
  int rc ;

  {
  sqlite3BtreeEnter(p);
  (p->pBt)->nPage = (u32 )0;
  rc = newDatabase(p->pBt);
  return (rc);
}
}
static int sqlite3BtreeBeginTrans(Btree *p , int wrflag , int *pSchemaVersion ) 
{ 
  BtShared *pBt ;
  int rc ;
  u8 tmp ;
  sqlite3 *pBlock ;
  BtLock *pIter ;
  int tmp___0 ;
  int tmp___1 ;
  MemPage *pPage1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
  pBt = p->pBt;
  rc = 0;
  sqlite3BtreeEnter(p);
  if ((int )p->inTrans == 2) {
    goto trans_begun;
  } else
  if ((int )p->inTrans == 1) {
    if (! wrflag) {
      goto trans_begun;
    }
  }
  if ((p->db)->flags & 33554432ULL) {
    tmp = sqlite3PagerIsreadonly(pBt->pPager);
    if ((int )tmp == 0) {
      pBt->btsFlags = (u16 )((int )pBt->btsFlags & -2);
    }
  }
  if (((int )pBt->btsFlags & 1) != 0) {
    if (wrflag) {
      rc = 8;
      goto trans_begun;
    }
  }
  pBlock = (sqlite3 *)0;
  if (wrflag) {
    if ((int )pBt->inTransaction == 2) {
      pBlock = (pBt->pWriter)->db;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (((int )pBt->btsFlags & 128) != 0) {
    pBlock = (pBt->pWriter)->db;
  } else
  if (wrflag > 1) {
    pIter = pBt->pLock;
    while (pIter) {
      if ((unsigned long )pIter->pBtree != (unsigned long )p) {
        pBlock = (pIter->pBtree)->db;
        break;
      }
      pIter = pIter->pNext;
    }
  }
  if (pBlock) {
    rc = 6 | (1 << 8);
    goto trans_begun;
  }
  rc = querySharedCacheTableLock(p, (Pgno )1, (u8 )1);
  if (0 != rc) {
    goto trans_begun;
  }
  pBt->btsFlags = (u16 )((int )pBt->btsFlags & -17);
  if (pBt->nPage == 0U) {
    pBt->btsFlags = (u16 )((int )pBt->btsFlags | 16);
  }
  while (1) {
    while (1) {
      if ((unsigned long )pBt->pPage1 == (unsigned long )((MemPage *)0)) {
        rc = lockBtree(pBt);
        if (! (0 == rc)) {
          break;
        }
      } else {
        break;
      }
    }
    if (rc == 0) {
      if (wrflag) {
        if (((int )pBt->btsFlags & 1) != 0) {
          rc = 8;
        } else {
          tmp___0 = sqlite3TempInMemory((sqlite3 const   *)p->db);
          rc = sqlite3PagerBegin(pBt->pPager, wrflag > 1, tmp___0);
          if (rc == 0) {
            rc = newDatabase(pBt);
          } else
          if (rc == (5 | (2 << 8))) {
            if ((int )pBt->inTransaction == 0) {
              rc = 5;
            }
          }
        }
      }
    }
    if (rc != 0) {
      unlockBtreeIfUnused(pBt);
    }
    if ((rc & 255) == 5) {
      if ((int )pBt->inTransaction == 0) {
        tmp___1 = btreeInvokeBusyHandler((void *)pBt);
        if (! tmp___1) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  if (rc == 0) {
    if ((int )p->inTrans == 0) {
      (pBt->nTransaction) ++;
      if (p->sharable) {
        p->lock.eLock = (u8 )1;
        p->lock.pNext = pBt->pLock;
        pBt->pLock = & p->lock;
      }
    }
    if (wrflag) {
      p->inTrans = (u8 )2;
    } else {
      p->inTrans = (u8 )1;
    }
    if ((int )p->inTrans > (int )pBt->inTransaction) {
      pBt->inTransaction = p->inTrans;
    }
    if (wrflag) {
      pPage1 = pBt->pPage1;
      pBt->pWriter = p;
      pBt->btsFlags = (u16 )((int )pBt->btsFlags & -65);
      if (wrflag > 1) {
        pBt->btsFlags = (u16 )((int )pBt->btsFlags | 64);
      }
      tmp___2 = sqlite3Get4byte((u8 const   *)(pPage1->aData + 28));
      if (pBt->nPage != tmp___2) {
        rc = sqlite3PagerWrite(pPage1->pDbPage);
        if (rc == 0) {
          sqlite3Put4byte(pPage1->aData + 28, pBt->nPage);
        }
      }
    }
  }
  trans_begun: 
  if (rc == 0) {
    if (pSchemaVersion) {
      tmp___3 = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 40));
      *pSchemaVersion = (int )tmp___3;
    }
    if (wrflag) {
      rc = sqlite3PagerOpenSavepoint(pBt->pPager, (p->db)->nSavepoint);
    }
  }
  return (rc);
}
}
static int setChildPtrmaps(MemPage *pPage ) 
{ 
  int i ;
  int nCell ;
  int rc ;
  BtShared *pBt ;
  Pgno pgno ;
  int tmp ;
  u8 *pCell ;
  short tmp___0 ;
  Pgno childPgno ;
  u32 tmp___1 ;
  Pgno childPgno___0 ;
  u32 tmp___2 ;

  {
  pBt = pPage->pBt;
  pgno = pPage->pgno;
  if (pPage->isInit) {
    rc = 0;
  } else {
    tmp = btreeInitPage(pPage);
    rc = tmp;
  }
  if (rc != 0) {
    return (rc);
  }
  nCell = (int )pPage->nCell;
  i = 0;
  while (i < nCell) {
    tmp___0 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * i)));
    pCell = pPage->aData + ((int )pPage->maskPage & (int )tmp___0);
    ptrmapPutOvflPtr(pPage, pPage, pCell, & rc);
    if (! pPage->leaf) {
      tmp___1 = sqlite3Get4byte((u8 const   *)pCell);
      childPgno = tmp___1;
      ptrmapPut(pBt, childPgno, (u8 )5, pgno, & rc);
    }
    i ++;
  }
  if (! pPage->leaf) {
    tmp___2 = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->hdrOffset + 8)));
    childPgno___0 = tmp___2;
    ptrmapPut(pBt, childPgno___0, (u8 )5, pgno, & rc);
  }
  return (rc);
}
}
static int modifyPagePointer(MemPage *pPage , Pgno iFrom , Pgno iTo , u8 eType ) 
{ 
  int tmp ;
  u32 tmp___0 ;
  int i ;
  int nCell ;
  int rc ;
  int tmp___1 ;
  u8 *pCell ;
  short tmp___2 ;
  CellInfo info ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;

  {
  if ((int )eType == 4) {
    tmp___0 = sqlite3Get4byte((u8 const   *)pPage->aData);
    if (tmp___0 != iFrom) {
      tmp = sqlite3CorruptError(66965);
      return (tmp);
    }
    sqlite3Put4byte(pPage->aData, iTo);
  } else {
    if (pPage->isInit) {
      rc = 0;
    } else {
      tmp___1 = btreeInitPage(pPage);
      rc = tmp___1;
    }
    if (rc) {
      return (rc);
    }
    nCell = (int )pPage->nCell;
    i = 0;
    while (i < nCell) {
      tmp___2 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * i)));
      pCell = pPage->aData + ((int )pPage->maskPage & (int )tmp___2);
      if ((int )eType == 3) {
        (*(pPage->xParseCell))(pPage, pCell, & info);
        if ((u32 )info.nLocal < info.nPayload) {
          if ((unsigned long )(pCell + (int )info.nSize) > (unsigned long )(pPage->aData + (pPage->pBt)->usableSize)) {
            tmp___3 = sqlite3CorruptError(66984);
            return (tmp___3);
          }
          tmp___4 = sqlite3Get4byte((u8 const   *)((pCell + (int )info.nSize) - 4));
          if (iFrom == tmp___4) {
            sqlite3Put4byte((pCell + (int )info.nSize) - 4, iTo);
            break;
          }
        }
      } else {
        tmp___5 = sqlite3Get4byte((u8 const   *)pCell);
        if (tmp___5 == iFrom) {
          sqlite3Put4byte(pCell, iTo);
          break;
        }
      }
      i ++;
    }
    if (i == nCell) {
      if ((int )eType != 5) {
        tmp___6 = sqlite3CorruptError(67002);
        return (tmp___6);
      } else {
        tmp___7 = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->hdrOffset + 8)));
        if (tmp___7 != iFrom) {
          tmp___6 = sqlite3CorruptError(67002);
          return (tmp___6);
        }
      }
      sqlite3Put4byte(pPage->aData + ((int )pPage->hdrOffset + 8), iTo);
    }
  }
  return (0);
}
}
static int relocatePage(BtShared *pBt , MemPage *pDbPage , u8 eType , Pgno iPtrPage ,
                        Pgno iFreePage , int isCommit ) 
{ 
  MemPage *pPtrPage ;
  Pgno iDbPage ;
  Pager *pPager ;
  int rc ;
  int tmp ;
  Pgno nextOvfl ;
  u32 tmp___0 ;

  {
  iDbPage = pDbPage->pgno;
  pPager = pBt->pPager;
  if (iDbPage < 3U) {
    tmp = sqlite3CorruptError(67037);
    return (tmp);
  }
  rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);
  if (rc != 0) {
    return (rc);
  }
  pDbPage->pgno = iFreePage;
  if ((int )eType == 5) {
    goto _L;
  } else
  if ((int )eType == 1) {
    _L: /* CIL Label */ 
    rc = setChildPtrmaps(pDbPage);
    if (rc != 0) {
      return (rc);
    }
  } else {
    tmp___0 = sqlite3Get4byte((u8 const   *)pDbPage->aData);
    nextOvfl = tmp___0;
    if (nextOvfl != 0U) {
      ptrmapPut(pBt, nextOvfl, (u8 )4, iFreePage, & rc);
      if (rc != 0) {
        return (rc);
      }
    }
  }
  if ((int )eType != 1) {
    rc = btreeGetPage(pBt, iPtrPage, & pPtrPage, 0);
    if (rc != 0) {
      return (rc);
    }
    rc = sqlite3PagerWrite(pPtrPage->pDbPage);
    if (rc != 0) {
      releasePage(pPtrPage);
      return (rc);
    }
    rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);
    releasePage(pPtrPage);
    if (rc == 0) {
      ptrmapPut(pBt, iFreePage, eType, iPtrPage, & rc);
    }
  }
  return (rc);
}
}
static int allocateBtreePage(BtShared *pBt , MemPage **ppPage , Pgno *pPgno , Pgno nearby ,
                             u8 eMode ) ;
static int incrVacuumStep(BtShared *pBt , Pgno nFin , Pgno iLastPg , int bCommit ) 
{ 
  Pgno nFreeList ;
  int rc ;
  u8 eType ;
  Pgno iPtrPage ;
  int tmp ;
  Pgno iFreePg ;
  MemPage *pFreePg ;
  Pgno iFreePg___0 ;
  MemPage *pLastPg ;
  u8 eMode ;
  Pgno iNear ;
  MemPage *pFreePg___0 ;
  Pgno tmp___0 ;
  Pgno tmp___1 ;

  {
  tmp___0 = ptrmapPageno(pBt, iLastPg);
  if (! (tmp___0 == iLastPg)) {
    if (iLastPg != (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
      nFreeList = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 36));
      if (nFreeList == 0U) {
        return (101);
      }
      rc = ptrmapGet(pBt, iLastPg, & eType, & iPtrPage);
      if (rc != 0) {
        return (rc);
      }
      if ((int )eType == 1) {
        tmp = sqlite3CorruptError(67135);
        return (tmp);
      }
      if ((int )eType == 2) {
        if (bCommit == 0) {
          rc = allocateBtreePage(pBt, & pFreePg, & iFreePg, iLastPg, (u8 )1);
          if (rc != 0) {
            return (rc);
          }
          releasePage(pFreePg);
        }
      } else {
        eMode = (u8 )0;
        iNear = (Pgno )0;
        rc = btreeGetPage(pBt, iLastPg, & pLastPg, 0);
        if (rc != 0) {
          return (rc);
        }
        if (bCommit == 0) {
          eMode = (u8 )2;
          iNear = nFin;
        }
        while (1) {
          rc = allocateBtreePage(pBt, & pFreePg___0, & iFreePg___0, iNear, eMode);
          if (rc != 0) {
            releasePage(pLastPg);
            return (rc);
          }
          releasePage(pFreePg___0);
          if (bCommit) {
            if (! (iFreePg___0 > nFin)) {
              break;
            }
          } else {
            break;
          }
        }
        rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg___0, bCommit);
        releasePage(pLastPg);
        if (rc != 0) {
          return (rc);
        }
      }
    }
  }
  if (bCommit == 0) {
    while (1) {
      iLastPg --;
      if (! (iLastPg == (u32 )sqlite3PendingByte / pBt->pageSize + 1U)) {
        tmp___1 = ptrmapPageno(pBt, iLastPg);
        if (! (tmp___1 == iLastPg)) {
          break;
        }
      }
    }
    pBt->bDoTruncate = (u8 )1;
    pBt->nPage = iLastPg;
  }
  return (0);
}
}
static Pgno finalDbSize(BtShared *pBt , Pgno nOrig , Pgno nFree ) 
{ 
  int nEntry ;
  Pgno nPtrmap ;
  Pgno nFin ;
  Pgno tmp ;
  Pgno tmp___0 ;

  {
  nEntry = (int )(pBt->usableSize / 5U);
  tmp = ptrmapPageno(pBt, nOrig);
  nPtrmap = (((nFree - nOrig) + tmp) + (Pgno )nEntry) / (Pgno )nEntry;
  nFin = (nOrig - nFree) - nPtrmap;
  if (nOrig > (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
    if (nFin < (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
      nFin --;
    }
  }
  while (1) {
    tmp___0 = ptrmapPageno(pBt, nFin);
    if (! (tmp___0 == nFin)) {
      if (! (nFin == (u32 )sqlite3PendingByte / pBt->pageSize + 1U)) {
        break;
      }
    }
    nFin --;
  }
  return (nFin);
}
}
static int sqlite3BtreeIncrVacuum(Btree *p ) 
{ 
  int rc ;
  BtShared *pBt ;
  Pgno nOrig ;
  Pgno tmp ;
  Pgno nFree ;
  u32 tmp___0 ;
  Pgno nFin ;
  Pgno tmp___1 ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if (! pBt->autoVacuum) {
    rc = 101;
  } else {
    tmp = btreePagecount(pBt);
    nOrig = tmp;
    tmp___0 = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 36));
    nFree = tmp___0;
    tmp___1 = finalDbSize(pBt, nOrig, nFree);
    nFin = tmp___1;
    if (nOrig < nFin) {
      rc = sqlite3CorruptError(67250);
    } else
    if (nFree > 0U) {
      rc = saveAllCursors(pBt, (Pgno )0, (BtCursor *)0);
      if (rc == 0) {
        invalidateAllOverflowCache(pBt);
        rc = incrVacuumStep(pBt, nFin, nOrig, 0);
      }
      if (rc == 0) {
        rc = sqlite3PagerWrite((pBt->pPage1)->pDbPage);
        sqlite3Put4byte((pBt->pPage1)->aData + 28, pBt->nPage);
      }
    } else {
      rc = 101;
    }
  }
  return (rc);
}
}
static int autoVacuumCommit(BtShared *pBt ) 
{ 
  int rc ;
  Pager *pPager ;
  Pgno nFin ;
  Pgno nFree ;
  Pgno iFree ;
  Pgno nOrig ;
  int tmp ;
  Pgno tmp___0 ;
  int tmp___1 ;

  {
  rc = 0;
  pPager = pBt->pPager;
  invalidateAllOverflowCache(pBt);
  if (! pBt->incrVacuum) {
    nOrig = btreePagecount(pBt);
    tmp___0 = ptrmapPageno(pBt, nOrig);
    if (tmp___0 == nOrig) {
      tmp = sqlite3CorruptError(67298);
      return (tmp);
    } else
    if (nOrig == (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
      tmp = sqlite3CorruptError(67298);
      return (tmp);
    }
    nFree = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 36));
    nFin = finalDbSize(pBt, nOrig, nFree);
    if (nFin > nOrig) {
      tmp___1 = sqlite3CorruptError(67303);
      return (tmp___1);
    }
    if (nFin < nOrig) {
      rc = saveAllCursors(pBt, (Pgno )0, (BtCursor *)0);
    }
    iFree = nOrig;
    while (1) {
      if (iFree > nFin) {
        if (! (rc == 0)) {
          break;
        }
      } else {
        break;
      }
      rc = incrVacuumStep(pBt, nFin, iFree, 1);
      iFree --;
    }
    if (rc == 101) {
      goto _L;
    } else
    if (rc == 0) {
      _L: /* CIL Label */ 
      if (nFree > 0U) {
        rc = sqlite3PagerWrite((pBt->pPage1)->pDbPage);
        sqlite3Put4byte((pBt->pPage1)->aData + 32, (u32 )0);
        sqlite3Put4byte((pBt->pPage1)->aData + 36, (u32 )0);
        sqlite3Put4byte((pBt->pPage1)->aData + 28, nFin);
        pBt->bDoTruncate = (u8 )1;
        pBt->nPage = nFin;
      }
    }
    if (rc != 0) {
      sqlite3PagerRollback(pPager);
    }
  }
  return (rc);
}
}
static int sqlite3BtreeCommitPhaseOne(Btree *p , char const   *zMaster ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  rc = 0;
  if ((int )p->inTrans == 2) {
    pBt = p->pBt;
    sqlite3BtreeEnter(p);
    if (pBt->autoVacuum) {
      rc = autoVacuumCommit(pBt);
      if (rc != 0) {
        return (rc);
      }
    }
    if (pBt->bDoTruncate) {
      sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
    }
    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
  }
  return (rc);
}
}
static void btreeEndTransaction(Btree *p ) 
{ 
  BtShared *pBt ;
  sqlite3 *db ;

  {
  pBt = p->pBt;
  db = p->db;
  pBt->bDoTruncate = (u8 )0;
  if ((int )p->inTrans > 0) {
    if (db->nVdbeRead > 1) {
      downgradeAllSharedCacheTableLocks(p);
      p->inTrans = (u8 )1;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if ((int )p->inTrans != 0) {
      clearAllSharedCacheTableLocks(p);
      (pBt->nTransaction) --;
      if (0 == pBt->nTransaction) {
        pBt->inTransaction = (u8 )0;
      }
    }
    p->inTrans = (u8 )0;
    unlockBtreeIfUnused(pBt);
  }
  return;
}
}
static int sqlite3BtreeCommitPhaseTwo(Btree *p , int bCleanup ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  if ((int )p->inTrans == 0) {
    return (0);
  }
  sqlite3BtreeEnter(p);
  if ((int )p->inTrans == 2) {
    pBt = p->pBt;
    rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);
    if (rc != 0) {
      if (bCleanup == 0) {
        return (rc);
      }
    }
    (p->iDataVersion) --;
    pBt->inTransaction = (u8 )1;
    btreeClearHasContent(pBt);
  }
  btreeEndTransaction(p);
  return (0);
}
}
static int sqlite3BtreeCommit(Btree *p ) 
{ 
  int rc ;

  {
  sqlite3BtreeEnter(p);
  rc = sqlite3BtreeCommitPhaseOne(p, (char const   *)0);
  if (rc == 0) {
    rc = sqlite3BtreeCommitPhaseTwo(p, 0);
  }
  return (rc);
}
}
static int sqlite3BtreeTripAllCursors(Btree *pBtree , int errCode , int writeOnly ) 
{ 
  BtCursor *p ;
  int rc ;

  {
  rc = 0;
  if (pBtree) {
    sqlite3BtreeEnter(pBtree);
    p = (pBtree->pBt)->pCursor;
    while (p) {
      if (writeOnly) {
        if (((int )p->curFlags & 1) == 0) {
          if ((int )p->eState == 0) {
            goto _L;
          } else
          if ((int )p->eState == 2) {
            _L: /* CIL Label */ 
            rc = saveCursorPosition(p);
            if (rc != 0) {
              sqlite3BtreeTripAllCursors(pBtree, rc, 0);
              break;
            }
          }
        } else {
          sqlite3BtreeClearCursor(p);
          p->eState = (u8 )4;
          p->skipNext = errCode;
        }
      } else {
        sqlite3BtreeClearCursor(p);
        p->eState = (u8 )4;
        p->skipNext = errCode;
      }
      btreeReleaseAllCursorPages(p);
      p = p->pNext;
    }
  }
  return (rc);
}
}
static void btreeSetNPage(BtShared *pBt , MemPage *pPage1 ) 
{ 
  int nPage ;
  u32 tmp ;

  {
  tmp = sqlite3Get4byte((u8 const   *)(pPage1->aData + 28));
  nPage = (int )tmp;
  if (nPage == 0) {
    sqlite3PagerPagecount(pBt->pPager, & nPage);
  }
  pBt->nPage = (u32 )nPage;
  return;
}
}
static int sqlite3BtreeRollback(Btree *p , int tripCode , int writeOnly ) 
{ 
  int rc ;
  BtShared *pBt ;
  MemPage *pPage1 ;
  int rc2 ;
  int tmp ;
  int rc2___0 ;
  int tmp___0 ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if (tripCode == 0) {
    tripCode = saveAllCursors(pBt, (Pgno )0, (BtCursor *)0);
    rc = tripCode;
    if (rc) {
      writeOnly = 0;
    }
  } else {
    rc = 0;
  }
  if (tripCode) {
    tmp = sqlite3BtreeTripAllCursors(p, tripCode, writeOnly);
    rc2 = tmp;
    if (rc2 != 0) {
      rc = rc2;
    }
  }
  if ((int )p->inTrans == 2) {
    rc2___0 = sqlite3PagerRollback(pBt->pPager);
    if (rc2___0 != 0) {
      rc = rc2___0;
    }
    tmp___0 = btreeGetPage(pBt, (Pgno )1, & pPage1, 0);
    if (tmp___0 == 0) {
      btreeSetNPage(pBt, pPage1);
      releasePageOne(pPage1);
    }
    pBt->inTransaction = (u8 )1;
    btreeClearHasContent(pBt);
  }
  btreeEndTransaction(p);
  return (rc);
}
}
static int sqlite3BtreeBeginStmt(Btree *p , int iStatement ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement);
  return (rc);
}
}
static int sqlite3BtreeSavepoint(Btree *p , int op , int iSavepoint ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  rc = 0;
  if (p) {
    if ((int )p->inTrans == 2) {
      pBt = p->pBt;
      sqlite3BtreeEnter(p);
      if (op == 2) {
        rc = saveAllCursors(pBt, (Pgno )0, (BtCursor *)0);
      }
      if (rc == 0) {
        rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint);
      }
      if (rc == 0) {
        if (iSavepoint < 0) {
          if (((int )pBt->btsFlags & 16) != 0) {
            pBt->nPage = (u32 )0;
          }
        }
        rc = newDatabase(pBt);
        btreeSetNPage(pBt, pBt->pPage1);
      }
    }
  }
  return (rc);
}
}
static int btreeCursor(Btree *p , int iTable , int wrFlag , struct KeyInfo *pKeyInfo ,
                       BtCursor *pCur ) 
{ 
  BtShared *pBt ;
  BtCursor *pX ;
  Pgno tmp ;

  {
  pBt = p->pBt;
  if (wrFlag) {
    allocateTempSpace(pBt);
    if ((unsigned long )pBt->pTmpSpace == (unsigned long )((u8 *)0)) {
      return (7);
    }
  }
  if (iTable == 1) {
    tmp = btreePagecount(pBt);
    if (tmp == 0U) {
      iTable = 0;
    }
  }
  pCur->pgnoRoot = (Pgno )iTable;
  pCur->iPage = (i8 )-1;
  pCur->pKeyInfo = pKeyInfo;
  pCur->pBtree = p;
  pCur->pBt = pBt;
  if (wrFlag) {
    pCur->curFlags = (u8 )1;
  } else {
    pCur->curFlags = (u8 )0;
  }
  if (wrFlag) {
    pCur->curPagerFlags = (u8 )0;
  } else {
    pCur->curPagerFlags = (u8 )2;
  }
  pX = pBt->pCursor;
  while (pX) {
    if (pX->pgnoRoot == (Pgno )iTable) {
      pX->curFlags = (u8 )((int )pX->curFlags | 32);
      pCur->curFlags = (u8 )((int )pCur->curFlags | 32);
    }
    pX = pX->pNext;
  }
  pCur->pNext = pBt->pCursor;
  pBt->pCursor = pCur;
  pCur->eState = (u8 )1;
  return (0);
}
}
static int sqlite3BtreeCursor(Btree *p , int iTable , int wrFlag , struct KeyInfo *pKeyInfo ,
                              BtCursor *pCur ) 
{ 
  int rc ;

  {
  if (iTable < 1) {
    rc = sqlite3CorruptError(67802);
  } else {
    sqlite3BtreeEnter(p);
    rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
  }
  return (rc);
}
}
static int sqlite3BtreeCursorSize(void) 
{ 


  {
  return ((int )((sizeof(BtCursor ) + 7UL) & 0xfffffffffffffff8UL));
}
}
static void sqlite3BtreeCursorZero(BtCursor *p ) 
{ 


  {
  memset((void *)p, 0, (unsigned long )(& ((BtCursor *)0)->pBt));
  return;
}
}
static int sqlite3BtreeCloseCursor(BtCursor *pCur ) 
{ 
  Btree *pBtree ;
  BtShared *pBt ;
  BtCursor *pPrev ;

  {
  pBtree = pCur->pBtree;
  if (pBtree) {
    pBt = pCur->pBt;
    sqlite3BtreeEnter(pBtree);
    if ((unsigned long )pBt->pCursor == (unsigned long )pCur) {
      pBt->pCursor = pCur->pNext;
    } else {
      pPrev = pBt->pCursor;
      while (1) {
        if ((unsigned long )pPrev->pNext == (unsigned long )pCur) {
          pPrev->pNext = pCur->pNext;
          break;
        }
        pPrev = pPrev->pNext;
        if (! pPrev) {
          break;
        }
      }
    }
    btreeReleaseAllCursorPages(pCur);
    unlockBtreeIfUnused(pBt);
    sqlite3_free((void *)pCur->aOverflow);
    sqlite3_free(pCur->pKey);
    pCur->pBtree = (Btree *)0;
  }
  return (0);
}
}
static void ( __attribute__((__noinline__)) getCellInfo)(BtCursor *pCur ) 
{ 


  {
  if ((int )pCur->info.nSize == 0) {
    pCur->curFlags = (u8 )((int )pCur->curFlags | 2);
    btreeParseCell(pCur->pPage, (int )pCur->ix, & pCur->info);
  }
  return;
}
}
static int sqlite3BtreeCursorIsValidNN(BtCursor *pCur ) 
{ 


  {
  return ((int )pCur->eState == 0);
}
}
static i64 sqlite3BtreeIntegerKey(BtCursor *pCur ) 
{ 


  {
  getCellInfo(pCur);
  return (pCur->info.nKey);
}
}
static u32 sqlite3BtreePayloadSize(BtCursor *pCur ) 
{ 


  {
  getCellInfo(pCur);
  return (pCur->info.nPayload);
}
}
static sqlite_int64 sqlite3BtreeMaxRecordSize(BtCursor *pCur ) 
{ 


  {
  return ((sqlite_int64 )(pCur->pBt)->pageSize * (sqlite_int64 )(pCur->pBt)->nPage);
}
}
static int getOverflowPage(BtShared *pBt , Pgno ovfl , MemPage **ppPage , Pgno *pPgnoNext ) 
{ 
  Pgno next ;
  MemPage *pPage ;
  int rc ;
  Pgno pgno ;
  Pgno iGuess ;
  u8 eType ;
  Pgno tmp ;
  Pgno tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  next = (Pgno )0;
  pPage = (MemPage *)0;
  rc = 0;
  if (pBt->autoVacuum) {
    iGuess = ovfl + 1U;
    while (1) {
      tmp = ptrmapPageno(pBt, iGuess);
      if (! (tmp == iGuess)) {
        if (! (iGuess == (u32 )sqlite3PendingByte / pBt->pageSize + 1U)) {
          break;
        }
      }
      iGuess ++;
    }
    tmp___0 = btreePagecount(pBt);
    if (iGuess <= tmp___0) {
      rc = ptrmapGet(pBt, iGuess, & eType, & pgno);
      if (rc == 0) {
        if ((int )eType == 4) {
          if (pgno == ovfl) {
            next = iGuess;
            rc = 101;
          }
        }
      }
    }
  }
  if (rc == 0) {
    if ((unsigned long )ppPage == (unsigned long )((MemPage **)0)) {
      tmp___1 = 2;
    } else {
      tmp___1 = 0;
    }
    rc = btreeGetPage(pBt, ovfl, & pPage, tmp___1);
    if (rc == 0) {
      next = sqlite3Get4byte((u8 const   *)pPage->aData);
    }
  }
  *pPgnoNext = next;
  if (ppPage) {
    *ppPage = pPage;
  } else {
    releasePage(pPage);
  }
  if (rc == 101) {
    tmp___2 = 0;
  } else {
    tmp___2 = rc;
  }
  return (tmp___2);
}
}
static int copyPayload(void *pPayload , void *pBuf , int nByte , int eOp , DbPage *pDbPage ) 
{ 
  int rc ;
  int tmp ;

  {
  if (eOp) {
    tmp = sqlite3PagerWrite(pDbPage);
    rc = tmp;
    if (rc != 0) {
      return (rc);
    }
    memcpy((void * __restrict  )pPayload, (void const   * __restrict  )pBuf, (size_t )nByte);
  } else {
    memcpy((void * __restrict  )pBuf, (void const   * __restrict  )pPayload, (size_t )nByte);
  }
  return (0);
}
}
static int accessPayload(BtCursor *pCur , u32 offset , u32 amt , unsigned char *pBuf ,
                         int eOp ) 
{ 
  unsigned char *aPayload ;
  int rc ;
  int iIdx ;
  MemPage *pPage ;
  BtShared *pBt ;
  int tmp ;
  int a___0 ;
  u32 ovflSize ;
  Pgno nextPage ;
  int nOvfl ;
  Pgno *aNew ;
  void *tmp___0 ;
  int tmp___1 ;
  int a___1 ;
  DbPage *pDbPage ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  rc = 0;
  iIdx = 0;
  pPage = pCur->pPage;
  pBt = pCur->pBt;
  getCellInfo(pCur);
  aPayload = pCur->info.pPayload;
  if ((uptr )(aPayload - pPage->aData) > (uptr )(pBt->usableSize - (u32 )pCur->info.nLocal)) {
    tmp = sqlite3CorruptError(68150);
    return (tmp);
  }
  if (offset < (u32 )pCur->info.nLocal) {
    a___0 = (int )amt;
    if ((u32 )a___0 + offset > (u32 )pCur->info.nLocal) {
      a___0 = (int )((u32 )pCur->info.nLocal - offset);
    }
    rc = copyPayload((void *)(aPayload + offset), (void *)pBuf, a___0, eOp, pPage->pDbPage);
    offset = (u32 )0;
    pBuf += a___0;
    amt -= (u32 )a___0;
  } else {
    offset -= (u32 )pCur->info.nLocal;
  }
  if (rc == 0) {
    if (amt > 0U) {
      ovflSize = pBt->usableSize - 4U;
      nextPage = sqlite3Get4byte((u8 const   *)(aPayload + pCur->info.nLocal));
      if (((int )pCur->curFlags & 4) == 0) {
        nOvfl = (int )((((pCur->info.nPayload - (u32 )pCur->info.nLocal) + ovflSize) - 1U) / ovflSize);
        if ((unsigned long )pCur->aOverflow == (unsigned long )((Pgno *)0)) {
          goto _L;
        } else {
          tmp___1 = sqlite3MallocSize((void *)pCur->aOverflow);
          if (nOvfl * (int )sizeof(Pgno ) > tmp___1) {
            _L: /* CIL Label */ 
            tmp___0 = sqlite3Realloc((void *)pCur->aOverflow, (u64 )((unsigned long )(nOvfl * 2) * sizeof(Pgno )));
            aNew = (Pgno *)tmp___0;
            if ((unsigned long )aNew == (unsigned long )((Pgno *)0)) {
              return (7);
            } else {
              pCur->aOverflow = aNew;
            }
          }
        }
        memset((void *)pCur->aOverflow, 0, (unsigned long )nOvfl * sizeof(Pgno ));
        pCur->curFlags = (u8 )((int )pCur->curFlags | 4);
      } else
      if (*(pCur->aOverflow + offset / ovflSize)) {
        iIdx = (int )(offset / ovflSize);
        nextPage = *(pCur->aOverflow + iIdx);
        offset %= ovflSize;
      }
      while (nextPage) {
        *(pCur->aOverflow + iIdx) = nextPage;
        if (offset >= ovflSize) {
          if (*(pCur->aOverflow + (iIdx + 1))) {
            nextPage = *(pCur->aOverflow + (iIdx + 1));
          } else {
            rc = getOverflowPage(pBt, nextPage, (MemPage **)0, & nextPage);
          }
          offset -= ovflSize;
        } else {
          a___1 = (int )amt;
          if ((u32 )a___1 + offset > ovflSize) {
            a___1 = (int )(ovflSize - offset);
          }
          if (eOp == 0) {
            tmp___2 = 2;
          } else {
            tmp___2 = 0;
          }
          rc = sqlite3PagerGet(pBt->pPager, nextPage, & pDbPage, tmp___2);
          if (rc == 0) {
            tmp___3 = sqlite3PagerGetData(pDbPage);
            aPayload = (unsigned char *)tmp___3;
            nextPage = sqlite3Get4byte((u8 const   *)aPayload);
            rc = copyPayload((void *)(aPayload + (offset + 4U)), (void *)pBuf, a___1,
                             eOp, pDbPage);
            sqlite3PagerUnref(pDbPage);
            offset = (u32 )0;
          }
          amt -= (u32 )a___1;
          if (amt == 0U) {
            return (rc);
          }
          pBuf += a___1;
        }
        if (rc) {
          break;
        }
        iIdx ++;
      }
    }
  }
  if (rc == 0) {
    if (amt > 0U) {
      tmp___4 = sqlite3CorruptError(68296);
      return (tmp___4);
    }
  }
  return (rc);
}
}
static int sqlite3BtreePayload(BtCursor *pCur , u32 offset , u32 amt , void *pBuf ) 
{ 
  int tmp ;

  {
  tmp = accessPayload(pCur, offset, amt, (unsigned char *)pBuf, 0);
  return (tmp);
}
}
static int ( __attribute__((__noinline__)) accessPayloadChecked)(BtCursor *pCur ,
                                                                 u32 offset , u32 amt ,
                                                                 void *pBuf ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )pCur->eState == 1) {
    return (4);
  }
  rc = btreeRestoreCursorPosition(pCur);
  if (rc) {
    tmp___0 = rc;
  } else {
    tmp = accessPayload(pCur, offset, amt, (unsigned char *)pBuf, 0);
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
static int sqlite3BtreePayloadChecked(BtCursor *pCur , u32 offset , u32 amt , void *pBuf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int )pCur->eState == 0) {
    tmp = accessPayload(pCur, offset, amt, (unsigned char *)pBuf, 0);
    return (tmp);
  } else {
    tmp___0 = accessPayloadChecked(pCur, offset, amt, pBuf);
    return (tmp___0);
  }
}
}
static void const   *fetchPayload(BtCursor *pCur , u32 *pAmt ) 
{ 
  int amt ;

  {
  amt = (int )pCur->info.nLocal;
  if (amt > (int )((pCur->pPage)->aDataEnd - pCur->info.pPayload)) {
    if (0 > (int )((pCur->pPage)->aDataEnd - pCur->info.pPayload)) {
      amt = 0;
    } else {
      amt = (int )((pCur->pPage)->aDataEnd - pCur->info.pPayload);
    }
  }
  *pAmt = (u32 )amt;
  return ((void const   *)((void *)pCur->info.pPayload));
}
}
static void const   *sqlite3BtreePayloadFetch(BtCursor *pCur , u32 *pAmt ) 
{ 
  void const   *tmp ;

  {
  tmp = fetchPayload(pCur, pAmt);
  return (tmp);
}
}
static int moveToChild(BtCursor *pCur , u32 newPgno ) 
{ 
  BtShared *pBt ;
  int tmp ;
  int tmp___0 ;

  {
  pBt = pCur->pBt;
  if ((int )pCur->iPage >= 19) {
    tmp = sqlite3CorruptError(68436);
    return (tmp);
  }
  pCur->info.nSize = (u16 )0;
  pCur->curFlags = (u8 )((int )pCur->curFlags & -7);
  pCur->aiIdx[pCur->iPage] = pCur->ix;
  pCur->apPage[pCur->iPage] = pCur->pPage;
  pCur->ix = (u16 )0;
  pCur->iPage = (i8 )((int )pCur->iPage + 1);
  tmp___0 = getAndInitPage(pBt, newPgno, & pCur->pPage, pCur, (int )pCur->curPagerFlags);
  return (tmp___0);
}
}
static void moveToParent(BtCursor *pCur ) 
{ 
  MemPage *pLeaf ;

  {
  pCur->info.nSize = (u16 )0;
  pCur->curFlags = (u8 )((int )pCur->curFlags & -7);
  pCur->ix = pCur->aiIdx[(int )pCur->iPage - 1];
  pLeaf = pCur->pPage;
  pCur->iPage = (i8 )((int )pCur->iPage - 1);
  pCur->pPage = pCur->apPage[pCur->iPage];
  releasePageNotNull(pLeaf);
  return;
}
}
static int moveToRoot(BtCursor *pCur ) 
{ 
  MemPage *pRoot ;
  int rc ;
  int tmp ;
  Pgno subpage ;
  int tmp___0 ;

  {
  rc = 0;
  if ((int )pCur->iPage >= 0) {
    if (pCur->iPage) {
      releasePageNotNull(pCur->pPage);
      while (1) {
        pCur->iPage = (i8 )((int )pCur->iPage - 1);
        if (! pCur->iPage) {
          break;
        }
        releasePageNotNull(pCur->apPage[pCur->iPage]);
      }
      pCur->pPage = pCur->apPage[0];
      goto skip_init;
    }
  } else
  if (pCur->pgnoRoot == 0U) {
    pCur->eState = (u8 )1;
    return (16);
  } else {
    if ((int )pCur->eState >= 3) {
      if ((int )pCur->eState == 4) {
        return (pCur->skipNext);
      }
      sqlite3BtreeClearCursor(pCur);
    }
    rc = getAndInitPage((pCur->pBtree)->pBt, pCur->pgnoRoot, & pCur->pPage, (BtCursor *)0,
                        (int )pCur->curPagerFlags);
    if (rc != 0) {
      pCur->eState = (u8 )1;
      return (rc);
    }
    pCur->iPage = (i8 )0;
    pCur->curIntKey = (pCur->pPage)->intKey;
  }
  pRoot = pCur->pPage;
  if ((int )pRoot->isInit == 0) {
    tmp = sqlite3CorruptError(68574);
    return (tmp);
  } else
  if (((unsigned long )pCur->pKeyInfo == (unsigned long )((struct KeyInfo *)0)) != (int )pRoot->intKey) {
    tmp = sqlite3CorruptError(68574);
    return (tmp);
  }
  skip_init: 
  pCur->ix = (u16 )0;
  pCur->info.nSize = (u16 )0;
  pCur->curFlags = (u8 )((int )pCur->curFlags & -15);
  pRoot = pCur->pPage;
  if ((int )pRoot->nCell > 0) {
    pCur->eState = (u8 )0;
  } else
  if (! pRoot->leaf) {
    if (pRoot->pgno != 1U) {
      tmp___0 = sqlite3CorruptError(68587);
      return (tmp___0);
    }
    subpage = sqlite3Get4byte((u8 const   *)(pRoot->aData + ((int )pRoot->hdrOffset + 8)));
    pCur->eState = (u8 )0;
    rc = moveToChild(pCur, subpage);
  } else {
    pCur->eState = (u8 )1;
    rc = 16;
  }
  return (rc);
}
}
static int moveToLeftmost(BtCursor *pCur ) 
{ 
  Pgno pgno ;
  int rc ;
  MemPage *pPage ;
  short tmp ;

  {
  rc = 0;
  while (1) {
    if (rc == 0) {
      pPage = pCur->pPage;
      if (pPage->leaf) {
        break;
      }
    } else {
      break;
    }
    tmp = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * (int )pCur->ix)));
    pgno = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->maskPage & (int )tmp)));
    rc = moveToChild(pCur, pgno);
  }
  return (rc);
}
}
static int moveToRightmost(BtCursor *pCur ) 
{ 
  Pgno pgno ;
  int rc ;
  MemPage *pPage ;

  {
  rc = 0;
  pPage = (MemPage *)0;
  while (1) {
    pPage = pCur->pPage;
    if (pPage->leaf) {
      break;
    }
    pgno = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->hdrOffset + 8)));
    pCur->ix = pPage->nCell;
    rc = moveToChild(pCur, pgno);
    if (rc) {
      return (rc);
    }
  }
  pCur->ix = (u16 )((int )pPage->nCell - 1);
  return (0);
}
}
static int sqlite3BtreeFirst(BtCursor *pCur , int *pRes ) 
{ 
  int rc ;

  {
  rc = moveToRoot(pCur);
  if (rc == 0) {
    *pRes = 0;
    rc = moveToLeftmost(pCur);
  } else
  if (rc == 16) {
    *pRes = 1;
    rc = 0;
  }
  return (rc);
}
}
static int sqlite3BtreeLast(BtCursor *pCur , int *pRes ) 
{ 
  int rc ;

  {
  if (0 == (int )pCur->eState) {
    if (((int )pCur->curFlags & 8) != 0) {
      *pRes = 0;
      return (0);
    }
  }
  rc = moveToRoot(pCur);
  if (rc == 0) {
    *pRes = 0;
    rc = moveToRightmost(pCur);
    if (rc == 0) {
      pCur->curFlags = (u8 )((int )pCur->curFlags | 8);
    } else {
      pCur->curFlags = (u8 )((int )pCur->curFlags & -9);
    }
  } else
  if (rc == 16) {
    *pRes = 1;
    rc = 0;
  }
  return (rc);
}
}
static int sqlite3BtreeMovetoUnpacked(BtCursor *pCur , UnpackedRecord *pIdxKey , i64 intKey ,
                                      int biasRight , int *pRes ) 
{ 
  int rc ;
  int (*xRecordCompare)(int  , void const   * , UnpackedRecord * ) ;
  int lwr ;
  int upr ;
  int idx ;
  int c ;
  Pgno chldPg ;
  MemPage *pPage ;
  u8 *pCell ;
  i64 nCellKey ;
  short tmp ;
  int tmp___0 ;
  u8 *tmp___1 ;
  int nCell ;
  short tmp___2 ;
  void *pCellKey ;
  u8 *pCellBody ;
  int nOverrun ;
  short tmp___3 ;

  {
  if ((unsigned long )pIdxKey == (unsigned long )((UnpackedRecord *)0)) {
    if ((int )pCur->eState == 0) {
      if (((int )pCur->curFlags & 2) != 0) {
        if (pCur->info.nKey == intKey) {
          *pRes = 0;
          return (0);
        }
        if (pCur->info.nKey < intKey) {
          if (((int )pCur->curFlags & 8) != 0) {
            *pRes = -1;
            return (0);
          }
          if (pCur->info.nKey + 1LL == intKey) {
            *pRes = 0;
            rc = sqlite3BtreeNext(pCur, 0);
            if (rc == 0) {
              getCellInfo(pCur);
              if (pCur->info.nKey == intKey) {
                return (0);
              }
            } else
            if (rc == 101) {
              rc = 0;
            } else {
              return (rc);
            }
          }
        }
      }
    }
  }
  if (pIdxKey) {
    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
    pIdxKey->errCode = (u8 )0;
  } else {
    xRecordCompare = (int (*)(int  , void const   * , UnpackedRecord * ))0;
  }
  rc = moveToRoot(pCur);
  if (rc) {
    if (rc == 16) {
      *pRes = -1;
      return (0);
    }
    return (rc);
  }
  while (1) {
    pPage = pCur->pPage;
    lwr = 0;
    upr = (int )pPage->nCell - 1;
    idx = upr >> (1 - biasRight);
    pCur->ix = (u16 )idx;
    if ((unsigned long )xRecordCompare == (unsigned long )((int (*)(int  , void const   * ,
                                                                    UnpackedRecord * ))0)) {
      while (1) {
        tmp = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * idx)));
        pCell = pPage->aDataOfst + ((int )pPage->maskPage & (int )tmp);
        if (pPage->intKeyLeaf) {
          while (1) {
            tmp___1 = pCell;
            pCell ++;
            if (! (128 <= (int )*tmp___1)) {
              break;
            }
            if ((unsigned long )pCell >= (unsigned long )pPage->aDataEnd) {
              tmp___0 = sqlite3CorruptError(68848);
              return (tmp___0);
            }
          }
        }
        sqlite3GetVarint((unsigned char const   *)pCell, (u64 *)(& nCellKey));
        if (nCellKey < intKey) {
          lwr = idx + 1;
          if (lwr > upr) {
            c = -1;
            break;
          }
        } else
        if (nCellKey > intKey) {
          upr = idx - 1;
          if (lwr > upr) {
            c = 1;
            break;
          }
        } else {
          pCur->ix = (u16 )idx;
          if (! pPage->leaf) {
            lwr = idx;
            goto moveto_next_layer;
          } else {
            pCur->curFlags = (u8 )((int )pCur->curFlags | 2);
            pCur->info.nKey = nCellKey;
            pCur->info.nSize = (u16 )0;
            *pRes = 0;
            return (0);
          }
        }
        idx = (lwr + upr) >> 1;
      }
    } else {
      while (1) {
        tmp___2 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * idx)));
        pCell = pPage->aDataOfst + ((int )pPage->maskPage & (int )tmp___2);
        nCell = (int )*(pCell + 0);
        if (nCell <= (int )pPage->max1bytePayload) {
          c = (*xRecordCompare)(nCell, (void const   *)((void *)(pCell + 1)), pIdxKey);
        } else
        if (! ((int )*(pCell + 1) & 128)) {
          nCell = ((nCell & 127) << 7) + (int )*(pCell + 1);
          if (nCell <= (int )pPage->maxLocal) {
            c = (*xRecordCompare)(nCell, (void const   *)((void *)(pCell + 2)), pIdxKey);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          pCellBody = pCell - (int )pPage->childPtrSize;
          nOverrun = 18;
          (*(pPage->xParseCell))(pPage, pCellBody, & pCur->info);
          nCell = (int )pCur->info.nKey;
          if (nCell < 2) {
            rc = sqlite3CorruptError(68923);
            goto moveto_finish;
          } else
          if ((u32 )nCell / (pCur->pBt)->usableSize > (pCur->pBt)->nPage) {
            rc = sqlite3CorruptError(68923);
            goto moveto_finish;
          }
          pCellKey = sqlite3Malloc((u64 )(nCell + nOverrun));
          if ((unsigned long )pCellKey == (unsigned long )((void *)0)) {
            rc = 7;
            goto moveto_finish;
          }
          pCur->ix = (u16 )idx;
          rc = accessPayload(pCur, (u32 )0, (u32 )nCell, (unsigned char *)pCellKey,
                             0);
          memset((void *)((u8 *)pCellKey + nCell), 0, (size_t )nOverrun);
          pCur->curFlags = (u8 )((int )pCur->curFlags & -5);
          if (rc) {
            sqlite3_free(pCellKey);
            goto moveto_finish;
          }
          c = sqlite3VdbeRecordCompare(nCell, (void const   *)pCellKey, pIdxKey);
          sqlite3_free(pCellKey);
        }
        if (c < 0) {
          lwr = idx + 1;
        } else
        if (c > 0) {
          upr = idx - 1;
        } else {
          *pRes = 0;
          rc = 0;
          pCur->ix = (u16 )idx;
          if (pIdxKey->errCode) {
            rc = sqlite3CorruptError(68955);
          }
          goto moveto_finish;
        }
        if (lwr > upr) {
          break;
        }
        idx = (lwr + upr) >> 1;
      }
    }
    if (pPage->leaf) {
      pCur->ix = (u16 )idx;
      *pRes = c;
      rc = 0;
      goto moveto_finish;
    }
    moveto_next_layer: 
    if (lwr >= (int )pPage->nCell) {
      chldPg = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->hdrOffset + 8)));
    } else {
      tmp___3 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * lwr)));
      chldPg = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->maskPage & (int )tmp___3)));
    }
    pCur->ix = (u16 )lwr;
    rc = moveToChild(pCur, chldPg);
    if (rc) {
      break;
    }
  }
  moveto_finish: 
  pCur->info.nSize = (u16 )0;
  return (rc);
}
}
static int sqlite3BtreeEof(BtCursor *pCur ) 
{ 


  {
  return (0 != (int )pCur->eState);
}
}
static i64 sqlite3BtreeRowCountEst(BtCursor *pCur ) 
{ 
  i64 n ;
  u8 i ;

  {
  if ((int )pCur->eState != 0) {
    return ((i64 )-1);
  }
  if ((int )(pCur->pPage)->leaf == 0) {
    return ((i64 )-1);
  }
  n = (i64 )(pCur->pPage)->nCell;
  i = (u8 )0;
  while ((int )i < (int )pCur->iPage) {
    n *= (i64 )(pCur->apPage[i])->nCell;
    i = (u8 )((int )i + 1);
  }
  return (n);
}
}
static int ( __attribute__((__noinline__)) btreeNext)(BtCursor *pCur ) 
{ 
  int rc ;
  int idx ;
  MemPage *pPage ;
  int tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((int )pCur->eState != 0) {
    if ((int )pCur->eState >= 3) {
      tmp = btreeRestoreCursorPosition(pCur);
      rc = tmp;
    } else {
      rc = 0;
    }
    if (rc != 0) {
      return (rc);
    }
    if (1 == (int )pCur->eState) {
      return (101);
    }
    if ((int )pCur->eState == 2) {
      pCur->eState = (u8 )0;
      if (pCur->skipNext > 0) {
        return (0);
      }
    }
  }
  pPage = pCur->pPage;
  pCur->ix = (u16 )((int )pCur->ix + 1);
  idx = (int )pCur->ix;
  if (! pPage->isInit) {
    tmp___0 = sqlite3CorruptError(69080);
    return (tmp___0);
  }
  if (idx >= (int )pPage->nCell) {
    if (! pPage->leaf) {
      tmp___1 = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->hdrOffset + 8)));
      rc = moveToChild(pCur, tmp___1);
      if (rc) {
        return (rc);
      }
      tmp___2 = moveToLeftmost(pCur);
      return (tmp___2);
    }
    while (1) {
      if ((int )pCur->iPage == 0) {
        pCur->eState = (u8 )1;
        return (101);
      }
      moveToParent(pCur);
      pPage = pCur->pPage;
      if (! ((int )pCur->ix >= (int )pPage->nCell)) {
        break;
      }
    }
    if (pPage->intKey) {
      tmp___3 = sqlite3BtreeNext(pCur, 0);
      return (tmp___3);
    } else {
      return (0);
    }
  }
  if (pPage->leaf) {
    return (0);
  } else {
    tmp___4 = moveToLeftmost(pCur);
    return (tmp___4);
  }
}
}
static int sqlite3BtreeNext(BtCursor *pCur , int flags___0 ) 
{ 
  MemPage *pPage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pCur->info.nSize = (u16 )0;
  pCur->curFlags = (u8 )((int )pCur->curFlags & -7);
  if ((int )pCur->eState != 0) {
    tmp = btreeNext(pCur);
    return (tmp);
  }
  pPage = pCur->pPage;
  pCur->ix = (u16 )((int )pCur->ix + 1);
  if ((int )pCur->ix >= (int )pPage->nCell) {
    pCur->ix = (u16 )((int )pCur->ix - 1);
    tmp___0 = btreeNext(pCur);
    return (tmp___0);
  }
  if (pPage->leaf) {
    return (0);
  } else {
    tmp___1 = moveToLeftmost(pCur);
    return (tmp___1);
  }
}
}
static int ( __attribute__((__noinline__)) btreePrevious)(BtCursor *pCur ) 
{ 
  int rc ;
  MemPage *pPage ;
  int tmp ;
  int idx ;
  short tmp___0 ;
  u32 tmp___1 ;

  {
  if ((int )pCur->eState != 0) {
    if ((int )pCur->eState >= 3) {
      tmp = btreeRestoreCursorPosition(pCur);
      rc = tmp;
    } else {
      rc = 0;
    }
    if (rc != 0) {
      return (rc);
    }
    if (1 == (int )pCur->eState) {
      return (101);
    }
    if (2 == (int )pCur->eState) {
      pCur->eState = (u8 )0;
      if (pCur->skipNext < 0) {
        return (0);
      }
    }
  }
  pPage = pCur->pPage;
  if (! pPage->leaf) {
    idx = (int )pCur->ix;
    tmp___0 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * idx)));
    tmp___1 = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->maskPage & (int )tmp___0)));
    rc = moveToChild(pCur, tmp___1);
    if (rc) {
      return (rc);
    }
    rc = moveToRightmost(pCur);
  } else {
    while ((int )pCur->ix == 0) {
      if ((int )pCur->iPage == 0) {
        pCur->eState = (u8 )1;
        return (101);
      }
      moveToParent(pCur);
    }
    pCur->ix = (u16 )((int )pCur->ix - 1);
    pPage = pCur->pPage;
    if (pPage->intKey) {
      if (! pPage->leaf) {
        rc = sqlite3BtreePrevious(pCur, 0);
      } else {
        rc = 0;
      }
    } else {
      rc = 0;
    }
  }
  return (rc);
}
}
static int sqlite3BtreePrevious(BtCursor *pCur , int flags___0 ) 
{ 
  int tmp ;

  {
  pCur->curFlags = (u8 )((int )pCur->curFlags & -15);
  pCur->info.nSize = (u16 )0;
  if ((int )pCur->eState != 0) {
    tmp = btreePrevious(pCur);
    return (tmp);
  } else
  if ((int )pCur->ix == 0) {
    tmp = btreePrevious(pCur);
    return (tmp);
  } else
  if ((int )(pCur->pPage)->leaf == 0) {
    tmp = btreePrevious(pCur);
    return (tmp);
  }
  pCur->ix = (u16 )((int )pCur->ix - 1);
  return (0);
}
}
static int allocateBtreePage(BtShared *pBt , MemPage **ppPage , Pgno *pPgno , Pgno nearby ,
                             u8 eMode ) 
{ 
  MemPage *pPage1 ;
  int rc ;
  u32 n ;
  u32 k ;
  MemPage *pTrunk ;
  MemPage *pPrevTrunk ;
  Pgno mxPage ;
  int tmp ;
  Pgno iTrunk ;
  u8 searchList ;
  u32 nSearch ;
  u8 eType ;
  u32 tmp___0 ;
  MemPage *pNewTrunk ;
  Pgno iNewTrunk ;
  u32 tmp___1 ;
  u32 closest ;
  Pgno iPage ;
  unsigned char *aData ;
  u32 i ;
  int dist ;
  u32 tmp___2 ;
  int d2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int noContent ;
  int tmp___6 ;
  int bNoContent ;
  int tmp___7 ;
  MemPage *pPg ;
  Pgno tmp___8 ;

  {
  pTrunk = (MemPage *)0;
  pPrevTrunk = (MemPage *)0;
  pPage1 = pBt->pPage1;
  mxPage = btreePagecount(pBt);
  n = sqlite3Get4byte((u8 const   *)(pPage1->aData + 36));
  if (n >= mxPage) {
    tmp = sqlite3CorruptError(69267);
    return (tmp);
  }
  if (n > 0U) {
    searchList = (u8 )0;
    nSearch = (u32 )0;
    if ((int )eMode == 1) {
      if (nearby <= mxPage) {
        rc = ptrmapGet(pBt, nearby, & eType, (Pgno *)0);
        if (rc) {
          return (rc);
        }
        if ((int )eType == 2) {
          searchList = (u8 )1;
        }
      }
    } else
    if ((int )eMode == 2) {
      searchList = (u8 )1;
    }
    rc = sqlite3PagerWrite(pPage1->pDbPage);
    if (rc) {
      return (rc);
    }
    sqlite3Put4byte(pPage1->aData + 36, n - 1U);
    while (1) {
      pPrevTrunk = pTrunk;
      if (pPrevTrunk) {
        iTrunk = sqlite3Get4byte((u8 const   *)(pPrevTrunk->aData + 0));
      } else {
        iTrunk = sqlite3Get4byte((u8 const   *)(pPage1->aData + 32));
      }
      if (iTrunk > mxPage) {
        rc = sqlite3CorruptError(69323);
      } else {
        tmp___0 = nSearch;
        nSearch ++;
        if (tmp___0 > n) {
          rc = sqlite3CorruptError(69323);
        } else {
          rc = btreeGetUnusedPage(pBt, iTrunk, & pTrunk, 0);
        }
      }
      if (rc) {
        pTrunk = (MemPage *)0;
        goto end_allocate_page;
      }
      k = sqlite3Get4byte((u8 const   *)(pTrunk->aData + 4));
      if (k == 0U) {
        if (! searchList) {
          rc = sqlite3PagerWrite(pTrunk->pDbPage);
          if (rc) {
            goto end_allocate_page;
          }
          *pPgno = iTrunk;
          memcpy((void * __restrict  )(pPage1->aData + 32), (void const   * __restrict  )(pTrunk->aData + 0),
                 (size_t )4);
          *ppPage = pTrunk;
          pTrunk = (MemPage *)0;
        } else {
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
      if (k > pBt->usableSize / 4U - 2U) {
        rc = sqlite3CorruptError(69352);
        goto end_allocate_page;
      } else
      if (searchList) {
        if (nearby == iTrunk) {
          goto _L___2;
        } else
        if (iTrunk < nearby) {
          if ((int )eMode == 2) {
            _L___2: /* CIL Label */ 
            *pPgno = iTrunk;
            *ppPage = pTrunk;
            searchList = (u8 )0;
            rc = sqlite3PagerWrite(pTrunk->pDbPage);
            if (rc) {
              goto end_allocate_page;
            }
            if (k == 0U) {
              if (! pPrevTrunk) {
                memcpy((void * __restrict  )(pPage1->aData + 32), (void const   * __restrict  )(pTrunk->aData + 0),
                       (size_t )4);
              } else {
                rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
                if (rc != 0) {
                  goto end_allocate_page;
                }
                memcpy((void * __restrict  )(pPrevTrunk->aData + 0), (void const   * __restrict  )(pTrunk->aData + 0),
                       (size_t )4);
              }
            } else {
              tmp___1 = sqlite3Get4byte((u8 const   *)(pTrunk->aData + 8));
              iNewTrunk = tmp___1;
              if (iNewTrunk > mxPage) {
                rc = sqlite3CorruptError(69386);
                goto end_allocate_page;
              }
              rc = btreeGetUnusedPage(pBt, iNewTrunk, & pNewTrunk, 0);
              if (rc != 0) {
                goto end_allocate_page;
              }
              rc = sqlite3PagerWrite(pNewTrunk->pDbPage);
              if (rc != 0) {
                releasePage(pNewTrunk);
                goto end_allocate_page;
              }
              memcpy((void * __restrict  )(pNewTrunk->aData + 0), (void const   * __restrict  )(pTrunk->aData + 0),
                     (size_t )4);
              sqlite3Put4byte(pNewTrunk->aData + 4, k - 1U);
              memcpy((void * __restrict  )(pNewTrunk->aData + 8), (void const   * __restrict  )(pTrunk->aData + 12),
                     (size_t )((k - 1U) * 4U));
              releasePage(pNewTrunk);
              if (! pPrevTrunk) {
                sqlite3Put4byte(pPage1->aData + 32, iNewTrunk);
              } else {
                rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
                if (rc) {
                  goto end_allocate_page;
                }
                sqlite3Put4byte(pPrevTrunk->aData + 0, iNewTrunk);
              }
            }
            pTrunk = (MemPage *)0;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (k > 0U) {
        aData = pTrunk->aData;
        if (nearby > 0U) {
          closest = (u32 )0;
          if ((int )eMode == 2) {
            i = (u32 )0;
            while (i < k) {
              iPage = sqlite3Get4byte((u8 const   *)(aData + (8U + i * 4U)));
              if (iPage <= nearby) {
                closest = i;
                break;
              }
              i ++;
            }
          } else {
            tmp___2 = sqlite3Get4byte((u8 const   *)(aData + 8));
            dist = sqlite3AbsInt32((int )(tmp___2 - nearby));
            i = (u32 )1;
            while (i < k) {
              tmp___3 = sqlite3Get4byte((u8 const   *)(aData + (8U + i * 4U)));
              tmp___4 = sqlite3AbsInt32((int )(tmp___3 - nearby));
              d2 = tmp___4;
              if (d2 < dist) {
                closest = i;
                dist = d2;
              }
              i ++;
            }
          }
        } else {
          closest = (u32 )0;
        }
        iPage = sqlite3Get4byte((u8 const   *)(aData + (8U + closest * 4U)));
        if (iPage > mxPage) {
          rc = sqlite3CorruptError(69451);
          goto end_allocate_page;
        }
        if (! searchList) {
          goto _L___0;
        } else
        if (iPage == nearby) {
          goto _L___0;
        } else
        if (iPage < nearby) {
          if ((int )eMode == 2) {
            _L___0: /* CIL Label */ 
            *pPgno = iPage;
            rc = sqlite3PagerWrite(pTrunk->pDbPage);
            if (rc) {
              goto end_allocate_page;
            }
            if (closest < k - 1U) {
              memcpy((void * __restrict  )(aData + (8U + closest * 4U)), (void const   * __restrict  )(aData + (4U + k * 4U)),
                     (size_t )4);
            }
            sqlite3Put4byte(aData + 4, k - 1U);
            tmp___6 = btreeGetHasContent(pBt, *pPgno);
            if (tmp___6) {
              noContent = 0;
            } else {
              noContent = 1;
            }
            rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);
            if (rc == 0) {
              rc = sqlite3PagerWrite((*ppPage)->pDbPage);
              if (rc != 0) {
                releasePage(*ppPage);
                *ppPage = (MemPage *)0;
              }
            }
            searchList = (u8 )0;
          }
        }
      }
      releasePage(pPrevTrunk);
      pPrevTrunk = (MemPage *)0;
      if (! searchList) {
        break;
      }
    }
  } else {
    if (0 == (int )pBt->bDoTruncate) {
      tmp___7 = 1;
    } else {
      tmp___7 = 0;
    }
    bNoContent = tmp___7;
    rc = sqlite3PagerWrite((pBt->pPage1)->pDbPage);
    if (rc) {
      return (rc);
    }
    (pBt->nPage) ++;
    if (pBt->nPage == (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
      (pBt->nPage) ++;
    }
    if (pBt->autoVacuum) {
      tmp___8 = ptrmapPageno(pBt, pBt->nPage);
      if (tmp___8 == pBt->nPage) {
        pPg = (MemPage *)0;
        rc = btreeGetUnusedPage(pBt, pBt->nPage, & pPg, bNoContent);
        if (rc == 0) {
          rc = sqlite3PagerWrite(pPg->pDbPage);
          releasePage(pPg);
        }
        if (rc) {
          return (rc);
        }
        (pBt->nPage) ++;
        if (pBt->nPage == (u32 )sqlite3PendingByte / pBt->pageSize + 1U) {
          (pBt->nPage) ++;
        }
      }
    }
    sqlite3Put4byte((pBt->pPage1)->aData + 28, pBt->nPage);
    *pPgno = pBt->nPage;
    rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);
    if (rc) {
      return (rc);
    }
    rc = sqlite3PagerWrite((*ppPage)->pDbPage);
    if (rc != 0) {
      releasePage(*ppPage);
      *ppPage = (MemPage *)0;
    }
  }
  end_allocate_page: 
  releasePage(pTrunk);
  releasePage(pPrevTrunk);
  return (rc);
}
}
static int freePage2(BtShared *pBt , MemPage *pMemPage , Pgno iPage ) 
{ 
  MemPage *pTrunk ;
  Pgno iTrunk ;
  MemPage *pPage1 ;
  MemPage *pPage ;
  int rc ;
  u32 nFree ;
  int tmp ;
  u32 nLeaf ;

  {
  pTrunk = (MemPage *)0;
  iTrunk = (Pgno )0;
  pPage1 = pBt->pPage1;
  if (iPage < 2U) {
    tmp = sqlite3CorruptError(69578);
    return (tmp);
  } else
  if (iPage > pBt->nPage) {
    tmp = sqlite3CorruptError(69578);
    return (tmp);
  }
  if (pMemPage) {
    pPage = pMemPage;
    sqlite3PagerRef(pPage->pDbPage);
  } else {
    pPage = btreePageLookup(pBt, iPage);
  }
  rc = sqlite3PagerWrite(pPage1->pDbPage);
  if (rc) {
    goto freepage_out;
  }
  nFree = sqlite3Get4byte((u8 const   *)(pPage1->aData + 36));
  sqlite3Put4byte(pPage1->aData + 36, nFree + 1U);
  if ((int )pBt->btsFlags & 4) {
    if (! pPage) {
      rc = btreeGetPage(pBt, iPage, & pPage, 0);
      if (rc != 0) {
        goto freepage_out;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      rc = sqlite3PagerWrite(pPage->pDbPage);
      if (rc != 0) {
        goto freepage_out;
      }
    }
    memset((void *)pPage->aData, 0, (size_t )(pPage->pBt)->pageSize);
  }
  if (pBt->autoVacuum) {
    ptrmapPut(pBt, iPage, (u8 )2, (Pgno )0, & rc);
    if (rc) {
      goto freepage_out;
    }
  }
  if (nFree != 0U) {
    iTrunk = sqlite3Get4byte((u8 const   *)(pPage1->aData + 32));
    rc = btreeGetPage(pBt, iTrunk, & pTrunk, 0);
    if (rc != 0) {
      goto freepage_out;
    }
    nLeaf = sqlite3Get4byte((u8 const   *)(pTrunk->aData + 4));
    if (nLeaf > pBt->usableSize / 4U - 2U) {
      rc = sqlite3CorruptError(69632);
      goto freepage_out;
    }
    if (nLeaf < pBt->usableSize / 4U - 8U) {
      rc = sqlite3PagerWrite(pTrunk->pDbPage);
      if (rc == 0) {
        sqlite3Put4byte(pTrunk->aData + 4, nLeaf + 1U);
        sqlite3Put4byte(pTrunk->aData + (8U + nLeaf * 4U), iPage);
        if (pPage) {
          if (((int )pBt->btsFlags & 4) == 0) {
            sqlite3PagerDontWrite(pPage->pDbPage);
          }
        }
        rc = btreeSetHasContent(pBt, iPage);
      }
      goto freepage_out;
    }
  }
  if ((unsigned long )pPage == (unsigned long )((MemPage *)0)) {
    rc = btreeGetPage(pBt, iPage, & pPage, 0);
    if (0 != rc) {
      goto freepage_out;
    }
  }
  rc = sqlite3PagerWrite(pPage->pDbPage);
  if (rc != 0) {
    goto freepage_out;
  }
  sqlite3Put4byte(pPage->aData, iTrunk);
  sqlite3Put4byte(pPage->aData + 4, (u32 )0);
  sqlite3Put4byte(pPage1->aData + 32, iPage);
  freepage_out: 
  if (pPage) {
    pPage->isInit = (u8 )0;
  }
  releasePage(pPage);
  releasePage(pTrunk);
  return (rc);
}
}
static void freePage(MemPage *pPage , int *pRC ) 
{ 


  {
  if (*pRC == 0) {
    *pRC = freePage2(pPage->pBt, pPage, pPage->pgno);
  }
  return;
}
}
static int clearCell(MemPage *pPage , unsigned char *pCell , CellInfo *pInfo ) 
{ 
  BtShared *pBt ;
  Pgno ovflPgno ;
  int rc ;
  int nOvfl ;
  u32 ovflPageSize ;
  int tmp ;
  Pgno iNext ;
  MemPage *pOvfl ;
  int tmp___0 ;
  Pgno tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  (*(pPage->xParseCell))(pPage, pCell, pInfo);
  if ((u32 )pInfo->nLocal == pInfo->nPayload) {
    return (0);
  }
  if ((unsigned long )(pCell + (int )pInfo->nSize) > (unsigned long )pPage->aDataEnd) {
    tmp = sqlite3CorruptError(69725);
    return (tmp);
  }
  ovflPgno = sqlite3Get4byte((u8 const   *)((pCell + (int )pInfo->nSize) - 4));
  pBt = pPage->pBt;
  ovflPageSize = pBt->usableSize - 4U;
  nOvfl = (int )((((pInfo->nPayload - (u32 )pInfo->nLocal) + ovflPageSize) - 1U) / ovflPageSize);
  while (1) {
    tmp___3 = nOvfl;
    nOvfl --;
    if (! tmp___3) {
      break;
    }
    iNext = (Pgno )0;
    pOvfl = (MemPage *)0;
    if (ovflPgno < 2U) {
      tmp___0 = sqlite3CorruptError(69742);
      return (tmp___0);
    } else {
      tmp___1 = btreePagecount(pBt);
      if (ovflPgno > tmp___1) {
        tmp___0 = sqlite3CorruptError(69742);
        return (tmp___0);
      }
    }
    if (nOvfl) {
      rc = getOverflowPage(pBt, ovflPgno, & pOvfl, & iNext);
      if (rc) {
        return (rc);
      }
    }
    if (pOvfl) {
      goto _L;
    } else {
      pOvfl = btreePageLookup(pBt, ovflPgno);
      if ((unsigned long )pOvfl != (unsigned long )((MemPage *)0)) {
        _L: /* CIL Label */ 
        tmp___2 = sqlite3PagerPageRefcount(pOvfl->pDbPage);
        if (tmp___2 != 1) {
          rc = sqlite3CorruptError(69762);
        } else {
          rc = freePage2(pBt, pOvfl, ovflPgno);
        }
      } else {
        rc = freePage2(pBt, pOvfl, ovflPgno);
      }
    }
    if (pOvfl) {
      sqlite3PagerUnref(pOvfl->pDbPage);
    }
    if (rc) {
      return (rc);
    }
    ovflPgno = iNext;
  }
  return (0);
}
}
static int fillInCell(MemPage *pPage , unsigned char *pCell , BtreePayload const   *pX ,
                      int *pnSize ) 
{ 
  int nPayload ;
  u8 const   *pSrc ;
  int nSrc ;
  int n ;
  int rc ;
  int mn ;
  int spaceLeft ;
  MemPage *pToRelease ;
  unsigned char *pPrior ;
  unsigned char *pPayload ;
  BtShared *pBt ;
  Pgno pgnoOvfl ;
  int nHeader ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  MemPage *pOvfl ;
  Pgno pgnoPtrmap ;
  Pgno tmp___4 ;
  u8 eType ;
  int tmp___5 ;

  {
  nHeader = (int )pPage->childPtrSize;
  if (pPage->intKey) {
    nPayload = (int )(pX->nData + pX->nZero);
    pSrc = (u8 const   *)pX->pData;
    nSrc = (int )pX->nData;
    if ((u32 )nPayload < 128U) {
      *(pCell + nHeader) = (unsigned char )nPayload;
      tmp___0 = 1;
    } else {
      tmp = sqlite3PutVarint(pCell + nHeader, (u64 )nPayload);
      tmp___0 = tmp;
    }
    nHeader += (int )((u8 )tmp___0);
    tmp___1 = sqlite3PutVarint(pCell + nHeader, *((u64 *)(& pX->nKey)));
    nHeader += tmp___1;
  } else {
    nPayload = (int )pX->nKey;
    nSrc = nPayload;
    pSrc = (u8 const   *)pX->pKey;
    if ((u32 )nPayload < 128U) {
      *(pCell + nHeader) = (unsigned char )nPayload;
      tmp___3 = 1;
    } else {
      tmp___2 = sqlite3PutVarint(pCell + nHeader, (u64 )nPayload);
      tmp___3 = tmp___2;
    }
    nHeader += (int )((u8 )tmp___3);
  }
  pPayload = pCell + nHeader;
  if (nPayload <= (int )pPage->maxLocal) {
    n = nHeader + nPayload;
    if (n < 4) {
      n = 4;
    }
    *pnSize = n;
    memcpy((void * __restrict  )pPayload, (void const   * __restrict  )pSrc, (size_t )nSrc);
    memset((void *)(pPayload + nSrc), 0, (size_t )(nPayload - nSrc));
    return (0);
  }
  mn = (int )pPage->minLocal;
  n = (int )((unsigned int )mn + (unsigned int )(nPayload - mn) % ((pPage->pBt)->usableSize - 4U));
  if (n > (int )pPage->maxLocal) {
    n = mn;
  }
  spaceLeft = n;
  *pnSize = (n + nHeader) + 4;
  pPrior = pCell + (nHeader + n);
  pToRelease = (MemPage *)0;
  pgnoOvfl = (Pgno )0;
  pBt = pPage->pBt;
  while (1) {
    n = nPayload;
    if (n > spaceLeft) {
      n = spaceLeft;
    }
    if (nSrc >= n) {
      memcpy((void * __restrict  )pPayload, (void const   * __restrict  )pSrc, (size_t )n);
    } else
    if (nSrc > 0) {
      n = nSrc;
      memcpy((void * __restrict  )pPayload, (void const   * __restrict  )pSrc, (size_t )n);
    } else {
      memset((void *)pPayload, 0, (size_t )n);
    }
    nPayload -= n;
    if (nPayload <= 0) {
      break;
    }
    pPayload += n;
    pSrc += n;
    nSrc -= n;
    spaceLeft -= n;
    if (spaceLeft == 0) {
      pOvfl = (MemPage *)0;
      pgnoPtrmap = pgnoOvfl;
      if (pBt->autoVacuum) {
        while (1) {
          pgnoOvfl ++;
          tmp___4 = ptrmapPageno(pBt, pgnoOvfl);
          if (! (tmp___4 == pgnoOvfl)) {
            if (! (pgnoOvfl == (u32 )sqlite3PendingByte / pBt->pageSize + 1U)) {
              break;
            }
          }
        }
      }
      rc = allocateBtreePage(pBt, & pOvfl, & pgnoOvfl, pgnoOvfl, (u8 )0);
      if (pBt->autoVacuum) {
        if (rc == 0) {
          if (pgnoPtrmap) {
            tmp___5 = 4;
          } else {
            tmp___5 = 3;
          }
          eType = (u8 )tmp___5;
          ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, & rc);
          if (rc) {
            releasePage(pOvfl);
          }
        }
      }
      if (rc) {
        releasePage(pToRelease);
        return (rc);
      }
      sqlite3Put4byte(pPrior, pgnoOvfl);
      releasePage(pToRelease);
      pToRelease = pOvfl;
      pPrior = pOvfl->aData;
      sqlite3Put4byte(pPrior, (u32 )0);
      pPayload = pOvfl->aData + 4;
      spaceLeft = (int )(pBt->usableSize - 4U);
    }
  }
  releasePage(pToRelease);
  return (0);
}
}
static void dropCell(MemPage *pPage , int idx , int sz , int *pRC ) 
{ 
  u32 pc ;
  u8 *data ;
  u8 *ptr ;
  int rc ;
  int hdr ;

  {
  if (*pRC) {
    return;
  }
  data = pPage->aData;
  ptr = pPage->aCellIdx + 2 * idx;
  pc = (u32 )(((int )*(ptr + 0) << 8) | (int )*(ptr + 1));
  hdr = (int )pPage->hdrOffset;
  if (pc + (u32 )sz > (pPage->pBt)->usableSize) {
    *pRC = sqlite3CorruptError(69998);
    return;
  }
  rc = freeSpace(pPage, (u16 )pc, (u16 )sz);
  if (rc) {
    *pRC = rc;
    return;
  }
  pPage->nCell = (u16 )((int )pPage->nCell - 1);
  if ((int )pPage->nCell == 0) {
    memset((void *)(data + (hdr + 1)), 0, (size_t )4);
    *(data + (hdr + 7)) = (u8 )0;
    *((data + (hdr + 5)) + 0) = (u8 )((pPage->pBt)->usableSize >> 8);
    *((data + (hdr + 5)) + 1) = (u8 )(pPage->pBt)->usableSize;
    pPage->nFree = (int )((((pPage->pBt)->usableSize - (u32 )pPage->hdrOffset) - (u32 )pPage->childPtrSize) - 8U);
  } else {
    memmove((void *)ptr, (void const   *)(ptr + 2), (size_t )(2 * ((int )pPage->nCell - idx)));
    *((data + (hdr + 3)) + 0) = (u8 )((int )pPage->nCell >> 8);
    *((data + (hdr + 3)) + 1) = (u8 )pPage->nCell;
    pPage->nFree += 2;
  }
  return;
}
}
static void insertCell(MemPage *pPage , int i , u8 *pCell , int sz , u8 *pTemp , Pgno iChild ,
                       int *pRC ) 
{ 
  int idx ;
  int j ;
  u8 *data ;
  u8 *pIns ;
  u8 tmp ;
  int rc ;
  int tmp___0 ;

  {
  idx = 0;
  if (pPage->nOverflow) {
    goto _L;
  } else
  if (sz + 2 > pPage->nFree) {
    _L: /* CIL Label */ 
    if (pTemp) {
      memcpy((void * __restrict  )pTemp, (void const   * __restrict  )pCell, (size_t )sz);
      pCell = pTemp;
    }
    if (iChild) {
      sqlite3Put4byte(pCell, iChild);
    }
    tmp = pPage->nOverflow;
    pPage->nOverflow = (u8 )((int )pPage->nOverflow + 1);
    j = (int )tmp;
    pPage->apOvfl[j] = pCell;
    pPage->aiOvfl[j] = (u16 )i;
  } else {
    tmp___0 = sqlite3PagerWrite(pPage->pDbPage);
    rc = tmp___0;
    if (rc != 0) {
      *pRC = rc;
      return;
    }
    data = pPage->aData;
    rc = allocateSpace(pPage, sz, & idx);
    if (rc) {
      *pRC = rc;
      return;
    }
    pPage->nFree -= (int )((u16 )(2 + sz));
    if (iChild) {
      memcpy((void * __restrict  )(data + (idx + 4)), (void const   * __restrict  )(pCell + 4),
             (size_t )(sz - 4));
      sqlite3Put4byte(data + idx, iChild);
    } else {
      memcpy((void * __restrict  )(data + idx), (void const   * __restrict  )pCell,
             (size_t )sz);
    }
    pIns = pPage->aCellIdx + i * 2;
    memmove((void *)(pIns + 2), (void const   *)pIns, (size_t )(2 * ((int )pPage->nCell - i)));
    *(pIns + 0) = (u8 )(idx >> 8);
    *(pIns + 1) = (u8 )idx;
    pPage->nCell = (u16 )((int )pPage->nCell + 1);
    *(data + ((int )pPage->hdrOffset + 4)) = (u8 )((int )*(data + ((int )pPage->hdrOffset + 4)) + 1);
    if ((int )*(data + ((int )pPage->hdrOffset + 4)) == 0) {
      *(data + ((int )pPage->hdrOffset + 3)) = (u8 )((int )*(data + ((int )pPage->hdrOffset + 3)) + 1);
    }
    if ((pPage->pBt)->autoVacuum) {
      ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);
    }
  }
  return;
}
}
static void populateCellCache(CellArray *p , int idx , int N ) 
{ 


  {
  while (N > 0) {
    if ((int )*(p->szCell + idx) == 0) {
      *(p->szCell + idx) = (*((p->pRef)->xCellSize))(p->pRef, *(p->apCell + idx));
    }
    idx ++;
    N --;
  }
  return;
}
}
static u16 ( __attribute__((__noinline__)) computeCellSize)(CellArray *p , int N ) 
{ 


  {
  *(p->szCell + N) = (*((p->pRef)->xCellSize))(p->pRef, *(p->apCell + N));
  return (*(p->szCell + N));
}
}
static u16 cachedCellSize(CellArray *p , int N ) 
{ 
  u16 tmp ;

  {
  if (*(p->szCell + N)) {
    return (*(p->szCell + N));
  }
  tmp = computeCellSize(p, N);
  return (tmp);
}
}
static int rebuildPage(CellArray *pCArray , int iFirst , int nCell , MemPage *pPg ) 
{ 
  int hdr ;
  u8 *aData ;
  int usableSize ;
  u8 *pEnd ;
  int i ;
  u32 j ;
  int iEnd ;
  u8 *pCellptr ;
  u8 *pTmp ;
  void *tmp ;
  u8 *pData ;
  int k ;
  u8 *pSrcEnd ;
  u8 *pCell ;
  u16 sz ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  hdr = (int )pPg->hdrOffset;
  aData = pPg->aData;
  usableSize = (int )(pPg->pBt)->usableSize;
  pEnd = aData + usableSize;
  i = iFirst;
  iEnd = i + nCell;
  pCellptr = pPg->aCellIdx;
  tmp = sqlite3PagerTempSpace((pPg->pBt)->pPager);
  pTmp = (u8 *)tmp;
  j = (u32 )(((int )*((aData + (hdr + 5)) + 0) << 8) | (int )*((aData + (hdr + 5)) + 1));
  if (j > (u32 )usableSize) {
    j = (u32 )0;
  }
  memcpy((void * __restrict  )(pTmp + j), (void const   * __restrict  )(aData + j),
         (size_t )((u32 )usableSize - j));
  k = 0;
  while (1) {
    if (pCArray->ixNx[k] <= i) {
      if (! (k < 6)) {
        break;
      }
    } else {
      break;
    }
    k ++;
  }
  pSrcEnd = pCArray->apEnd[k];
  pData = pEnd;
  while (1) {
    pCell = *(pCArray->apCell + i);
    sz = *(pCArray->szCell + i);
    if ((uptr )pCell >= (uptr )aData) {
      if ((uptr )pCell < (uptr )pEnd) {
        if ((uptr )(pCell + (int )sz) > (uptr )pEnd) {
          tmp___0 = sqlite3CorruptError(70299);
          return (tmp___0);
        }
        pCell = pTmp + (pCell - aData);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((uptr )(pCell + (int )sz) > (uptr )pSrcEnd) {
      if ((uptr )pCell < (uptr )pSrcEnd) {
        tmp___1 = sqlite3CorruptError(70304);
        return (tmp___1);
      }
    }
    pData -= (int )sz;
    *(pCellptr + 0) = (u8 )((pData - aData) >> 8);
    *(pCellptr + 1) = (u8 )(pData - aData);
    pCellptr += 2;
    if ((unsigned long )pData < (unsigned long )pCellptr) {
      tmp___2 = sqlite3CorruptError(70310);
      return (tmp___2);
    }
    memcpy((void * __restrict  )pData, (void const   * __restrict  )pCell, (size_t )sz);
    i ++;
    if (i >= iEnd) {
      break;
    }
    if (pCArray->ixNx[k] <= i) {
      k ++;
      pSrcEnd = pCArray->apEnd[k];
    }
  }
  pPg->nCell = (u16 )nCell;
  pPg->nOverflow = (u8 )0;
  *((aData + (hdr + 1)) + 0) = (u8 )0;
  *((aData + (hdr + 1)) + 1) = (u8 )0;
  *((aData + (hdr + 3)) + 0) = (u8 )((int )pPg->nCell >> 8);
  *((aData + (hdr + 3)) + 1) = (u8 )pPg->nCell;
  *((aData + (hdr + 5)) + 0) = (u8 )((pData - aData) >> 8);
  *((aData + (hdr + 5)) + 1) = (u8 )(pData - aData);
  *(aData + (hdr + 7)) = (u8 )0;
  return (0);
}
}
static int pageInsertArray(MemPage *pPg , u8 *pBegin , u8 **ppData , u8 *pCellptr ,
                           int iFirst , int nCell , CellArray *pCArray ) 
{ 
  int i ;
  u8 *aData ;
  u8 *pData ;
  int iEnd ;
  int k ;
  u8 *pEnd ;
  int sz ;
  int rc ;
  u8 *pSlot ;

  {
  i = iFirst;
  aData = pPg->aData;
  pData = *ppData;
  iEnd = iFirst + nCell;
  if (iEnd <= iFirst) {
    return (0);
  }
  k = 0;
  while (1) {
    if (pCArray->ixNx[k] <= i) {
      if (! (k < 6)) {
        break;
      }
    } else {
      break;
    }
    k ++;
  }
  pEnd = pCArray->apEnd[k];
  while (1) {
    sz = (int )*(pCArray->szCell + i);
    if ((int )*(aData + 1) == 0) {
      if ((int )*(aData + 2) == 0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      pSlot = pageFindSlot(pPg, sz, & rc);
      if ((unsigned long )pSlot == (unsigned long )((u8 *)0)) {
        _L: /* CIL Label */ 
        if (pData - pBegin < (long )sz) {
          return (1);
        }
        pData -= sz;
        pSlot = pData;
      }
    }
    if ((uptr )(*(pCArray->apCell + i) + sz) > (uptr )pEnd) {
      if ((uptr )*(pCArray->apCell + i) < (uptr )pEnd) {
        sqlite3CorruptError(70396);
        return (1);
      }
    }
    memmove((void *)pSlot, (void const   *)*(pCArray->apCell + i), (size_t )sz);
    *(pCellptr + 0) = (u8 )((pSlot - aData) >> 8);
    *(pCellptr + 1) = (u8 )(pSlot - aData);
    pCellptr += 2;
    i ++;
    if (i >= iEnd) {
      break;
    }
    if (pCArray->ixNx[k] <= i) {
      k ++;
      pEnd = pCArray->apEnd[k];
    }
  }
  *ppData = pData;
  return (0);
}
}
static int pageFreeArray(MemPage *pPg , int iFirst , int nCell , CellArray *pCArray ) 
{ 
  u8 *aData ;
  u8 *pEnd ;
  u8 *pStart ;
  int nRet ;
  int i ;
  int iEnd ;
  u8 *pFree ;
  int szFree ;
  u8 *pCell ;
  int sz ;

  {
  aData = pPg->aData;
  pEnd = aData + (pPg->pBt)->usableSize;
  pStart = aData + (((int )pPg->hdrOffset + 8) + (int )pPg->childPtrSize);
  nRet = 0;
  iEnd = iFirst + nCell;
  pFree = (u8 *)0;
  szFree = 0;
  i = iFirst;
  while (i < iEnd) {
    pCell = *(pCArray->apCell + i);
    if ((uptr )pCell >= (uptr )pStart) {
      if ((uptr )pCell < (uptr )pEnd) {
        sz = (int )*(pCArray->szCell + i);
        if ((unsigned long )pFree != (unsigned long )(pCell + sz)) {
          if (pFree) {
            freeSpace(pPg, (u16 )(pFree - aData), (u16 )szFree);
          }
          pFree = pCell;
          szFree = sz;
          if ((unsigned long )(pFree + sz) > (unsigned long )pEnd) {
            return (0);
          }
        } else {
          pFree = pCell;
          szFree += sz;
        }
        nRet ++;
      }
    }
    i ++;
  }
  if (pFree) {
    freeSpace(pPg, (u16 )(pFree - aData), (u16 )szFree);
  }
  return (nRet);
}
}
static int editPage(MemPage *pPg , int iOld , int iNew , int nNew , CellArray *pCArray ) 
{ 
  u8 *aData ;
  int hdr ;
  u8 *pBegin ;
  int nCell ;
  u8 *pData ;
  u8 *pCellptr ;
  int i ;
  int iOldEnd ;
  int iNewEnd ;
  int nShift ;
  int tmp ;
  int tmp___0 ;
  int nTail ;
  int tmp___1 ;
  int nAdd ;
  int tmp___2 ;
  int tmp___3 ;
  int iCell ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  aData = pPg->aData;
  hdr = (int )pPg->hdrOffset;
  pBegin = pPg->aCellIdx + nNew * 2;
  nCell = (int )pPg->nCell;
  iOldEnd = (iOld + (int )pPg->nCell) + (int )pPg->nOverflow;
  iNewEnd = iNew + nNew;
  if (iOld < iNew) {
    tmp = pageFreeArray(pPg, iOld, iNew - iOld, pCArray);
    nShift = tmp;
    if (nShift > nCell) {
      tmp___0 = sqlite3CorruptError(70505);
      return (tmp___0);
    }
    memmove((void *)pPg->aCellIdx, (void const   *)(pPg->aCellIdx + nShift * 2), (size_t )(nCell * 2));
    nCell -= nShift;
  }
  if (iNewEnd < iOldEnd) {
    tmp___1 = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);
    nTail = tmp___1;
    nCell -= nTail;
  }
  pData = aData + ((((((int )*((aData + (hdr + 5)) + 0) << 8) | (int )*((aData + (hdr + 5)) + 1)) - 1) & 65535) + 1);
  if ((unsigned long )pData < (unsigned long )pBegin) {
    goto editpage_fail;
  }
  if (iNew < iOld) {
    if (nNew < iOld - iNew) {
      tmp___2 = nNew;
    } else {
      tmp___2 = iOld - iNew;
    }
    nAdd = tmp___2;
    pCellptr = pPg->aCellIdx;
    memmove((void *)(pCellptr + nAdd * 2), (void const   *)pCellptr, (size_t )(nCell * 2));
    tmp___3 = pageInsertArray(pPg, pBegin, & pData, pCellptr, iNew, nAdd, pCArray);
    if (tmp___3) {
      goto editpage_fail;
    }
    nCell += nAdd;
  }
  i = 0;
  while (i < (int )pPg->nOverflow) {
    iCell = (iOld + (int )pPg->aiOvfl[i]) - iNew;
    if (iCell >= 0) {
      if (iCell < nNew) {
        pCellptr = pPg->aCellIdx + iCell * 2;
        if (nCell > iCell) {
          memmove((void *)(pCellptr + 2), (void const   *)pCellptr, (size_t )((nCell - iCell) * 2));
        }
        nCell ++;
        cachedCellSize(pCArray, iCell + iNew);
        tmp___4 = pageInsertArray(pPg, pBegin, & pData, pCellptr, iCell + iNew, 1,
                                  pCArray);
        if (tmp___4) {
          goto editpage_fail;
        }
      }
    }
    i ++;
  }
  pCellptr = pPg->aCellIdx + nCell * 2;
  tmp___5 = pageInsertArray(pPg, pBegin, & pData, pCellptr, iNew + nCell, nNew - nCell,
                            pCArray);
  if (tmp___5) {
    goto editpage_fail;
  }
  pPg->nCell = (u16 )nNew;
  pPg->nOverflow = (u8 )0;
  *((aData + (hdr + 3)) + 0) = (u8 )((int )pPg->nCell >> 8);
  *((aData + (hdr + 3)) + 1) = (u8 )pPg->nCell;
  *((aData + (hdr + 5)) + 0) = (u8 )((pData - aData) >> 8);
  *((aData + (hdr + 5)) + 1) = (u8 )(pData - aData);
  return (0);
  editpage_fail: 
  populateCellCache(pCArray, iNew, nNew);
  tmp___6 = rebuildPage(pCArray, iNew, nNew, pPg);
  return (tmp___6);
}
}
static int balance_quick(MemPage *pParent , MemPage *pPage , u8 *pSpace ) 
{ 
  BtShared *pBt ;
  MemPage *pNew ;
  int rc ;
  Pgno pgnoNew ;
  int tmp ;
  u8 *pOut ;
  u8 *pCell ;
  u16 szCell ;
  u16 tmp___0 ;
  u8 *pStop ;
  CellArray b ;
  short tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 tmp___4 ;
  u8 *tmp___5 ;

  {
  pBt = pPage->pBt;
  if ((int )pPage->nCell == 0) {
    tmp = sqlite3CorruptError(70617);
    return (tmp);
  }
  rc = allocateBtreePage(pBt, & pNew, & pgnoNew, (Pgno )0, (u8 )0);
  if (rc == 0) {
    pOut = pSpace + 4;
    pCell = pPage->apOvfl[0];
    tmp___0 = (*(pPage->xCellSize))(pPage, pCell);
    szCell = tmp___0;
    zeroPage(pNew, 13);
    b.nCell = 1;
    b.pRef = pPage;
    b.apCell = & pCell;
    b.szCell = & szCell;
    b.apEnd[0] = pPage->aDataEnd;
    b.ixNx[0] = 2;
    rc = rebuildPage(& b, 0, 1, pNew);
    if (rc) {
      releasePage(pNew);
      return (rc);
    }
    pNew->nFree = (int )(((pBt->usableSize - (u32 )pNew->cellOffset) - 2U) - (u32 )szCell);
    if (pBt->autoVacuum) {
      ptrmapPut(pBt, pgnoNew, (u8 )5, pParent->pgno, & rc);
      if ((int )szCell > (int )pNew->minLocal) {
        ptrmapPutOvflPtr(pNew, pNew, pCell, & rc);
      }
    }
    tmp___1 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * ((int )pPage->nCell - 1))));
    pCell = pPage->aData + ((int )pPage->maskPage & (int )tmp___1);
    pStop = pCell + 9;
    while (1) {
      tmp___2 = pCell;
      pCell ++;
      if ((int )*tmp___2 & 128) {
        if (! ((unsigned long )pCell < (unsigned long )pStop)) {
          break;
        }
      } else {
        break;
      }
    }
    pStop = pCell + 9;
    while (1) {
      tmp___3 = pOut;
      pOut ++;
      tmp___5 = pCell;
      pCell ++;
      tmp___4 = *tmp___5;
      *tmp___3 = tmp___4;
      if ((int )tmp___4 & 128) {
        if (! ((unsigned long )pCell < (unsigned long )pStop)) {
          break;
        }
      } else {
        break;
      }
    }
    if (rc == 0) {
      insertCell(pParent, (int )pParent->nCell, pSpace, (int )(pOut - pSpace), (u8 *)0,
                 pPage->pgno, & rc);
    }
    sqlite3Put4byte(pParent->aData + ((int )pParent->hdrOffset + 8), pgnoNew);
    releasePage(pNew);
  }
  return (rc);
}
}
static void copyNodeContent(MemPage *pFrom , MemPage *pTo , int *pRC ) 
{ 
  BtShared *pBt ;
  u8 *aFrom ;
  u8 *aTo ;
  int iFromHdr ;
  int iToHdr ;
  int tmp ;
  int rc ;
  int iData ;

  {
  if (*pRC == 0) {
    pBt = pFrom->pBt;
    aFrom = pFrom->aData;
    aTo = pTo->aData;
    iFromHdr = (int )pFrom->hdrOffset;
    if (pTo->pgno == 1U) {
      tmp = 100;
    } else {
      tmp = 0;
    }
    iToHdr = tmp;
    iData = ((int )*((aFrom + (iFromHdr + 5)) + 0) << 8) | (int )*((aFrom + (iFromHdr + 5)) + 1);
    memcpy((void * __restrict  )(aTo + iData), (void const   * __restrict  )(aFrom + iData),
           (size_t )(pBt->usableSize - (u32 )iData));
    memcpy((void * __restrict  )(aTo + iToHdr), (void const   * __restrict  )(aFrom + iFromHdr),
           (size_t )((int )pFrom->cellOffset + 2 * (int )pFrom->nCell));
    pTo->isInit = (u8 )0;
    rc = btreeInitPage(pTo);
    if (rc == 0) {
      rc = btreeComputeFreeSpace(pTo);
    }
    if (rc != 0) {
      *pRC = rc;
      return;
    }
    if (pBt->autoVacuum) {
      *pRC = setChildPtrmaps(pTo);
    }
  }
  return;
}
}
static int balance_nonroot(MemPage *pParent , int iParentIdx , u8 *aOvflSpace , int isRoot ,
                           int bBulk ) 
{ 
  BtShared *pBt ;
  int nMaxCells ;
  int nNew ;
  int nOld ;
  int i ;
  int j ;
  int k ;
  int nxDiv ;
  int rc ;
  u16 leafCorrection ;
  int leafData ;
  int usableSpace ;
  int pageFlags ;
  int iSpace1 ;
  int iOvflSpace ;
  int szScratch ;
  MemPage *apOld[3] ;
  MemPage *apNew[5] ;
  u8 *pRight ;
  u8 *apDiv[2] ;
  int cntNew[5] ;
  int cntOld[5] ;
  int szNew[5] ;
  u8 *aSpace1 ;
  Pgno pgno ;
  u8 abDone[5] ;
  Pgno aPgno[5] ;
  Pgno aPgOrder[5] ;
  u16 aPgFlags[5] ;
  CellArray b ;
  short tmp ;
  int tmp___0 ;
  u16 tmp___1 ;
  short tmp___2 ;
  u16 tmp___3 ;
  int iOff ;
  void *tmp___4 ;
  MemPage *pOld ;
  int limit ;
  u8 *aData ;
  u16 maskPage ;
  u8 *piCell ;
  u8 *piEnd ;
  short tmp___5 ;
  short tmp___6 ;
  u16 sz ;
  u8 *pTemp ;
  int tmp___7 ;
  MemPage *p ;
  u16 tmp___8 ;
  int sz___0 ;
  u16 tmp___9 ;
  u16 tmp___10 ;
  u16 tmp___11 ;
  u16 tmp___12 ;
  int tmp___13 ;
  int szRight ;
  int szLeft ;
  int r ;
  int d ;
  int tmp___14 ;
  int tmp___15 ;
  MemPage *pNew ;
  MemPage *tmp___16 ;
  Pgno tmp___17 ;
  Pgno tmp___18 ;
  int iBest ;
  MemPage *pOld___0 ;
  MemPage **tmp___19 ;
  MemPage *pOld___1 ;
  MemPage *pNew___0 ;
  int cntOldNext ;
  int iNew ;
  int iOld ;
  u8 *pCell ;
  u32 tmp___20 ;
  u16 tmp___21 ;
  u8 *pCell___0 ;
  u8 *pTemp___0 ;
  int sz___1 ;
  MemPage *pNew___1 ;
  CellInfo info ;
  int tmp___22 ;
  u16 tmp___23 ;
  int iPg ;
  int tmp___24 ;
  int iNew___0 ;
  int iOld___0 ;
  int nNewCell ;
  u32 key ;
  u32 tmp___25 ;

  {
  nMaxCells = 0;
  nNew = 0;
  rc = 0;
  iSpace1 = 0;
  iOvflSpace = 0;
  memset((void *)(abDone), 0, sizeof(abDone));
  b.nCell = 0;
  b.apCell = (u8 **)0;
  pBt = pParent->pBt;
  if (! aOvflSpace) {
    return (7);
  }
  i = (int )pParent->nOverflow + (int )pParent->nCell;
  if (i < 2) {
    nxDiv = 0;
  } else {
    if (iParentIdx == 0) {
      nxDiv = 0;
    } else
    if (iParentIdx == i) {
      nxDiv = (i - 2) + bBulk;
    } else {
      nxDiv = iParentIdx - 1;
    }
    i = 2 - bBulk;
  }
  nOld = i + 1;
  if ((i + nxDiv) - (int )pParent->nOverflow == (int )pParent->nCell) {
    pRight = pParent->aData + ((int )pParent->hdrOffset + 8);
  } else {
    tmp = __builtin_bswap16((short )*((u16 *)(pParent->aCellIdx + 2 * ((i + nxDiv) - (int )pParent->nOverflow))));
    pRight = pParent->aData + ((int )pParent->maskPage & (int )tmp);
  }
  pgno = sqlite3Get4byte((u8 const   *)pRight);
  while (1) {
    rc = getAndInitPage(pBt, pgno, & apOld[i], (BtCursor *)0, 0);
    if (rc) {
      memset((void *)(apOld), 0, (unsigned long )(i + 1) * sizeof(MemPage *));
      goto balance_cleanup;
    }
    if ((apOld[i])->nFree < 0) {
      rc = btreeComputeFreeSpace(apOld[i]);
      if (rc) {
        memset((void *)(apOld), 0, (unsigned long )i * sizeof(MemPage *));
        goto balance_cleanup;
      }
    }
    tmp___0 = i;
    i --;
    if (tmp___0 == 0) {
      break;
    }
    if (pParent->nOverflow) {
      if (i + nxDiv == (int )pParent->aiOvfl[0]) {
        apDiv[i] = pParent->apOvfl[0];
        pgno = sqlite3Get4byte((u8 const   *)apDiv[i]);
        tmp___1 = (*(pParent->xCellSize))(pParent, apDiv[i]);
        szNew[i] = (int )tmp___1;
        pParent->nOverflow = (u8 )0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___2 = __builtin_bswap16((short )*((u16 *)(pParent->aCellIdx + 2 * ((i + nxDiv) - (int )pParent->nOverflow))));
      apDiv[i] = pParent->aData + ((int )pParent->maskPage & (int )tmp___2);
      pgno = sqlite3Get4byte((u8 const   *)apDiv[i]);
      tmp___3 = (*(pParent->xCellSize))(pParent, apDiv[i]);
      szNew[i] = (int )tmp___3;
      if ((int )pBt->btsFlags & 12) {
        iOff = (int )((long )apDiv[i]) - (int )((long )pParent->aData);
        if (iOff + szNew[i] > (int )pBt->usableSize) {
          rc = sqlite3CorruptError(70974);
          memset((void *)(apOld), 0, (unsigned long )(i + 1) * sizeof(MemPage *));
          goto balance_cleanup;
        } else {
          memcpy((void * __restrict  )(aOvflSpace + iOff), (void const   * __restrict  )apDiv[i],
                 (size_t )szNew[i]);
          apDiv[i] = aOvflSpace + (apDiv[i] - pParent->aData);
        }
      }
      dropCell(pParent, (i + nxDiv) - (int )pParent->nOverflow, szNew[i], & rc);
    }
  }
  nMaxCells = (int )((u32 )nOld * ((pBt->pageSize - 8U) / 6U + (u32 )((int )(sizeof(pParent->apOvfl) / sizeof(pParent->apOvfl[0])))));
  nMaxCells = (nMaxCells + 3) & -4;
  szScratch = (int )(((unsigned long )nMaxCells * sizeof(u8 *) + (unsigned long )nMaxCells * sizeof(u16 )) + (unsigned long )pBt->pageSize);
  tmp___4 = sqlite3DbMallocRaw((sqlite3 *)0, (u64 )szScratch);
  b.apCell = (u8 **)tmp___4;
  if ((unsigned long )b.apCell == (unsigned long )((u8 **)0)) {
    rc = 7;
    goto balance_cleanup;
  }
  b.szCell = (u16 *)(b.apCell + nMaxCells);
  aSpace1 = (u8 *)(b.szCell + nMaxCells);
  b.pRef = apOld[0];
  leafCorrection = (u16 )((int )(b.pRef)->leaf * 4);
  leafData = (int )(b.pRef)->intKeyLeaf;
  i = 0;
  while (i < nOld) {
    pOld = apOld[i];
    limit = (int )pOld->nCell;
    aData = pOld->aData;
    maskPage = pOld->maskPage;
    piCell = aData + (int )pOld->cellOffset;
    if ((int )*(pOld->aData + 0) != (int )*((apOld[0])->aData + 0)) {
      rc = sqlite3CorruptError(71041);
      goto balance_cleanup;
    }
    memset((void *)(b.szCell + b.nCell), 0, sizeof(*(b.szCell + 0)) * (unsigned long )(limit + (int )pOld->nOverflow));
    if ((int )pOld->nOverflow > 0) {
      if (limit < (int )pOld->aiOvfl[0]) {
        rc = sqlite3CorruptError(71065);
        goto balance_cleanup;
      }
      limit = (int )pOld->aiOvfl[0];
      j = 0;
      while (j < limit) {
        tmp___5 = __builtin_bswap16((short )*((u16 *)piCell));
        *(b.apCell + b.nCell) = aData + ((int )maskPage & (int )tmp___5);
        piCell += 2;
        (b.nCell) ++;
        j ++;
      }
      k = 0;
      while (k < (int )pOld->nOverflow) {
        *(b.apCell + b.nCell) = pOld->apOvfl[k];
        (b.nCell) ++;
        k ++;
      }
    }
    piEnd = (aData + (int )pOld->cellOffset) + 2 * (int )pOld->nCell;
    while ((unsigned long )piCell < (unsigned long )piEnd) {
      tmp___6 = __builtin_bswap16((short )*((u16 *)piCell));
      *(b.apCell + b.nCell) = aData + ((int )maskPage & (int )tmp___6);
      piCell += 2;
      (b.nCell) ++;
    }
    cntOld[i] = b.nCell;
    if (i < nOld - 1) {
      if (! leafData) {
        sz = (u16 )szNew[i];
        *(b.szCell + b.nCell) = sz;
        pTemp = aSpace1 + iSpace1;
        iSpace1 += (int )sz;
        memcpy((void * __restrict  )pTemp, (void const   * __restrict  )apDiv[i],
               (size_t )sz);
        *(b.apCell + b.nCell) = pTemp + (int )leafCorrection;
        *(b.szCell + b.nCell) = (u16 )((int )*(b.szCell + b.nCell) - (int )leafCorrection);
        if (! pOld->leaf) {
          memcpy((void * __restrict  )*(b.apCell + b.nCell), (void const   * __restrict  )(pOld->aData + 8),
                 (size_t )4);
        } else {
          while ((int )*(b.szCell + b.nCell) < 4) {
            tmp___7 = iSpace1;
            iSpace1 ++;
            *(aSpace1 + tmp___7) = (u8 )0;
            *(b.szCell + b.nCell) = (u16 )((int )*(b.szCell + b.nCell) + 1);
          }
        }
        (b.nCell) ++;
      }
    }
    i ++;
  }
  usableSpace = (int )((pBt->usableSize - 12U) + (u32 )leafCorrection);
  k = 0;
  i = k;
  while (i < nOld) {
    p = apOld[i];
    b.apEnd[k] = p->aDataEnd;
    b.ixNx[k] = cntOld[i];
    if (k) {
      if (b.ixNx[k] == b.ixNx[k - 1]) {
        k --;
      }
    }
    if (! leafData) {
      k ++;
      b.apEnd[k] = pParent->aDataEnd;
      b.ixNx[k] = cntOld[i] + 1;
    }
    szNew[i] = usableSpace - p->nFree;
    j = 0;
    while (j < (int )p->nOverflow) {
      tmp___8 = (*(p->xCellSize))(p, p->apOvfl[j]);
      szNew[i] += 2 + (int )tmp___8;
      j ++;
    }
    cntNew[i] = cntOld[i];
    i ++;
    k ++;
  }
  k = nOld;
  i = 0;
  while (i < k) {
    while (szNew[i] > usableSpace) {
      if (i + 1 >= k) {
        k = i + 2;
        if (k > 5) {
          rc = sqlite3CorruptError(71166);
          goto balance_cleanup;
        }
        szNew[k - 1] = 0;
        cntNew[k - 1] = b.nCell;
      }
      tmp___9 = cachedCellSize(& b, cntNew[i] - 1);
      sz___0 = 2 + (int )tmp___9;
      szNew[i] -= sz___0;
      if (! leafData) {
        if (cntNew[i] < b.nCell) {
          tmp___10 = cachedCellSize(& b, cntNew[i]);
          sz___0 = 2 + (int )tmp___10;
        } else {
          sz___0 = 0;
        }
      }
      szNew[i + 1] += sz___0;
      (cntNew[i]) --;
    }
    while (cntNew[i] < b.nCell) {
      tmp___11 = cachedCellSize(& b, cntNew[i]);
      sz___0 = 2 + (int )tmp___11;
      if (szNew[i] + sz___0 > usableSpace) {
        break;
      }
      szNew[i] += sz___0;
      (cntNew[i]) ++;
      if (! leafData) {
        if (cntNew[i] < b.nCell) {
          tmp___12 = cachedCellSize(& b, cntNew[i]);
          sz___0 = 2 + (int )tmp___12;
        } else {
          sz___0 = 0;
        }
      }
      szNew[i + 1] -= sz___0;
    }
    if (cntNew[i] >= b.nCell) {
      k = i + 1;
    } else {
      if (i > 0) {
        tmp___13 = cntNew[i - 1];
      } else {
        tmp___13 = 0;
      }
      if (cntNew[i] <= tmp___13) {
        rc = sqlite3CorruptError(71199);
        goto balance_cleanup;
      }
    }
    i ++;
  }
  i = k - 1;
  while (i > 0) {
    szRight = szNew[i];
    szLeft = szNew[i - 1];
    r = cntNew[i - 1] - 1;
    d = (r + 1) - leafData;
    cachedCellSize(& b, d);
    while (1) {
      cachedCellSize(& b, r);
      if (szRight != 0) {
        if (bBulk) {
          break;
        } else {
          if (i == k - 1) {
            tmp___14 = 0;
          } else {
            tmp___14 = 2;
          }
          if ((szRight + (int )*(b.szCell + d)) + 2 > szLeft - ((int )*(b.szCell + r) + tmp___14)) {
            break;
          }
        }
      }
      szRight += (int )*(b.szCell + d) + 2;
      szLeft -= (int )*(b.szCell + r) + 2;
      cntNew[i - 1] = r;
      r --;
      d --;
      if (! (r >= 0)) {
        break;
      }
    }
    szNew[i] = szRight;
    szNew[i - 1] = szLeft;
    if (i > 1) {
      tmp___15 = cntNew[i - 2];
    } else {
      tmp___15 = 0;
    }
    if (cntNew[i - 1] <= tmp___15) {
      rc = sqlite3CorruptError(71241);
      goto balance_cleanup;
    }
    i --;
  }
  pageFlags = (int )*((apOld[0])->aData + 0);
  i = 0;
  while (i < k) {
    if (i < nOld) {
      tmp___16 = apOld[i];
      apNew[i] = tmp___16;
      pNew = tmp___16;
      apOld[i] = (MemPage *)0;
      rc = sqlite3PagerWrite(pNew->pDbPage);
      nNew ++;
      if (rc) {
        goto balance_cleanup;
      }
    } else {
      if (bBulk) {
        tmp___17 = (Pgno )1;
      } else {
        tmp___17 = pgno;
      }
      rc = allocateBtreePage(pBt, & pNew, & pgno, tmp___17, (u8 )0);
      if (rc) {
        goto balance_cleanup;
      }
      zeroPage(pNew, pageFlags);
      apNew[i] = pNew;
      nNew ++;
      cntOld[i] = b.nCell;
      if (pBt->autoVacuum) {
        ptrmapPut(pBt, pNew->pgno, (u8 )5, pParent->pgno, & rc);
        if (rc != 0) {
          goto balance_cleanup;
        }
      }
    }
    i ++;
  }
  i = 0;
  while (i < nNew) {
    tmp___18 = (apNew[i])->pgno;
    aPgno[i] = tmp___18;
    aPgOrder[i] = tmp___18;
    aPgFlags[i] = ((apNew[i])->pDbPage)->flags;
    j = 0;
    while (j < i) {
      if (aPgno[j] == aPgno[i]) {
        rc = sqlite3CorruptError(71315);
        goto balance_cleanup;
      }
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < nNew) {
    iBest = 0;
    j = 1;
    while (j < nNew) {
      if (aPgOrder[j] < aPgOrder[iBest]) {
        iBest = j;
      }
      j ++;
    }
    pgno = aPgOrder[iBest];
    aPgOrder[iBest] = 4294967295U;
    if (iBest != i) {
      if (iBest > i) {
        sqlite3PagerRekey((apNew[iBest])->pDbPage, (pBt->nPage + (u32 )iBest) + 1U,
                          (u16 )0);
      }
      sqlite3PagerRekey((apNew[i])->pDbPage, pgno, aPgFlags[iBest]);
      (apNew[i])->pgno = pgno;
    }
    i ++;
  }
  sqlite3Put4byte(pRight, (apNew[nNew - 1])->pgno);
  if ((pageFlags & 8) == 0) {
    if (nOld != nNew) {
      if (nNew > nOld) {
        tmp___19 = apNew;
      } else {
        tmp___19 = apOld;
      }
      pOld___0 = *(tmp___19 + (nOld - 1));
      memcpy((void * __restrict  )((apNew[nNew - 1])->aData + 8), (void const   * __restrict  )(pOld___0->aData + 8),
             (size_t )4);
    }
  }
  if (pBt->autoVacuum) {
    pOld___1 = apNew[0];
    pNew___0 = pOld___1;
    cntOldNext = (int )pNew___0->nCell + (int )pNew___0->nOverflow;
    iNew = 0;
    iOld = 0;
    i = 0;
    while (i < b.nCell) {
      pCell = *(b.apCell + i);
      while (i == cntOldNext) {
        iOld ++;
        if (iOld < nNew) {
          pOld___1 = apNew[iOld];
        } else {
          pOld___1 = apOld[iOld];
        }
        cntOldNext += ((int )pOld___1->nCell + (int )pOld___1->nOverflow) + ! leafData;
      }
      if (i == cntNew[iNew]) {
        iNew ++;
        pNew___0 = apNew[iNew];
        if (! leafData) {
          goto __Cont;
        }
      }
      if (iOld >= nNew) {
        goto _L___1;
      } else
      if (pNew___0->pgno != aPgno[iOld]) {
        goto _L___1;
      } else
      if ((uptr )pCell >= (uptr )pOld___1->aData) {
        if (! ((uptr )pCell < (uptr )pOld___1->aDataEnd)) {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (! leafCorrection) {
          tmp___20 = sqlite3Get4byte((u8 const   *)pCell);
          ptrmapPut(pBt, tmp___20, (u8 )5, pNew___0->pgno, & rc);
        }
        tmp___21 = cachedCellSize(& b, i);
        if ((int )tmp___21 > (int )pNew___0->minLocal) {
          ptrmapPutOvflPtr(pNew___0, pOld___1, pCell, & rc);
        }
        if (rc) {
          goto balance_cleanup;
        }
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
  }
  i = 0;
  while (i < nNew - 1) {
    pNew___1 = apNew[i];
    j = cntNew[i];
    pCell___0 = *(b.apCell + j);
    sz___1 = (int )*(b.szCell + j) + (int )leafCorrection;
    pTemp___0 = aOvflSpace + iOvflSpace;
    if (! pNew___1->leaf) {
      memcpy((void * __restrict  )(pNew___1->aData + 8), (void const   * __restrict  )pCell___0,
             (size_t )4);
    } else
    if (leafData) {
      j --;
      (*(pNew___1->xParseCell))(pNew___1, *(b.apCell + j), & info);
      pCell___0 = pTemp___0;
      tmp___22 = sqlite3PutVarint(pCell___0 + 4, (u64 )info.nKey);
      sz___1 = 4 + tmp___22;
      pTemp___0 = (u8 *)0;
    } else {
      pCell___0 -= 4;
      if ((int )*(b.szCell + j) == 4) {
        tmp___23 = (*(pParent->xCellSize))(pParent, pCell___0);
        sz___1 = (int )tmp___23;
      }
    }
    iOvflSpace += sz___1;
    insertCell(pParent, nxDiv + i, pCell___0, sz___1, pTemp___0, pNew___1->pgno, & rc);
    if (rc != 0) {
      goto balance_cleanup;
    }
    i ++;
  }
  i = 1 - nNew;
  while (i < nNew) {
    if (i < 0) {
      tmp___24 = - i;
    } else {
      tmp___24 = i;
    }
    iPg = tmp___24;
    if (abDone[iPg]) {
      goto __Cont___0;
    }
    if (i >= 0) {
      goto _L___2;
    } else
    if (cntOld[iPg - 1] >= cntNew[iPg - 1]) {
      _L___2: /* CIL Label */ 
      if (iPg == 0) {
        iOld___0 = 0;
        iNew___0 = iOld___0;
        nNewCell = cntNew[0];
      } else {
        if (iPg < nOld) {
          iOld___0 = cntOld[iPg - 1] + ! leafData;
        } else {
          iOld___0 = b.nCell;
        }
        iNew___0 = cntNew[iPg - 1] + ! leafData;
        nNewCell = cntNew[iPg] - iNew___0;
      }
      rc = editPage(apNew[iPg], iOld___0, iNew___0, nNewCell, & b);
      if (rc) {
        goto balance_cleanup;
      }
      abDone[iPg] = (u8 )((int )abDone[iPg] + 1);
      (apNew[iPg])->nFree = usableSpace - szNew[iPg];
    }
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  if (isRoot) {
    if ((int )pParent->nCell == 0) {
      if ((int )pParent->hdrOffset <= (apNew[0])->nFree) {
        rc = defragmentPage(apNew[0], -1);
        copyNodeContent(apNew[0], pParent, & rc);
        freePage(apNew[0], & rc);
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if (pBt->autoVacuum) {
    if (! leafCorrection) {
      i = 0;
      while (i < nNew) {
        tmp___25 = sqlite3Get4byte((u8 const   *)((apNew[i])->aData + 8));
        key = tmp___25;
        ptrmapPut(pBt, key, (u8 )5, (apNew[i])->pgno, & rc);
        i ++;
      }
    }
  }
  i = nNew;
  while (i < nOld) {
    freePage(apOld[i], & rc);
    i ++;
  }
  balance_cleanup: 
  sqlite3DbFree((sqlite3 *)0, (void *)b.apCell);
  i = 0;
  while (i < nOld) {
    releasePage(apOld[i]);
    i ++;
  }
  i = 0;
  while (i < nNew) {
    releasePage(apNew[i]);
    i ++;
  }
  return (rc);
}
}
static int balance_deeper(MemPage *pRoot , MemPage **ppChild ) 
{ 
  int rc ;
  MemPage *pChild ;
  Pgno pgnoChild ;
  BtShared *pBt ;

  {
  pChild = (MemPage *)0;
  pgnoChild = (Pgno )0;
  pBt = pRoot->pBt;
  rc = sqlite3PagerWrite(pRoot->pDbPage);
  if (rc == 0) {
    rc = allocateBtreePage(pBt, & pChild, & pgnoChild, pRoot->pgno, (u8 )0);
    copyNodeContent(pRoot, pChild, & rc);
    if (pBt->autoVacuum) {
      ptrmapPut(pBt, pgnoChild, (u8 )5, pRoot->pgno, & rc);
    }
  }
  if (rc) {
    *ppChild = (MemPage *)0;
    releasePage(pChild);
    return (rc);
  }
  memcpy((void * __restrict  )(pChild->aiOvfl), (void const   * __restrict  )(pRoot->aiOvfl),
         (unsigned long )pRoot->nOverflow * sizeof(pRoot->aiOvfl[0]));
  memcpy((void * __restrict  )(pChild->apOvfl), (void const   * __restrict  )(pRoot->apOvfl),
         (unsigned long )pRoot->nOverflow * sizeof(pRoot->apOvfl[0]));
  pChild->nOverflow = pRoot->nOverflow;
  zeroPage(pRoot, (int )*(pChild->aData + 0) & -9);
  sqlite3Put4byte(pRoot->aData + ((int )pRoot->hdrOffset + 8), pgnoChild);
  *ppChild = pChild;
  return (0);
}
}
static int balance(BtCursor *pCur ) 
{ 
  int rc ;
  int nMin ;
  u8 aBalanceQuickSpace[13] ;
  u8 *pFree ;
  int iPage ;
  MemPage *pPage ;
  int tmp ;
  MemPage *pParent ;
  int iIdx ;
  u8 *pSpace ;
  void *tmp___0 ;

  {
  rc = 0;
  nMin = (int )(((pCur->pBt)->usableSize * 2U) / 3U);
  pFree = (u8 *)0;
  while (1) {
    pPage = pCur->pPage;
    if (pPage->nFree < 0) {
      tmp = btreeComputeFreeSpace(pPage);
      if (tmp) {
        break;
      }
    }
    if ((int )pPage->nOverflow == 0) {
      if (pPage->nFree <= nMin) {
        break;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      iPage = (int )pCur->iPage;
      if (iPage == 0) {
        if (pPage->nOverflow) {
          rc = balance_deeper(pPage, & pCur->apPage[1]);
          if (rc == 0) {
            pCur->iPage = (i8 )1;
            pCur->ix = (u16 )0;
            pCur->aiIdx[0] = (u16 )0;
            pCur->apPage[0] = pPage;
            pCur->pPage = pCur->apPage[1];
          }
        } else {
          break;
        }
      } else {
        pParent = pCur->apPage[iPage - 1];
        iIdx = (int )pCur->aiIdx[iPage - 1];
        rc = sqlite3PagerWrite(pParent->pDbPage);
        if (rc == 0) {
          if (pParent->nFree < 0) {
            rc = btreeComputeFreeSpace(pParent);
          }
        }
        if (rc == 0) {
          if (pPage->intKeyLeaf) {
            if ((int )pPage->nOverflow == 1) {
              if ((int )pPage->aiOvfl[0] == (int )pPage->nCell) {
                if (pParent->pgno != 1U) {
                  if ((int )pParent->nCell == iIdx) {
                    rc = balance_quick(pParent, pPage, aBalanceQuickSpace);
                  } else {
                    goto _L___2;
                  }
                } else {
                  goto _L___2;
                }
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            tmp___0 = sqlite3PageMalloc((int )(pCur->pBt)->pageSize);
            pSpace = (u8 *)tmp___0;
            rc = balance_nonroot(pParent, iIdx, pSpace, iPage == 1, (int )pCur->hints & 1);
            if (pFree) {
              sqlite3PageFree((void *)pFree);
            }
            pFree = pSpace;
          }
        }
        pPage->nOverflow = (u8 )0;
        releasePage(pPage);
        pCur->iPage = (i8 )((int )pCur->iPage - 1);
        pCur->pPage = pCur->apPage[pCur->iPage];
      }
    }
    if (! (rc == 0)) {
      break;
    }
  }
  if (pFree) {
    sqlite3PageFree((void *)pFree);
  }
  return (rc);
}
}
static int btreeOverwriteContent(MemPage *pPage , u8 *pDest , BtreePayload const   *pX ,
                                 int iOffset___0 , int iAmt ) 
{ 
  int nData ;
  int i ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int rc___1 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  nData = (int )(pX->nData - (int const   )iOffset___0);
  if (nData <= 0) {
    i = 0;
    while (1) {
      if (i < iAmt) {
        if (! ((int )*(pDest + i) == 0)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if (i < iAmt) {
      tmp = sqlite3PagerWrite(pPage->pDbPage);
      rc = tmp;
      if (rc) {
        return (rc);
      }
      memset((void *)(pDest + i), 0, (size_t )(iAmt - i));
    }
  } else {
    if (nData < iAmt) {
      tmp___0 = btreeOverwriteContent(pPage, pDest + nData, pX, iOffset___0 + nData,
                                      iAmt - nData);
      rc___0 = tmp___0;
      if (rc___0) {
        return (rc___0);
      }
      iAmt = nData;
    }
    tmp___2 = memcmp((void const   *)pDest, (void const   *)((u8 *)pX->pData + iOffset___0),
                     (size_t )iAmt);
    if (tmp___2 != 0) {
      tmp___1 = sqlite3PagerWrite(pPage->pDbPage);
      rc___1 = tmp___1;
      if (rc___1) {
        return (rc___1);
      }
      memmove((void *)pDest, (void const   *)((u8 *)pX->pData + iOffset___0), (size_t )iAmt);
    }
  }
  return (0);
}
}
static int btreeOverwriteCell(BtCursor *pCur , BtreePayload const   *pX ) 
{ 
  int iOffset___0 ;
  int nTotal ;
  int rc ;
  MemPage *pPage ;
  BtShared *pBt ;
  Pgno ovflPgno ;
  u32 ovflPageSize ;
  int tmp ;
  int tmp___0 ;

  {
  nTotal = (int )(pX->nData + pX->nZero);
  pPage = pCur->pPage;
  if ((unsigned long )(pCur->info.pPayload + (int )pCur->info.nLocal) > (unsigned long )pPage->aDataEnd) {
    tmp = sqlite3CorruptError(71868);
    return (tmp);
  } else
  if ((unsigned long )pCur->info.pPayload < (unsigned long )(pPage->aData + (int )pPage->cellOffset)) {
    tmp = sqlite3CorruptError(71868);
    return (tmp);
  }
  rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX, 0, (int )pCur->info.nLocal);
  if (rc) {
    return (rc);
  }
  if ((int )pCur->info.nLocal == nTotal) {
    return (0);
  }
  iOffset___0 = (int )pCur->info.nLocal;
  ovflPgno = sqlite3Get4byte((u8 const   *)(pCur->info.pPayload + iOffset___0));
  pBt = pPage->pBt;
  ovflPageSize = pBt->usableSize - 4U;
  while (1) {
    rc = btreeGetPage(pBt, ovflPgno, & pPage, 0);
    if (rc) {
      return (rc);
    }
    tmp___0 = sqlite3PagerPageRefcount(pPage->pDbPage);
    if (tmp___0 != 1) {
      rc = sqlite3CorruptError(71887);
    } else {
      if ((u32 )iOffset___0 + ovflPageSize < (u32 )nTotal) {
        ovflPgno = sqlite3Get4byte((u8 const   *)pPage->aData);
      } else {
        ovflPageSize = (u32 )(nTotal - iOffset___0);
      }
      rc = btreeOverwriteContent(pPage, pPage->aData + 4, pX, iOffset___0, (int )ovflPageSize);
    }
    sqlite3PagerUnref(pPage->pDbPage);
    if (rc) {
      return (rc);
    }
    iOffset___0 = (int )((u32 )iOffset___0 + ovflPageSize);
    if (! (iOffset___0 < nTotal)) {
      break;
    }
  }
  return (0);
}
}
static int sqlite3BtreeInsert(BtCursor *pCur , BtreePayload const   *pX , int flags___0 ,
                              int seekResult ) 
{ 
  int rc ;
  int loc ;
  int szNew ;
  int idx ;
  MemPage *pPage ;
  Btree *p ;
  BtShared *pBt ;
  unsigned char *oldCell ;
  unsigned char *newCell ;
  int tmp ;
  UnpackedRecord r ;
  BtreePayload x2 ;
  int tmp___0 ;
  CellInfo info ;
  short tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  loc = seekResult;
  szNew = 0;
  p = pCur->pBtree;
  pBt = p->pBt;
  newCell = (unsigned char *)0;
  if ((int )pCur->eState == 4) {
    return (pCur->skipNext);
  }
  if ((int )pCur->curFlags & 32) {
    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
    if (rc) {
      return (rc);
    }
  }
  if ((unsigned long )pCur->pKeyInfo == (unsigned long )((struct KeyInfo *)0)) {
    invalidateIncrblobCursors(p, pCur->pgnoRoot, (i64 )pX->nKey, 0);
    if (((int )pCur->curFlags & 2) != 0) {
      if (pX->nKey == (sqlite_int64 const   )pCur->info.nKey) {
        if ((int )pCur->info.nSize != 0) {
          if (pCur->info.nPayload == (u32 )pX->nData + (u32 )pX->nZero) {
            tmp = btreeOverwriteCell(pCur, pX);
            return (tmp);
          }
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (loc == 0) {
      rc = sqlite3BtreeMovetoUnpacked(pCur, (UnpackedRecord *)0, (i64 )pX->nKey, flags___0 != 0,
                                      & loc);
      if (rc) {
        return (rc);
      }
    }
  } else {
    if (loc == 0) {
      if ((flags___0 & 2) == 0) {
        if (pX->nMem) {
          r.pKeyInfo = pCur->pKeyInfo;
          r.aMem = (Mem *)pX->aMem;
          r.nField = (u16 )pX->nMem;
          r.default_rc = (i8 )0;
          r.errCode = (u8 )0;
          r.r1 = (i8 )0;
          r.r2 = (i8 )0;
          r.eqSeen = (u8 )0;
          rc = sqlite3BtreeMovetoUnpacked(pCur, & r, (i64 )0, flags___0 != 0, & loc);
        } else {
          rc = btreeMoveto(pCur, (void const   *)pX->pKey, (i64 )pX->nKey, flags___0 != 0,
                           & loc);
        }
        if (rc) {
          return (rc);
        }
      }
    }
    if (loc == 0) {
      getCellInfo(pCur);
      if (pCur->info.nKey == (i64 )pX->nKey) {
        x2.pData = (void const   *)pX->pKey;
        x2.nData = (int )pX->nKey;
        x2.nZero = 0;
        tmp___0 = btreeOverwriteCell(pCur, (BtreePayload const   *)(& x2));
        return (tmp___0);
      }
    }
  }
  pPage = pCur->pPage;
  if (pPage->nFree < 0) {
    rc = btreeComputeFreeSpace(pPage);
    if (rc) {
      return (rc);
    }
  }
  newCell = pBt->pTmpSpace;
  rc = fillInCell(pPage, newCell, pX, & szNew);
  if (rc) {
    goto end_insert;
  }
  idx = (int )pCur->ix;
  if (loc == 0) {
    rc = sqlite3PagerWrite(pPage->pDbPage);
    if (rc) {
      goto end_insert;
    }
    tmp___1 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * idx)));
    oldCell = pPage->aData + ((int )pPage->maskPage & (int )tmp___1);
    if (! pPage->leaf) {
      memcpy((void * __restrict  )newCell, (void const   * __restrict  )oldCell, (size_t )4);
    }
    rc = clearCell(pPage, oldCell, & info);
    pCur->curFlags = (u8 )((int )pCur->curFlags & -5);
    if ((int )info.nSize == szNew) {
      if ((u32 )info.nLocal == info.nPayload) {
        if (! pBt->autoVacuum) {
          goto _L___0;
        } else
        if (szNew < (int )pPage->minLocal) {
          _L___0: /* CIL Label */ 
          if ((unsigned long )oldCell < (unsigned long )((pPage->aData + (int )pPage->hdrOffset) + 10)) {
            tmp___2 = sqlite3CorruptError(72124);
            return (tmp___2);
          }
          if ((unsigned long )(oldCell + szNew) > (unsigned long )pPage->aDataEnd) {
            tmp___3 = sqlite3CorruptError(72127);
            return (tmp___3);
          }
          memcpy((void * __restrict  )oldCell, (void const   * __restrict  )newCell,
                 (size_t )szNew);
          return (0);
        }
      }
    }
    dropCell(pPage, idx, (int )info.nSize, & rc);
    if (rc) {
      goto end_insert;
    }
  } else
  if (loc < 0) {
    if ((int )pPage->nCell > 0) {
      pCur->ix = (u16 )((int )pCur->ix + 1);
      idx = (int )pCur->ix;
      pCur->curFlags = (u8 )((int )pCur->curFlags & -3);
    }
  }
  insertCell(pPage, idx, newCell, szNew, (u8 *)0, (Pgno )0, & rc);
  pCur->info.nSize = (u16 )0;
  if (pPage->nOverflow) {
    pCur->curFlags = (u8 )((int )pCur->curFlags & -3);
    rc = balance(pCur);
    (pCur->pPage)->nOverflow = (u8 )0;
    pCur->eState = (u8 )1;
    if (flags___0 & 2) {
      if (rc == 0) {
        btreeReleaseAllCursorPages(pCur);
        if (pCur->pKeyInfo) {
          pCur->pKey = sqlite3Malloc((u64 )pX->nKey);
          if ((unsigned long )pCur->pKey == (unsigned long )((void *)0)) {
            rc = 7;
          } else {
            memcpy((void * __restrict  )pCur->pKey, (void const   * __restrict  )pX->pKey,
                   (size_t )pX->nKey);
          }
        }
        pCur->eState = (u8 )3;
        pCur->nKey = (i64 )pX->nKey;
      }
    }
  }
  end_insert: 
  return (rc);
}
}
static int sqlite3BtreeDelete(BtCursor *pCur , u8 flags___0 ) 
{ 
  Btree *p ;
  BtShared *pBt ;
  int rc ;
  MemPage *pPage ;
  unsigned char *pCell ;
  int iCellIdx ;
  int iCellDepth ;
  CellInfo info ;
  int bSkipnext ;
  u8 bPreserve ;
  short tmp ;
  int tmp___0 ;
  u16 tmp___1 ;
  MemPage *pLeaf ;
  int nCell ;
  Pgno n ;
  unsigned char *pTmp ;
  short tmp___2 ;
  int tmp___3 ;
  u16 tmp___4 ;
  i8 tmp___5 ;

  {
  p = pCur->pBtree;
  pBt = p->pBt;
  bSkipnext = 0;
  bPreserve = (u8 )((int )flags___0 & 2);
  if ((int )pCur->eState == 3) {
    rc = btreeRestoreCursorPosition(pCur);
    if (rc) {
      return (rc);
    }
  }
  iCellDepth = (int )pCur->iPage;
  iCellIdx = (int )pCur->ix;
  pPage = pCur->pPage;
  tmp = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * iCellIdx)));
  pCell = pPage->aData + ((int )pPage->maskPage & (int )tmp);
  if (pPage->nFree < 0) {
    tmp___0 = btreeComputeFreeSpace(pPage);
    if (tmp___0) {
      return (11);
    }
  }
  if (bPreserve) {
    if (! pPage->leaf) {
      goto _L;
    } else {
      tmp___1 = cellSizePtr(pPage, pCell);
      if ((pPage->nFree + (int )tmp___1) + 2 > (int )((pBt->usableSize * 2U) / 3U)) {
        goto _L;
      } else
      if ((int )pPage->nCell == 1) {
        _L: /* CIL Label */ 
        rc = saveCursorKey(pCur);
        if (rc) {
          return (rc);
        }
      } else {
        bSkipnext = 1;
      }
    }
  }
  if (! pPage->leaf) {
    rc = sqlite3BtreePrevious(pCur, 0);
    if (rc) {
      return (rc);
    }
  }
  if ((int )pCur->curFlags & 32) {
    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
    if (rc) {
      return (rc);
    }
  }
  if ((unsigned long )pCur->pKeyInfo == (unsigned long )((struct KeyInfo *)0)) {
    invalidateIncrblobCursors(p, pCur->pgnoRoot, pCur->info.nKey, 0);
  }
  rc = sqlite3PagerWrite(pPage->pDbPage);
  if (rc) {
    return (rc);
  }
  rc = clearCell(pPage, pCell, & info);
  dropCell(pPage, iCellIdx, (int )info.nSize, & rc);
  if (rc) {
    return (rc);
  }
  if (! pPage->leaf) {
    pLeaf = pCur->pPage;
    if (pLeaf->nFree < 0) {
      rc = btreeComputeFreeSpace(pLeaf);
      if (rc) {
        return (rc);
      }
    }
    if (iCellDepth < (int )pCur->iPage - 1) {
      n = (pCur->apPage[iCellDepth + 1])->pgno;
    } else {
      n = (pCur->pPage)->pgno;
    }
    tmp___2 = __builtin_bswap16((short )*((u16 *)(pLeaf->aCellIdx + 2 * ((int )pLeaf->nCell - 1))));
    pCell = pLeaf->aData + ((int )pLeaf->maskPage & (int )tmp___2);
    if ((unsigned long )pCell < (unsigned long )(pLeaf->aData + 4)) {
      tmp___3 = sqlite3CorruptError(72325);
      return (tmp___3);
    }
    tmp___4 = (*(pLeaf->xCellSize))(pLeaf, pCell);
    nCell = (int )tmp___4;
    pTmp = pBt->pTmpSpace;
    rc = sqlite3PagerWrite(pLeaf->pDbPage);
    if (rc == 0) {
      insertCell(pPage, iCellIdx, pCell - 4, nCell + 4, pTmp, n, & rc);
    }
    dropCell(pLeaf, (int )pLeaf->nCell - 1, nCell, & rc);
    if (rc) {
      return (rc);
    }
  }
  rc = balance(pCur);
  if (rc == 0) {
    if ((int )pCur->iPage > iCellDepth) {
      releasePageNotNull(pCur->pPage);
      pCur->iPage = (i8 )((int )pCur->iPage - 1);
      while ((int )pCur->iPage > iCellDepth) {
        tmp___5 = pCur->iPage;
        pCur->iPage = (i8 )((int )pCur->iPage - 1);
        releasePage(pCur->apPage[tmp___5]);
      }
      pCur->pPage = pCur->apPage[pCur->iPage];
      rc = balance(pCur);
    }
  }
  if (rc == 0) {
    if (bSkipnext) {
      pCur->eState = (u8 )2;
      if (iCellIdx >= (int )pPage->nCell) {
        pCur->skipNext = -1;
        pCur->ix = (u16 )((int )pPage->nCell - 1);
      } else {
        pCur->skipNext = 1;
      }
    } else {
      rc = moveToRoot(pCur);
      if (bPreserve) {
        btreeReleaseAllCursorPages(pCur);
        pCur->eState = (u8 )3;
      }
      if (rc == 16) {
        rc = 0;
      }
    }
  }
  return (rc);
}
}
static int btreeCreateTable(Btree *p , int *piTable , int createTabFlags ) 
{ 
  BtShared *pBt ;
  MemPage *pRoot ;
  Pgno pgnoRoot ;
  int rc ;
  int ptfFlags ;
  Pgno pgnoMove ;
  MemPage *pPageMove ;
  Pgno tmp ;
  u8 eType ;
  Pgno iPtrPage ;

  {
  pBt = p->pBt;
  if (pBt->autoVacuum) {
    invalidateAllOverflowCache(pBt);
    sqlite3BtreeGetMeta(p, 4, & pgnoRoot);
    pgnoRoot ++;
    while (1) {
      tmp = ptrmapPageno(pBt, pgnoRoot);
      if (! (pgnoRoot == tmp)) {
        if (! (pgnoRoot == (u32 )sqlite3PendingByte / pBt->pageSize + 1U)) {
          break;
        }
      }
      pgnoRoot ++;
    }
    rc = allocateBtreePage(pBt, & pPageMove, & pgnoMove, pgnoRoot, (u8 )1);
    if (rc != 0) {
      return (rc);
    }
    if (pgnoMove != pgnoRoot) {
      eType = (u8 )0;
      iPtrPage = (Pgno )0;
      rc = saveAllCursors(pBt, (Pgno )0, (BtCursor *)0);
      releasePage(pPageMove);
      if (rc != 0) {
        return (rc);
      }
      rc = btreeGetPage(pBt, pgnoRoot, & pRoot, 0);
      if (rc != 0) {
        return (rc);
      }
      rc = ptrmapGet(pBt, pgnoRoot, & eType, & iPtrPage);
      if ((int )eType == 1) {
        rc = sqlite3CorruptError(72479);
      } else
      if ((int )eType == 2) {
        rc = sqlite3CorruptError(72479);
      }
      if (rc != 0) {
        releasePage(pRoot);
        return (rc);
      }
      rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
      releasePage(pRoot);
      if (rc != 0) {
        return (rc);
      }
      rc = btreeGetPage(pBt, pgnoRoot, & pRoot, 0);
      if (rc != 0) {
        return (rc);
      }
      rc = sqlite3PagerWrite(pRoot->pDbPage);
      if (rc != 0) {
        releasePage(pRoot);
        return (rc);
      }
    } else {
      pRoot = pPageMove;
    }
    ptrmapPut(pBt, pgnoRoot, (u8 )1, (Pgno )0, & rc);
    if (rc) {
      releasePage(pRoot);
      return (rc);
    }
    rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);
    if (rc) {
      releasePage(pRoot);
      return (rc);
    }
  } else {
    rc = allocateBtreePage(pBt, & pRoot, & pgnoRoot, (Pgno )1, (u8 )0);
    if (rc) {
      return (rc);
    }
  }
  if (createTabFlags & 1) {
    ptfFlags = 13;
  } else {
    ptfFlags = 10;
  }
  zeroPage(pRoot, ptfFlags);
  sqlite3PagerUnref(pRoot->pDbPage);
  *piTable = (int )pgnoRoot;
  return (0);
}
}
static int sqlite3BtreeCreateTable(Btree *p , int *piTable , int flags___0 ) 
{ 
  int rc ;

  {
  sqlite3BtreeEnter(p);
  rc = btreeCreateTable(p, piTable, flags___0);
  return (rc);
}
}
static int clearDatabasePage(BtShared *pBt , Pgno pgno , int freePageFlag , int *pnChange ) 
{ 
  MemPage *pPage ;
  int rc ;
  unsigned char *pCell ;
  int i ;
  int hdr ;
  CellInfo info ;
  int tmp ;
  Pgno tmp___0 ;
  short tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
  tmp___0 = btreePagecount(pBt);
  if (pgno > tmp___0) {
    tmp = sqlite3CorruptError(72569);
    return (tmp);
  }
  rc = getAndInitPage(pBt, pgno, & pPage, (BtCursor *)0, 0);
  if (rc) {
    return (rc);
  }
  if (pPage->bBusy) {
    rc = sqlite3CorruptError(72574);
    goto cleardatabasepage_out;
  }
  pPage->bBusy = (u8 )1;
  hdr = (int )pPage->hdrOffset;
  i = 0;
  while (i < (int )pPage->nCell) {
    tmp___1 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * i)));
    pCell = pPage->aData + ((int )pPage->maskPage & (int )tmp___1);
    if (! pPage->leaf) {
      tmp___2 = sqlite3Get4byte((u8 const   *)pCell);
      rc = clearDatabasePage(pBt, tmp___2, 1, pnChange);
      if (rc) {
        goto cleardatabasepage_out;
      }
    }
    rc = clearCell(pPage, pCell, & info);
    if (rc) {
      goto cleardatabasepage_out;
    }
    i ++;
  }
  if (! pPage->leaf) {
    tmp___3 = sqlite3Get4byte((u8 const   *)(pPage->aData + (hdr + 8)));
    rc = clearDatabasePage(pBt, tmp___3, 1, pnChange);
    if (rc) {
      goto cleardatabasepage_out;
    }
  } else
  if (pnChange) {
    *pnChange += (int )pPage->nCell;
  }
  if (freePageFlag) {
    freePage(pPage, & rc);
  } else {
    rc = sqlite3PagerWrite(pPage->pDbPage);
    if (rc == 0) {
      zeroPage(pPage, (int )*(pPage->aData + hdr) | 8);
    }
  }
  cleardatabasepage_out: 
  pPage->bBusy = (u8 )0;
  releasePage(pPage);
  return (rc);
}
}
static int sqlite3BtreeClearTable(Btree *p , int iTable , int *pnChange ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  rc = saveAllCursors(pBt, (Pgno )iTable, (BtCursor *)0);
  if (0 == rc) {
    invalidateIncrblobCursors(p, (Pgno )iTable, (i64 )0, 1);
    rc = clearDatabasePage(pBt, (Pgno )iTable, 0, pnChange);
  }
  return (rc);
}
}
static int sqlite3BtreeClearTableOfCursor(BtCursor *pCur ) 
{ 
  int tmp ;

  {
  tmp = sqlite3BtreeClearTable(pCur->pBtree, (int )pCur->pgnoRoot, (int *)0);
  return (tmp);
}
}
static int btreeDropTable(Btree *p , Pgno iTable , int *piMoved ) 
{ 
  int rc ;
  MemPage *pPage ;
  BtShared *pBt ;
  int tmp ;
  Pgno tmp___0 ;
  Pgno maxRootPgno ;
  MemPage *pMove ;
  Pgno tmp___1 ;

  {
  pPage = (MemPage *)0;
  pBt = p->pBt;
  tmp___0 = btreePagecount(pBt);
  if (iTable > tmp___0) {
    tmp = sqlite3CorruptError(72678);
    return (tmp);
  }
  rc = btreeGetPage(pBt, iTable, & pPage, 0);
  if (rc) {
    return (rc);
  }
  rc = sqlite3BtreeClearTable(p, (int )iTable, (int *)0);
  if (rc) {
    releasePage(pPage);
    return (rc);
  }
  *piMoved = 0;
  if (pBt->autoVacuum) {
    sqlite3BtreeGetMeta(p, 4, & maxRootPgno);
    if (iTable == maxRootPgno) {
      freePage(pPage, & rc);
      releasePage(pPage);
      if (rc != 0) {
        return (rc);
      }
    } else {
      releasePage(pPage);
      rc = btreeGetPage(pBt, maxRootPgno, & pMove, 0);
      if (rc != 0) {
        return (rc);
      }
      rc = relocatePage(pBt, pMove, (u8 )1, (Pgno )0, iTable, 0);
      releasePage(pMove);
      if (rc != 0) {
        return (rc);
      }
      pMove = (MemPage *)0;
      rc = btreeGetPage(pBt, maxRootPgno, & pMove, 0);
      freePage(pMove, & rc);
      releasePage(pMove);
      if (rc != 0) {
        return (rc);
      }
      *piMoved = (int )maxRootPgno;
    }
    maxRootPgno --;
    while (1) {
      if (! (maxRootPgno == (u32 )sqlite3PendingByte / pBt->pageSize + 1U)) {
        tmp___1 = ptrmapPageno(pBt, maxRootPgno);
        if (! (tmp___1 == maxRootPgno)) {
          break;
        }
      }
      maxRootPgno --;
    }
    rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);
  } else {
    freePage(pPage, & rc);
    releasePage(pPage);
  }
  return (rc);
}
}
static int sqlite3BtreeDropTable(Btree *p , int iTable , int *piMoved ) 
{ 
  int rc ;

  {
  sqlite3BtreeEnter(p);
  rc = btreeDropTable(p, (Pgno )iTable, piMoved);
  return (rc);
}
}
static void sqlite3BtreeGetMeta(Btree *p , int idx , u32 *pMeta ) 
{ 
  BtShared *pBt ;
  u32 tmp ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if (idx == 15) {
    tmp = sqlite3PagerDataVersion(pBt->pPager);
    *pMeta = tmp + p->iDataVersion;
  } else {
    *pMeta = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + (36 + idx * 4)));
  }
  return;
}
}
static int sqlite3BtreeUpdateMeta(Btree *p , int idx , u32 iMeta ) 
{ 
  BtShared *pBt ;
  unsigned char *pP1 ;
  int rc ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  pP1 = (pBt->pPage1)->aData;
  rc = sqlite3PagerWrite((pBt->pPage1)->pDbPage);
  if (rc == 0) {
    sqlite3Put4byte(pP1 + (36 + idx * 4), iMeta);
    if (idx == 7) {
      pBt->incrVacuum = (u8 )iMeta;
    }
  }
  return (rc);
}
}
static int sqlite3BtreeCount(BtCursor *pCur , i64 *pnEntry ) 
{ 
  i64 nEntry ;
  int rc ;
  int iIdx ;
  MemPage *pPage ;
  int tmp ;
  u32 tmp___0 ;
  short tmp___1 ;
  u32 tmp___2 ;

  {
  nEntry = (i64 )0;
  rc = moveToRoot(pCur);
  if (rc == 16) {
    *pnEntry = (i64 )0;
    return (0);
  }
  while (rc == 0) {
    pPage = pCur->pPage;
    if (pPage->leaf) {
      nEntry += (i64 )pPage->nCell;
    } else
    if (! pPage->intKey) {
      nEntry += (i64 )pPage->nCell;
    }
    if (pPage->leaf) {
      while (1) {
        if ((int )pCur->iPage == 0) {
          *pnEntry = nEntry;
          tmp = moveToRoot(pCur);
          return (tmp);
        }
        moveToParent(pCur);
        if (! ((int )pCur->ix >= (int )(pCur->pPage)->nCell)) {
          break;
        }
      }
      pCur->ix = (u16 )((int )pCur->ix + 1);
      pPage = pCur->pPage;
    }
    iIdx = (int )pCur->ix;
    if (iIdx == (int )pPage->nCell) {
      tmp___0 = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->hdrOffset + 8)));
      rc = moveToChild(pCur, tmp___0);
    } else {
      tmp___1 = __builtin_bswap16((short )*((u16 *)(pPage->aCellIdx + 2 * iIdx)));
      tmp___2 = sqlite3Get4byte((u8 const   *)(pPage->aData + ((int )pPage->maskPage & (int )tmp___1)));
      rc = moveToChild(pCur, tmp___2);
    }
  }
  return (rc);
}
}
static struct Pager *sqlite3BtreePager(Btree *p ) 
{ 


  {
  return ((p->pBt)->pPager);
}
}
static void checkAppendMsg(IntegrityCk *pCheck , char const   *zFormat  , ...) 
{ 
  va_list ap ;

  {
  if (! pCheck->mxErr) {
    return;
  }
  (pCheck->mxErr) --;
  (pCheck->nErr) ++;
  __builtin_va_start(ap, zFormat);
  if (pCheck->errMsg.nChar) {
    sqlite3_str_append(& pCheck->errMsg, "\n", 1);
  }
  if (pCheck->zPfx) {
    sqlite3_str_appendf(& pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  }
  sqlite3_str_vappendf(& pCheck->errMsg, zFormat, ap);
  __builtin_va_end(ap);
  if ((int )pCheck->errMsg.accError == 7) {
    pCheck->mallocFailed = 1;
  }
  return;
}
}
static int getPageReferenced(IntegrityCk *pCheck , Pgno iPg ) 
{ 


  {
  return ((int )*(pCheck->aPgRef + iPg / 8U) & (1 << (iPg & 7U)));
}
}
static void setPageReferenced(IntegrityCk *pCheck , Pgno iPg ) 
{ 


  {
  *(pCheck->aPgRef + iPg / 8U) = (u8 )((int )*(pCheck->aPgRef + iPg / 8U) | (1 << (iPg & 7U)));
  return;
}
}
static int checkRef(IntegrityCk *pCheck , Pgno iPage ) 
{ 
  int tmp ;

  {
  if (iPage > pCheck->nPage) {
    checkAppendMsg(pCheck, "invalid page number %d", iPage);
    return (1);
  } else
  if (iPage == 0U) {
    checkAppendMsg(pCheck, "invalid page number %d", iPage);
    return (1);
  }
  tmp = getPageReferenced(pCheck, iPage);
  if (tmp) {
    checkAppendMsg(pCheck, "2nd reference to page %d", iPage);
    return (1);
  }
  setPageReferenced(pCheck, iPage);
  return (0);
}
}
static void checkPtrmap(IntegrityCk *pCheck , Pgno iChild , u8 eType , Pgno iParent ) 
{ 
  int rc ;
  u8 ePtrmapType ;
  Pgno iPtrmapParent ;

  {
  rc = ptrmapGet(pCheck->pBt, iChild, & ePtrmapType, & iPtrmapParent);
  if (rc != 0) {
    if (rc == 7) {
      pCheck->mallocFailed = 1;
    } else
    if (rc == (10 | (12 << 8))) {
      pCheck->mallocFailed = 1;
    }
    checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", iChild);
    return;
  }
  if ((int )ePtrmapType != (int )eType) {
    checkAppendMsg(pCheck, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",
                   iChild, (int )eType, iParent, (int )ePtrmapType, iPtrmapParent);
  } else
  if (iPtrmapParent != iParent) {
    checkAppendMsg(pCheck, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",
                   iChild, (int )eType, iParent, (int )ePtrmapType, iPtrmapParent);
  }
  return;
}
}
static void checkList(IntegrityCk *pCheck , int isFreeList , int iPage , u32 N ) 
{ 
  int i ;
  u32 expected ;
  int nErrAtStart ;
  DbPage *pOvflPage ;
  unsigned char *pOvflData ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u32 n ;
  u32 tmp___2 ;
  Pgno iFreePage ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  char const   *tmp___6 ;

  {
  expected = N;
  nErrAtStart = pCheck->nErr;
  while (1) {
    if (iPage != 0) {
      if (! pCheck->mxErr) {
        break;
      }
    } else {
      break;
    }
    tmp = checkRef(pCheck, (Pgno )iPage);
    if (tmp) {
      break;
    }
    N --;
    tmp___0 = sqlite3PagerGet(pCheck->pPager, (Pgno )iPage, & pOvflPage, 0);
    if (tmp___0) {
      checkAppendMsg(pCheck, "failed to get page %d", iPage);
      break;
    }
    tmp___1 = sqlite3PagerGetData(pOvflPage);
    pOvflData = (unsigned char *)tmp___1;
    if (isFreeList) {
      tmp___2 = sqlite3Get4byte((u8 const   *)(pOvflData + 4));
      n = tmp___2;
      if ((pCheck->pBt)->autoVacuum) {
        checkPtrmap(pCheck, (Pgno )iPage, (u8 )2, (Pgno )0);
      }
      if (n > (pCheck->pBt)->usableSize / 4U - 2U) {
        checkAppendMsg(pCheck, "freelist leaf count too big on page %d", iPage);
        N --;
      } else {
        i = 0;
        while (i < (int )n) {
          tmp___3 = sqlite3Get4byte((u8 const   *)(pOvflData + (8 + i * 4)));
          iFreePage = tmp___3;
          if ((pCheck->pBt)->autoVacuum) {
            checkPtrmap(pCheck, iFreePage, (u8 )2, (Pgno )0);
          }
          checkRef(pCheck, iFreePage);
          i ++;
        }
        N -= n;
      }
    } else
    if ((pCheck->pBt)->autoVacuum) {
      if (N > 0U) {
        tmp___4 = sqlite3Get4byte((u8 const   *)pOvflData);
        i = (int )tmp___4;
        checkPtrmap(pCheck, (Pgno )i, (u8 )4, (Pgno )iPage);
      }
    }
    tmp___5 = sqlite3Get4byte((u8 const   *)pOvflData);
    iPage = (int )tmp___5;
    sqlite3PagerUnref(pOvflPage);
  }
  if (N) {
    if (nErrAtStart == pCheck->nErr) {
      if (isFreeList) {
        tmp___6 = "size";
      } else {
        tmp___6 = "overflow list length";
      }
      checkAppendMsg(pCheck, "%s is %d but should be %d", tmp___6, expected - N, expected);
    }
  }
  return;
}
}
static void btreeHeapInsert(u32 *aHeap , u32 x___0 ) 
{ 
  u32 j ;
  u32 i ;

  {
  (*(aHeap + 0)) ++;
  i = *(aHeap + 0);
  *(aHeap + i) = x___0;
  while (1) {
    j = i / 2U;
    if (j > 0U) {
      if (! (*(aHeap + j) > *(aHeap + i))) {
        break;
      }
    } else {
      break;
    }
    x___0 = *(aHeap + j);
    *(aHeap + j) = *(aHeap + i);
    *(aHeap + i) = x___0;
    i = j;
  }
  return;
}
}
static int btreeHeapPull(u32 *aHeap , u32 *pOut ) 
{ 
  u32 j ;
  u32 i ;
  u32 x___0 ;

  {
  x___0 = *(aHeap + 0);
  if (x___0 == 0U) {
    return (0);
  }
  *pOut = *(aHeap + 1);
  *(aHeap + 1) = *(aHeap + x___0);
  *(aHeap + x___0) = 4294967295U;
  (*(aHeap + 0)) --;
  i = (u32 )1;
  while (1) {
    j = i * 2U;
    if (! (j <= *(aHeap + 0))) {
      break;
    }
    if (*(aHeap + j) > *(aHeap + (j + 1U))) {
      j ++;
    }
    if (*(aHeap + i) < *(aHeap + j)) {
      break;
    }
    x___0 = *(aHeap + i);
    *(aHeap + i) = *(aHeap + j);
    *(aHeap + j) = x___0;
    i = j;
  }
  return (1);
}
}
static int checkTreePage(IntegrityCk *pCheck , int iPage , i64 *piMinKey , i64 maxKey ) 
{ 
  MemPage *pPage ;
  int i ;
  int rc ;
  int depth ;
  int d2 ;
  int pgno ;
  int nFrag ;
  int hdr ;
  int cellStart ;
  int nCell ;
  int doCoverageCheck ;
  int keyCanBeEqual ;
  u8 *data ;
  u8 *pCell ;
  u8 *pCellIdx ;
  BtShared *pBt ;
  u32 pc ;
  u32 usableSize ;
  u32 contentOffset ;
  u32 *heap ;
  u32 x___0 ;
  u32 prev ;
  char const   *saved_zPfx ;
  int saved_v1 ;
  int saved_v2 ;
  u8 savedIsInit ;
  int tmp ;
  u32 tmp___0 ;
  CellInfo info ;
  short tmp___1 ;
  int tmp___2 ;
  u32 nPage ;
  Pgno pgnoOvfl ;
  u32 tmp___3 ;
  u32 size ;
  short tmp___4 ;
  u16 tmp___5 ;
  int size___0 ;
  int j ;
  int tmp___6 ;

  {
  pPage = (MemPage *)0;
  depth = -1;
  doCoverageCheck = 1;
  keyCanBeEqual = 1;
  heap = (u32 *)0;
  prev = (u32 )0;
  saved_zPfx = pCheck->zPfx;
  saved_v1 = pCheck->v1;
  saved_v2 = pCheck->v2;
  savedIsInit = (u8 )0;
  pBt = pCheck->pBt;
  usableSize = pBt->usableSize;
  if (iPage == 0) {
    return (0);
  }
  tmp = checkRef(pCheck, (Pgno )iPage);
  if (tmp) {
    return (0);
  }
  pCheck->zPfx = "Page %d: ";
  pCheck->v1 = iPage;
  rc = btreeGetPage(pBt, (Pgno )iPage, & pPage, 0);
  if (rc != 0) {
    checkAppendMsg(pCheck, "unable to get the page. error code=%d", rc);
    goto end_of_check;
  }
  savedIsInit = pPage->isInit;
  pPage->isInit = (u8 )0;
  rc = btreeInitPage(pPage);
  if (rc != 0) {
    checkAppendMsg(pCheck, "btreeInitPage() returns error code %d", rc);
    goto end_of_check;
  }
  rc = btreeComputeFreeSpace(pPage);
  if (rc != 0) {
    checkAppendMsg(pCheck, "free space corruption", rc);
    goto end_of_check;
  }
  data = pPage->aData;
  hdr = (int )pPage->hdrOffset;
  pCheck->zPfx = "On tree page %d cell %d: ";
  contentOffset = (u32 )((((((int )*((data + (hdr + 5)) + 0) << 8) | (int )*((data + (hdr + 5)) + 1)) - 1) & 65535) + 1);
  nCell = ((int )*((data + (hdr + 3)) + 0) << 8) | (int )*((data + (hdr + 3)) + 1);
  cellStart = (hdr + 12) - 4 * (int )pPage->leaf;
  pCellIdx = data + (cellStart + 2 * (nCell - 1));
  if (! pPage->leaf) {
    tmp___0 = sqlite3Get4byte((u8 const   *)(data + (hdr + 8)));
    pgno = (int )tmp___0;
    if (pBt->autoVacuum) {
      pCheck->zPfx = "On page %d at right child: ";
      checkPtrmap(pCheck, (Pgno )pgno, (u8 )5, (Pgno )iPage);
    }
    depth = checkTreePage(pCheck, pgno, & maxKey, maxKey);
    keyCanBeEqual = 0;
  } else {
    heap = pCheck->heap;
    *(heap + 0) = (u32 )0;
  }
  i = nCell - 1;
  while (1) {
    if (i >= 0) {
      if (! pCheck->mxErr) {
        break;
      }
    } else {
      break;
    }
    pCheck->v2 = i;
    tmp___1 = __builtin_bswap16((short )*((u16 *)pCellIdx));
    pc = (u32 )tmp___1;
    pCellIdx -= 2;
    if (pc < contentOffset) {
      checkAppendMsg(pCheck, "Offset %d out of range %d..%d", pc, contentOffset, usableSize - 4U);
      doCoverageCheck = 0;
      goto __Cont;
    } else
    if (pc > usableSize - 4U) {
      checkAppendMsg(pCheck, "Offset %d out of range %d..%d", pc, contentOffset, usableSize - 4U);
      doCoverageCheck = 0;
      goto __Cont;
    }
    pCell = data + pc;
    (*(pPage->xParseCell))(pPage, pCell, & info);
    if (pc + (u32 )info.nSize > usableSize) {
      checkAppendMsg(pCheck, "Extends off end of page");
      doCoverageCheck = 0;
      goto __Cont;
    }
    if (pPage->intKey) {
      if (keyCanBeEqual) {
        tmp___2 = info.nKey > maxKey;
      } else {
        tmp___2 = info.nKey >= maxKey;
      }
      if (tmp___2) {
        checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);
      }
      maxKey = info.nKey;
      keyCanBeEqual = 0;
    }
    if (info.nPayload > (u32 )info.nLocal) {
      nPage = (((info.nPayload - (u32 )info.nLocal) + usableSize) - 5U) / (usableSize - 4U);
      pgnoOvfl = sqlite3Get4byte((u8 const   *)(pCell + ((int )info.nSize - 4)));
      if (pBt->autoVacuum) {
        checkPtrmap(pCheck, pgnoOvfl, (u8 )3, (Pgno )iPage);
      }
      checkList(pCheck, 0, (int )pgnoOvfl, nPage);
    }
    if (! pPage->leaf) {
      tmp___3 = sqlite3Get4byte((u8 const   *)pCell);
      pgno = (int )tmp___3;
      if (pBt->autoVacuum) {
        checkPtrmap(pCheck, (Pgno )pgno, (u8 )5, (Pgno )iPage);
      }
      d2 = checkTreePage(pCheck, pgno, & maxKey, maxKey);
      keyCanBeEqual = 0;
      if (d2 != depth) {
        checkAppendMsg(pCheck, "Child page depth differs");
        depth = d2;
      }
    } else {
      btreeHeapInsert(heap, (pc << 16) | ((pc + (u32 )info.nSize) - 1U));
    }
    __Cont: /* CIL Label */ 
    i --;
  }
  *piMinKey = maxKey;
  pCheck->zPfx = (char const   *)0;
  if (doCoverageCheck) {
    if (pCheck->mxErr > 0) {
      if (! pPage->leaf) {
        heap = pCheck->heap;
        *(heap + 0) = (u32 )0;
        i = nCell - 1;
        while (i >= 0) {
          tmp___4 = __builtin_bswap16((short )*((u16 *)(data + (cellStart + i * 2))));
          pc = (u32 )tmp___4;
          tmp___5 = (*(pPage->xCellSize))(pPage, data + pc);
          size = (u32 )tmp___5;
          btreeHeapInsert(heap, (pc << 16) | ((pc + size) - 1U));
          i --;
        }
      }
      i = ((int )*((data + (hdr + 1)) + 0) << 8) | (int )*((data + (hdr + 1)) + 1);
      while (i > 0) {
        size___0 = ((int )*((data + (i + 2)) + 0) << 8) | (int )*((data + (i + 2)) + 1);
        btreeHeapInsert(heap, ((u32 )i << 16) | (unsigned int )((i + size___0) - 1));
        j = ((int )*((data + i) + 0) << 8) | (int )*((data + i) + 1);
        i = j;
      }
      nFrag = 0;
      prev = contentOffset - 1U;
      while (1) {
        tmp___6 = btreeHeapPull(heap, & x___0);
        if (! tmp___6) {
          break;
        }
        if ((prev & 65535U) >= x___0 >> 16) {
          checkAppendMsg(pCheck, "Multiple uses for byte %u of page %d", x___0 >> 16,
                         iPage);
          break;
        } else {
          nFrag = (int )((u32 )nFrag + (((x___0 >> 16) - (prev & 65535U)) - 1U));
          prev = x___0;
        }
      }
      nFrag = (int )((u32 )nFrag + ((usableSize - (prev & 65535U)) - 1U));
      if (*(heap + 0) == 0U) {
        if (nFrag != (int )*(data + (hdr + 7))) {
          checkAppendMsg(pCheck, "Fragmentation of %d bytes reported as %d on page %d",
                         nFrag, (int )*(data + (hdr + 7)), iPage);
        }
      }
    }
  }
  end_of_check: 
  if (! doCoverageCheck) {
    pPage->isInit = savedIsInit;
  }
  releasePage(pPage);
  pCheck->zPfx = saved_zPfx;
  pCheck->v1 = saved_v1;
  pCheck->v2 = saved_v2;
  return (depth + 1);
}
}
static char *sqlite3BtreeIntegrityCheck(Btree *p , int *aRoot , int nRoot , int mxErr ,
                                        int *pnErr ) 
{ 
  Pgno i ;
  IntegrityCk sCheck ;
  BtShared *pBt ;
  u64 savedDbFlags ;
  char zErr[100] ;
  void *tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int mx ;
  int mxInHdr ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  i64 notUsed ;
  int tmp___5 ;
  Pgno tmp___6 ;
  int tmp___7 ;
  Pgno tmp___8 ;
  char *tmp___9 ;

  {
  pBt = p->pBt;
  savedDbFlags = (pBt->db)->flags;
  sqlite3BtreeEnter(p);
  sCheck.pBt = pBt;
  sCheck.pPager = pBt->pPager;
  sCheck.nPage = btreePagecount(sCheck.pBt);
  sCheck.mxErr = mxErr;
  sCheck.nErr = 0;
  sCheck.mallocFailed = 0;
  sCheck.zPfx = (char const   *)0;
  sCheck.v1 = 0;
  sCheck.v2 = 0;
  sCheck.aPgRef = (u8 *)0;
  sCheck.heap = (u32 *)0;
  sqlite3StrAccumInit(& sCheck.errMsg, (sqlite3 *)0, zErr, (int )sizeof(zErr), 1000000000);
  sCheck.errMsg.printfFlags = (u8 )1;
  if (sCheck.nPage == 0U) {
    goto integrity_ck_cleanup;
  }
  tmp = sqlite3MallocZero((u64 )(sCheck.nPage / 8U + 1U));
  sCheck.aPgRef = (u8 *)tmp;
  if (! sCheck.aPgRef) {
    sCheck.mallocFailed = 1;
    goto integrity_ck_cleanup;
  }
  tmp___0 = sqlite3PageMalloc((int )pBt->pageSize);
  sCheck.heap = (u32 *)tmp___0;
  if ((unsigned long )sCheck.heap == (unsigned long )((u32 *)0)) {
    sCheck.mallocFailed = 1;
    goto integrity_ck_cleanup;
  }
  i = (u32 )sqlite3PendingByte / pBt->pageSize + 1U;
  if (i <= sCheck.nPage) {
    setPageReferenced(& sCheck, i);
  }
  sCheck.zPfx = "Main freelist: ";
  tmp___1 = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 36));
  tmp___2 = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 32));
  checkList(& sCheck, 1, (int )tmp___2, tmp___1);
  sCheck.zPfx = (char const   *)0;
  if (pBt->autoVacuum) {
    mx = 0;
    i = (Pgno )0;
    while ((int )i < nRoot) {
      if (mx < *(aRoot + i)) {
        mx = *(aRoot + i);
      }
      i ++;
    }
    tmp___3 = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 52));
    mxInHdr = (int )tmp___3;
    if (mx != mxInHdr) {
      checkAppendMsg(& sCheck, "max rootpage (%d) disagrees with header (%d)", mx,
                     mxInHdr);
    }
  } else {
    tmp___4 = sqlite3Get4byte((u8 const   *)((pBt->pPage1)->aData + 64));
    if (tmp___4 != 0U) {
      checkAppendMsg(& sCheck, "incremental_vacuum enabled with a max rootpage of zero");
    }
  }
  (pBt->db)->flags &= 0xffffffffffdfffffULL;
  i = (Pgno )0;
  while (1) {
    if ((int )i < nRoot) {
      if (! sCheck.mxErr) {
        break;
      }
    } else {
      break;
    }
    if (*(aRoot + i) == 0) {
      goto __Cont;
    }
    if (pBt->autoVacuum) {
      if (*(aRoot + i) > 1) {
        checkPtrmap(& sCheck, (Pgno )*(aRoot + i), (u8 )1, (Pgno )0);
      }
    }
    checkTreePage(& sCheck, *(aRoot + i), & notUsed, 4294967295LL | (2147483647LL << 32));
    __Cont: /* CIL Label */ 
    i ++;
  }
  (pBt->db)->flags = savedDbFlags;
  i = (Pgno )1;
  while (1) {
    if (i <= sCheck.nPage) {
      if (! sCheck.mxErr) {
        break;
      }
    } else {
      break;
    }
    tmp___5 = getPageReferenced(& sCheck, i);
    if (tmp___5 == 0) {
      tmp___6 = ptrmapPageno(pBt, i);
      if (tmp___6 != i) {
        checkAppendMsg(& sCheck, "Page %d is never used", i);
      } else
      if (! pBt->autoVacuum) {
        checkAppendMsg(& sCheck, "Page %d is never used", i);
      }
    }
    tmp___7 = getPageReferenced(& sCheck, i);
    if (tmp___7 != 0) {
      tmp___8 = ptrmapPageno(pBt, i);
      if (tmp___8 == i) {
        if (pBt->autoVacuum) {
          checkAppendMsg(& sCheck, "Pointer map page %d is referenced", i);
        }
      }
    }
    i ++;
  }
  integrity_ck_cleanup: 
  sqlite3PageFree((void *)sCheck.heap);
  sqlite3_free((void *)sCheck.aPgRef);
  if (sCheck.mallocFailed) {
    sqlite3_str_reset(& sCheck.errMsg);
    (sCheck.nErr) ++;
  }
  *pnErr = sCheck.nErr;
  if (sCheck.nErr == 0) {
    sqlite3_str_reset(& sCheck.errMsg);
  }
  tmp___9 = sqlite3StrAccumFinish(& sCheck.errMsg);
  return (tmp___9);
}
}
static char const   *sqlite3BtreeGetFilename(Btree *p ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3PagerFilename((p->pBt)->pPager, 1);
  return (tmp);
}
}
static char const   *sqlite3BtreeGetJournalname(Btree *p ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3PagerJournalname((p->pBt)->pPager);
  return (tmp);
}
}
static int sqlite3BtreeIsInTrans(Btree *p ) 
{ 
  int tmp ;

  {
  if (p) {
    if ((int )p->inTrans == 2) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int sqlite3BtreeCheckpoint(Btree *p , int eMode , int *pnLog , int *pnCkpt ) 
{ 
  int rc ;
  BtShared *pBt ;

  {
  rc = 0;
  if (p) {
    pBt = p->pBt;
    sqlite3BtreeEnter(p);
    if ((int )pBt->inTransaction != 0) {
      rc = 6;
    } else {
      rc = sqlite3PagerCheckpoint(pBt->pPager, p->db, eMode, pnLog, pnCkpt);
    }
  }
  return (rc);
}
}
static int sqlite3BtreeIsInReadTrans(Btree *p ) 
{ 


  {
  return ((int )p->inTrans != 0);
}
}
static int sqlite3BtreeIsInBackup(Btree *p ) 
{ 


  {
  return (p->nBackup != 0);
}
}
static void *sqlite3BtreeSchema(Btree *p , int nBytes , void (*xFree)(void * ) ) 
{ 
  BtShared *pBt ;

  {
  pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if (! pBt->pSchema) {
    if (nBytes) {
      pBt->pSchema = sqlite3DbMallocZero((sqlite3 *)0, (u64 )nBytes);
      pBt->xFreeSchema = xFree;
    }
  }
  return (pBt->pSchema);
}
}
static int sqlite3BtreeSchemaLocked(Btree *p ) 
{ 
  int rc ;

  {
  sqlite3BtreeEnter(p);
  rc = querySharedCacheTableLock(p, (Pgno )1, (u8 )1);
  return (rc);
}
}
static int sqlite3BtreeLockTable(Btree *p , int iTab , u8 isWriteLock ) 
{ 
  int rc ;
  u8 lockType ;

  {
  rc = 0;
  if (p->sharable) {
    lockType = (u8 )(1 + (int )isWriteLock);
    sqlite3BtreeEnter(p);
    rc = querySharedCacheTableLock(p, (Pgno )iTab, lockType);
    if (rc == 0) {
      rc = setSharedCacheTableLock(p, (Pgno )iTab, lockType);
    }
  }
  return (rc);
}
}
static int sqlite3BtreePutData(BtCursor *pCsr , u32 offset , u32 amt , void *z ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )pCsr->eState >= 3) {
    tmp = btreeRestoreCursorPosition(pCsr);
    rc = tmp;
  } else {
    rc = 0;
  }
  if (rc != 0) {
    return (rc);
  }
  if ((int )pCsr->eState != 0) {
    return (4);
  }
  saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);
  if (((int )pCsr->curFlags & 1) == 0) {
    return (8);
  }
  tmp___0 = accessPayload(pCsr, offset, amt, (unsigned char *)z, 1);
  return (tmp___0);
}
}
static void sqlite3BtreeIncrblobCursor(BtCursor *pCur ) 
{ 


  {
  pCur->curFlags = (u8 )((int )pCur->curFlags | 16);
  (pCur->pBtree)->hasIncrblobCur = (u8 )1;
  return;
}
}
static int sqlite3BtreeSetVersion(Btree *pBtree , int iVersion ) 
{ 
  BtShared *pBt ;
  int rc ;
  u8 *aData ;

  {
  pBt = pBtree->pBt;
  pBt->btsFlags = (u16 )((int )pBt->btsFlags & -33);
  if (iVersion == 1) {
    pBt->btsFlags = (u16 )((int )pBt->btsFlags | 32);
  }
  rc = sqlite3BtreeBeginTrans(pBtree, 0, (int *)0);
  if (rc == 0) {
    aData = (pBt->pPage1)->aData;
    if ((int )*(aData + 18) != (int )((u8 )iVersion)) {
      goto _L;
    } else
    if ((int )*(aData + 19) != (int )((u8 )iVersion)) {
      _L: /* CIL Label */ 
      rc = sqlite3BtreeBeginTrans(pBtree, 2, (int *)0);
      if (rc == 0) {
        rc = sqlite3PagerWrite((pBt->pPage1)->pDbPage);
        if (rc == 0) {
          *(aData + 18) = (u8 )iVersion;
          *(aData + 19) = (u8 )iVersion;
        }
      }
    }
  }
  pBt->btsFlags = (u16 )((int )pBt->btsFlags & -33);
  return (rc);
}
}
static int sqlite3BtreeCursorHasHint(BtCursor *pCsr , unsigned int mask ) 
{ 


  {
  return (((unsigned int )pCsr->hints & mask) != 0U);
}
}
static int sqlite3BtreeIsReadonly(Btree *p ) 
{ 


  {
  return (((int )(p->pBt)->btsFlags & 1) != 0);
}
}
static int sqlite3HeaderSizeBtree(void) 
{ 


  {
  return ((int )((sizeof(MemPage ) + 7UL) & 0xfffffffffffffff8UL));
}
}
static int sqlite3BtreeSharable(Btree *p ) 
{ 


  {
  return ((int )p->sharable);
}
}
static int sqlite3BtreeConnectionCount(Btree *p ) 
{ 


  {
  return ((p->pBt)->nRef);
}
}
static Btree *findBtree(sqlite3 *pErrorDb , sqlite3 *pDb , char const   *zDb ) 
{ 
  int i ;
  int tmp ;
  Parse sParse ;
  int rc ;
  int tmp___0 ;

  {
  tmp = sqlite3FindDbName(pDb, zDb);
  i = tmp;
  if (i == 1) {
    rc = 0;
    memset((void *)(& sParse), 0, sizeof(sParse));
    sParse.db = pDb;
    tmp___0 = sqlite3OpenTempDatabase(& sParse);
    if (tmp___0) {
      sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);
      rc = 1;
    }
    sqlite3DbFree(pErrorDb, (void *)sParse.zErrMsg);
    sqlite3ParserReset(& sParse);
    if (rc) {
      return ((Btree *)0);
    }
  }
  if (i < 0) {
    sqlite3ErrorWithMsg(pErrorDb, 1, "unknown database %s", zDb);
    return ((Btree *)0);
  }
  return ((pDb->aDb + i)->pBt);
}
}
static int setDestPgsz(sqlite3_backup *p ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3BtreeGetPageSize(p->pSrc);
  rc = sqlite3BtreeSetPageSize(p->pDest, tmp, -1, 0);
  return (rc);
}
}
static int checkReadTransaction(sqlite3 *db , Btree *p ) 
{ 
  int tmp ;

  {
  tmp = sqlite3BtreeIsInReadTrans(p);
  if (tmp) {
    sqlite3ErrorWithMsg(db, 1, "destination database is in use");
    return (1);
  }
  return (0);
}
}
sqlite3_backup *sqlite3_backup_init(sqlite3 *pDestDb , char const   *zDestDb , sqlite3 *pSrcDb ,
                                    char const   *zSrcDb ) 
{ 
  sqlite3_backup *p ;
  void *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )pSrcDb == (unsigned long )pDestDb) {
    sqlite3ErrorWithMsg(pDestDb, 1, "source and destination must be distinct");
    p = (sqlite3_backup *)0;
  } else {
    tmp = sqlite3MallocZero((u64 )sizeof(sqlite3_backup ));
    p = (sqlite3_backup *)tmp;
    if (! p) {
      sqlite3Error(pDestDb, 7);
    }
  }
  if (p) {
    p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
    p->pDest = findBtree(pDestDb, pDestDb, zDestDb);
    p->pDestDb = pDestDb;
    p->pSrcDb = pSrcDb;
    p->iNext = (Pgno )1;
    p->isAttached = 0;
    if ((unsigned long )((Btree *)0) == (unsigned long )p->pSrc) {
      sqlite3_free((void *)p);
      p = (sqlite3_backup *)0;
    } else
    if ((unsigned long )((Btree *)0) == (unsigned long )p->pDest) {
      sqlite3_free((void *)p);
      p = (sqlite3_backup *)0;
    } else {
      tmp___0 = checkReadTransaction(pDestDb, p->pDest);
      if (tmp___0 != 0) {
        sqlite3_free((void *)p);
        p = (sqlite3_backup *)0;
      }
    }
  }
  if (p) {
    ((p->pSrc)->nBackup) ++;
  }
  return (p);
}
}
static int isFatalError(int rc ) 
{ 
  int tmp ;

  {
  if (rc != 0) {
    if (rc != 5) {
      if (rc != 6) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int backupOnePage(sqlite3_backup *p , Pgno iSrcPg , u8 const   *zSrcData ,
                         int bUpdate ) 
{ 
  Pager *pDestPager ;
  struct Pager *tmp ;
  int nSrcPgsz ;
  int tmp___0 ;
  int nDestPgsz ;
  int tmp___1 ;
  int nCopy ;
  int tmp___2 ;
  i64 iEnd ;
  int rc ;
  i64 iOff ;
  int tmp___3 ;
  DbPage *pDestPg ;
  Pgno iDest ;
  u8 const   *zIn ;
  u8 *zDestData ;
  void *tmp___4 ;
  u8 *zOut ;
  void *tmp___5 ;
  u32 tmp___6 ;

  {
  tmp = sqlite3BtreePager(p->pDest);
  pDestPager = tmp;
  tmp___0 = sqlite3BtreeGetPageSize(p->pSrc);
  nSrcPgsz = tmp___0;
  tmp___1 = sqlite3BtreeGetPageSize(p->pDest);
  nDestPgsz = tmp___1;
  if (nSrcPgsz < nDestPgsz) {
    tmp___2 = nSrcPgsz;
  } else {
    tmp___2 = nDestPgsz;
  }
  nCopy = tmp___2;
  iEnd = (i64 )iSrcPg * (i64 )nSrcPgsz;
  rc = 0;
  if (nSrcPgsz != nDestPgsz) {
    tmp___3 = sqlite3PagerIsMemdb(pDestPager);
    if (tmp___3) {
      rc = 8;
    }
  }
  iOff = iEnd - (i64 )nSrcPgsz;
  while (1) {
    if (rc == 0) {
      if (! (iOff < iEnd)) {
        break;
      }
    } else {
      break;
    }
    pDestPg = (DbPage *)0;
    iDest = (Pgno )(iOff / (i64 )nDestPgsz) + 1U;
    if (iDest == (u32 )sqlite3PendingByte / ((p->pDest)->pBt)->pageSize + 1U) {
      goto __Cont;
    }
    rc = sqlite3PagerGet(pDestPager, iDest, & pDestPg, 0);
    if (0 == rc) {
      rc = sqlite3PagerWrite(pDestPg);
      if (0 == rc) {
        zIn = zSrcData + iOff % (long long )nSrcPgsz;
        tmp___4 = sqlite3PagerGetData(pDestPg);
        zDestData = (u8 *)tmp___4;
        zOut = zDestData + iOff % (long long )nDestPgsz;
        memcpy((void * __restrict  )zOut, (void const   * __restrict  )zIn, (size_t )nCopy);
        tmp___5 = sqlite3PagerGetExtra(pDestPg);
        *((u8 *)tmp___5 + 0) = (u8 )0;
        if (iOff == 0LL) {
          if (bUpdate == 0) {
            tmp___6 = sqlite3BtreeLastPage(p->pSrc);
            sqlite3Put4byte(zOut + 28, tmp___6);
          }
        }
      }
    }
    sqlite3PagerUnref(pDestPg);
    __Cont: /* CIL Label */ 
    iOff += (i64 )nDestPgsz;
  }
  return (rc);
}
}
static int backupTruncateFile(sqlite3_file *pFile , i64 iSize ) 
{ 
  i64 iCurrent ;
  int rc ;
  int tmp ;

  {
  tmp = sqlite3OsFileSize(pFile, & iCurrent);
  rc = tmp;
  if (rc == 0) {
    if (iCurrent > iSize) {
      rc = sqlite3OsTruncate(pFile, iSize);
    }
  }
  return (rc);
}
}
static void attachBackupObject(sqlite3_backup *p ) 
{ 
  sqlite3_backup **pp ;
  struct Pager *tmp ;

  {
  tmp = sqlite3BtreePager(p->pSrc);
  pp = sqlite3PagerBackupPtr(tmp);
  p->pNext = *pp;
  *pp = p;
  p->isAttached = 1;
  return;
}
}
int sqlite3_backup_step(sqlite3_backup *p , int nPage ) 
{ 
  int rc ;
  int destMode ;
  int pgszSrc ;
  int pgszDest ;
  Pager *pSrcPager ;
  struct Pager *tmp ;
  Pager *pDestPager ;
  struct Pager *tmp___0 ;
  int ii ;
  int nSrcPage ;
  int bCloseTrans ;
  int tmp___1 ;
  int tmp___2 ;
  struct Pager *tmp___3 ;
  u32 tmp___4 ;
  Pgno iSrcPg ;
  DbPage *pSrcPg ;
  void *tmp___5 ;
  int nDestTruncate ;
  int ratio ;
  i64 iSize ;
  sqlite3_file *pFile ;
  sqlite3_file *tmp___6 ;
  Pgno iPg ;
  int nDstPage ;
  i64 iOff ;
  i64 iEnd ;
  DbPage *pPg ;
  PgHdr *pSrcPg___0 ;
  Pgno iSrcPg___0 ;
  u8 *zData ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  pgszSrc = 0;
  pgszDest = 0;
  sqlite3BtreeEnter(p->pSrc);
  rc = p->rc;
  tmp___8 = isFatalError(rc);
  if (! tmp___8) {
    tmp = sqlite3BtreePager(p->pSrc);
    pSrcPager = tmp;
    tmp___0 = sqlite3BtreePager(p->pDest);
    pDestPager = tmp___0;
    nSrcPage = -1;
    bCloseTrans = 0;
    if (p->pDestDb) {
      if ((int )((p->pSrc)->pBt)->inTransaction == 2) {
        rc = 5;
      } else {
        rc = 0;
      }
    } else {
      rc = 0;
    }
    if (rc == 0) {
      tmp___1 = sqlite3BtreeIsInReadTrans(p->pSrc);
      if (0 == tmp___1) {
        rc = sqlite3BtreeBeginTrans(p->pSrc, 0, (int *)0);
        bCloseTrans = 1;
      }
    }
    if (p->bDestLocked == 0) {
      if (rc == 0) {
        tmp___2 = setDestPgsz(p);
        if (tmp___2 == 7) {
          rc = 7;
        }
      }
    }
    if (0 == rc) {
      if (p->bDestLocked == 0) {
        rc = sqlite3BtreeBeginTrans(p->pDest, 2, (int *)(& p->iDestSchema));
        if (0 == rc) {
          p->bDestLocked = 1;
        }
      }
    }
    pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);
    pgszDest = sqlite3BtreeGetPageSize(p->pDest);
    tmp___3 = sqlite3BtreePager(p->pDest);
    destMode = sqlite3PagerGetJournalMode(tmp___3);
    if (0 == rc) {
      if (destMode == 5) {
        if (pgszSrc != pgszDest) {
          rc = 8;
        }
      }
    }
    tmp___4 = sqlite3BtreeLastPage(p->pSrc);
    nSrcPage = (int )tmp___4;
    ii = 0;
    while (1) {
      if (nPage < 0) {
        goto _L;
      } else
      if (ii < nPage) {
        _L: /* CIL Label */ 
        if (p->iNext <= (Pgno )nSrcPage) {
          if (! (! rc)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      iSrcPg = p->iNext;
      if (iSrcPg != (u32 )sqlite3PendingByte / ((p->pSrc)->pBt)->pageSize + 1U) {
        rc = sqlite3PagerGet(pSrcPager, iSrcPg, & pSrcPg, 2);
        if (rc == 0) {
          tmp___5 = sqlite3PagerGetData(pSrcPg);
          rc = backupOnePage(p, iSrcPg, (u8 const   *)tmp___5, 0);
          sqlite3PagerUnref(pSrcPg);
        }
      }
      (p->iNext) ++;
      ii ++;
    }
    if (rc == 0) {
      p->nPagecount = (Pgno )nSrcPage;
      p->nRemaining = (Pgno )(nSrcPage + 1) - p->iNext;
      if (p->iNext > (Pgno )nSrcPage) {
        rc = 101;
      } else
      if (! p->isAttached) {
        attachBackupObject(p);
      }
    }
    if (rc == 101) {
      if (nSrcPage == 0) {
        rc = sqlite3BtreeNewDb(p->pDest);
        nSrcPage = 1;
      }
      if (rc == 0) {
        rc = sqlite3BtreeUpdateMeta(p->pDest, 1, p->iDestSchema + 1U);
      } else
      if (rc == 101) {
        rc = sqlite3BtreeUpdateMeta(p->pDest, 1, p->iDestSchema + 1U);
      }
      if (rc == 0) {
        if (p->pDestDb) {
          sqlite3ResetAllSchemasOfConnection(p->pDestDb);
        }
        if (destMode == 5) {
          rc = sqlite3BtreeSetVersion(p->pDest, 2);
        }
      }
      if (rc == 0) {
        if (pgszSrc < pgszDest) {
          ratio = pgszDest / pgszSrc;
          nDestTruncate = ((nSrcPage + ratio) - 1) / ratio;
          if (nDestTruncate == (int )((u32 )sqlite3PendingByte / ((p->pDest)->pBt)->pageSize + 1U)) {
            nDestTruncate --;
          }
        } else {
          nDestTruncate = nSrcPage * (pgszSrc / pgszDest);
        }
        if (pgszSrc < pgszDest) {
          iSize = (i64 )pgszSrc * (i64 )nSrcPage;
          tmp___6 = sqlite3PagerFile(pDestPager);
          pFile = tmp___6;
          sqlite3PagerPagecount(pDestPager, & nDstPage);
          iPg = (Pgno )nDestTruncate;
          while (1) {
            if (rc == 0) {
              if (! (iPg <= (Pgno )nDstPage)) {
                break;
              }
            } else {
              break;
            }
            if (iPg != (u32 )sqlite3PendingByte / ((p->pDest)->pBt)->pageSize + 1U) {
              rc = sqlite3PagerGet(pDestPager, iPg, & pPg, 0);
              if (rc == 0) {
                rc = sqlite3PagerWrite(pPg);
                sqlite3PagerUnref(pPg);
              }
            }
            iPg ++;
          }
          if (rc == 0) {
            rc = sqlite3PagerCommitPhaseOne(pDestPager, (char const   *)0, 1);
          }
          if ((i64 )(sqlite3PendingByte + pgszDest) < iSize) {
            iEnd = (i64 )(sqlite3PendingByte + pgszDest);
          } else {
            iEnd = iSize;
          }
          iOff = (i64 )(sqlite3PendingByte + pgszSrc);
          while (1) {
            if (rc == 0) {
              if (! (iOff < iEnd)) {
                break;
              }
            } else {
              break;
            }
            pSrcPg___0 = (PgHdr *)0;
            iSrcPg___0 = (Pgno )(iOff / (i64 )pgszSrc + 1LL);
            rc = sqlite3PagerGet(pSrcPager, iSrcPg___0, & pSrcPg___0, 0);
            if (rc == 0) {
              tmp___7 = sqlite3PagerGetData(pSrcPg___0);
              zData = (u8 *)tmp___7;
              rc = sqlite3OsWrite(pFile, (void const   *)zData, pgszSrc, iOff);
            }
            sqlite3PagerUnref(pSrcPg___0);
            iOff += (i64 )pgszSrc;
          }
          if (rc == 0) {
            rc = backupTruncateFile(pFile, iSize);
          }
          if (rc == 0) {
            rc = sqlite3PagerSync(pDestPager, (char const   *)0);
          }
        } else {
          sqlite3PagerTruncateImage(pDestPager, (Pgno )nDestTruncate);
          rc = sqlite3PagerCommitPhaseOne(pDestPager, (char const   *)0, 0);
        }
        if (0 == rc) {
          rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0);
          if (0 == rc) {
            rc = 101;
          }
        }
      }
    }
    if (bCloseTrans) {
      sqlite3BtreeCommitPhaseOne(p->pSrc, (char const   *)0);
      sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
    }
    if (rc == (10 | (12 << 8))) {
      rc = 7;
    }
    p->rc = rc;
  }
  return (rc);
}
}
int sqlite3_backup_finish(sqlite3_backup *p ) 
{ 
  sqlite3_backup **pp ;
  sqlite3 *pSrcDb ;
  int rc ;
  struct Pager *tmp ;

  {
  if ((unsigned long )p == (unsigned long )((sqlite3_backup *)0)) {
    return (0);
  }
  pSrcDb = p->pSrcDb;
  sqlite3BtreeEnter(p->pSrc);
  if (p->pDestDb) {
    ((p->pSrc)->nBackup) --;
  }
  if (p->isAttached) {
    tmp = sqlite3BtreePager(p->pSrc);
    pp = sqlite3PagerBackupPtr(tmp);
    while ((unsigned long )*pp != (unsigned long )p) {
      pp = & (*pp)->pNext;
    }
    *pp = p->pNext;
  }
  sqlite3BtreeRollback(p->pDest, 0, 0);
  if (p->rc == 101) {
    rc = 0;
  } else {
    rc = p->rc;
  }
  if (p->pDestDb) {
    sqlite3Error(p->pDestDb, rc);
    sqlite3LeaveMutexAndCloseZombie(p->pDestDb);
  }
  if (p->pDestDb) {
    sqlite3_free((void *)p);
  }
  sqlite3LeaveMutexAndCloseZombie(pSrcDb);
  return (rc);
}
}
int sqlite3_backup_remaining(sqlite3_backup *p ) 
{ 


  {
  return ((int )p->nRemaining);
}
}
int sqlite3_backup_pagecount(sqlite3_backup *p ) 
{ 


  {
  return ((int )p->nPagecount);
}
}
static void ( __attribute__((__noinline__)) backupUpdate)(sqlite3_backup *p , Pgno iPage ,
                                                          u8 const   *aData ) 
{ 
  int rc ;
  int tmp ;

  {
  while (1) {
    tmp = isFatalError(p->rc);
    if (! tmp) {
      if (iPage < p->iNext) {
        rc = backupOnePage(p, iPage, aData, 1);
        if (rc != 0) {
          p->rc = rc;
        }
      }
    }
    p = p->pNext;
    if (! ((unsigned long )p != (unsigned long )((sqlite3_backup *)0))) {
      break;
    }
  }
  return;
}
}
static void sqlite3BackupUpdate(sqlite3_backup *pBackup , Pgno iPage , u8 const   *aData ) 
{ 


  {
  if (pBackup) {
    backupUpdate(pBackup, iPage, aData);
  }
  return;
}
}
static void sqlite3BackupRestart(sqlite3_backup *pBackup ) 
{ 
  sqlite3_backup *p ;

  {
  p = pBackup;
  while (p) {
    p->iNext = (Pgno )1;
    p = p->pNext;
  }
  return;
}
}
static int sqlite3BtreeCopyFile(Btree *pTo , Btree *pFrom ) 
{ 
  int rc ;
  sqlite3_file *pFd ;
  sqlite3_backup b ;
  struct Pager *tmp ;
  i64 nByte ;
  int tmp___0 ;
  u32 tmp___1 ;
  struct Pager *tmp___2 ;

  {
  sqlite3BtreeEnter(pTo);
  sqlite3BtreeEnter(pFrom);
  tmp = sqlite3BtreePager(pTo);
  pFd = sqlite3PagerFile(tmp);
  if (pFd->pMethods) {
    tmp___0 = sqlite3BtreeGetPageSize(pFrom);
    tmp___1 = sqlite3BtreeLastPage(pFrom);
    nByte = (i64 )tmp___0 * (i64 )tmp___1;
    rc = sqlite3OsFileControl(pFd, 11, (void *)(& nByte));
    if (rc == 12) {
      rc = 0;
    }
    if (rc) {
      goto copy_finished;
    }
  }
  memset((void *)(& b), 0, sizeof(b));
  b.pSrcDb = pFrom->db;
  b.pSrc = pFrom;
  b.pDest = pTo;
  b.iNext = (Pgno )1;
  sqlite3_backup_step(& b, 2147483647);
  rc = sqlite3_backup_finish(& b);
  if (rc == 0) {
    (pTo->pBt)->btsFlags = (u16 )((int )(pTo->pBt)->btsFlags & -3);
  } else {
    tmp___2 = sqlite3BtreePager(b.pDest);
    sqlite3PagerClearCache(tmp___2);
  }
  copy_finished: ;
  return (rc);
}
}
static void vdbeMemRenderNum(int sz , char *zBuf , Mem *p ) 
{ 
  StrAccum acc ;

  {
  sqlite3StrAccumInit(& acc, (sqlite3 *)0, zBuf, sz, 0);
  if ((int )p->flags & 4) {
    sqlite3_str_appendf(& acc, "%lld", p->u.i);
  } else
  if ((int )p->flags & 32) {
    sqlite3_str_appendf(& acc, "%!.15g", (double )p->u.i);
  } else {
    sqlite3_str_appendf(& acc, "%!.15g", p->u.r);
  }
  *(zBuf + acc.nChar) = (char)0;
  return;
}
}
static int sqlite3VdbeChangeEncoding(Mem *pMem , int desiredEnc ) 
{ 
  int rc ;

  {
  if (! ((int )pMem->flags & 2)) {
    return (0);
  } else
  if ((int )pMem->enc == desiredEnc) {
    return (0);
  }
  rc = sqlite3VdbeMemTranslate(pMem, (u8 )desiredEnc);
  return (rc);
}
}
static int ( __attribute__((__noinline__)) sqlite3VdbeMemGrow)(Mem *pMem , int n ,
                                                               int bPreserve ) 
{ 
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  if (pMem->szMalloc > 0) {
    if (bPreserve) {
      if ((unsigned long )pMem->z == (unsigned long )pMem->zMalloc) {
        if (pMem->db) {
          tmp___0 = sqlite3DbReallocOrFree(pMem->db, (void *)pMem->z, (u64 )n);
          tmp = (char *)tmp___0;
          pMem->zMalloc = tmp;
          pMem->z = tmp;
        } else {
          tmp___1 = sqlite3Realloc((void *)pMem->z, (u64 )n);
          pMem->zMalloc = (char *)tmp___1;
          if ((unsigned long )pMem->zMalloc == (unsigned long )((char *)0)) {
            sqlite3_free((void *)pMem->z);
          }
          pMem->z = pMem->zMalloc;
        }
        bPreserve = 0;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (pMem->szMalloc > 0) {
      sqlite3DbFreeNN(pMem->db, (void *)pMem->zMalloc);
    }
    tmp___2 = sqlite3DbMallocRaw(pMem->db, (u64 )n);
    pMem->zMalloc = (char *)tmp___2;
  }
  if ((unsigned long )pMem->zMalloc == (unsigned long )((char *)0)) {
    sqlite3VdbeMemSetNull(pMem);
    pMem->z = (char *)0;
    pMem->szMalloc = 0;
    return (7);
  } else {
    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, (void *)pMem->zMalloc);
  }
  if (bPreserve) {
    if (pMem->z) {
      memcpy((void * __restrict  )pMem->zMalloc, (void const   * __restrict  )pMem->z,
             (size_t )pMem->n);
    }
  }
  if (((int )pMem->flags & 1024) != 0) {
    (*(pMem->xDel))((void *)pMem->z);
  }
  pMem->z = pMem->zMalloc;
  pMem->flags = (u16 )((int )pMem->flags & -7169);
  return (0);
}
}
static int sqlite3VdbeMemClearAndResize(Mem *pMem , int szNew ) 
{ 
  int tmp ;

  {
  if (pMem->szMalloc < szNew) {
    tmp = sqlite3VdbeMemGrow(pMem, szNew, 0);
    return (tmp);
  }
  pMem->z = pMem->zMalloc;
  pMem->flags = (u16 )((int )pMem->flags & 45);
  return (0);
}
}
static int ( __attribute__((__noinline__)) vdbeMemAddTerminator)(Mem *pMem ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeMemGrow(pMem, pMem->n + 3, 1);
  if (tmp) {
    return (7);
  }
  *(pMem->z + pMem->n) = (char)0;
  *(pMem->z + (pMem->n + 1)) = (char)0;
  *(pMem->z + (pMem->n + 2)) = (char)0;
  pMem->flags = (u16 )((int )pMem->flags | 512);
  return (0);
}
}
static int sqlite3VdbeMemMakeWriteable(Mem *pMem ) 
{ 
  int tmp ;
  int tmp___0 ;
  int rc ;
  int tmp___1 ;

  {
  if (((int )pMem->flags & 18) != 0) {
    if ((int )pMem->flags & 16384) {
      tmp = sqlite3VdbeMemExpandBlob(pMem);
      tmp___0 = tmp;
    } else {
      tmp___0 = 0;
    }
    if (tmp___0) {
      return (7);
    }
    if (pMem->szMalloc == 0) {
      goto _L;
    } else
    if ((unsigned long )pMem->z != (unsigned long )pMem->zMalloc) {
      _L: /* CIL Label */ 
      tmp___1 = vdbeMemAddTerminator(pMem);
      rc = tmp___1;
      if (rc) {
        return (rc);
      }
    }
  }
  pMem->flags = (u16 )((int )pMem->flags & -4097);
  return (0);
}
}
static int sqlite3VdbeMemExpandBlob(Mem *pMem ) 
{ 
  int nByte ;
  int tmp ;

  {
  nByte = pMem->n + pMem->u.nZero;
  if (nByte <= 0) {
    if (((int )pMem->flags & 16) == 0) {
      return (0);
    }
    nByte = 1;
  }
  tmp = sqlite3VdbeMemGrow(pMem, nByte, 1);
  if (tmp) {
    return (7);
  }
  memset((void *)(pMem->z + pMem->n), 0, (size_t )pMem->u.nZero);
  pMem->n += pMem->u.nZero;
  pMem->flags = (u16 )((int )pMem->flags & -16897);
  return (0);
}
}
static int sqlite3VdbeMemNulTerminate(Mem *pMem ) 
{ 
  int tmp ;

  {
  if (((int )pMem->flags & 514) != 2) {
    return (0);
  } else {
    tmp = vdbeMemAddTerminator(pMem);
    return (tmp);
  }
}
}
static int sqlite3VdbeMemStringify(Mem *pMem , u8 enc , u8 bForce ) 
{ 
  int nByte ;
  int tmp ;
  size_t tmp___0 ;

  {
  nByte = 32;
  tmp = sqlite3VdbeMemClearAndResize(pMem, nByte);
  if (tmp) {
    pMem->enc = (u8 )0;
    return (7);
  }
  vdbeMemRenderNum(nByte, pMem->z, pMem);
  tmp___0 = strlen((char const   *)pMem->z);
  pMem->n = (int )(tmp___0 & 1073741823UL);
  pMem->enc = (u8 )1;
  pMem->flags = (u16 )((int )pMem->flags | 514);
  if (bForce) {
    pMem->flags = (u16 )((int )pMem->flags & -45);
  }
  sqlite3VdbeChangeEncoding(pMem, (int )enc);
  return (0);
}
}
static int sqlite3VdbeMemFinalize(Mem *pMem , FuncDef *pFunc ) 
{ 
  sqlite3_context ctx ;
  Mem t ;

  {
  memset((void *)(& ctx), 0, sizeof(ctx));
  memset((void *)(& t), 0, sizeof(t));
  t.flags = (u16 )1;
  t.db = pMem->db;
  ctx.pOut = & t;
  ctx.pMem = pMem;
  ctx.pFunc = pFunc;
  (*(pFunc->xFinalize))(& ctx);
  if (pMem->szMalloc > 0) {
    sqlite3DbFreeNN(pMem->db, (void *)pMem->zMalloc);
  }
  memcpy((void * __restrict  )pMem, (void const   * __restrict  )(& t), sizeof(t));
  return (ctx.isError);
}
}
static int sqlite3VdbeMemAggValue(Mem *pAccum , Mem *pOut , FuncDef *pFunc ) 
{ 
  sqlite3_context ctx ;
  Mem t ;

  {
  memset((void *)(& ctx), 0, sizeof(ctx));
  memset((void *)(& t), 0, sizeof(t));
  t.flags = (u16 )1;
  t.db = pAccum->db;
  sqlite3VdbeMemSetNull(pOut);
  ctx.pOut = pOut;
  ctx.pMem = pAccum;
  ctx.pFunc = pFunc;
  (*(pFunc->xValue))(& ctx);
  return (ctx.isError);
}
}
static void ( __attribute__((__noinline__)) vdbeMemClearExternAndSetNull)(Mem *p ) 
{ 


  {
  if ((int )p->flags & 8192) {
    sqlite3VdbeMemFinalize(p, p->u.pDef);
  }
  if ((int )p->flags & 1024) {
    (*(p->xDel))((void *)p->z);
  }
  p->flags = (u16 )1;
  return;
}
}
static void ( __attribute__((__noinline__)) vdbeMemClear)(Mem *p ) 
{ 


  {
  if (((int )p->flags & 9216) != 0) {
    vdbeMemClearExternAndSetNull(p);
  }
  if (p->szMalloc) {
    sqlite3DbFreeNN(p->db, (void *)p->zMalloc);
    p->szMalloc = 0;
  }
  p->z = (char *)0;
  return;
}
}
static void sqlite3VdbeMemRelease(Mem *p ) 
{ 


  {
  if (((int )p->flags & 9216) != 0) {
    vdbeMemClear(p);
  } else
  if (p->szMalloc) {
    vdbeMemClear(p);
  }
  return;
}
}
static i64 ( __attribute__((__noinline__)) doubleToInt64)(double r ) ;
static long long const   maxInt  =    (i64 const   )(4294967295LL | (2147483647LL << 32));
static long long const   minInt  =    (i64 const   )(-1LL - (4294967295LL | (2147483647LL << 32)));
static i64 ( __attribute__((__noinline__)) doubleToInt64)(double r ) 
{ 


  {
  if (r <= (double )minInt) {
    return ((i64 )minInt);
  } else
  if (r >= (double )maxInt) {
    return ((i64 )maxInt);
  } else {
    return ((i64 )r);
  }
}
}
static i64 ( __attribute__((__noinline__)) memIntValue)(Mem *pMem ) 
{ 
  i64 value ;

  {
  value = (i64 )0;
  sqlite3Atoi64((char const   *)pMem->z, & value, pMem->n, pMem->enc);
  return (value);
}
}
static i64 sqlite3VdbeIntValue(Mem *pMem ) 
{ 
  int flags___0 ;
  i64 tmp ;
  i64 tmp___0 ;

  {
  flags___0 = (int )pMem->flags;
  if (flags___0 & 36) {
    return (pMem->u.i);
  } else
  if (flags___0 & 8) {
    tmp = doubleToInt64(pMem->u.r);
    return (tmp);
  } else
  if (flags___0 & 18) {
    tmp___0 = memIntValue(pMem);
    return (tmp___0);
  } else {
    return ((i64 )0);
  }
}
}
static double ( __attribute__((__noinline__)) memRealValue)(Mem *pMem ) 
{ 
  double val ;

  {
  val = (double )0;
  sqlite3AtoF((char const   *)pMem->z, & val, pMem->n, pMem->enc);
  return (val);
}
}
static double sqlite3VdbeRealValue(Mem *pMem ) 
{ 
  double tmp ;

  {
  if ((int )pMem->flags & 8) {
    return (pMem->u.r);
  } else
  if ((int )pMem->flags & 36) {
    return ((double )pMem->u.i);
  } else
  if ((int )pMem->flags & 18) {
    tmp = memRealValue(pMem);
    return (tmp);
  } else {
    return ((double )0);
  }
}
}
static int sqlite3VdbeBooleanValue(Mem *pMem , int ifNull ) 
{ 
  double tmp ;

  {
  if ((int )pMem->flags & 36) {
    return (pMem->u.i != 0LL);
  }
  if ((int )pMem->flags & 1) {
    return (ifNull);
  }
  tmp = sqlite3VdbeRealValue(pMem);
  return (tmp != 0.0);
}
}
static void sqlite3VdbeIntegerAffinity(Mem *pMem ) 
{ 
  i64 ix ;

  {
  ix = doubleToInt64(pMem->u.r);
  if (pMem->u.r == (double )ix) {
    if (ix > -1LL - (4294967295LL | (2147483647LL << 32))) {
      if (ix < (4294967295LL | (2147483647LL << 32))) {
        pMem->u.i = ix;
        pMem->flags = (u16 )(((int )pMem->flags & -49600) | 4);
      }
    }
  }
  return;
}
}
static int sqlite3VdbeMemIntegerify(Mem *pMem ) 
{ 


  {
  pMem->u.i = sqlite3VdbeIntValue(pMem);
  pMem->flags = (u16 )(((int )pMem->flags & -49600) | 4);
  return (0);
}
}
static int sqlite3VdbeMemRealify(Mem *pMem ) 
{ 


  {
  pMem->u.r = sqlite3VdbeRealValue(pMem);
  pMem->flags = (u16 )(((int )pMem->flags & -49600) | 8);
  return (0);
}
}
static int sqlite3RealSameAsInt(double r1 , sqlite_int64 i ) 
{ 
  double r2 ;
  int tmp ;
  int tmp___0 ;

  {
  r2 = (double )i;
  if (r1 == 0.0) {
    tmp___0 = 1;
  } else {
    tmp = memcmp((void const   *)(& r1), (void const   *)(& r2), sizeof(r1));
    if (tmp == 0) {
      if (i >= -2251799813685248LL) {
        if (i < 2251799813685248LL) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
static int sqlite3VdbeMemNumerify(Mem *pMem ) 
{ 
  int rc ;
  sqlite_int64 ix ;
  int tmp ;
  int tmp___0 ;

  {
  if (((int )pMem->flags & 45) == 0) {
    rc = sqlite3AtoF((char const   *)pMem->z, & pMem->u.r, pMem->n, pMem->enc);
    if (rc == 0) {
      goto _L___0;
    } else
    if (rc == 1) {
      _L___0: /* CIL Label */ 
      tmp = sqlite3Atoi64((char const   *)pMem->z, & ix, pMem->n, pMem->enc);
      if (tmp <= 1) {
        pMem->u.i = ix;
        pMem->flags = (u16 )(((int )pMem->flags & -49600) | 4);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      ix = (i64 )pMem->u.r;
      tmp___0 = sqlite3RealSameAsInt(pMem->u.r, ix);
      if (tmp___0) {
        pMem->u.i = ix;
        pMem->flags = (u16 )(((int )pMem->flags & -49600) | 4);
      } else {
        pMem->flags = (u16 )(((int )pMem->flags & -49600) | 8);
      }
    }
  }
  pMem->flags = (u16 )((int )pMem->flags & -16403);
  return (0);
}
}
static void sqlite3VdbeMemCast(Mem *pMem , u8 aff , u8 encoding ) 
{ 


  {
  if ((int )pMem->flags & 1) {
    return;
  }
  switch ((int )aff) {
  case 65: 
  if (((int )pMem->flags & 16) == 0) {
    sqlite3ValueApplyAffinity(pMem, (u8 )66, encoding);
    if ((int )pMem->flags & 2) {
      pMem->flags = (u16 )(((int )pMem->flags & -49600) | 16);
    }
  } else {
    pMem->flags = (u16 )((int )pMem->flags & -49584);
  }
  break;
  case 67: 
  sqlite3VdbeMemNumerify(pMem);
  break;
  case 68: 
  sqlite3VdbeMemIntegerify(pMem);
  break;
  case 69: 
  sqlite3VdbeMemRealify(pMem);
  break;
  default: 
  pMem->flags = (u16 )((int )pMem->flags | (((int )pMem->flags & 16) >> 3));
  sqlite3ValueApplyAffinity(pMem, (u8 )66, encoding);
  pMem->flags = (u16 )((int )pMem->flags & -16445);
  break;
  }
  return;
}
}
static void sqlite3VdbeMemInit(Mem *pMem , sqlite3 *db , u16 flags___0 ) 
{ 


  {
  pMem->flags = flags___0;
  pMem->db = db;
  pMem->szMalloc = 0;
  return;
}
}
static void sqlite3VdbeMemSetNull(Mem *pMem ) 
{ 


  {
  if (((int )pMem->flags & 9216) != 0) {
    vdbeMemClearExternAndSetNull(pMem);
  } else {
    pMem->flags = (u16 )1;
  }
  return;
}
}
static void sqlite3ValueSetNull(sqlite3_value *p ) 
{ 


  {
  sqlite3VdbeMemSetNull(p);
  return;
}
}
static void sqlite3VdbeMemSetZeroBlob(Mem *pMem , int n ) 
{ 


  {
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = (u16 )16400;
  pMem->n = 0;
  if (n < 0) {
    n = 0;
  }
  pMem->u.nZero = n;
  pMem->enc = (u8 )1;
  pMem->z = (char *)0;
  return;
}
}
static void ( __attribute__((__noinline__)) vdbeReleaseAndSetInt64)(Mem *pMem , i64 val ) 
{ 


  {
  sqlite3VdbeMemSetNull(pMem);
  pMem->u.i = val;
  pMem->flags = (u16 )4;
  return;
}
}
static void sqlite3VdbeMemSetInt64(Mem *pMem , i64 val ) 
{ 


  {
  if (((int )pMem->flags & 9216) != 0) {
    vdbeReleaseAndSetInt64(pMem, val);
  } else {
    pMem->u.i = val;
    pMem->flags = (u16 )4;
  }
  return;
}
}
static void sqlite3NoopDestructor(void *p ) 
{ 


  {
  return;
}
}
static void sqlite3VdbeMemSetPointer(Mem *pMem , void *pPtr , char const   *zPType ,
                                     void (*xDestructor)(void * ) ) 
{ 


  {
  if (zPType) {
    pMem->u.zPType = zPType;
  } else {
    pMem->u.zPType = "";
  }
  pMem->z = (char *)pPtr;
  pMem->flags = (u16 )34305;
  pMem->eSubtype = (u8 )'p';
  if (xDestructor) {
    pMem->xDel = xDestructor;
  } else {
    pMem->xDel = & sqlite3NoopDestructor;
  }
  return;
}
}
static void sqlite3VdbeMemSetDouble(Mem *pMem , double val ) 
{ 
  int tmp ;

  {
  sqlite3VdbeMemSetNull(pMem);
  tmp = sqlite3IsNaN(val);
  if (! tmp) {
    pMem->u.r = val;
    pMem->flags = (u16 )8;
  }
  return;
}
}
static int sqlite3VdbeMemSetRowSet(Mem *pMem ) 
{ 
  sqlite3 *db ;
  RowSet *p ;

  {
  db = pMem->db;
  sqlite3VdbeMemRelease(pMem);
  p = sqlite3RowSetInit(db);
  if ((unsigned long )p == (unsigned long )((RowSet *)0)) {
    return (7);
  }
  pMem->z = (char *)p;
  pMem->flags = (u16 )1040;
  pMem->xDel = & sqlite3RowSetDelete;
  return (0);
}
}
static int sqlite3VdbeMemTooBig(Mem *p ) 
{ 
  int n ;

  {
  if ((int )p->flags & 18) {
    n = p->n;
    if ((int )p->flags & 16384) {
      n += p->u.nZero;
    }
    return (n > (p->db)->aLimit[0]);
  }
  return (0);
}
}
static void ( __attribute__((__noinline__)) vdbeClrCopy)(Mem *pTo , Mem const   *pFrom ,
                                                         int eType ) 
{ 


  {
  vdbeMemClearExternAndSetNull(pTo);
  sqlite3VdbeMemShallowCopy(pTo, pFrom, eType);
  return;
}
}
static void sqlite3VdbeMemShallowCopy(Mem *pTo , Mem const   *pFrom , int srcType ) 
{ 


  {
  if (((int )pTo->flags & 9216) != 0) {
    vdbeClrCopy(pTo, pFrom, srcType);
    return;
  }
  memcpy((void * __restrict  )pTo, (void const   * __restrict  )pFrom, (unsigned long )(& ((Mem *)0)->zMalloc));
  if (((int const   )pFrom->flags & 2048) == 0) {
    pTo->flags = (u16 )((int )pTo->flags & -7169);
    pTo->flags = (u16 )((int )pTo->flags | srcType);
  }
  return;
}
}
static int sqlite3VdbeMemCopy(Mem *pTo , Mem const   *pFrom ) 
{ 
  int rc ;

  {
  rc = 0;
  if (((int )pTo->flags & 9216) != 0) {
    vdbeMemClearExternAndSetNull(pTo);
  }
  memcpy((void * __restrict  )pTo, (void const   * __restrict  )pFrom, (unsigned long )(& ((Mem *)0)->zMalloc));
  pTo->flags = (u16 )((int )pTo->flags & -1025);
  if ((int )pTo->flags & 18) {
    if (0 == (int )((int const   )pFrom->flags & 2048)) {
      pTo->flags = (u16 )((int )pTo->flags | 4096);
      rc = sqlite3VdbeMemMakeWriteable(pTo);
    }
  }
  return (rc);
}
}
static void sqlite3VdbeMemMove(Mem *pTo , Mem *pFrom ) 
{ 


  {
  sqlite3VdbeMemRelease(pTo);
  memcpy((void * __restrict  )pTo, (void const   * __restrict  )pFrom, sizeof(Mem ));
  pFrom->flags = (u16 )1;
  pFrom->szMalloc = 0;
  return;
}
}
static int sqlite3VdbeMemSetStr(Mem *pMem , char const   *z , int n , u8 enc , void (*xDel)(void * ) ) 
{ 
  int nByte ;
  int iLimit ;
  u16 flags___0 ;
  size_t tmp ;
  u32 nAlloc ;
  int tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  nByte = n;
  flags___0 = (u16 )0;
  if (! z) {
    sqlite3VdbeMemSetNull(pMem);
    return (0);
  }
  if (pMem->db) {
    iLimit = (pMem->db)->aLimit[0];
  } else {
    iLimit = 1000000000;
  }
  if ((int )enc == 0) {
    flags___0 = (u16 )16;
  } else {
    flags___0 = (u16 )2;
  }
  if (nByte < 0) {
    if ((int )enc == 1) {
      tmp = strlen(z);
      nByte = 2147483647 & (int )tmp;
    } else {
      nByte = 0;
      while (1) {
        if (nByte <= iLimit) {
          if (! ((int const   )*(z + nByte) | (int const   )*(z + (nByte + 1)))) {
            break;
          }
        } else {
          break;
        }
        nByte += 2;
      }
    }
    flags___0 = (u16 )((int )flags___0 | 512);
  }
  if ((unsigned long )xDel == (unsigned long )((void (*)(void * ))-1)) {
    nAlloc = (u32 )nByte;
    if ((int )flags___0 & 512) {
      if ((int )enc == 1) {
        tmp___0 = 1;
      } else {
        tmp___0 = 2;
      }
      nAlloc += (u32 )tmp___0;
    }
    if (nByte > iLimit) {
      tmp___1 = sqlite3ErrorToParser(pMem->db, 18);
      return (tmp___1);
    }
    if (nAlloc > 32U) {
      tmp___2 = nAlloc;
    } else {
      tmp___2 = (u32 )32;
    }
    tmp___3 = sqlite3VdbeMemClearAndResize(pMem, (int )tmp___2);
    if (tmp___3) {
      return (7);
    }
    memcpy((void * __restrict  )pMem->z, (void const   * __restrict  )z, (size_t )nAlloc);
  } else {
    sqlite3VdbeMemRelease(pMem);
    pMem->z = (char *)z;
    if ((unsigned long )xDel == (unsigned long )((void (*)(void * ))(& sqlite3MallocSize))) {
      pMem->zMalloc = pMem->z;
      pMem->szMalloc = sqlite3DbMallocSize(pMem->db, (void *)pMem->zMalloc);
    } else {
      pMem->xDel = xDel;
      if ((unsigned long )xDel == (unsigned long )((void (*)(void * ))0)) {
        tmp___4 = 2048;
      } else {
        tmp___4 = 1024;
      }
      flags___0 = (u16 )((int )flags___0 | tmp___4);
    }
  }
  pMem->n = nByte;
  pMem->flags = flags___0;
  if ((int )enc == 0) {
    pMem->enc = (u8 )1;
  } else {
    pMem->enc = enc;
  }
  if ((int )pMem->enc != 1) {
    tmp___5 = sqlite3VdbeMemHandleBom(pMem);
    if (tmp___5) {
      return (7);
    }
  }
  if (nByte > iLimit) {
    return (18);
  }
  return (0);
}
}
static int ( __attribute__((__noinline__)) vdbeMemFromBtreeResize)(BtCursor *pCur ,
                                                                   u32 offset , u32 amt ,
                                                                   Mem *pMem ) 
{ 
  int rc ;
  int tmp ;
  sqlite_int64 tmp___0 ;

  {
  pMem->flags = (u16 )1;
  tmp___0 = sqlite3BtreeMaxRecordSize(pCur);
  if (tmp___0 < (sqlite_int64 )(offset + amt)) {
    tmp = sqlite3CorruptError(75818);
    return (tmp);
  }
  rc = sqlite3VdbeMemClearAndResize(pMem, (int )(amt + 1U));
  if (0 == rc) {
    rc = sqlite3BtreePayload(pCur, offset, amt, (void *)pMem->z);
    if (rc == 0) {
      *(pMem->z + amt) = (char)0;
      pMem->flags = (u16 )16;
      pMem->n = (int )amt;
    } else {
      sqlite3VdbeMemRelease(pMem);
    }
  }
  return (rc);
}
}
static int sqlite3VdbeMemFromBtree(BtCursor *pCur , u32 offset , u32 amt , Mem *pMem ) 
{ 
  char *zData ;
  u32 available ;
  int rc ;
  void const   *tmp ;

  {
  available = (u32 )0;
  rc = 0;
  tmp = sqlite3BtreePayloadFetch(pCur, & available);
  zData = (char *)tmp;
  if (offset + amt <= available) {
    pMem->z = zData + offset;
    pMem->flags = (u16 )4112;
    pMem->n = (int )amt;
  } else {
    rc = vdbeMemFromBtreeResize(pCur, offset, amt, pMem);
  }
  return (rc);
}
}
static void const   *( __attribute__((__noinline__)) valueToText)(sqlite3_value *pVal ,
                                                                  u8 enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )pVal->flags & 18) {
    if ((int )pVal->flags & 16384) {
      tmp = sqlite3VdbeMemExpandBlob(pVal);
      tmp___0 = tmp;
    } else {
      tmp___0 = 0;
    }
    if (tmp___0) {
      return ((void const   *)0);
    }
    pVal->flags = (u16 )((int )pVal->flags | 2);
    if ((int )pVal->enc != ((int )enc & -9)) {
      sqlite3VdbeChangeEncoding(pVal, (int )enc & -9);
    }
    if (((int )enc & 8) != 0) {
      if (1 == (1 & (int )((long )pVal->z))) {
        tmp___1 = sqlite3VdbeMemMakeWriteable(pVal);
        if (tmp___1 != 0) {
          return ((void const   *)0);
        }
      }
    }
    sqlite3VdbeMemNulTerminate(pVal);
  } else {
    sqlite3VdbeMemStringify(pVal, enc, (u8 )0);
  }
  if ((int )pVal->enc == ((int )enc & -9)) {
    return ((void const   *)pVal->z);
  } else {
    return ((void const   *)0);
  }
}
}
static void const   *sqlite3ValueText(sqlite3_value *pVal , u8 enc ) 
{ 
  void const   *tmp ;

  {
  if (! pVal) {
    return ((void const   *)0);
  }
  if (((int )pVal->flags & 514) == 514) {
    if ((int )pVal->enc == (int )enc) {
      return ((void const   *)pVal->z);
    }
  }
  if ((int )pVal->flags & 1) {
    return ((void const   *)0);
  }
  tmp = valueToText(pVal, enc);
  return (tmp);
}
}
static sqlite3_value *sqlite3ValueNew(sqlite3 *db ) 
{ 
  Mem *p ;
  void *tmp ;

  {
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(*p));
  p = (Mem *)tmp;
  if (p) {
    p->flags = (u16 )1;
    p->db = db;
  }
  return (p);
}
}
static sqlite3_value *valueNew(sqlite3 *db , struct ValueNewStat4Ctx *p ) 
{ 
  sqlite3_value *tmp ;

  {
  tmp = sqlite3ValueNew(db);
  return (tmp);
}
}
static int valueFromExpr(sqlite3 *db , Expr *pExpr , u8 enc , u8 affinity , sqlite3_value **ppVal ,
                         struct ValueNewStat4Ctx *pCtx ) 
{ 
  int op ;
  char *zVal ;
  sqlite3_value *pVal ;
  int negInt ;
  char const   *zNeg ;
  int rc ;
  u8 aff ;
  char tmp ;
  int tmp___0 ;
  int nVal ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  zVal = (char *)0;
  pVal = (sqlite3_value *)0;
  negInt = 1;
  zNeg = "";
  rc = 0;
  while (1) {
    op = (int )pExpr->op;
    if (! (op == 169)) {
      if (! (op == 176)) {
        break;
      }
    }
    pExpr = pExpr->pLeft;
  }
  if (op == 171) {
    op = (int )pExpr->op2;
  }
  if (op == 36) {
    tmp = sqlite3AffinityType((char const   *)pExpr->u.zToken, (Column *)0);
    aff = (u8 )tmp;
    rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
    if (*ppVal) {
      sqlite3VdbeMemCast(*ppVal, aff, (u8 )1);
      sqlite3ValueApplyAffinity(*ppVal, affinity, (u8 )1);
    }
    return (rc);
  }
  if (op == 168) {
    if ((int )(pExpr->pLeft)->op == 150) {
      pExpr = pExpr->pLeft;
      op = (int )pExpr->op;
      negInt = -1;
      zNeg = "-";
    } else
    if ((int )(pExpr->pLeft)->op == 148) {
      pExpr = pExpr->pLeft;
      op = (int )pExpr->op;
      negInt = -1;
      zNeg = "-";
    }
  }
  if (op == 113) {
    goto _L___0;
  } else
  if (op == 148) {
    goto _L___0;
  } else
  if (op == 150) {
    _L___0: /* CIL Label */ 
    pVal = valueNew(db, pCtx);
    if ((unsigned long )pVal == (unsigned long )((sqlite3_value *)0)) {
      goto no_mem;
    }
    if ((pExpr->flags & 1024U) != 0U) {
      sqlite3VdbeMemSetInt64(pVal, (i64 )pExpr->u.iValue * (i64 )negInt);
    } else {
      zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
      if ((unsigned long )zVal == (unsigned long )((char *)0)) {
        goto no_mem;
      }
      sqlite3ValueSetStr(pVal, -1, (void const   *)zVal, (u8 )1, (void (*)(void * ))(& sqlite3MallocSize));
    }
    if (op == 150) {
      goto _L;
    } else
    if (op == 148) {
      _L: /* CIL Label */ 
      if ((int )affinity == 65) {
        sqlite3ValueApplyAffinity(pVal, (u8 )67, (u8 )1);
      } else {
        sqlite3ValueApplyAffinity(pVal, affinity, (u8 )1);
      }
    } else {
      sqlite3ValueApplyAffinity(pVal, affinity, (u8 )1);
    }
    if ((int )pVal->flags & 44) {
      pVal->flags = (u16 )((int )pVal->flags & -3);
    }
    if ((int )enc != 1) {
      rc = sqlite3VdbeChangeEncoding(pVal, (int )enc);
    }
  } else
  if (op == 168) {
    tmp___0 = valueFromExpr(db, pExpr->pLeft, enc, affinity, & pVal, pCtx);
    if (0 == tmp___0) {
      if ((unsigned long )pVal != (unsigned long )((sqlite3_value *)0)) {
        sqlite3VdbeMemNumerify(pVal);
        if ((int )pVal->flags & 8) {
          pVal->u.r = - pVal->u.r;
        } else
        if (pVal->u.i == -1LL - (4294967295LL | (2147483647LL << 32))) {
          pVal->u.r = - ((double )(-1LL - (4294967295LL | (2147483647LL << 32))));
          pVal->flags = (u16 )(((int )pVal->flags & -49600) | 8);
        } else {
          pVal->u.i = - pVal->u.i;
        }
        sqlite3ValueApplyAffinity(pVal, affinity, enc);
      }
    }
  } else
  if (op == 117) {
    pVal = valueNew(db, pCtx);
    if ((unsigned long )pVal == (unsigned long )((sqlite3_value *)0)) {
      goto no_mem;
    }
    sqlite3VdbeMemSetNull(pVal);
  } else
  if (op == 149) {
    pVal = valueNew(db, pCtx);
    if (! pVal) {
      goto no_mem;
    }
    zVal = pExpr->u.zToken + 2;
    tmp___1 = sqlite3Strlen30((char const   *)zVal);
    nVal = tmp___1 - 1;
    tmp___2 = sqlite3HexToBlob(db, (char const   *)zVal, nVal);
    sqlite3VdbeMemSetStr(pVal, (char const   *)tmp___2, nVal / 2, (u8 )0, (void (*)(void * ))(& sqlite3MallocSize));
  } else
  if (op == 165) {
    pVal = valueNew(db, pCtx);
    if (pVal) {
      pVal->flags = (u16 )4;
      pVal->u.i = (i64 )((int )*(pExpr->u.zToken + 4) == 0);
    }
  }
  *ppVal = pVal;
  return (rc);
  no_mem: 
  sqlite3OomFault(db);
  sqlite3DbFree(db, (void *)zVal);
  sqlite3ValueFree(pVal);
  return (7);
}
}
static int sqlite3ValueFromExpr(sqlite3 *db , Expr *pExpr , u8 enc , u8 affinity ,
                                sqlite3_value **ppVal ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (pExpr) {
    tmp = valueFromExpr(db, pExpr, enc, affinity, ppVal, (struct ValueNewStat4Ctx *)0);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static void sqlite3ValueSetStr(sqlite3_value *v , int n , void const   *z , u8 enc ,
                               void (*xDel)(void * ) ) 
{ 


  {
  if (v) {
    sqlite3VdbeMemSetStr(v, (char const   *)z, n, enc, xDel);
  }
  return;
}
}
static void sqlite3ValueFree(sqlite3_value *v ) 
{ 


  {
  if (! v) {
    return;
  }
  sqlite3VdbeMemRelease(v);
  sqlite3DbFreeNN(v->db, (void *)v);
  return;
}
}
static int ( __attribute__((__noinline__)) valueBytes)(sqlite3_value *pVal , u8 enc ) 
{ 
  int tmp___0 ;
  void const   *tmp___1 ;

  {
  tmp___1 = valueToText(pVal, enc);
  if ((unsigned long )tmp___1 != (unsigned long )((void const   *)0)) {
    tmp___0 = pVal->n;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3ValueBytes(sqlite3_value *pVal , u8 enc ) 
{ 
  Mem *p ;
  int tmp ;

  {
  p = pVal;
  if (((int )p->flags & 2) != 0) {
    if ((int )pVal->enc == (int )enc) {
      return (p->n);
    }
  }
  if (((int )p->flags & 16) != 0) {
    if ((int )p->flags & 16384) {
      return (p->n + p->u.nZero);
    } else {
      return (p->n);
    }
  }
  if ((int )p->flags & 1) {
    return (0);
  }
  tmp = valueBytes(pVal, enc);
  return (tmp);
}
}
static Vdbe *sqlite3VdbeCreate(Parse *pParse ) 
{ 
  sqlite3 *db ;
  Vdbe *p ;
  void *tmp ;

  {
  db = pParse->db;
  tmp = sqlite3DbMallocRawNN(db, (u64 )sizeof(Vdbe ));
  p = (Vdbe *)tmp;
  if ((unsigned long )p == (unsigned long )((Vdbe *)0)) {
    return ((Vdbe *)0);
  }
  memset((void *)(& p->aOp), 0, sizeof(Vdbe ) - (unsigned long )(& ((Vdbe *)0)->aOp));
  p->db = db;
  if (db->pVdbe) {
    (db->pVdbe)->pPrev = p;
  }
  p->pNext = db->pVdbe;
  p->pPrev = (Vdbe *)0;
  db->pVdbe = p;
  p->magic = (u32 )381479589;
  p->pParse = pParse;
  pParse->pVdbe = p;
  sqlite3VdbeAddOp2(p, 61, 0, 1);
  return (p);
}
}
static void sqlite3VdbeError(Vdbe *p , char const   *zFormat  , ...) 
{ 
  va_list ap ;

  {
  sqlite3DbFree(p->db, (void *)p->zErrMsg);
  __builtin_va_start(ap, zFormat);
  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);
  __builtin_va_end(ap);
  return;
}
}
static void sqlite3VdbeSetSql(Vdbe *p , char const   *z , int n , u8 prepFlags ) 
{ 


  {
  if ((unsigned long )p == (unsigned long )((Vdbe *)0)) {
    return;
  }
  p->prepFlags = prepFlags;
  if (((int )prepFlags & 128) == 0) {
    p->expmask = (u32 )0;
  }
  p->zSql = sqlite3DbStrNDup(p->db, z, (u64 )n);
  return;
}
}
static void sqlite3VdbeSwap(Vdbe *pA , Vdbe *pB ) 
{ 
  Vdbe tmp ;
  Vdbe *pTmp ;
  char *zTmp ;

  {
  tmp = *pA;
  *pA = *pB;
  *pB = tmp;
  pTmp = pA->pNext;
  pA->pNext = pB->pNext;
  pB->pNext = pTmp;
  pTmp = pA->pPrev;
  pA->pPrev = pB->pPrev;
  pB->pPrev = pTmp;
  zTmp = pA->zSql;
  pA->zSql = pB->zSql;
  pB->zSql = zTmp;
  pB->expmask = pA->expmask;
  pB->prepFlags = pA->prepFlags;
  memcpy((void * __restrict  )(pB->aCounter), (void const   * __restrict  )(pA->aCounter),
         sizeof(pB->aCounter));
  (pB->aCounter[5]) ++;
  return;
}
}
static int growOpArray(Vdbe *v , int nOp ) 
{ 
  VdbeOp *pNew ;
  Parse *p ;
  sqlite_int64 nNew ;
  sqlite_int64 tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  p = v->pParse;
  if (v->nOpAlloc) {
    tmp = 2LL * (sqlite_int64 )v->nOpAlloc;
  } else {
    tmp = (sqlite_int64 )(1024UL / sizeof(Op ));
  }
  nNew = tmp;
  if (nNew > (sqlite_int64 )(p->db)->aLimit[5]) {
    sqlite3OomFault(p->db);
    return (7);
  }
  tmp___0 = sqlite3DbRealloc(p->db, (void *)v->aOp, (unsigned long long )nNew * (unsigned long long )sizeof(Op ));
  pNew = (VdbeOp *)tmp___0;
  if (pNew) {
    p->szOpAlloc = sqlite3DbMallocSize(p->db, (void *)pNew);
    v->nOpAlloc = (int )((unsigned long )p->szOpAlloc / sizeof(Op ));
    v->aOp = pNew;
  }
  if (pNew) {
    tmp___1 = 0;
  } else {
    tmp___1 = 7;
  }
  return (tmp___1);
}
}
static int ( __attribute__((__noinline__)) growOp3)(Vdbe *p , int op , int p1 , int p2 ,
                                                    int p3 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = growOpArray(p, 1);
  if (tmp) {
    return (1);
  }
  tmp___0 = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  return (tmp___0);
}
}
static int sqlite3VdbeAddOp3(Vdbe *p , int op , int p1 , int p2 , int p3 ) 
{ 
  int i ;
  VdbeOp *pOp ;
  int tmp ;

  {
  i = p->nOp;
  if (p->nOpAlloc <= i) {
    tmp = growOp3(p, op, p1, p2, p3);
    return (tmp);
  }
  (p->nOp) ++;
  pOp = p->aOp + i;
  pOp->opcode = (u8 )op;
  pOp->p5 = (u16 )0;
  pOp->p1 = p1;
  pOp->p2 = p2;
  pOp->p3 = p3;
  pOp->p4.p = (void *)0;
  pOp->p4type = (signed char)0;
  return (i);
}
}
static int sqlite3VdbeAddOp0(Vdbe *p , int op ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeAddOp3(p, op, 0, 0, 0);
  return (tmp);
}
}
static int sqlite3VdbeAddOp1(Vdbe *p , int op , int p1 ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeAddOp3(p, op, p1, 0, 0);
  return (tmp);
}
}
static int sqlite3VdbeAddOp2(Vdbe *p , int op , int p1 , int p2 ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeAddOp3(p, op, p1, p2, 0);
  return (tmp);
}
}
static int sqlite3VdbeGoto(Vdbe *p , int iDest ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeAddOp3(p, 11, 0, iDest, 0);
  return (tmp);
}
}
static int sqlite3VdbeLoadString(Vdbe *p , int iDest , char const   *zStr ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeAddOp4(p, 113, 0, iDest, 0, zStr, 0);
  return (tmp);
}
}
static void sqlite3VdbeMultiLoad(Vdbe *p , int iDest , char const   *zTypes  , ...) 
{ 
  va_list ap ;
  int i ;
  char c ;
  char const   *z ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  __builtin_va_start(ap, zTypes);
  i = 0;
  while (1) {
    c = (char )*(zTypes + i);
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 115) {
      tmp___0 = __builtin_va_arg(ap, char const   *);
      z = tmp___0;
      if ((unsigned long )z == (unsigned long )((char const   *)0)) {
        tmp___1 = 73;
      } else {
        tmp___1 = 113;
      }
      sqlite3VdbeAddOp4(p, tmp___1, 0, iDest + i, 0, z, 0);
    } else
    if ((int )c == 105) {
      tmp___3 = __builtin_va_arg(ap, int );
      sqlite3VdbeAddOp2(p, 70, tmp___3, iDest + i);
    } else {
      goto skip_op_resultrow;
    }
    i ++;
  }
  sqlite3VdbeAddOp2(p, 81, iDest, i);
  skip_op_resultrow: 
  __builtin_va_end(ap);
  return;
}
}
static int sqlite3VdbeAddOp4(Vdbe *p , int op , int p1 , int p2 , int p3 , char const   *zP4 ,
                             int p4type ) 
{ 
  int addr ;
  int tmp ;

  {
  tmp = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  addr = tmp;
  sqlite3VdbeChangeP4(p, addr, zP4, p4type);
  return (addr);
}
}
static int sqlite3VdbeAddOp4Dup8(Vdbe *p , int op , int p1 , int p2 , int p3 , u8 const   *zP4 ,
                                 int p4type ) 
{ 
  char *p4copy ;
  sqlite3 *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3VdbeDb(p);
  tmp___0 = sqlite3DbMallocRawNN(tmp, (u64 )8);
  p4copy = (char *)tmp___0;
  if (p4copy) {
    memcpy((void * __restrict  )p4copy, (void const   * __restrict  )zP4, (size_t )8);
  }
  tmp___1 = sqlite3VdbeAddOp4(p, op, p1, p2, p3, (char const   *)p4copy, p4type);
  return (tmp___1);
}
}
static int sqlite3VdbeExplainParent(Parse *pParse ) 
{ 
  VdbeOp *pOp ;

  {
  if (pParse->addrExplain == 0) {
    return (0);
  }
  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);
  return (pOp->p2);
}
}
static void sqlite3VdbeExplain(Parse *pParse , u8 bPush , char const   *zFmt  , ...) 
{ 
  char *zMsg ;
  Vdbe *v ;
  va_list ap ;
  int iThis ;

  {
  if ((int )pParse->explain == 2) {
    __builtin_va_start(ap, zFmt);
    zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);
    __builtin_va_end(ap);
    v = pParse->pVdbe;
    iThis = v->nOp;
    sqlite3VdbeAddOp4(v, 171, iThis, pParse->addrExplain, 0, (char const   *)zMsg,
                      -7);
    if (bPush) {
      pParse->addrExplain = iThis;
    }
  }
  return;
}
}
static void sqlite3VdbeExplainPop(Parse *pParse ) 
{ 


  {
  pParse->addrExplain = sqlite3VdbeExplainParent(pParse);
  return;
}
}
static void sqlite3VdbeAddParseSchemaOp(Vdbe *p , int iDb , char *zWhere ) 
{ 
  int j ;

  {
  sqlite3VdbeAddOp4(p, 141, iDb, 0, 0, (char const   *)zWhere, -7);
  j = 0;
  while (j < (p->db)->nDb) {
    sqlite3VdbeUsesBtree(p, j);
    j ++;
  }
  return;
}
}
static int sqlite3VdbeAddOp4Int(Vdbe *p , int op , int p1 , int p2 , int p3 , int p4 ) 
{ 
  int addr ;
  int tmp ;
  VdbeOp *pOp ;

  {
  tmp = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  addr = tmp;
  if ((int )(p->db)->mallocFailed == 0) {
    pOp = p->aOp + addr;
    pOp->p4type = (signed char)-3;
    pOp->p4.i = p4;
  }
  return (addr);
}
}
static void sqlite3VdbeEndCoroutine(Vdbe *v , int regYield ) 
{ 


  {
  sqlite3VdbeAddOp1(v, 67, regYield);
  (v->pParse)->nTempReg = (u8 )0;
  (v->pParse)->nRangeReg = 0;
  return;
}
}
static int sqlite3VdbeMakeLabel(Parse *pParse ) 
{ 


  {
  (pParse->nLabel) --;
  return (pParse->nLabel);
}
}
static void ( __attribute__((__noinline__)) resizeResolveLabel)(Parse *p , Vdbe *v ,
                                                                int j ) 
{ 
  int nNewSize ;
  void *tmp ;

  {
  nNewSize = 10 - p->nLabel;
  tmp = sqlite3DbReallocOrFree(p->db, (void *)p->aLabel, (u64 )((unsigned long )nNewSize * sizeof(*(p->aLabel + 0))));
  p->aLabel = (int *)tmp;
  if ((unsigned long )p->aLabel == (unsigned long )((int *)0)) {
    p->nLabelAlloc = 0;
  } else {
    p->nLabelAlloc = nNewSize;
    *(p->aLabel + j) = v->nOp;
  }
  return;
}
}
static void sqlite3VdbeResolveLabel(Vdbe *v , int x___0 ) 
{ 
  Parse *p ;
  int j ;

  {
  p = v->pParse;
  j = ~ x___0;
  if (p->nLabelAlloc + p->nLabel < 0) {
    resizeResolveLabel(p, v, j);
  } else {
    *(p->aLabel + j) = v->nOp;
  }
  return;
}
}
static void sqlite3VdbeRunOnlyOnce(Vdbe *p ) 
{ 


  {
  p->runOnlyOnce = (bft )1;
  return;
}
}
static void sqlite3VdbeReusable(Vdbe *p ) 
{ 


  {
  p->runOnlyOnce = (bft )0;
  return;
}
}
static void resolveP2Values(Vdbe *p , int *pMaxFuncArgs ) 
{ 
  int nMaxArgs ;
  Op *pOp ;
  Parse *pParse ;
  int *aLabel ;
  int n ;

  {
  nMaxArgs = *pMaxFuncArgs;
  pParse = p->pParse;
  aLabel = pParse->aLabel;
  p->readOnly = (bft )1;
  p->bIsReader = (bft )0;
  pOp = p->aOp + (p->nOp - 1);
  while (1) {
    if ((int )pOp->opcode <= 61) {
      switch ((int )pOp->opcode) {
      case 2: 
      if (pOp->p2 != 0) {
        p->readOnly = (bft )0;
      }
      case 0: 
      case 1: 
      p->bIsReader = (bft )1;
      break;
      case 7: 
      case 8: 
      case 6: 
      p->readOnly = (bft )0;
      p->bIsReader = (bft )1;
      break;
      case 3: 
      case 5: 
      pOp->p4.xAdvance = & sqlite3BtreeNext;
      pOp->p4type = (signed char)-5;
      break;
      case 4: 
      pOp->p4.xAdvance = & sqlite3BtreePrevious;
      pOp->p4type = (signed char)-5;
      break;
      case 10: 
      if (pOp->p2 > nMaxArgs) {
        nMaxArgs = pOp->p2;
      }
      break;
      case 9: 
      n = (pOp + -1)->p1;
      if (n > nMaxArgs) {
        nMaxArgs = n;
      }
      default: 
      if (pOp->p2 < 0) {
        pOp->p2 = *(aLabel + ~ pOp->p2);
      }
      break;
      }
    }
    if ((unsigned long )pOp == (unsigned long )p->aOp) {
      break;
    }
    pOp --;
  }
  sqlite3DbFree(p->db, (void *)pParse->aLabel);
  pParse->aLabel = (int *)0;
  pParse->nLabel = 0;
  *pMaxFuncArgs = nMaxArgs;
  return;
}
}
static int sqlite3VdbeCurrentAddr(Vdbe *p ) 
{ 


  {
  return (p->nOp);
}
}
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p , int *pnOp , int *pnMaxArg ) 
{ 
  VdbeOp *aOp___1 ;

  {
  aOp___1 = p->aOp;
  resolveP2Values(p, pnMaxArg);
  *pnOp = p->nOp;
  p->aOp = (Op *)0;
  return (aOp___1);
}
}
static VdbeOp *sqlite3VdbeAddOpList(Vdbe *p , int nOp , VdbeOpList const   *aOp___1 ,
                                    int iLineno ) 
{ 
  int i ;
  VdbeOp *pOut ;
  VdbeOp *pFirst ;
  int tmp ;

  {
  if (p->nOp + nOp > p->nOpAlloc) {
    tmp = growOpArray(p, nOp);
    if (tmp) {
      return ((VdbeOp *)0);
    }
  }
  pOut = p->aOp + p->nOp;
  pFirst = pOut;
  i = 0;
  while (i < nOp) {
    pOut->opcode = (u8 )aOp___1->opcode;
    pOut->p1 = (int )aOp___1->p1;
    pOut->p2 = (int )aOp___1->p2;
    if (((int const   )sqlite3OpcodeProperty[aOp___1->opcode] & 1) != 0) {
      if ((int const   )aOp___1->p2 > 0) {
        pOut->p2 += p->nOp;
      }
    }
    pOut->p3 = (int )aOp___1->p3;
    pOut->p4type = (signed char)0;
    pOut->p4.p = (void *)0;
    pOut->p5 = (u16 )0;
    i ++;
    aOp___1 ++;
    pOut ++;
  }
  p->nOp += nOp;
  return (pFirst);
}
}
static void sqlite3VdbeChangeOpcode(Vdbe *p , int addr , u8 iNewOpcode ) 
{ 
  VdbeOp *tmp ;

  {
  tmp = sqlite3VdbeGetOp(p, addr);
  tmp->opcode = iNewOpcode;
  return;
}
}
static void sqlite3VdbeChangeP1(Vdbe *p , int addr , int val ) 
{ 
  VdbeOp *tmp ;

  {
  tmp = sqlite3VdbeGetOp(p, addr);
  tmp->p1 = val;
  return;
}
}
static void sqlite3VdbeChangeP2(Vdbe *p , int addr , int val ) 
{ 
  VdbeOp *tmp ;

  {
  tmp = sqlite3VdbeGetOp(p, addr);
  tmp->p2 = val;
  return;
}
}
static void sqlite3VdbeChangeP3(Vdbe *p , int addr , int val ) 
{ 
  VdbeOp *tmp ;

  {
  tmp = sqlite3VdbeGetOp(p, addr);
  tmp->p3 = val;
  return;
}
}
static void sqlite3VdbeChangeP5(Vdbe *p , u16 p5 ) 
{ 


  {
  if (p->nOp > 0) {
    (p->aOp + (p->nOp - 1))->p5 = p5;
  }
  return;
}
}
static void sqlite3VdbeJumpHere(Vdbe *p , int addr ) 
{ 


  {
  sqlite3VdbeChangeP2(p, addr, p->nOp);
  return;
}
}
static void freeEphemeralFunction(sqlite3 *db , FuncDef *pDef ) 
{ 


  {
  if ((pDef->funcFlags & 16U) != 0U) {
    sqlite3DbFreeNN(db, (void *)pDef);
  }
  return;
}
}
static void vdbeFreeOpArray(sqlite3 *db , Op *aOp___1 , int nOp ) ;
static void ( __attribute__((__noinline__)) freeP4Mem)(sqlite3 *db , Mem *p ) 
{ 


  {
  if (p->szMalloc) {
    sqlite3DbFree(db, (void *)p->zMalloc);
  }
  sqlite3DbFreeNN(db, (void *)p);
  return;
}
}
static void ( __attribute__((__noinline__)) freeP4FuncCtx)(sqlite3 *db , sqlite3_context *p ) 
{ 


  {
  freeEphemeralFunction(db, p->pFunc);
  sqlite3DbFreeNN(db, (void *)p);
  return;
}
}
static void freeP4(sqlite3 *db , int p4type , void *p4 ) 
{ 


  {
  switch (p4type) {
  case -16: 
  freeP4FuncCtx(db, (sqlite3_context *)p4);
  break;
  case -15: 
  case -17: 
  case -7: 
  case -14: 
  case -13: 
  sqlite3DbFree(db, p4);
  break;
  case -9: 
  if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
    sqlite3KeyInfoUnref((KeyInfo *)p4);
  }
  break;
  case -8: 
  freeEphemeralFunction(db, (FuncDef *)p4);
  break;
  case -11: 
  if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
    sqlite3ValueFree((sqlite3_value *)p4);
  } else {
    freeP4Mem(db, (Mem *)p4);
  }
  break;
  case -12: 
  if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
    sqlite3VtabUnlock((VTable *)p4);
  }
  break;
  }
  return;
}
}
static void vdbeFreeOpArray(sqlite3 *db , Op *aOp___1 , int nOp ) 
{ 
  Op *pOp ;

  {
  if (aOp___1) {
    pOp = aOp___1 + (nOp - 1);
    while ((unsigned long )pOp >= (unsigned long )aOp___1) {
      if ((int )pOp->p4type <= -7) {
        freeP4(db, (int )pOp->p4type, pOp->p4.p);
      }
      pOp --;
    }
    sqlite3DbFreeNN(db, (void *)aOp___1);
  }
  return;
}
}
static void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe , SubProgram *p ) 
{ 


  {
  p->pNext = pVdbe->pProgram;
  pVdbe->pProgram = p;
  return;
}
}
static int sqlite3VdbeChangeToNoop(Vdbe *p , int addr ) 
{ 
  VdbeOp *pOp ;

  {
  if ((p->db)->mallocFailed) {
    return (0);
  }
  pOp = p->aOp + addr;
  freeP4(p->db, (int )pOp->p4type, pOp->p4.p);
  pOp->p4type = (signed char)0;
  pOp->p4.z = (char *)0;
  pOp->opcode = (u8 )170;
  return (1);
}
}
static int sqlite3VdbeDeletePriorOpcode(Vdbe *p , u8 op ) 
{ 
  int tmp ;

  {
  if (p->nOp > 0) {
    if ((int )(p->aOp + (p->nOp - 1))->opcode == (int )op) {
      tmp = sqlite3VdbeChangeToNoop(p, p->nOp - 1);
      return (tmp);
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
static void ( __attribute__((__noinline__)) vdbeChangeP4Full)(Vdbe *p , Op *pOp ,
                                                              char const   *zP4 ,
                                                              int n ) 
{ 


  {
  if (pOp->p4type) {
    freeP4(p->db, (int )pOp->p4type, pOp->p4.p);
    pOp->p4type = (signed char)0;
    pOp->p4.p = (void *)0;
  }
  if (n < 0) {
    sqlite3VdbeChangeP4(p, (int )(pOp - p->aOp), zP4, n);
  } else {
    if (n == 0) {
      n = sqlite3Strlen30(zP4);
    }
    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, (u64 )n);
    pOp->p4type = (signed char)-7;
  }
  return;
}
}
static void sqlite3VdbeChangeP4(Vdbe *p , int addr , char const   *zP4 , int n ) 
{ 
  Op *pOp ;
  sqlite3 *db ;

  {
  db = p->db;
  if (db->mallocFailed) {
    if (n != -12) {
      freeP4(db, n, (void *)*((char **)(& zP4)));
    }
    return;
  }
  if (addr < 0) {
    addr = p->nOp - 1;
  }
  pOp = p->aOp + addr;
  if (n >= 0) {
    vdbeChangeP4Full(p, pOp, zP4, n);
    return;
  } else
  if (pOp->p4type) {
    vdbeChangeP4Full(p, pOp, zP4, n);
    return;
  }
  if (n == -3) {
    pOp->p4.i = (int )((long )zP4);
    pOp->p4type = (signed char)-3;
  } else
  if ((unsigned long )zP4 != (unsigned long )((char const   *)0)) {
    pOp->p4.p = (void *)zP4;
    pOp->p4type = (signed char )n;
    if (n == -12) {
      sqlite3VtabLock((VTable *)zP4);
    }
  }
  return;
}
}
static void sqlite3VdbeAppendP4(Vdbe *p , void *pP4 , int n ) 
{ 
  VdbeOp *pOp ;

  {
  if ((p->db)->mallocFailed) {
    freeP4(p->db, n, pP4);
  } else {
    pOp = p->aOp + (p->nOp - 1);
    pOp->p4type = (signed char )n;
    pOp->p4.p = pP4;
  }
  return;
}
}
static void sqlite3VdbeSetP4KeyInfo(Parse *pParse , Index *pIdx ) 
{ 
  Vdbe *v ;
  KeyInfo *pKeyInfo ;

  {
  v = pParse->pVdbe;
  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
  if (pKeyInfo) {
    sqlite3VdbeAppendP4(v, (void *)pKeyInfo, -9);
  }
  return;
}
}
static VdbeOp dummy  ;
static VdbeOp *sqlite3VdbeGetOp(Vdbe *p , int addr ) 
{ 


  {
  if (addr < 0) {
    addr = p->nOp - 1;
  }
  if ((p->db)->mallocFailed) {
    return (& dummy);
  } else {
    return (p->aOp + addr);
  }
}
}
static char *displayP4(Op *pOp , char *zTemp , int nTemp ) 
{ 
  char *zP4 ;
  StrAccum x___0 ;
  int j ;
  KeyInfo *pKeyInfo ;
  CollSeq *pColl ;
  char const   *zColl ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  CollSeq *pColl___0 ;
  FuncDef *pDef ;
  Mem *pMem ;
  sqlite3_vtab *pVtab ;
  int i ;
  int *ai ;
  int n ;

  {
  zP4 = zTemp;
  sqlite3StrAccumInit(& x___0, (sqlite3 *)0, zTemp, nTemp, 0);
  switch ((int )pOp->p4type) {
  case -9: 
  pKeyInfo = pOp->p4.pKeyInfo;
  sqlite3_str_appendf(& x___0, "k(%d", (int )pKeyInfo->nKeyField);
  j = 0;
  while (j < (int )pKeyInfo->nKeyField) {
    pColl = pKeyInfo->aColl[j];
    if (pColl) {
      tmp = (char const   *)pColl->zName;
    } else {
      tmp = "";
    }
    zColl = tmp;
    tmp___0 = strcmp(zColl, "BINARY");
    if (tmp___0 == 0) {
      zColl = "B";
    }
    if ((int )*(pKeyInfo->aSortFlags + j) & 2) {
      tmp___1 = "N.";
    } else {
      tmp___1 = "";
    }
    if ((int )*(pKeyInfo->aSortFlags + j) & 1) {
      tmp___2 = "-";
    } else {
      tmp___2 = "";
    }
    sqlite3_str_appendf(& x___0, ",%s%s%s", tmp___2, tmp___1, zColl);
    j ++;
  }
  sqlite3_str_append(& x___0, ")", 1);
  break;
  case -2: 
  pColl___0 = pOp->p4.pColl;
  sqlite3_str_appendf(& x___0, "(%.20s)", pColl___0->zName);
  break;
  case -8: 
  pDef = pOp->p4.pFunc;
  sqlite3_str_appendf(& x___0, "%s(%d)", pDef->zName, (int )pDef->nArg);
  break;
  case -14: 
  sqlite3_str_appendf(& x___0, "%lld", *(pOp->p4.pI64));
  break;
  case -3: 
  sqlite3_str_appendf(& x___0, "%d", pOp->p4.i);
  break;
  case -13: 
  sqlite3_str_appendf(& x___0, "%.16g", *(pOp->p4.pReal));
  break;
  case -11: 
  pMem = pOp->p4.pMem;
  if ((int )pMem->flags & 2) {
    zP4 = pMem->z;
  } else
  if ((int )pMem->flags & 36) {
    sqlite3_str_appendf(& x___0, "%lld", pMem->u.i);
  } else
  if ((int )pMem->flags & 8) {
    sqlite3_str_appendf(& x___0, "%.16g", pMem->u.r);
  } else
  if ((int )pMem->flags & 1) {
    zP4 = (char *)"NULL";
  } else {
    zP4 = (char *)"(blob)";
  }
  break;
  case -12: 
  pVtab = (pOp->p4.pVtab)->pVtab;
  sqlite3_str_appendf(& x___0, "vtab:%p", pVtab);
  break;
  case -15: 
  ai = pOp->p4.ai;
  n = *(ai + 0);
  i = 1;
  while (i <= n) {
    sqlite3_str_appendf(& x___0, ",%d", *(ai + i));
    i ++;
  }
  *(zTemp + 0) = (char )'[';
  sqlite3_str_append(& x___0, "]", 1);
  break;
  case -4: 
  sqlite3_str_appendf(& x___0, "program");
  break;
  case -5: 
  case -17: 
  *(zTemp + 0) = (char)0;
  break;
  case -6: 
  sqlite3_str_appendf(& x___0, "%s", (pOp->p4.pTab)->zName);
  break;
  default: 
  zP4 = pOp->p4.z;
  if ((unsigned long )zP4 == (unsigned long )((char *)0)) {
    zP4 = zTemp;
    *(zTemp + 0) = (char)0;
  }
  }
  sqlite3StrAccumFinish(& x___0);
  return (zP4);
}
}
static void sqlite3VdbeUsesBtree(Vdbe *p , int i ) 
{ 
  int tmp ;

  {
  p->btreeMask |= 1U << i;
  if (i != 1) {
    tmp = sqlite3BtreeSharable(((p->db)->aDb + i)->pBt);
    if (tmp) {
      p->lockMask |= 1U << i;
    }
  }
  return;
}
}
static void sqlite3VdbeEnter(Vdbe *p ) 
{ 
  int i ;
  sqlite3 *db ;
  Db *aDb ;
  int nDb ;

  {
  if (p->lockMask == 0U) {
    return;
  }
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  i = 0;
  while (i < nDb) {
    if (i != 1) {
      if ((p->lockMask & (1U << i)) != 0U) {
        if ((unsigned long )(aDb + i)->pBt != (unsigned long )((Btree *)0)) {
          sqlite3BtreeEnter((aDb + i)->pBt);
        }
      }
    }
    i ++;
  }
  return;
}
}
static void initMemArray(Mem *p , int N , sqlite3 *db , u16 flags___0 ) 
{ 
  int tmp ;

  {
  while (1) {
    tmp = N;
    N --;
    if (! (tmp > 0)) {
      break;
    }
    p->db = db;
    p->flags = flags___0;
    p->szMalloc = 0;
    p ++;
  }
  return;
}
}
static void releaseMemArray(Mem *p , int N ) 
{ 
  Mem *pEnd ;
  sqlite3 *db ;

  {
  if (p) {
    if (N) {
      pEnd = p + N;
      db = p->db;
      if (db->pnBytesFreed) {
        while (1) {
          if (p->szMalloc) {
            sqlite3DbFree(db, (void *)p->zMalloc);
          }
          p ++;
          if (! ((unsigned long )p < (unsigned long )pEnd)) {
            break;
          }
        }
        return;
      }
      while (1) {
        if ((int )p->flags & 9216) {
          sqlite3VdbeMemRelease(p);
        } else
        if (p->szMalloc) {
          sqlite3DbFreeNN(db, (void *)p->zMalloc);
          p->szMalloc = 0;
        }
        p->flags = (u16 )128;
        p ++;
        if (! ((unsigned long )p < (unsigned long )pEnd)) {
          break;
        }
      }
    }
  }
  return;
}
}
static void sqlite3VdbeFrameMemDel(void *pArg ) 
{ 
  VdbeFrame *pFrame ;

  {
  pFrame = (VdbeFrame *)pArg;
  pFrame->pParent = (pFrame->v)->pDelFrame;
  (pFrame->v)->pDelFrame = pFrame;
  return;
}
}
static void sqlite3VdbeFrameDelete(VdbeFrame *p ) 
{ 
  int i ;
  Mem *aMem ;
  VdbeCursor **apCsr ;

  {
  aMem = (Mem *)((u8 *)p + ((sizeof(VdbeFrame ) + 7UL) & 0xfffffffffffffff8UL));
  apCsr = (VdbeCursor **)(aMem + p->nChildMem);
  i = 0;
  while (i < p->nChildCsr) {
    sqlite3VdbeFreeCursor(p->v, *(apCsr + i));
    i ++;
  }
  releaseMemArray(aMem, p->nChildMem);
  sqlite3VdbeDeleteAuxData((p->v)->db, & p->pAuxData, -1, 0);
  sqlite3DbFree((p->v)->db, (void *)p);
  return;
}
}
static int sqlite3VdbeList(Vdbe *p ) 
{ 
  int nRow ;
  int nSub ;
  SubProgram **apSub ;
  Mem *pSub ;
  sqlite3 *db ;
  int i ;
  int rc ;
  Mem *pMem ;
  int bListSubprogs ;
  int tmp ;
  Op *pOp ;
  int tmp___0 ;
  int j ;
  int nByte ;
  int j___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *zP4 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  nSub = 0;
  apSub = (SubProgram **)0;
  pSub = (Mem *)0;
  db = p->db;
  rc = 0;
  pMem = p->aMem + 1;
  if (p->explain == 1U) {
    tmp = 1;
  } else
  if ((db->flags & 16777216ULL) != 0ULL) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  bListSubprogs = tmp;
  pOp = (Op *)0;
  releaseMemArray(pMem, 8);
  p->pResultSet = (Mem *)0;
  if (p->rc == 7) {
    sqlite3OomFault(db);
    return (1);
  }
  nRow = p->nOp;
  if (bListSubprogs) {
    pSub = p->aMem + 9;
    if ((int )pSub->flags & 16) {
      nSub = (int )((unsigned long )pSub->n / sizeof(Vdbe *));
      apSub = (SubProgram **)pSub->z;
    }
    i = 0;
    while (i < nSub) {
      nRow += (*(apSub + i))->nOp;
      i ++;
    }
  }
  while (1) {
    tmp___0 = p->pc;
    (p->pc) ++;
    i = tmp___0;
    if (i >= nRow) {
      p->rc = 0;
      rc = 101;
      break;
    }
    if (i < p->nOp) {
      pOp = p->aOp + i;
    } else {
      i -= p->nOp;
      j = 0;
      while (i >= (*(apSub + j))->nOp) {
        i -= (*(apSub + j))->nOp;
        j ++;
      }
      pOp = (*(apSub + j))->aOp + i;
    }
    if (bListSubprogs) {
      if ((int )pOp->p4type == -4) {
        nByte = (int )((unsigned long )(nSub + 1) * sizeof(SubProgram *));
        j___0 = 0;
        while (j___0 < nSub) {
          if ((unsigned long )*(apSub + j___0) == (unsigned long )pOp->p4.pProgram) {
            break;
          }
          j___0 ++;
        }
        if (j___0 == nSub) {
          p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub != 0);
          if (p->rc != 0) {
            rc = 1;
            break;
          }
          apSub = (SubProgram **)pSub->z;
          tmp___1 = nSub;
          nSub ++;
          *(apSub + tmp___1) = pOp->p4.pProgram;
          pSub->flags = (u16 )((int )pSub->flags | 16);
          pSub->n = (int )((unsigned long )nSub * sizeof(SubProgram *));
          nRow += (pOp->p4.pProgram)->nOp;
        }
      }
    }
    if (p->explain < 2U) {
      break;
    }
    if ((int )pOp->opcode == 171) {
      break;
    }
    if ((int )pOp->opcode == 61) {
      if (p->pc > 1) {
        break;
      }
    }
  }
  if (rc == 0) {
    if (db->u1.isInterrupted) {
      p->rc = 9;
      rc = 1;
      tmp___2 = sqlite3ErrStr(p->rc);
      sqlite3VdbeError(p, tmp___2);
    } else {
      if (p->explain == 1U) {
        pMem->flags = (u16 )4;
        pMem->u.i = (i64 )i;
        pMem ++;
        pMem->flags = (u16 )2562;
        tmp___3 = sqlite3OpcodeName((int )pOp->opcode);
        pMem->z = (char *)tmp___3;
        pMem->n = sqlite3Strlen30((char const   *)pMem->z);
        pMem->enc = (u8 )1;
        pMem ++;
      }
      pMem->flags = (u16 )4;
      pMem->u.i = (i64 )pOp->p1;
      pMem ++;
      pMem->flags = (u16 )4;
      pMem->u.i = (i64 )pOp->p2;
      pMem ++;
      pMem->flags = (u16 )4;
      pMem->u.i = (i64 )pOp->p3;
      pMem ++;
      tmp___4 = sqlite3VdbeMemClearAndResize(pMem, 100);
      if (tmp___4) {
        return (1);
      }
      pMem->flags = (u16 )514;
      zP4 = displayP4(pOp, pMem->z, pMem->szMalloc);
      if ((unsigned long )zP4 != (unsigned long )pMem->z) {
        pMem->n = 0;
        sqlite3VdbeMemSetStr(pMem, (char const   *)zP4, -1, (u8 )1, (void (*)(void * ))0);
      } else {
        pMem->n = sqlite3Strlen30((char const   *)pMem->z);
        pMem->enc = (u8 )1;
      }
      pMem ++;
      if (p->explain == 1U) {
        tmp___5 = sqlite3VdbeMemClearAndResize(pMem, 4);
        if (tmp___5) {
          return (1);
        }
        pMem->flags = (u16 )514;
        pMem->n = 2;
        sqlite3_snprintf(3, pMem->z, "%.2x", (int )pOp->p5);
        pMem->enc = (u8 )1;
        pMem ++;
        pMem->flags = (u16 )1;
      }
      p->nResColumn = (u16 )(8U - 4U * (p->explain - 1U));
      p->pResultSet = p->aMem + 1;
      p->rc = 0;
      rc = 100;
    }
  }
  return (rc);
}
}
static void *allocSpace(struct ReusableSpace *p , void *pBuf , sqlite_int64 nByte ) 
{ 


  {
  if ((unsigned long )pBuf == (unsigned long )((void *)0)) {
    nByte = (nByte + 7LL) & -8LL;
    if (nByte <= p->nFree) {
      p->nFree -= nByte;
      pBuf = (void *)(p->pSpace + p->nFree);
    } else {
      p->nNeeded += nByte;
    }
  }
  return (pBuf);
}
}
static void sqlite3VdbeRewind(Vdbe *p ) 
{ 


  {
  p->magic = (u32 )770837923;
  p->pc = -1;
  p->rc = 0;
  p->errorAction = (u8 )2;
  p->nChange = 0;
  p->cacheCtr = (u32 )1;
  p->minWriteFileFormat = (u8 )255;
  p->iStatement = 0;
  p->nFkConstraint = (i64 )0;
  return;
}
}
static void sqlite3VdbeMakeReady(Vdbe *p , Parse *pParse ) 
{ 
  sqlite3 *db ;
  int nVar ;
  int nMem ;
  int nCursor ;
  int nArg ;
  int n ;
  struct ReusableSpace x___0 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  db = p->db;
  nVar = (int )pParse->nVar;
  nMem = pParse->nMem;
  nCursor = pParse->nTab;
  nArg = pParse->nMaxArg;
  nMem += nCursor;
  if (nCursor == 0) {
    if (nMem > 0) {
      nMem ++;
    }
  }
  n = (int )((sizeof(Op ) * (unsigned long )p->nOp + 7UL) & 0xfffffffffffffff8UL);
  x___0.pSpace = (u8 *)p->aOp + n;
  x___0.nFree = (sqlite_int64 )((pParse->szOpAlloc - n) & -8);
  resolveP2Values(p, & nArg);
  if (pParse->isMultiWrite) {
    if (pParse->mayAbort) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  p->usesStmtJournal = (bft )((u8 )tmp);
  if (pParse->explain) {
    if (nMem < 10) {
      nMem = 10;
    }
  }
  p->expired = (bft )0;
  x___0.nNeeded = (sqlite_int64 )0;
  tmp___0 = allocSpace(& x___0, (void *)0, (sqlite_int64 )((unsigned long )nMem * sizeof(Mem )));
  p->aMem = (Mem *)tmp___0;
  tmp___1 = allocSpace(& x___0, (void *)0, (sqlite_int64 )((unsigned long )nVar * sizeof(Mem )));
  p->aVar = (Mem *)tmp___1;
  tmp___2 = allocSpace(& x___0, (void *)0, (sqlite_int64 )((unsigned long )nArg * sizeof(Mem *)));
  p->apArg = (Mem **)tmp___2;
  tmp___3 = allocSpace(& x___0, (void *)0, (sqlite_int64 )((unsigned long )nCursor * sizeof(VdbeCursor *)));
  p->apCsr = (VdbeCursor **)tmp___3;
  if (x___0.nNeeded) {
    tmp___4 = sqlite3DbMallocRawNN(db, (u64 )x___0.nNeeded);
    p->pFree = tmp___4;
    x___0.pSpace = (u8 *)tmp___4;
    x___0.nFree = x___0.nNeeded;
    if (! db->mallocFailed) {
      tmp___5 = allocSpace(& x___0, (void *)p->aMem, (sqlite_int64 )((unsigned long )nMem * sizeof(Mem )));
      p->aMem = (Mem *)tmp___5;
      tmp___6 = allocSpace(& x___0, (void *)p->aVar, (sqlite_int64 )((unsigned long )nVar * sizeof(Mem )));
      p->aVar = (Mem *)tmp___6;
      tmp___7 = allocSpace(& x___0, (void *)p->apArg, (sqlite_int64 )((unsigned long )nArg * sizeof(Mem *)));
      p->apArg = (Mem **)tmp___7;
      tmp___8 = allocSpace(& x___0, (void *)p->apCsr, (sqlite_int64 )((unsigned long )nCursor * sizeof(VdbeCursor *)));
      p->apCsr = (VdbeCursor **)tmp___8;
    }
  }
  p->pVList = pParse->pVList;
  pParse->pVList = (VList *)0;
  p->explain = (bft )pParse->explain;
  if (db->mallocFailed) {
    p->nVar = (ynVar )0;
    p->nCursor = 0;
    p->nMem = 0;
  } else {
    p->nCursor = nCursor;
    p->nVar = (ynVar )nVar;
    initMemArray(p->aVar, nVar, db, (u16 )1);
    p->nMem = nMem;
    initMemArray(p->aMem, nMem, db, (u16 )128);
    memset((void *)p->apCsr, 0, (unsigned long )nCursor * sizeof(VdbeCursor *));
  }
  sqlite3VdbeRewind(p);
  return;
}
}
static void sqlite3VdbeFreeCursor(Vdbe *p , VdbeCursor *pCx ) 
{ 
  sqlite3_vtab_cursor *pVCur ;
  sqlite3_module const   *pModule ;

  {
  if ((unsigned long )pCx == (unsigned long )((VdbeCursor *)0)) {
    return;
  }
  switch ((int )pCx->eCurType) {
  case 1: 
  sqlite3VdbeSorterClose(p->db, pCx);
  break;
  case 0: 
  if (pCx->isEphemeral) {
    if (pCx->pBtx) {
      sqlite3BtreeClose(pCx->pBtx);
    }
  } else {
    sqlite3BtreeCloseCursor(pCx->uc.pCursor);
  }
  break;
  case 2: 
  pVCur = pCx->uc.pVCur;
  pModule = (pVCur->pVtab)->pModule;
  ((pVCur->pVtab)->nRef) --;
  (*(pModule->xClose))(pVCur);
  break;
  }
  return;
}
}
static void closeCursorsInFrame(Vdbe *p ) 
{ 
  int i ;
  VdbeCursor *pC ;

  {
  if (p->apCsr) {
    i = 0;
    while (i < p->nCursor) {
      pC = *(p->apCsr + i);
      if (pC) {
        sqlite3VdbeFreeCursor(p, pC);
        *(p->apCsr + i) = (VdbeCursor *)0;
      }
      i ++;
    }
  }
  return;
}
}
static int sqlite3VdbeFrameRestore(VdbeFrame *pFrame ) 
{ 
  Vdbe *v ;

  {
  v = pFrame->v;
  closeCursorsInFrame(v);
  v->aOp = pFrame->aOp;
  v->nOp = pFrame->nOp;
  v->aMem = pFrame->aMem;
  v->nMem = pFrame->nMem;
  v->apCsr = pFrame->apCsr;
  v->nCursor = pFrame->nCursor;
  (v->db)->lastRowid = pFrame->lastRowid;
  v->nChange = pFrame->nChange;
  (v->db)->nChange = pFrame->nDbChange;
  sqlite3VdbeDeleteAuxData(v->db, & v->pAuxData, -1, 0);
  v->pAuxData = pFrame->pAuxData;
  pFrame->pAuxData = (AuxData *)0;
  return (pFrame->pc);
}
}
static void closeAllCursors(Vdbe *p ) 
{ 
  VdbeFrame *pFrame ;
  VdbeFrame *pDel ;

  {
  if (p->pFrame) {
    pFrame = p->pFrame;
    while (pFrame->pParent) {
      pFrame = pFrame->pParent;
    }
    sqlite3VdbeFrameRestore(pFrame);
    p->pFrame = (VdbeFrame *)0;
    p->nFrame = 0;
  }
  closeCursorsInFrame(p);
  if (p->aMem) {
    releaseMemArray(p->aMem, p->nMem);
  }
  while (p->pDelFrame) {
    pDel = p->pDelFrame;
    p->pDelFrame = pDel->pParent;
    sqlite3VdbeFrameDelete(pDel);
  }
  if (p->pAuxData) {
    sqlite3VdbeDeleteAuxData(p->db, & p->pAuxData, -1, 0);
  }
  return;
}
}
static void sqlite3VdbeSetNumCols(Vdbe *p , int nResColumn ) 
{ 
  int n ;
  sqlite3 *db ;
  void *tmp ;

  {
  db = p->db;
  if (p->nResColumn) {
    releaseMemArray(p->aColName, (int )p->nResColumn * 2);
    sqlite3DbFree(db, (void *)p->aColName);
  }
  n = nResColumn * 2;
  p->nResColumn = (u16 )nResColumn;
  tmp = sqlite3DbMallocRawNN(db, (u64 )(sizeof(Mem ) * (unsigned long )n));
  p->aColName = (Mem *)tmp;
  if ((unsigned long )p->aColName == (unsigned long )((Mem *)0)) {
    return;
  }
  initMemArray(p->aColName, n, db, (u16 )1);
  return;
}
}
static int sqlite3VdbeSetColName(Vdbe *p , int idx , int var , char const   *zName ,
                                 void (*xDel)(void * ) ) 
{ 
  int rc ;
  Mem *pColName ;

  {
  if ((p->db)->mallocFailed) {
    return (7);
  }
  pColName = p->aColName + (idx + var * (int )p->nResColumn);
  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, (u8 )1, xDel);
  return (rc);
}
}
static int vdbeCommit(sqlite3 *db , Vdbe *p ) ;
static u8 const   aMJNeeded[6]  = {      (u8 const   )1,      (u8 const   )1,      (u8 const   )0,      (u8 const   )1, 
        (u8 const   )0,      (u8 const   )0};
static int vdbeCommit(sqlite3 *db , Vdbe *p ) 
{ 
  int i ;
  int nTrans ;
  int rc ;
  int needXcommit ;
  Btree *pBt ;
  Pager *pPager ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Btree *pBt___0 ;
  Btree *pBt___1 ;
  sqlite3_vfs *pVfs ;
  char *zMaster ;
  char const   *zMainFile ;
  char const   *tmp___2 ;
  sqlite3_file *pMaster ;
  i64 offset ;
  int res ;
  int retryCount ;
  int nMainFile ;
  u32 iRandom ;
  Btree *pBt___2 ;
  char const   *zFile ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Btree *pBt___3 ;
  Btree *pBt___4 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
  nTrans = 0;
  rc = 0;
  needXcommit = 0;
  rc = sqlite3VtabSync(db, p);
  i = 0;
  while (1) {
    if (rc == 0) {
      if (! (i < db->nDb)) {
        break;
      }
    } else {
      break;
    }
    pBt = (db->aDb + i)->pBt;
    tmp___1 = sqlite3BtreeIsInTrans(pBt);
    if (tmp___1) {
      needXcommit = 1;
      sqlite3BtreeEnter(pBt);
      pPager = sqlite3BtreePager(pBt);
      if ((int )(db->aDb + i)->safety_level != 1) {
        tmp = sqlite3PagerGetJournalMode(pPager);
        if (aMJNeeded[tmp]) {
          tmp___0 = sqlite3PagerIsMemdb(pPager);
          if (tmp___0 == 0) {
            nTrans ++;
          }
        }
      }
      rc = sqlite3PagerExclusiveLock(pPager);
    }
    i ++;
  }
  if (rc != 0) {
    return (rc);
  }
  if (needXcommit) {
    if (db->xCommitCallback) {
      rc = (*(db->xCommitCallback))(db->pCommitArg);
      if (rc) {
        return (19 | (2 << 8));
      }
    }
  }
  tmp___8 = sqlite3BtreeGetFilename((db->aDb + 0)->pBt);
  tmp___9 = sqlite3Strlen30(tmp___8);
  if (0 == tmp___9) {
    goto _L;
  } else
  if (nTrans <= 1) {
    _L: /* CIL Label */ 
    i = 0;
    while (1) {
      if (rc == 0) {
        if (! (i < db->nDb)) {
          break;
        }
      } else {
        break;
      }
      pBt___0 = (db->aDb + i)->pBt;
      if (pBt___0) {
        rc = sqlite3BtreeCommitPhaseOne(pBt___0, (char const   *)0);
      }
      i ++;
    }
    i = 0;
    while (1) {
      if (rc == 0) {
        if (! (i < db->nDb)) {
          break;
        }
      } else {
        break;
      }
      pBt___1 = (db->aDb + i)->pBt;
      if (pBt___1) {
        rc = sqlite3BtreeCommitPhaseTwo(pBt___1, 0);
      }
      i ++;
    }
    if (rc == 0) {
      sqlite3VtabCommit(db);
    }
  } else {
    pVfs = db->pVfs;
    zMaster = (char *)0;
    tmp___2 = sqlite3BtreeGetFilename((db->aDb + 0)->pBt);
    zMainFile = tmp___2;
    pMaster = (sqlite3_file *)0;
    offset = (i64 )0;
    retryCount = 0;
    nMainFile = sqlite3Strlen30(zMainFile);
    zMaster = sqlite3MPrintf(db, "%s-mjXXXXXX9XXz", zMainFile);
    if ((unsigned long )zMaster == (unsigned long )((char *)0)) {
      return (7);
    }
    while (1) {
      if (retryCount) {
        if (retryCount > 100) {
          sqlite3_log(13, "MJ delete: %s", zMaster);
          sqlite3OsDelete(pVfs, (char const   *)zMaster, 0);
          break;
        } else
        if (retryCount == 1) {
          sqlite3_log(13, "MJ collide: %s", zMaster);
        }
      }
      retryCount ++;
      sqlite3_randomness((int )sizeof(iRandom), (void *)(& iRandom));
      sqlite3_snprintf(13, zMaster + nMainFile, "-mj%06X9%02X", (iRandom >> 8) & 16777215U,
                       iRandom & 255U);
      rc = sqlite3OsAccess(pVfs, (char const   *)zMaster, 0, & res);
      if (rc == 0) {
        if (! res) {
          break;
        }
      } else {
        break;
      }
    }
    if (rc == 0) {
      rc = sqlite3OsOpenMalloc(pVfs, (char const   *)zMaster, & pMaster, 16406, (int *)0);
    }
    if (rc != 0) {
      sqlite3DbFree(db, (void *)zMaster);
      return (rc);
    }
    i = 0;
    while (i < db->nDb) {
      pBt___2 = (db->aDb + i)->pBt;
      tmp___6 = sqlite3BtreeIsInTrans(pBt___2);
      if (tmp___6) {
        tmp___3 = sqlite3BtreeGetJournalname(pBt___2);
        zFile = tmp___3;
        if ((unsigned long )zFile == (unsigned long )((char const   *)0)) {
          goto __Cont;
        }
        tmp___4 = sqlite3Strlen30(zFile);
        rc = sqlite3OsWrite(pMaster, (void const   *)zFile, tmp___4 + 1, offset);
        tmp___5 = sqlite3Strlen30(zFile);
        offset += (i64 )(tmp___5 + 1);
        if (rc != 0) {
          sqlite3OsCloseFree(pMaster);
          sqlite3OsDelete(pVfs, (char const   *)zMaster, 0);
          sqlite3DbFree(db, (void *)zMaster);
          return (rc);
        }
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
    tmp___7 = sqlite3OsDeviceCharacteristics(pMaster);
    if (0 == (tmp___7 & 1024)) {
      rc = sqlite3OsSync(pMaster, 2);
      if (0 != rc) {
        sqlite3OsCloseFree(pMaster);
        sqlite3OsDelete(pVfs, (char const   *)zMaster, 0);
        sqlite3DbFree(db, (void *)zMaster);
        return (rc);
      }
    }
    i = 0;
    while (1) {
      if (rc == 0) {
        if (! (i < db->nDb)) {
          break;
        }
      } else {
        break;
      }
      pBt___3 = (db->aDb + i)->pBt;
      if (pBt___3) {
        rc = sqlite3BtreeCommitPhaseOne(pBt___3, (char const   *)zMaster);
      }
      i ++;
    }
    sqlite3OsCloseFree(pMaster);
    if (rc != 0) {
      sqlite3DbFree(db, (void *)zMaster);
      return (rc);
    }
    rc = sqlite3OsDelete(pVfs, (char const   *)zMaster, 1);
    sqlite3DbFree(db, (void *)zMaster);
    zMaster = (char *)0;
    if (rc) {
      return (rc);
    }
    sqlite3BeginBenignMalloc();
    i = 0;
    while (i < db->nDb) {
      pBt___4 = (db->aDb + i)->pBt;
      if (pBt___4) {
        sqlite3BtreeCommitPhaseTwo(pBt___4, 1);
      }
      i ++;
    }
    sqlite3EndBenignMalloc();
    sqlite3VtabCommit(db);
  }
  return (rc);
}
}
static int ( __attribute__((__noinline__)) vdbeCloseStatement)(Vdbe *p , int eOp ) 
{ 
  sqlite3 *db ;
  int rc ;
  int i ;
  int iSavepoint ;
  int rc2 ;
  Btree *pBt ;

  {
  db = p->db;
  rc = 0;
  iSavepoint = p->iStatement - 1;
  i = 0;
  while (i < db->nDb) {
    rc2 = 0;
    pBt = (db->aDb + i)->pBt;
    if (pBt) {
      if (eOp == 2) {
        rc2 = sqlite3BtreeSavepoint(pBt, 2, iSavepoint);
      }
      if (rc2 == 0) {
        rc2 = sqlite3BtreeSavepoint(pBt, 1, iSavepoint);
      }
      if (rc == 0) {
        rc = rc2;
      }
    }
    i ++;
  }
  (db->nStatement) --;
  p->iStatement = 0;
  if (rc == 0) {
    if (eOp == 2) {
      rc = sqlite3VtabSavepoint(db, 2, iSavepoint);
    }
    if (rc == 0) {
      rc = sqlite3VtabSavepoint(db, 1, iSavepoint);
    }
  }
  if (eOp == 2) {
    db->nDeferredCons = p->nStmtDefCons;
    db->nDeferredImmCons = p->nStmtDefImmCons;
  }
  return (rc);
}
}
static int sqlite3VdbeCloseStatement(Vdbe *p , int eOp ) 
{ 
  int tmp ;

  {
  if ((p->db)->nStatement) {
    if (p->iStatement) {
      tmp = vdbeCloseStatement(p, eOp);
      return (tmp);
    }
  }
  return (0);
}
}
static int sqlite3VdbeCheckFk(Vdbe *p , int deferred ) 
{ 
  sqlite3 *db ;

  {
  db = p->db;
  if (deferred) {
    if (db->nDeferredCons + db->nDeferredImmCons > 0LL) {
      p->rc = 19 | (3 << 8);
      p->errorAction = (u8 )2;
      sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
      return (1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! deferred) {
    if (p->nFkConstraint > 0LL) {
      p->rc = 19 | (3 << 8);
      p->errorAction = (u8 )2;
      sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
      return (1);
    }
  }
  return (0);
}
}
static int sqlite3VdbeHalt(Vdbe *p ) 
{ 
  int rc ;
  sqlite3 *db ;
  int mrc ;
  int eStatementOp ;
  int isSpecialError ;
  int tmp ;
  int tmp___0 ;

  {
  db = p->db;
  if (p->magic != 770837923U) {
    return (0);
  }
  if (db->mallocFailed) {
    p->rc = 7;
  }
  closeAllCursors(p);
  if (p->pc >= 0) {
    if (p->bIsReader) {
      eStatementOp = 0;
      sqlite3VdbeEnter(p);
      mrc = p->rc & 255;
      if (mrc == 7) {
        tmp = 1;
      } else
      if (mrc == 10) {
        tmp = 1;
      } else
      if (mrc == 9) {
        tmp = 1;
      } else
      if (mrc == 13) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      isSpecialError = tmp;
      if (isSpecialError) {
        if (! p->readOnly) {
          goto _L___0;
        } else
        if (mrc != 9) {
          _L___0: /* CIL Label */ 
          if (mrc == 7) {
            goto _L;
          } else
          if (mrc == 13) {
            _L: /* CIL Label */ 
            if (p->usesStmtJournal) {
              eStatementOp = 2;
            } else {
              sqlite3RollbackAll(db, 4 | (2 << 8));
              sqlite3CloseSavepoints(db);
              db->autoCommit = (u8 )1;
              p->nChange = 0;
            }
          } else {
            sqlite3RollbackAll(db, 4 | (2 << 8));
            sqlite3CloseSavepoints(db);
            db->autoCommit = (u8 )1;
            p->nChange = 0;
          }
        }
      }
      if (p->rc == 0) {
        sqlite3VdbeCheckFk(p, 0);
      } else
      if ((int )p->errorAction == 3) {
        if (! isSpecialError) {
          sqlite3VdbeCheckFk(p, 0);
        }
      }
      if (db->nVTrans > 0) {
        if ((unsigned long )db->aVTrans == (unsigned long )((VTable **)0)) {
          _L___4: /* CIL Label */ 
          if (eStatementOp == 0) {
            if (p->rc == 0) {
              eStatementOp = 1;
            } else
            if ((int )p->errorAction == 3) {
              eStatementOp = 1;
            } else
            if ((int )p->errorAction == 2) {
              eStatementOp = 2;
            } else {
              sqlite3RollbackAll(db, 4 | (2 << 8));
              sqlite3CloseSavepoints(db);
              db->autoCommit = (u8 )1;
              p->nChange = 0;
            }
          }
        } else {
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
      if (db->autoCommit) {
        if (db->nVdbeWrite == (p->readOnly == 0U)) {
          if (p->rc == 0) {
            goto _L___2;
          } else
          if ((int )p->errorAction == 3) {
            if (! isSpecialError) {
              _L___2: /* CIL Label */ 
              rc = sqlite3VdbeCheckFk(p, 1);
              if (rc != 0) {
                if (p->readOnly) {
                  return (1);
                }
                rc = 19 | (3 << 8);
              } else {
                rc = vdbeCommit(db, p);
              }
              if (rc == 5) {
                if (p->readOnly) {
                  return (5);
                } else {
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
              if (rc != 0) {
                p->rc = rc;
                sqlite3RollbackAll(db, 0);
                p->nChange = 0;
              } else {
                db->nDeferredCons = (i64 )0;
                db->nDeferredImmCons = (i64 )0;
                db->flags &= 0xfffffffffff7ffffULL;
                sqlite3CommitInternalChanges(db);
              }
            } else {
              sqlite3RollbackAll(db, 0);
              p->nChange = 0;
            }
          } else {
            sqlite3RollbackAll(db, 0);
            p->nChange = 0;
          }
          db->nStatement = 0;
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
      if (eStatementOp) {
        rc = sqlite3VdbeCloseStatement(p, eStatementOp);
        if (rc) {
          if (p->rc == 0) {
            p->rc = rc;
            sqlite3DbFree(db, (void *)p->zErrMsg);
            p->zErrMsg = (char *)0;
          } else
          if ((p->rc & 255) == 19) {
            p->rc = rc;
            sqlite3DbFree(db, (void *)p->zErrMsg);
            p->zErrMsg = (char *)0;
          }
          sqlite3RollbackAll(db, 4 | (2 << 8));
          sqlite3CloseSavepoints(db);
          db->autoCommit = (u8 )1;
          p->nChange = 0;
        }
      }
      if (p->changeCntOn) {
        if (eStatementOp != 2) {
          sqlite3VdbeSetChanges(db, p->nChange);
        } else {
          sqlite3VdbeSetChanges(db, 0);
        }
        p->nChange = 0;
      }
    }
  }
  if (p->pc >= 0) {
    (db->nVdbeActive) --;
    if (! p->readOnly) {
      (db->nVdbeWrite) --;
    }
    if (p->bIsReader) {
      (db->nVdbeRead) --;
    }
  }
  p->magic = (u32 )832317811;
  if (db->mallocFailed) {
    p->rc = 7;
  }
  if (p->rc == 5) {
    tmp___0 = 5;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static void sqlite3VdbeResetStepResult(Vdbe *p ) 
{ 


  {
  p->rc = 0;
  return;
}
}
static int sqlite3VdbeTransferError(Vdbe *p ) 
{ 
  sqlite3 *db ;
  int rc ;

  {
  db = p->db;
  rc = p->rc;
  if (p->zErrMsg) {
    db->bBenignMalloc = (u8 )((int )db->bBenignMalloc + 1);
    sqlite3BeginBenignMalloc();
    if ((unsigned long )db->pErr == (unsigned long )((sqlite3_value *)0)) {
      db->pErr = sqlite3ValueNew(db);
    }
    sqlite3ValueSetStr(db->pErr, -1, (void const   *)p->zErrMsg, (u8 )1, (void (*)(void * ))-1);
    sqlite3EndBenignMalloc();
    db->bBenignMalloc = (u8 )((int )db->bBenignMalloc - 1);
  } else
  if (db->pErr) {
    sqlite3ValueSetNull(db->pErr);
  }
  db->errCode = rc;
  return (rc);
}
}
static int sqlite3VdbeReset(Vdbe *p ) 
{ 
  sqlite3 *db ;
  char const   *tmp ;

  {
  db = p->db;
  sqlite3VdbeHalt(p);
  if (p->pc >= 0) {
    sqlite3VdbeTransferError(p);
    if (p->runOnlyOnce) {
      p->expired = (bft )1;
    }
  } else
  if (p->rc) {
    if (p->expired) {
      if (p->zErrMsg) {
        tmp = "%s";
      } else {
        tmp = (char const   *)0;
      }
      sqlite3ErrorWithMsg(db, p->rc, tmp, p->zErrMsg);
    }
  }
  sqlite3DbFree(db, (void *)p->zErrMsg);
  p->zErrMsg = (char *)0;
  p->pResultSet = (Mem *)0;
  p->magic = (u32 )1224384374;
  return (p->rc & db->errMask);
}
}
static int sqlite3VdbeFinalize(Vdbe *p ) 
{ 
  int rc ;

  {
  rc = 0;
  if (p->magic == 770837923U) {
    rc = sqlite3VdbeReset(p);
  } else
  if (p->magic == 832317811U) {
    rc = sqlite3VdbeReset(p);
  }
  sqlite3VdbeDelete(p);
  return (rc);
}
}
static void sqlite3VdbeDeleteAuxData(sqlite3 *db , AuxData **pp , int iOp , int mask ) 
{ 
  AuxData *pAux ;

  {
  while (*pp) {
    pAux = *pp;
    if (iOp < 0) {
      goto _L___0;
    } else
    if (pAux->iAuxOp == iOp) {
      if (pAux->iAuxArg >= 0) {
        if (pAux->iAuxArg > 31) {
          goto _L___0;
        } else
        if (! ((unsigned int )mask & (1U << pAux->iAuxArg))) {
          _L___0: /* CIL Label */ 
          if (pAux->xDeleteAux) {
            (*(pAux->xDeleteAux))(pAux->pAux);
          }
          *pp = pAux->pNextAux;
          sqlite3DbFree(db, (void *)pAux);
        } else {
          pp = & pAux->pNextAux;
        }
      } else {
        pp = & pAux->pNextAux;
      }
    } else {
      pp = & pAux->pNextAux;
    }
  }
  return;
}
}
static void sqlite3VdbeClearObject(sqlite3 *db , Vdbe *p ) 
{ 
  SubProgram *pSub ;
  SubProgram *pNext ;

  {
  releaseMemArray(p->aColName, (int )p->nResColumn * 2);
  pSub = p->pProgram;
  while (pSub) {
    pNext = pSub->pNext;
    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
    sqlite3DbFree(db, (void *)pSub);
    pSub = pNext;
  }
  if (p->magic != 381479589U) {
    releaseMemArray(p->aVar, (int )p->nVar);
    sqlite3DbFree(db, (void *)p->pVList);
    sqlite3DbFree(db, p->pFree);
  }
  vdbeFreeOpArray(db, p->aOp, p->nOp);
  sqlite3DbFree(db, (void *)p->aColName);
  sqlite3DbFree(db, (void *)p->zSql);
  return;
}
}
static void sqlite3VdbeDelete(Vdbe *p ) 
{ 
  sqlite3 *db ;

  {
  db = p->db;
  sqlite3VdbeClearObject(db, p);
  if (p->pPrev) {
    (p->pPrev)->pNext = p->pNext;
  } else {
    db->pVdbe = p->pNext;
  }
  if (p->pNext) {
    (p->pNext)->pPrev = p->pPrev;
  }
  p->magic = (u32 )1443283912;
  p->db = (sqlite3 *)0;
  sqlite3DbFreeNN(db, (void *)p);
  return;
}
}
static int ( __attribute__((__noinline__)) handleDeferredMoveto)(VdbeCursor *p ) 
{ 
  int res ;
  int rc ;
  int tmp ;

  {
  rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, (UnpackedRecord *)0, p->movetoTarget,
                                  0, & res);
  if (rc) {
    return (rc);
  }
  if (res != 0) {
    tmp = sqlite3CorruptError(79866);
    return (tmp);
  }
  p->deferredMoveto = (u8 )0;
  p->cacheStatus = (u32 )0;
  return (0);
}
}
static int ( __attribute__((__noinline__)) handleMovedCursor)(VdbeCursor *p ) 
{ 
  int isDifferentRow ;
  int rc ;

  {
  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, & isDifferentRow);
  p->cacheStatus = (u32 )0;
  if (isDifferentRow) {
    p->nullRow = (u8 )1;
  }
  return (rc);
}
}
static int sqlite3VdbeCursorRestore(VdbeCursor *p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = sqlite3BtreeCursorHasMoved(p->uc.pCursor);
  if (tmp___0) {
    tmp = handleMovedCursor(p);
    return (tmp);
  }
  return (0);
}
}
static int sqlite3VdbeCursorMoveto(VdbeCursor **pp , int *piCol ) 
{ 
  VdbeCursor *p ;
  int iMap ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  p = *pp;
  if (p->deferredMoveto) {
    if (p->aAltMap) {
      iMap = *(p->aAltMap + (1 + *piCol));
      if (iMap > 0) {
        *pp = p->pAltCursor;
        *piCol = iMap - 1;
        return (0);
      }
    }
    tmp = handleDeferredMoveto(p);
    return (tmp);
  }
  tmp___1 = sqlite3BtreeCursorHasMoved(p->uc.pCursor);
  if (tmp___1) {
    tmp___0 = handleMovedCursor(p);
    return (tmp___0);
  }
  return (0);
}
}
static u8 const   sqlite3SmallTypeSizes[128]  = 
  {      (u8 const   )0,      (u8 const   )1,      (u8 const   )2,      (u8 const   )3, 
        (u8 const   )4,      (u8 const   )6,      (u8 const   )8,      (u8 const   )8, 
        (u8 const   )0,      (u8 const   )0,      (u8 const   )0,      (u8 const   )0, 
        (u8 const   )0,      (u8 const   )0,      (u8 const   )1,      (u8 const   )1, 
        (u8 const   )2,      (u8 const   )2,      (u8 const   )3,      (u8 const   )3, 
        (u8 const   )4,      (u8 const   )4,      (u8 const   )5,      (u8 const   )5, 
        (u8 const   )6,      (u8 const   )6,      (u8 const   )7,      (u8 const   )7, 
        (u8 const   )8,      (u8 const   )8,      (u8 const   )9,      (u8 const   )9, 
        (u8 const   )10,      (u8 const   )10,      (u8 const   )11,      (u8 const   )11, 
        (u8 const   )12,      (u8 const   )12,      (u8 const   )13,      (u8 const   )13, 
        (u8 const   )14,      (u8 const   )14,      (u8 const   )15,      (u8 const   )15, 
        (u8 const   )16,      (u8 const   )16,      (u8 const   )17,      (u8 const   )17, 
        (u8 const   )18,      (u8 const   )18,      (u8 const   )19,      (u8 const   )19, 
        (u8 const   )20,      (u8 const   )20,      (u8 const   )21,      (u8 const   )21, 
        (u8 const   )22,      (u8 const   )22,      (u8 const   )23,      (u8 const   )23, 
        (u8 const   )24,      (u8 const   )24,      (u8 const   )25,      (u8 const   )25, 
        (u8 const   )26,      (u8 const   )26,      (u8 const   )27,      (u8 const   )27, 
        (u8 const   )28,      (u8 const   )28,      (u8 const   )29,      (u8 const   )29, 
        (u8 const   )30,      (u8 const   )30,      (u8 const   )31,      (u8 const   )31, 
        (u8 const   )32,      (u8 const   )32,      (u8 const   )33,      (u8 const   )33, 
        (u8 const   )34,      (u8 const   )34,      (u8 const   )35,      (u8 const   )35, 
        (u8 const   )36,      (u8 const   )36,      (u8 const   )37,      (u8 const   )37, 
        (u8 const   )38,      (u8 const   )38,      (u8 const   )39,      (u8 const   )39, 
        (u8 const   )40,      (u8 const   )40,      (u8 const   )41,      (u8 const   )41, 
        (u8 const   )42,      (u8 const   )42,      (u8 const   )43,      (u8 const   )43, 
        (u8 const   )44,      (u8 const   )44,      (u8 const   )45,      (u8 const   )45, 
        (u8 const   )46,      (u8 const   )46,      (u8 const   )47,      (u8 const   )47, 
        (u8 const   )48,      (u8 const   )48,      (u8 const   )49,      (u8 const   )49, 
        (u8 const   )50,      (u8 const   )50,      (u8 const   )51,      (u8 const   )51, 
        (u8 const   )52,      (u8 const   )52,      (u8 const   )53,      (u8 const   )53, 
        (u8 const   )54,      (u8 const   )54,      (u8 const   )55,      (u8 const   )55, 
        (u8 const   )56,      (u8 const   )56,      (u8 const   )57,      (u8 const   )57};
static u32 sqlite3VdbeSerialTypeLen(u32 serial_type ) 
{ 


  {
  if (serial_type >= 128U) {
    return ((serial_type - 12U) / 2U);
  } else {
    return ((u32 )sqlite3SmallTypeSizes[serial_type]);
  }
}
}
static u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type ) 
{ 


  {
  return ((u8 )sqlite3SmallTypeSizes[serial_type]);
}
}
static u32 sqlite3VdbeSerialPut(unsigned char *buf , Mem *pMem , u32 serial_type ) 
{ 
  u32 len ;
  u64 v ;
  u32 i ;

  {
  if (serial_type <= 7U) {
    if (serial_type > 0U) {
      if (serial_type == 7U) {
        memcpy((void * __restrict  )(& v), (void const   * __restrict  )(& pMem->u.r),
               sizeof(v));
      } else {
        v = (u64 )pMem->u.i;
      }
      i = (u32 )sqlite3SmallTypeSizes[serial_type];
      len = i;
      while (1) {
        i --;
        *(buf + i) = (u8 )(v & 255ULL);
        v >>= 8;
        if (! i) {
          break;
        }
      }
      return (len);
    }
  }
  if (serial_type >= 12U) {
    len = (u32 )pMem->n;
    if (len > 0U) {
      memcpy((void * __restrict  )buf, (void const   * __restrict  )pMem->z, (size_t )len);
    }
    return (len);
  }
  return ((u32 )0);
}
}
static u32 serialGet(unsigned char const   *buf , u32 serial_type , Mem *pMem ) 
{ 
  u64 x___0 ;
  u32 y ;

  {
  x___0 = (u64 )(((((u32 )*(buf + 0) << 24) | (unsigned int )((int const   )*(buf + 1) << 16)) | (unsigned int )((int const   )*(buf + 2) << 8)) | (unsigned int )*(buf + 3));
  y = ((((u32 )*((buf + 4) + 0) << 24) | (unsigned int )((int const   )*((buf + 4) + 1) << 16)) | (unsigned int )((int const   )*((buf + 4) + 2) << 8)) | (unsigned int )*((buf + 4) + 3);
  x___0 = (x___0 << 32) + (u64 )y;
  if (serial_type == 6U) {
    pMem->u.i = *((i64 *)(& x___0));
    pMem->flags = (u16 )4;
  } else {
    memcpy((void * __restrict  )(& pMem->u.r), (void const   * __restrict  )(& x___0),
           sizeof(x___0));
    if ((x___0 & (2047ULL << 52)) == 2047ULL << 52) {
      if ((x___0 & ((1ULL << 52) - 1ULL)) != 0ULL) {
        pMem->flags = (u16 )1;
      } else {
        pMem->flags = (u16 )8;
      }
    } else {
      pMem->flags = (u16 )8;
    }
  }
  return ((u32 )8);
}
}
static u16 const   aFlag[2]  = {      (u16 const   )4112,      (u16 const   )4098};
static u32 sqlite3VdbeSerialGet(unsigned char const   *buf , u32 serial_type , Mem *pMem ) 
{ 
  u32 tmp ;

  {
  switch (serial_type) {
  case 10U: 
  pMem->flags = (u16 )16385;
  pMem->n = 0;
  pMem->u.nZero = 0;
  break;
  case 0U: 
  case 11U: 
  pMem->flags = (u16 )1;
  break;
  case 1U: 
  pMem->u.i = (i64 )((i8 )*(buf + 0));
  pMem->flags = (u16 )4;
  return ((u32 )1);
  case 2U: 
  pMem->u.i = (i64 )(256 * (int )((i8 )*(buf + 0)) | (int )*(buf + 1));
  pMem->flags = (u16 )4;
  return ((u32 )2);
  case 3U: 
  pMem->u.i = (i64 )((65536 * (int )((i8 )*(buf + 0)) | (int )((int const   )*(buf + 1) << 8)) | (int )*(buf + 2));
  pMem->flags = (u16 )4;
  return ((u32 )3);
  case 4U: 
  pMem->u.i = (i64 )(((16777216 * (int )((i8 )*(buf + 0)) | (int )((int const   )*(buf + 1) << 16)) | (int )((int const   )*(buf + 2) << 8)) | (int )*(buf + 3));
  pMem->flags = (u16 )4;
  return ((u32 )4);
  case 5U: 
  pMem->u.i = (i64 )(((((u32 )*((buf + 2) + 0) << 24) | (unsigned int )((int const   )*((buf + 2) + 1) << 16)) | (unsigned int )((int const   )*((buf + 2) + 2) << 8)) | (unsigned int )*((buf + 2) + 3)) + (1LL << 32) * (i64 )(256 * (int )((i8 )*(buf + 0)) | (int )*(buf + 1));
  pMem->flags = (u16 )4;
  return ((u32 )6);
  case 7U: 
  case 6U: 
  tmp = serialGet(buf, serial_type, pMem);
  return (tmp);
  case 9U: 
  case 8U: 
  pMem->u.i = (i64 )(serial_type - 8U);
  pMem->flags = (u16 )4;
  return ((u32 )0);
  default: 
  pMem->z = (char *)buf;
  pMem->n = (int )((serial_type - 12U) / 2U);
  pMem->flags = (u16 )aFlag[serial_type & 1U];
  return ((u32 )pMem->n);
  }
  return ((u32 )0);
}
}
static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo *pKeyInfo ) 
{ 
  UnpackedRecord *p ;
  int nByte ;
  void *tmp ;

  {
  nByte = (int )(((sizeof(UnpackedRecord ) + 7UL) & 0xfffffffffffffff8UL) + sizeof(Mem ) * (unsigned long )((int )pKeyInfo->nKeyField + 1));
  tmp = sqlite3DbMallocRaw(pKeyInfo->db, (u64 )nByte);
  p = (UnpackedRecord *)tmp;
  if (! p) {
    return ((UnpackedRecord *)0);
  }
  p->aMem = (Mem *)((char *)p + ((sizeof(UnpackedRecord ) + 7UL) & 0xfffffffffffffff8UL));
  p->pKeyInfo = pKeyInfo;
  p->nField = (u16 )((int )pKeyInfo->nKeyField + 1);
  return (p);
}
}
static void sqlite3VdbeRecordUnpack(KeyInfo *pKeyInfo , int nKey , void const   *pKey ,
                                    UnpackedRecord *p ) 
{ 
  unsigned char const   *aKey ;
  u32 d ;
  u32 idx ;
  u16 u ;
  u32 szHdr ;
  Mem *pMem ;
  u8 tmp ;
  int tmp___0 ;
  u32 serial_type ;
  u8 tmp___1 ;
  int tmp___2 ;
  u32 tmp___3 ;

  {
  aKey = (unsigned char const   *)pKey;
  pMem = p->aMem;
  p->default_rc = (i8 )0;
  if ((int const   )*aKey < 128) {
    szHdr = (u32 )*aKey;
    tmp___0 = 1;
  } else {
    tmp = sqlite3GetVarint32(aKey, & szHdr);
    tmp___0 = (int )tmp;
  }
  idx = (u32 )((u8 )tmp___0);
  d = szHdr;
  u = (u16 )0;
  while (1) {
    if (idx < szHdr) {
      if (! (d <= (u32 )nKey)) {
        break;
      }
    } else {
      break;
    }
    if ((int const   )*(aKey + idx) < 128) {
      serial_type = (u32 )*(aKey + idx);
      tmp___2 = 1;
    } else {
      tmp___1 = sqlite3GetVarint32(aKey + idx, & serial_type);
      tmp___2 = (int )tmp___1;
    }
    idx += (u32 )((u8 )tmp___2);
    pMem->enc = pKeyInfo->enc;
    pMem->db = pKeyInfo->db;
    pMem->szMalloc = 0;
    pMem->z = (char *)0;
    tmp___3 = sqlite3VdbeSerialGet(aKey + d, serial_type, pMem);
    d += tmp___3;
    pMem ++;
    u = (u16 )((int )u + 1);
    if ((int )u >= (int )p->nField) {
      break;
    }
  }
  if (d > (u32 )nKey) {
    if (u) {
      sqlite3VdbeMemSetNull(pMem - 1);
    }
  }
  p->nField = u;
  return;
}
}
static int vdbeCompareMemString(Mem const   *pMem1 , Mem const   *pMem2 , CollSeq const   *pColl ,
                                u8 *prcErr ) 
{ 
  int tmp ;
  int rc ;
  void const   *v1 ;
  void const   *v2 ;
  Mem c1 ;
  Mem c2 ;

  {
  if ((int const   )pMem1->enc == (int const   )pColl->enc) {
    tmp = (*(pColl->xCmp))((void *)pColl->pUser, (int )pMem1->n, (void const   *)pMem1->z,
                           (int )pMem2->n, (void const   *)pMem2->z);
    return (tmp);
  } else {
    sqlite3VdbeMemInit(& c1, (sqlite3 *)pMem1->db, (u16 )1);
    sqlite3VdbeMemInit(& c2, (sqlite3 *)pMem1->db, (u16 )1);
    sqlite3VdbeMemShallowCopy(& c1, pMem1, 4096);
    sqlite3VdbeMemShallowCopy(& c2, pMem2, 4096);
    v1 = sqlite3ValueText(& c1, (u8 )pColl->enc);
    v2 = sqlite3ValueText(& c2, (u8 )pColl->enc);
    if ((unsigned long )v1 == (unsigned long )((void const   *)0)) {
      goto _L;
    } else
    if ((unsigned long )v2 == (unsigned long )((void const   *)0)) {
      _L: /* CIL Label */ 
      if (prcErr) {
        *prcErr = (u8 )7;
      }
      rc = 0;
    } else {
      rc = (*(pColl->xCmp))((void *)pColl->pUser, c1.n, v1, c2.n, v2);
    }
    sqlite3VdbeMemRelease(& c1);
    sqlite3VdbeMemRelease(& c2);
    return (rc);
  }
}
}
static int isAllZero(char const   *z , int n ) 
{ 
  int i ;

  {
  i = 0;
  while (i < n) {
    if (*(z + i)) {
      return (0);
    }
    i ++;
  }
  return (1);
}
}
static int ( __attribute__((__noinline__)) sqlite3BlobCompare)(Mem const   *pB1 ,
                                                               Mem const   *pB2 ) 
{ 
  int c ;
  int n1 ;
  int n2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  n1 = (int )pB1->n;
  n2 = (int )pB2->n;
  if (((int const   )pB1->flags | (int const   )pB2->flags) & 16384) {
    if (((int const   )pB1->flags & (int const   )pB2->flags) & 16384) {
      return ((int )(pB1->u.nZero - pB2->u.nZero));
    } else
    if ((int const   )pB1->flags & 16384) {
      tmp = isAllZero((char const   *)pB2->z, (int )pB2->n);
      if (! tmp) {
        return (-1);
      }
      return ((int )(pB1->u.nZero - (int const   )n2));
    } else {
      tmp___0 = isAllZero((char const   *)pB1->z, (int )pB1->n);
      if (! tmp___0) {
        return (1);
      }
      return (n1 - (int )pB2->u.nZero);
    }
  }
  if (n1 > n2) {
    tmp___1 = n2;
  } else {
    tmp___1 = n1;
  }
  c = memcmp((void const   *)pB1->z, (void const   *)pB2->z, (size_t )tmp___1);
  if (c) {
    return (c);
  }
  return (n1 - n2);
}
}
static int sqlite3IntFloatCompare(i64 i , double r ) 
{ 
  long double x___0 ;
  i64 y ;
  double s ;

  {
  if (sizeof(long double ) > 8UL) {
    x___0 = (long double )i;
    if (x___0 < (long double )r) {
      return (-1);
    }
    if (x___0 > (long double )r) {
      return (1);
    }
    return (0);
  } else {
    if (r < - 9223372036854775808.0) {
      return (1);
    }
    if (r >= 9223372036854775808.0) {
      return (-1);
    }
    y = (i64 )r;
    if (i < y) {
      return (-1);
    }
    if (i > y) {
      return (1);
    }
    s = (double )i;
    if (s < r) {
      return (-1);
    }
    if (s > r) {
      return (1);
    }
    return (0);
  }
}
}
static int sqlite3MemCompare(Mem const   *pMem1 , Mem const   *pMem2 , CollSeq const   *pColl ) 
{ 
  int f1 ;
  int f2 ;
  int combined_flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  f1 = (int )pMem1->flags;
  f2 = (int )pMem2->flags;
  combined_flags = f1 | f2;
  if (combined_flags & 1) {
    return ((f2 & 1) - (f1 & 1));
  }
  if (combined_flags & 44) {
    if (((f1 & f2) & 36) != 0) {
      if (pMem1->u.i < pMem2->u.i) {
        return (-1);
      }
      if (pMem1->u.i > pMem2->u.i) {
        return (1);
      }
      return (0);
    }
    if (((f1 & f2) & 8) != 0) {
      if (pMem1->u.r < pMem2->u.r) {
        return (-1);
      }
      if (pMem1->u.r > pMem2->u.r) {
        return (1);
      }
      return (0);
    }
    if ((f1 & 36) != 0) {
      if ((f2 & 8) != 0) {
        tmp = sqlite3IntFloatCompare((i64 )pMem1->u.i, (double )pMem2->u.r);
        return (tmp);
      } else
      if ((f2 & 36) != 0) {
        if (pMem1->u.i < pMem2->u.i) {
          return (-1);
        }
        if (pMem1->u.i > pMem2->u.i) {
          return (1);
        }
        return (0);
      } else {
        return (-1);
      }
    }
    if ((f1 & 8) != 0) {
      if ((f2 & 36) != 0) {
        tmp___0 = sqlite3IntFloatCompare((i64 )pMem2->u.i, (double )pMem1->u.r);
        return (- tmp___0);
      } else {
        return (-1);
      }
    }
    return (1);
  }
  if (combined_flags & 2) {
    if ((f1 & 2) == 0) {
      return (1);
    }
    if ((f2 & 2) == 0) {
      return (-1);
    }
    if (pColl) {
      tmp___1 = vdbeCompareMemString(pMem1, pMem2, pColl, (u8 *)0);
      return (tmp___1);
    }
  }
  tmp___2 = sqlite3BlobCompare(pMem1, pMem2);
  return (tmp___2);
}
}
static i64 vdbeRecordDecodeInt(u32 serial_type , u8 const   *aKey ) 
{ 
  u32 y ;
  u64 x___0 ;

  {
  switch (serial_type) {
  case 1U: 
  case 0U: ;
  return ((i64 )((i8 )*(aKey + 0)));
  case 2U: ;
  return ((i64 )(256 * (int )((i8 )*(aKey + 0)) | (int )*(aKey + 1)));
  case 3U: ;
  return ((i64 )((65536 * (int )((i8 )*(aKey + 0)) | (int )((int const   )*(aKey + 1) << 8)) | (int )*(aKey + 2)));
  case 4U: 
  y = ((((u32 )*(aKey + 0) << 24) | (unsigned int )((int const   )*(aKey + 1) << 16)) | (unsigned int )((int const   )*(aKey + 2) << 8)) | (unsigned int )*(aKey + 3);
  return ((i64 )*((int *)(& y)));
  case 5U: 
  return ((i64 )(((((u32 )*((aKey + 2) + 0) << 24) | (unsigned int )((int const   )*((aKey + 2) + 1) << 16)) | (unsigned int )((int const   )*((aKey + 2) + 2) << 8)) | (unsigned int )*((aKey + 2) + 3)) + (1LL << 32) * (i64 )(256 * (int )((i8 )*(aKey + 0)) | (int )*(aKey + 1)));
  case 6U: 
  x___0 = (u64 )(((((u32 )*(aKey + 0) << 24) | (unsigned int )((int const   )*(aKey + 1) << 16)) | (unsigned int )((int const   )*(aKey + 2) << 8)) | (unsigned int )*(aKey + 3));
  x___0 = (x___0 << 32) | (unsigned long long )(((((u32 )*((aKey + 4) + 0) << 24) | (unsigned int )((int const   )*((aKey + 4) + 1) << 16)) | (unsigned int )((int const   )*((aKey + 4) + 2) << 8)) | (unsigned int )*((aKey + 4) + 3));
  return (*((i64 *)(& x___0)));
  }
  return ((i64 )(serial_type - 8U));
}
}
static int sqlite3VdbeRecordCompareWithSkip(int nKey1 , void const   *pKey1 , UnpackedRecord *pPKey2 ,
                                            int bSkip ) 
{ 
  u32 d1 ;
  int i ;
  u32 szHdr1 ;
  u32 idx1 ;
  int rc ;
  Mem *pRhs ;
  KeyInfo *pKeyInfo ;
  unsigned char const   *aKey1 ;
  Mem mem1 ;
  u32 s1 ;
  u8 tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  u8 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u32 serial_type ;
  int tmp___5 ;
  i64 lhs ;
  i64 tmp___6 ;
  i64 rhs ;
  int tmp___7 ;
  int nCmp ;
  int tmp___8 ;
  int nStr ;
  int tmp___9 ;
  int tmp___10 ;
  int nCmp___0 ;
  int tmp___11 ;
  int sortFlags ;
  int tmp___12 ;
  u32 tmp___13 ;
  int tmp___14 ;

  {
  rc = 0;
  pRhs = pPKey2->aMem;
  aKey1 = (unsigned char const   *)pKey1;
  if (bSkip) {
    if ((int const   )*(aKey1 + 1) < 128) {
      s1 = (u32 )*(aKey1 + 1);
      tmp___0 = 1;
    } else {
      tmp = sqlite3GetVarint32(aKey1 + 1, & s1);
      tmp___0 = (int )tmp;
    }
    idx1 = (u32 )(1 + (int )((u8 )tmp___0));
    szHdr1 = (u32 )*(aKey1 + 0);
    tmp___1 = sqlite3VdbeSerialTypeLen(s1);
    d1 = szHdr1 + tmp___1;
    i = 1;
    pRhs ++;
  } else {
    if ((int const   )*aKey1 < 128) {
      szHdr1 = (u32 )*aKey1;
      tmp___3 = 1;
    } else {
      tmp___2 = sqlite3GetVarint32(aKey1, & szHdr1);
      tmp___3 = (int )tmp___2;
    }
    idx1 = (u32 )((u8 )tmp___3);
    d1 = szHdr1;
    i = 0;
  }
  if (d1 > (unsigned int )nKey1) {
    tmp___4 = sqlite3CorruptError(80862);
    pPKey2->errCode = (u8 )tmp___4;
    return (0);
  }
  while (1) {
    if ((int )pRhs->flags & 36) {
      serial_type = (u32 )*(aKey1 + idx1);
      if (serial_type >= 10U) {
        rc = 1;
      } else
      if (serial_type == 0U) {
        rc = -1;
      } else
      if (serial_type == 7U) {
        sqlite3VdbeSerialGet(aKey1 + d1, serial_type, & mem1);
        tmp___5 = sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);
        rc = - tmp___5;
      } else {
        tmp___6 = vdbeRecordDecodeInt(serial_type, aKey1 + d1);
        lhs = tmp___6;
        rhs = pRhs->u.i;
        if (lhs < rhs) {
          rc = -1;
        } else
        if (lhs > rhs) {
          rc = 1;
        }
      }
    } else
    if ((int )pRhs->flags & 8) {
      serial_type = (u32 )*(aKey1 + idx1);
      if (serial_type >= 10U) {
        rc = 1;
      } else
      if (serial_type == 0U) {
        rc = -1;
      } else {
        sqlite3VdbeSerialGet(aKey1 + d1, serial_type, & mem1);
        if (serial_type == 7U) {
          if (mem1.u.r < pRhs->u.r) {
            rc = -1;
          } else
          if (mem1.u.r > pRhs->u.r) {
            rc = 1;
          }
        } else {
          rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);
        }
      }
    } else
    if ((int )pRhs->flags & 2) {
      if ((int const   )*(aKey1 + idx1) < 128) {
        serial_type = (u32 )*(aKey1 + idx1);
      } else {
        sqlite3GetVarint32(aKey1 + idx1, & serial_type);
      }
      if (serial_type < 12U) {
        rc = -1;
      } else
      if (! (serial_type & 1U)) {
        rc = 1;
      } else {
        mem1.n = (int )((serial_type - 12U) / 2U);
        if (d1 + (u32 )mem1.n > (unsigned int )nKey1) {
          tmp___7 = sqlite3CorruptError(80939);
          pPKey2->errCode = (u8 )tmp___7;
          return (0);
        } else {
          pKeyInfo = pPKey2->pKeyInfo;
          if ((int )pKeyInfo->nAllField <= i) {
            tmp___7 = sqlite3CorruptError(80939);
            pPKey2->errCode = (u8 )tmp___7;
            return (0);
          } else
          if (pKeyInfo->aColl[i]) {
            mem1.enc = pKeyInfo->enc;
            mem1.db = pKeyInfo->db;
            mem1.flags = (u16 )2;
            mem1.z = (char *)(aKey1 + d1);
            rc = vdbeCompareMemString((Mem const   *)(& mem1), (Mem const   *)pRhs,
                                      (CollSeq const   *)pKeyInfo->aColl[i], & pPKey2->errCode);
          } else {
            if (mem1.n < pRhs->n) {
              tmp___8 = mem1.n;
            } else {
              tmp___8 = pRhs->n;
            }
            nCmp = tmp___8;
            rc = memcmp((void const   *)(aKey1 + d1), (void const   *)pRhs->z, (size_t )nCmp);
            if (rc == 0) {
              rc = mem1.n - pRhs->n;
            }
          }
        }
      }
    } else
    if ((int )pRhs->flags & 16) {
      if ((int const   )*(aKey1 + idx1) < 128) {
        serial_type = (u32 )*(aKey1 + idx1);
      } else {
        sqlite3GetVarint32(aKey1 + idx1, & serial_type);
      }
      if (serial_type < 12U) {
        rc = -1;
      } else
      if (serial_type & 1U) {
        rc = -1;
      } else {
        nStr = (int )((serial_type - 12U) / 2U);
        if (d1 + (u32 )nStr > (unsigned int )nKey1) {
          tmp___9 = sqlite3CorruptError(80969);
          pPKey2->errCode = (u8 )tmp___9;
          return (0);
        } else
        if ((int )pRhs->flags & 16384) {
          tmp___10 = isAllZero((char const   *)(aKey1 + d1), nStr);
          if (tmp___10) {
            rc = nStr - pRhs->u.nZero;
          } else {
            rc = 1;
          }
        } else {
          if (nStr < pRhs->n) {
            tmp___11 = nStr;
          } else {
            tmp___11 = pRhs->n;
          }
          nCmp___0 = tmp___11;
          rc = memcmp((void const   *)(aKey1 + d1), (void const   *)pRhs->z, (size_t )nCmp___0);
          if (rc == 0) {
            rc = nStr - pRhs->n;
          }
        }
      }
    } else {
      serial_type = (u32 )*(aKey1 + idx1);
      rc = serial_type != 0U;
    }
    if (rc != 0) {
      sortFlags = (int )*((pPKey2->pKeyInfo)->aSortFlags + i);
      if (sortFlags) {
        if ((sortFlags & 2) == 0) {
          rc = - rc;
        } else {
          if (serial_type == 0U) {
            tmp___12 = 1;
          } else
          if ((int )pRhs->flags & 1) {
            tmp___12 = 1;
          } else {
            tmp___12 = 0;
          }
          if ((sortFlags & 1) != tmp___12) {
            rc = - rc;
          }
        }
      }
      return (rc);
    }
    i ++;
    if (i == (int )pPKey2->nField) {
      break;
    }
    pRhs ++;
    tmp___13 = sqlite3VdbeSerialTypeLen(serial_type);
    d1 += tmp___13;
    tmp___14 = sqlite3VarintLen((u64 )serial_type);
    idx1 += (u32 )tmp___14;
    if (idx1 < szHdr1) {
      if (! (d1 <= (unsigned int )nKey1)) {
        break;
      }
    } else {
      break;
    }
  }
  pPKey2->eqSeen = (u8 )1;
  return ((int )pPKey2->default_rc);
}
}
static int sqlite3VdbeRecordCompare(int nKey1 , void const   *pKey1 , UnpackedRecord *pPKey2 ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
  return (tmp);
}
}
static int vdbeRecordCompareInt(int nKey1 , void const   *pKey1 , UnpackedRecord *pPKey2 ) 
{ 
  u8 const   *aKey ;
  int serial_type ;
  int res ;
  u32 y ;
  u64 x___0 ;
  i64 v ;
  i64 lhs ;
  int tmp ;
  int tmp___0 ;

  {
  aKey = (u8 const   *)pKey1 + ((int const   )*((u8 const   *)pKey1) & 63);
  serial_type = (int )*((u8 const   *)pKey1 + 1);
  switch (serial_type) {
  case 1: 
  lhs = (i64 )((i8 )*(aKey + 0));
  break;
  case 2: 
  lhs = (i64 )(256 * (int )((i8 )*(aKey + 0)) | (int )*(aKey + 1));
  break;
  case 3: 
  lhs = (i64 )((65536 * (int )((i8 )*(aKey + 0)) | (int )((int const   )*(aKey + 1) << 8)) | (int )*(aKey + 2));
  break;
  case 4: 
  y = ((((u32 )*(aKey + 0) << 24) | (unsigned int )((int const   )*(aKey + 1) << 16)) | (unsigned int )((int const   )*(aKey + 2) << 8)) | (unsigned int )*(aKey + 3);
  lhs = (i64 )*((int *)(& y));
  break;
  case 5: 
  lhs = (i64 )(((((u32 )*((aKey + 2) + 0) << 24) | (unsigned int )((int const   )*((aKey + 2) + 1) << 16)) | (unsigned int )((int const   )*((aKey + 2) + 2) << 8)) | (unsigned int )*((aKey + 2) + 3)) + (1LL << 32) * (i64 )(256 * (int )((i8 )*(aKey + 0)) | (int )*(aKey + 1));
  break;
  case 6: 
  x___0 = (u64 )(((((u32 )*(aKey + 0) << 24) | (unsigned int )((int const   )*(aKey + 1) << 16)) | (unsigned int )((int const   )*(aKey + 2) << 8)) | (unsigned int )*(aKey + 3));
  x___0 = (x___0 << 32) | (unsigned long long )(((((u32 )*((aKey + 4) + 0) << 24) | (unsigned int )((int const   )*((aKey + 4) + 1) << 16)) | (unsigned int )((int const   )*((aKey + 4) + 2) << 8)) | (unsigned int )*((aKey + 4) + 3));
  lhs = *((i64 *)(& x___0));
  break;
  case 8: 
  lhs = (i64 )0;
  break;
  case 9: 
  lhs = (i64 )1;
  break;
  case 7: 
  case 0: 
  tmp = sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);
  return (tmp);
  default: 
  tmp___0 = sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);
  return (tmp___0);
  }
  v = (pPKey2->aMem + 0)->u.i;
  if (v > lhs) {
    res = (int )pPKey2->r1;
  } else
  if (v < lhs) {
    res = (int )pPKey2->r2;
  } else
  if ((int )pPKey2->nField > 1) {
    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
  } else {
    res = (int )pPKey2->default_rc;
    pPKey2->eqSeen = (u8 )1;
  }
  return (res);
}
}
static int vdbeRecordCompareString(int nKey1 , void const   *pKey1 , UnpackedRecord *pPKey2 ) 
{ 
  u8 const   *aKey1 ;
  int serial_type ;
  int res ;
  int nCmp ;
  int nStr ;
  int szHdr ;
  int tmp ;

  {
  aKey1 = (u8 const   *)pKey1;
  if ((int const   )*(aKey1 + 1) < 128) {
    serial_type = (int )((u32 )*(aKey1 + 1));
  } else {
    sqlite3GetVarint32(aKey1 + 1, (u32 *)(& serial_type));
  }
  if (serial_type < 12) {
    res = (int )pPKey2->r1;
  } else
  if (! (serial_type & 1)) {
    res = (int )pPKey2->r2;
  } else {
    szHdr = (int )*(aKey1 + 0);
    nStr = (serial_type - 12) / 2;
    if (szHdr + nStr > nKey1) {
      tmp = sqlite3CorruptError(81161);
      pPKey2->errCode = (u8 )tmp;
      return (0);
    }
    if ((pPKey2->aMem + 0)->n < nStr) {
      nCmp = (pPKey2->aMem + 0)->n;
    } else {
      nCmp = nStr;
    }
    res = memcmp((void const   *)(aKey1 + szHdr), (void const   *)(pPKey2->aMem + 0)->z,
                 (size_t )nCmp);
    if (res > 0) {
      res = (int )pPKey2->r2;
    } else
    if (res < 0) {
      res = (int )pPKey2->r1;
    } else {
      res = nStr - (pPKey2->aMem + 0)->n;
      if (res == 0) {
        if ((int )pPKey2->nField > 1) {
          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
        } else {
          res = (int )pPKey2->default_rc;
          pPKey2->eqSeen = (u8 )1;
        }
      } else
      if (res > 0) {
        res = (int )pPKey2->r2;
      } else {
        res = (int )pPKey2->r1;
      }
    }
  }
  return (res);
}
}
static RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p ) 
{ 
  int flags___0 ;

  {
  if ((int )(p->pKeyInfo)->nAllField <= 13) {
    flags___0 = (int )(p->aMem + 0)->flags;
    if (*((p->pKeyInfo)->aSortFlags + 0)) {
      if ((int )*((p->pKeyInfo)->aSortFlags + 0) & 2) {
        return (& sqlite3VdbeRecordCompare);
      }
      p->r1 = (i8 )1;
      p->r2 = (i8 )-1;
    } else {
      p->r1 = (i8 )-1;
      p->r2 = (i8 )1;
    }
    if (flags___0 & 4) {
      return (& vdbeRecordCompareInt);
    }
    if ((flags___0 & 57) == 0) {
      if ((unsigned long )(p->pKeyInfo)->aColl[0] == (unsigned long )((CollSeq *)0)) {
        return (& vdbeRecordCompareString);
      }
    }
  }
  return (& sqlite3VdbeRecordCompare);
}
}
static int sqlite3VdbeIdxRowid(sqlite3 *db , BtCursor *pCur , i64 *rowid ) 
{ 
  i64 nCellKey ;
  int rc ;
  u32 szHdr ;
  u32 typeRowid ;
  u32 lenRowid ;
  Mem m ;
  Mem v ;
  u32 tmp ;
  int tmp___0 ;

  {
  nCellKey = (i64 )0;
  tmp = sqlite3BtreePayloadSize(pCur);
  nCellKey = (i64 )tmp;
  sqlite3VdbeMemInit(& m, db, (u16 )0);
  rc = sqlite3VdbeMemFromBtree(pCur, (u32 )0, (u32 )nCellKey, & m);
  if (rc) {
    return (rc);
  }
  if ((int )*((u8 *)m.z) < 128) {
    szHdr = (u32 )*((u8 *)m.z);
  } else {
    sqlite3GetVarint32((unsigned char const   *)((u8 *)m.z), & szHdr);
  }
  if (szHdr < 3U) {
    goto idx_rowid_corruption;
  } else
  if (szHdr > (unsigned int )m.n) {
    goto idx_rowid_corruption;
  }
  if ((int )*((u8 *)(m.z + (szHdr - 1U))) < 128) {
    typeRowid = (u32 )*((u8 *)(m.z + (szHdr - 1U)));
  } else {
    sqlite3GetVarint32((unsigned char const   *)((u8 *)(m.z + (szHdr - 1U))), & typeRowid);
  }
  if (typeRowid < 1U) {
    goto idx_rowid_corruption;
  } else
  if (typeRowid > 9U) {
    goto idx_rowid_corruption;
  } else
  if (typeRowid == 7U) {
    goto idx_rowid_corruption;
  }
  lenRowid = (u32 )sqlite3SmallTypeSizes[typeRowid];
  if ((u32 )m.n < szHdr + lenRowid) {
    goto idx_rowid_corruption;
  }
  sqlite3VdbeSerialGet((unsigned char const   *)((u8 *)(m.z + ((u32 )m.n - lenRowid))),
                       typeRowid, & v);
  *rowid = v.u.i;
  sqlite3VdbeMemRelease(& m);
  return (0);
  idx_rowid_corruption: 
  sqlite3VdbeMemRelease(& m);
  tmp___0 = sqlite3CorruptError(81316);
  return (tmp___0);
}
}
static int sqlite3VdbeIdxKeyCompare(sqlite3 *db , VdbeCursor *pC , UnpackedRecord *pUnpacked ,
                                    int *res ) 
{ 
  i64 nCellKey ;
  int rc ;
  BtCursor *pCur ;
  Mem m ;
  u32 tmp ;
  int tmp___0 ;

  {
  nCellKey = (i64 )0;
  pCur = pC->uc.pCursor;
  tmp = sqlite3BtreePayloadSize(pCur);
  nCellKey = (i64 )tmp;
  if (nCellKey <= 0LL) {
    *res = 0;
    tmp___0 = sqlite3CorruptError(81349);
    return (tmp___0);
  } else
  if (nCellKey > 2147483647LL) {
    *res = 0;
    tmp___0 = sqlite3CorruptError(81349);
    return (tmp___0);
  }
  sqlite3VdbeMemInit(& m, db, (u16 )0);
  rc = sqlite3VdbeMemFromBtree(pCur, (u32 )0, (u32 )nCellKey, & m);
  if (rc) {
    return (rc);
  }
  *res = sqlite3VdbeRecordCompareWithSkip(m.n, (void const   *)m.z, pUnpacked, 0);
  sqlite3VdbeMemRelease(& m);
  return (0);
}
}
static void sqlite3VdbeSetChanges(sqlite3 *db , int nChange ) 
{ 


  {
  db->nChange = nChange;
  db->nTotalChange += nChange;
  return;
}
}
static void sqlite3VdbeCountChanges(Vdbe *v ) 
{ 


  {
  v->changeCntOn = (bft )1;
  return;
}
}
static void sqlite3ExpirePreparedStatements(sqlite3 *db , int iCode ) 
{ 
  Vdbe *p ;

  {
  p = db->pVdbe;
  while (p) {
    p->expired = (bft )(iCode + 1);
    p = p->pNext;
  }
  return;
}
}
static sqlite3 *sqlite3VdbeDb(Vdbe *v ) 
{ 


  {
  return (v->db);
}
}
static u8 sqlite3VdbePrepareFlags(Vdbe *v ) 
{ 


  {
  return (v->prepFlags);
}
}
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v , int iVar , u8 aff ) 
{ 
  Mem *pMem ;
  sqlite3_value *pRet ;
  sqlite3_value *tmp ;

  {
  if (v) {
    pMem = v->aVar + (iVar - 1);
    if (0 == ((int )pMem->flags & 1)) {
      tmp = sqlite3ValueNew(v->db);
      pRet = tmp;
      if (pRet) {
        sqlite3VdbeMemCopy(pRet, (Mem const   *)pMem);
        sqlite3ValueApplyAffinity(pRet, aff, (u8 )1);
      }
      return (pRet);
    }
  }
  return ((sqlite3_value *)0);
}
}
static void sqlite3VdbeSetVarmask(Vdbe *v , int iVar ) 
{ 


  {
  if (iVar >= 32) {
    v->expmask |= 2147483648U;
  } else {
    v->expmask |= 1U << (iVar - 1);
  }
  return;
}
}
static int sqlite3NotPureFunc(sqlite3_context *pCtx ) 
{ 


  {
  if ((int )((pCtx->pVdbe)->aOp + pCtx->iOp)->opcode == 64) {
    sqlite3_result_error(pCtx, "non-deterministic function in index expression or CHECK constraint",
                         -1);
    return (0);
  }
  return (1);
}
}
static void sqlite3VtabImportErrmsg(Vdbe *p , sqlite3_vtab *pVtab ) 
{ 
  sqlite3 *db ;

  {
  if (pVtab->zErrMsg) {
    db = p->db;
    sqlite3DbFree(db, (void *)p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, (char const   *)pVtab->zErrMsg);
    sqlite3_free((void *)pVtab->zErrMsg);
    pVtab->zErrMsg = (char *)0;
  }
  return;
}
}
int sqlite3_expired(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *p ;
  int tmp ;

  {
  p = (Vdbe *)pStmt;
  if ((unsigned long )p == (unsigned long )((Vdbe *)0)) {
    tmp = 1;
  } else
  if (p->expired) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int vdbeSafety(Vdbe *p ) 
{ 


  {
  if ((unsigned long )p->db == (unsigned long )((sqlite3 *)0)) {
    sqlite3_log(21, "API called with finalized prepared statement");
    return (1);
  } else {
    return (0);
  }
}
}
static int vdbeSafetyNotNull(Vdbe *p ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p == (unsigned long )((Vdbe *)0)) {
    sqlite3_log(21, "API called with NULL prepared statement");
    return (1);
  } else {
    tmp = vdbeSafety(p);
    return (tmp);
  }
}
}
static void ( __attribute__((__noinline__)) invokeProfileCallback)(sqlite3 *db , Vdbe *p ) 
{ 
  sqlite_int64 iNow ;
  sqlite_int64 iElapse ;

  {
  sqlite3OsCurrentTimeInt64(db->pVfs, & iNow);
  iElapse = (iNow - p->startTime) * 1000000LL;
  if (db->xProfile) {
    (*(db->xProfile))(db->pProfileArg, (char const   *)p->zSql, (u64 )iElapse);
  }
  if ((int )db->mTrace & 2) {
    (*(db->xTrace))((u32 )2, db->pTraceArg, (void *)p, (void *)(& iElapse));
  }
  p->startTime = (i64 )0;
  return;
}
}
int sqlite3_finalize(sqlite3_stmt *pStmt ) 
{ 
  int rc ;
  Vdbe *v ;
  sqlite3 *db ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )pStmt == (unsigned long )((sqlite3_stmt *)0)) {
    rc = 0;
  } else {
    v = (Vdbe *)pStmt;
    db = v->db;
    tmp___0 = vdbeSafety(v);
    if (tmp___0) {
      tmp = sqlite3MisuseError(81695);
      return (tmp);
    }
    if (v->startTime > 0LL) {
      invokeProfileCallback(db, v);
    }
    rc = sqlite3VdbeFinalize(v);
    rc = sqlite3ApiExit(db, rc);
    sqlite3LeaveMutexAndCloseZombie(db);
  }
  return (rc);
}
}
int sqlite3_reset(sqlite3_stmt *pStmt ) 
{ 
  int rc ;
  Vdbe *v ;
  sqlite3 *db ;

  {
  if ((unsigned long )pStmt == (unsigned long )((sqlite3_stmt *)0)) {
    rc = 0;
  } else {
    v = (Vdbe *)pStmt;
    db = v->db;
    if (v->startTime > 0LL) {
      invokeProfileCallback(db, v);
    }
    rc = sqlite3VdbeReset(v);
    sqlite3VdbeRewind(v);
    rc = sqlite3ApiExit(db, rc);
  }
  return (rc);
}
}
int sqlite3_clear_bindings(sqlite3_stmt *pStmt ) 
{ 
  int i ;
  int rc ;
  Vdbe *p ;

  {
  rc = 0;
  p = (Vdbe *)pStmt;
  i = 0;
  while (i < (int )p->nVar) {
    sqlite3VdbeMemRelease(p->aVar + i);
    (p->aVar + i)->flags = (u16 )1;
    i ++;
  }
  if (p->expmask) {
    p->expired = (bft )1;
  }
  return (rc);
}
}
void const   *sqlite3_value_blob(sqlite3_value *pVal ) 
{ 
  Mem *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned char const   *tmp___2 ;

  {
  p = pVal;
  if ((int )p->flags & 18) {
    if ((int )p->flags & 16384) {
      tmp = sqlite3VdbeMemExpandBlob(p);
      tmp___0 = tmp;
    } else {
      tmp___0 = 0;
    }
    if (tmp___0 != 0) {
      return ((void const   *)0);
    }
    p->flags = (u16 )((int )p->flags | 16);
    if (p->n) {
      tmp___1 = p->z;
    } else {
      tmp___1 = (char *)0;
    }
    return ((void const   *)tmp___1);
  } else {
    tmp___2 = sqlite3_value_text(pVal);
    return ((void const   *)tmp___2);
  }
}
}
int sqlite3_value_bytes(sqlite3_value *pVal ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ValueBytes(pVal, (u8 )1);
  return (tmp);
}
}
int sqlite3_value_bytes16(sqlite3_value *pVal ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ValueBytes(pVal, (u8 )2);
  return (tmp);
}
}
double sqlite3_value_double(sqlite3_value *pVal ) 
{ 
  double tmp ;

  {
  tmp = sqlite3VdbeRealValue(pVal);
  return (tmp);
}
}
int sqlite3_value_int(sqlite3_value *pVal ) 
{ 
  i64 tmp ;

  {
  tmp = sqlite3VdbeIntValue(pVal);
  return ((int )tmp);
}
}
long long sqlite3_value_int64(sqlite3_value *pVal ) 
{ 
  i64 tmp ;

  {
  tmp = sqlite3VdbeIntValue(pVal);
  return (tmp);
}
}
unsigned int sqlite3_value_subtype(sqlite3_value *pVal ) 
{ 
  Mem *pMem ;
  int tmp ;

  {
  pMem = pVal;
  if ((int )pMem->flags & 32768) {
    tmp = (int )pMem->eSubtype;
  } else {
    tmp = 0;
  }
  return ((unsigned int )tmp);
}
}
void *sqlite3_value_pointer(sqlite3_value *pVal , char const   *zPType ) 
{ 
  Mem *p ;
  int tmp ;

  {
  p = pVal;
  if (((int )p->flags & 50111) == 33281) {
    if ((unsigned long )zPType != (unsigned long )((char const   *)0)) {
      if ((int )p->eSubtype == 112) {
        tmp = strcmp(p->u.zPType, zPType);
        if (tmp == 0) {
          return ((void *)p->z);
        } else {
          return ((void *)0);
        }
      } else {
        return ((void *)0);
      }
    } else {
      return ((void *)0);
    }
  } else {
    return ((void *)0);
  }
}
}
unsigned char const   *sqlite3_value_text(sqlite3_value *pVal ) 
{ 
  void const   *tmp ;

  {
  tmp = sqlite3ValueText(pVal, (u8 )1);
  return ((unsigned char const   *)tmp);
}
}
void const   *sqlite3_value_text16(sqlite3_value *pVal ) 
{ 
  void const   *tmp ;

  {
  tmp = sqlite3ValueText(pVal, (u8 )2);
  return (tmp);
}
}
void const   *sqlite3_value_text16be(sqlite3_value *pVal ) 
{ 
  void const   *tmp ;

  {
  tmp = sqlite3ValueText(pVal, (u8 )3);
  return (tmp);
}
}
void const   *sqlite3_value_text16le(sqlite3_value *pVal ) 
{ 
  void const   *tmp ;

  {
  tmp = sqlite3ValueText(pVal, (u8 )2);
  return (tmp);
}
}
static u8 const   aType[64]  = 
  {      (u8 const   )4,      (u8 const   )5,      (u8 const   )3,      (u8 const   )5, 
        (u8 const   )1,      (u8 const   )5,      (u8 const   )1,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )1,      (u8 const   )5,      (u8 const   )1,      (u8 const   )5, 
        (u8 const   )4,      (u8 const   )5,      (u8 const   )3,      (u8 const   )5, 
        (u8 const   )1,      (u8 const   )5,      (u8 const   )1,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )1,      (u8 const   )5,      (u8 const   )1,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )3,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )4,      (u8 const   )5,      (u8 const   )3,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5, 
        (u8 const   )2,      (u8 const   )5,      (u8 const   )2,      (u8 const   )5};
int sqlite3_value_type(sqlite3_value *pVal ) 
{ 


  {
  return ((int )aType[(int )pVal->flags & 63]);
}
}
int sqlite3_value_nochange(sqlite3_value *pVal ) 
{ 


  {
  return (((int )pVal->flags & 16385) == 16385);
}
}
int sqlite3_value_frombind(sqlite3_value *pVal ) 
{ 


  {
  return (((int )pVal->flags & 64) != 0);
}
}
sqlite3_value *sqlite3_value_dup(sqlite3_value const   *pOrig ) 
{ 
  sqlite3_value *pNew ;
  void *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )pOrig == (unsigned long )((sqlite3_value const   *)0)) {
    return ((sqlite3_value *)0);
  }
  tmp = sqlite3_malloc((int )sizeof(*pNew));
  pNew = (sqlite3_value *)tmp;
  if ((unsigned long )pNew == (unsigned long )((sqlite3_value *)0)) {
    return ((sqlite3_value *)0);
  }
  memset((void *)pNew, 0, sizeof(*pNew));
  memcpy((void * __restrict  )pNew, (void const   * __restrict  )pOrig, (unsigned long )(& ((Mem *)0)->zMalloc));
  pNew->flags = (u16 )((int )pNew->flags & -1025);
  pNew->db = (sqlite3 *)0;
  if ((int )pNew->flags & 18) {
    pNew->flags = (u16 )((int )pNew->flags & -3073);
    pNew->flags = (u16 )((int )pNew->flags | 4096);
    tmp___0 = sqlite3VdbeMemMakeWriteable(pNew);
    if (tmp___0 != 0) {
      sqlite3ValueFree(pNew);
      pNew = (sqlite3_value *)0;
    }
  }
  return (pNew);
}
}
void sqlite3_value_free(sqlite3_value *pOld ) 
{ 


  {
  sqlite3ValueFree(pOld);
  return;
}
}
static void setResultStrOrError(sqlite3_context *pCtx , char const   *z , int n ,
                                u8 enc , void (*xDel)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel);
  if (tmp == 18) {
    sqlite3_result_error_toobig(pCtx);
  }
  return;
}
}
static int invokeValueDestructor(void const   *p , void (*xDel)(void * ) , sqlite3_context *pCtx ) 
{ 


  {
  if (! ((unsigned long )xDel == (unsigned long )((void (*)(void * ))0))) {
    if (! ((unsigned long )xDel == (unsigned long )((void (*)(void * ))-1))) {
      (*xDel)((void *)p);
    }
  }
  if (pCtx) {
    sqlite3_result_error_toobig(pCtx);
  }
  return (18);
}
}
void sqlite3_result_blob(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) 
{ 


  {
  setResultStrOrError(pCtx, (char const   *)z, n, (u8 )0, xDel);
  return;
}
}
void sqlite3_result_blob64(sqlite3_context *pCtx , void const   *z , sqlite_uint64 n ,
                           void (*xDel)(void * ) ) 
{ 


  {
  if (n > 2147483647ULL) {
    invokeValueDestructor(z, xDel, pCtx);
  } else {
    setResultStrOrError(pCtx, (char const   *)z, (int )n, (u8 )0, xDel);
  }
  return;
}
}
void sqlite3_result_double(sqlite3_context *pCtx , double rVal ) 
{ 


  {
  sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);
  return;
}
}
void sqlite3_result_error(sqlite3_context *pCtx , char const   *z , int n ) 
{ 


  {
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, (u8 )1, (void (*)(void * ))-1);
  return;
}
}
void sqlite3_result_error16(sqlite3_context *pCtx , void const   *z , int n ) 
{ 


  {
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(pCtx->pOut, (char const   *)z, n, (u8 )2, (void (*)(void * ))-1);
  return;
}
}
void sqlite3_result_int(sqlite3_context *pCtx , int iVal ) 
{ 


  {
  sqlite3VdbeMemSetInt64(pCtx->pOut, (i64 )iVal);
  return;
}
}
void sqlite3_result_int64(sqlite3_context *pCtx , long long iVal ) 
{ 


  {
  sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);
  return;
}
}
void sqlite3_result_null(sqlite3_context *pCtx ) 
{ 


  {
  sqlite3VdbeMemSetNull(pCtx->pOut);
  return;
}
}
void sqlite3_result_pointer(sqlite3_context *pCtx , void *pPtr , char const   *zPType ,
                            void (*xDestructor)(void * ) ) 
{ 
  Mem *pOut ;

  {
  pOut = pCtx->pOut;
  sqlite3VdbeMemRelease(pOut);
  pOut->flags = (u16 )1;
  sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
  return;
}
}
void sqlite3_result_subtype(sqlite3_context *pCtx , unsigned int eSubtype ) 
{ 
  Mem *pOut ;

  {
  pOut = pCtx->pOut;
  pOut->eSubtype = (u8 )(eSubtype & 255U);
  pOut->flags = (u16 )((int )pOut->flags | 32768);
  return;
}
}
void sqlite3_result_text(sqlite3_context *pCtx , char const   *z , int n , void (*xDel)(void * ) ) 
{ 


  {
  setResultStrOrError(pCtx, z, n, (u8 )1, xDel);
  return;
}
}
void sqlite3_result_text64(sqlite3_context *pCtx , char const   *z , sqlite_uint64 n ,
                           void (*xDel)(void * ) , unsigned char enc ) 
{ 


  {
  if ((int )enc == 4) {
    enc = (unsigned char)2;
  }
  if (n > 2147483647ULL) {
    invokeValueDestructor((void const   *)z, xDel, pCtx);
  } else {
    setResultStrOrError(pCtx, z, (int )n, enc, xDel);
  }
  return;
}
}
void sqlite3_result_text16(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) 
{ 


  {
  setResultStrOrError(pCtx, (char const   *)z, n, (u8 )2, xDel);
  return;
}
}
void sqlite3_result_text16be(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) 
{ 


  {
  setResultStrOrError(pCtx, (char const   *)z, n, (u8 )3, xDel);
  return;
}
}
void sqlite3_result_text16le(sqlite3_context *pCtx , void const   *z , int n , void (*xDel)(void * ) ) 
{ 


  {
  setResultStrOrError(pCtx, (char const   *)z, n, (u8 )2, xDel);
  return;
}
}
void sqlite3_result_value(sqlite3_context *pCtx , sqlite3_value *pValue ) 
{ 


  {
  sqlite3VdbeMemCopy(pCtx->pOut, (Mem const   *)pValue);
  return;
}
}
void sqlite3_result_zeroblob(sqlite3_context *pCtx , int n ) 
{ 


  {
  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n);
  return;
}
}
int sqlite3_result_zeroblob64(sqlite3_context *pCtx , unsigned long long n ) 
{ 
  Mem *pOut ;

  {
  pOut = pCtx->pOut;
  if (n > (u64 )(pOut->db)->aLimit[0]) {
    return (18);
  }
  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int )n);
  return (0);
}
}
void sqlite3_result_error_code(sqlite3_context *pCtx , int errCode ) 
{ 
  char const   *tmp ;

  {
  if (errCode) {
    pCtx->isError = errCode;
  } else {
    pCtx->isError = -1;
  }
  if ((int )(pCtx->pOut)->flags & 1) {
    tmp = sqlite3ErrStr(errCode);
    sqlite3VdbeMemSetStr(pCtx->pOut, tmp, -1, (u8 )1, (void (*)(void * ))0);
  }
  return;
}
}
void sqlite3_result_error_toobig(sqlite3_context *pCtx ) 
{ 


  {
  pCtx->isError = 18;
  sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1, (u8 )1, (void (*)(void * ))0);
  return;
}
}
void sqlite3_result_error_nomem(sqlite3_context *pCtx ) 
{ 


  {
  sqlite3VdbeMemSetNull(pCtx->pOut);
  pCtx->isError = 7;
  sqlite3OomFault((pCtx->pOut)->db);
  return;
}
}
static void sqlite3ResultIntReal(sqlite3_context *pCtx ) 
{ 


  {
  if ((int )(pCtx->pOut)->flags & 4) {
    (pCtx->pOut)->flags = (u16 )((int )(pCtx->pOut)->flags & -5);
    (pCtx->pOut)->flags = (u16 )((int )(pCtx->pOut)->flags | 32);
  }
  return;
}
}
static int doWalCallbacks(sqlite3 *db ) 
{ 
  int rc ;
  int i ;
  Btree *pBt ;
  int nEntry ;
  struct Pager *tmp ;

  {
  rc = 0;
  i = 0;
  while (i < db->nDb) {
    pBt = (db->aDb + i)->pBt;
    if (pBt) {
      sqlite3BtreeEnter(pBt);
      tmp = sqlite3BtreePager(pBt);
      nEntry = sqlite3PagerWalCallback(tmp);
      if (nEntry > 0) {
        if (db->xWalCallback) {
          if (rc == 0) {
            rc = (*(db->xWalCallback))(db->pWalArg, db, (char const   *)(db->aDb + i)->zDbSName,
                                       nEntry);
          }
        }
      }
    }
    i ++;
  }
  return (rc);
}
}
static int sqlite3Step(Vdbe *p ) 
{ 
  sqlite3 *db ;
  int rc ;
  int tmp ;

  {
  if (p->magic != 770837923U) {
    sqlite3_reset((sqlite3_stmt *)p);
  }
  db = p->db;
  if (db->mallocFailed) {
    p->rc = 7;
    return (7);
  }
  if (p->pc < 0) {
    if (p->expired) {
      p->rc = 17;
      rc = 1;
      goto end_of_step;
    }
  }
  if (p->pc < 0) {
    if (db->nVdbeActive == 0) {
      db->u1.isInterrupted = (int volatile   )0;
    }
    if (((int )db->mTrace & 130) != 0) {
      if (! db->init.busy) {
        if (p->zSql) {
          sqlite3OsCurrentTimeInt64(db->pVfs, & p->startTime);
        }
      }
    }
    (db->nVdbeActive) ++;
    if (p->readOnly == 0U) {
      (db->nVdbeWrite) ++;
    }
    if (p->bIsReader) {
      (db->nVdbeRead) ++;
    }
    p->pc = 0;
  }
  if (p->explain) {
    rc = sqlite3VdbeList(p);
  } else {
    (db->nVdbeExec) ++;
    rc = sqlite3VdbeExec(p);
    (db->nVdbeExec) --;
  }
  if (rc != 100) {
    if (p->startTime > 0LL) {
      invokeProfileCallback(db, p);
    }
    if (rc == 101) {
      if (db->autoCommit) {
        p->rc = doWalCallbacks(db);
        if (p->rc != 0) {
          rc = 1;
        }
      }
    }
  }
  db->errCode = rc;
  tmp = sqlite3ApiExit(p->db, p->rc);
  if (7 == tmp) {
    p->rc = 7;
  }
  end_of_step: ;
  if (rc != 100) {
    if (rc != 101) {
      if (((int )p->prepFlags & 128) != 0) {
        rc = sqlite3VdbeTransferError(p);
      }
    }
  }
  return (rc & db->errMask);
}
}
int sqlite3_step(sqlite3_stmt *pStmt ) 
{ 
  int rc ;
  Vdbe *v ;
  int cnt ;
  sqlite3 *db ;
  int tmp ;
  int tmp___0 ;
  int savedPc ;
  char const   *zErr ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;

  {
  rc = 0;
  v = (Vdbe *)pStmt;
  cnt = 0;
  tmp___0 = vdbeSafetyNotNull(v);
  if (tmp___0) {
    tmp = sqlite3MisuseError(82344);
    return (tmp);
  }
  db = v->db;
  v->doingRerun = (bft )0;
  while (1) {
    rc = sqlite3Step(v);
    if (rc == 17) {
      tmp___2 = cnt;
      cnt ++;
      if (! (tmp___2 < 50)) {
        break;
      }
    } else {
      break;
    }
    savedPc = v->pc;
    rc = sqlite3Reprepare(v);
    if (rc != 0) {
      tmp___1 = sqlite3_value_text(db->pErr);
      zErr = (char const   *)tmp___1;
      sqlite3DbFree(db, (void *)v->zErrMsg);
      if (! db->mallocFailed) {
        v->zErrMsg = sqlite3DbStrDup(db, zErr);
        rc = sqlite3ApiExit(db, rc);
        v->rc = rc;
      } else {
        v->zErrMsg = (char *)0;
        rc = 7;
        v->rc = rc;
      }
      break;
    }
    sqlite3_reset(pStmt);
    if (savedPc >= 0) {
      v->doingRerun = (bft )1;
    }
  }
  return (rc);
}
}
void *sqlite3_user_data(sqlite3_context *p ) 
{ 


  {
  return ((p->pFunc)->pUserData);
}
}
sqlite3 *sqlite3_context_db_handle(sqlite3_context *p ) 
{ 


  {
  return ((p->pOut)->db);
}
}
int sqlite3_vtab_nochange(sqlite3_context *p ) 
{ 
  int tmp ;

  {
  tmp = sqlite3_value_nochange(p->pOut);
  return (tmp);
}
}
static sqlite_int64 sqlite3StmtCurrentTime(sqlite3_context *p ) 
{ 
  int rc ;
  sqlite_int64 *piTime ;

  {
  piTime = & (p->pVdbe)->iCurrentTime;
  if (*piTime == 0LL) {
    rc = sqlite3OsCurrentTimeInt64(((p->pOut)->db)->pVfs, piTime);
    if (rc) {
      *piTime = (sqlite_int64 )0;
    }
  }
  return (*piTime);
}
}
static void *( __attribute__((__noinline__)) createAggContext)(sqlite3_context *p ,
                                                               int nByte ) 
{ 
  Mem *pMem ;

  {
  pMem = p->pMem;
  if (nByte <= 0) {
    sqlite3VdbeMemSetNull(pMem);
    pMem->z = (char *)0;
  } else {
    sqlite3VdbeMemClearAndResize(pMem, nByte);
    pMem->flags = (u16 )8192;
    pMem->u.pDef = p->pFunc;
    if (pMem->z) {
      memset((void *)pMem->z, 0, (size_t )nByte);
    }
  }
  return ((void *)pMem->z);
}
}
void *sqlite3_aggregate_context(sqlite3_context *p , int nByte ) 
{ 
  void *tmp ;

  {
  if (((int )(p->pMem)->flags & 8192) == 0) {
    tmp = createAggContext(p, nByte);
    return (tmp);
  } else {
    return ((void *)(p->pMem)->z);
  }
}
}
void *sqlite3_get_auxdata(sqlite3_context *pCtx , int iArg ) 
{ 
  AuxData *pAuxData ;

  {
  pAuxData = (pCtx->pVdbe)->pAuxData;
  while (pAuxData) {
    if (pAuxData->iAuxArg == iArg) {
      if (pAuxData->iAuxOp == pCtx->iOp) {
        return (pAuxData->pAux);
      } else
      if (iArg < 0) {
        return (pAuxData->pAux);
      }
    }
    pAuxData = pAuxData->pNextAux;
  }
  return ((void *)0);
}
}
void sqlite3_set_auxdata(sqlite3_context *pCtx , int iArg , void *pAux , void (*xDelete)(void * ) ) 
{ 
  AuxData *pAuxData ;
  Vdbe *pVdbe ;
  void *tmp ;

  {
  pVdbe = pCtx->pVdbe;
  pAuxData = pVdbe->pAuxData;
  while (pAuxData) {
    if (pAuxData->iAuxArg == iArg) {
      if (pAuxData->iAuxOp == pCtx->iOp) {
        break;
      } else
      if (iArg < 0) {
        break;
      }
    }
    pAuxData = pAuxData->pNextAux;
  }
  if ((unsigned long )pAuxData == (unsigned long )((AuxData *)0)) {
    tmp = sqlite3DbMallocZero(pVdbe->db, (u64 )sizeof(AuxData ));
    pAuxData = (AuxData *)tmp;
    if (! pAuxData) {
      goto failed;
    }
    pAuxData->iAuxOp = pCtx->iOp;
    pAuxData->iAuxArg = iArg;
    pAuxData->pNextAux = pVdbe->pAuxData;
    pVdbe->pAuxData = pAuxData;
    if (pCtx->isError == 0) {
      pCtx->isError = -1;
    }
  } else
  if (pAuxData->xDeleteAux) {
    (*(pAuxData->xDeleteAux))(pAuxData->pAux);
  }
  pAuxData->pAux = pAux;
  pAuxData->xDeleteAux = xDelete;
  return;
  failed: 
  if (xDelete) {
    (*xDelete)(pAux);
  }
  return;
}
}
int sqlite3_aggregate_count(sqlite3_context *p ) 
{ 


  {
  return ((p->pMem)->n);
}
}
int sqlite3_column_count(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *pVm ;
  int tmp ;

  {
  pVm = (Vdbe *)pStmt;
  if (pVm) {
    tmp = (int )pVm->nResColumn;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int sqlite3_data_count(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *pVm ;

  {
  pVm = (Vdbe *)pStmt;
  if ((unsigned long )pVm == (unsigned long )((Vdbe *)0)) {
    return (0);
  } else
  if ((unsigned long )pVm->pResultSet == (unsigned long )((Mem *)0)) {
    return (0);
  }
  return ((int )pVm->nResColumn);
}
}
static Mem const   *columnNullValue(void) ;
static struct sqlite3_value  const  nullMem  = 
     {{(double )0}, (u16 )1, (u8 )0, (u8 )0, 0, (char *)0, (char *)0, 0, (u32 )0, (sqlite3 *)0,
    (void (*)(void * ))0};
static Mem const   *columnNullValue(void) 
{ 


  {
  return (& nullMem);
}
}
static Mem *columnMem(sqlite3_stmt *pStmt , int i ) 
{ 
  Vdbe *pVm ;
  Mem *pOut ;
  Mem const   *tmp ;
  Mem const   *tmp___0 ;

  {
  pVm = (Vdbe *)pStmt;
  if ((unsigned long )pVm == (unsigned long )((Vdbe *)0)) {
    tmp = columnNullValue();
    return ((Mem *)tmp);
  }
  if ((unsigned long )pVm->pResultSet != (unsigned long )((Mem *)0)) {
    if (i < (int )pVm->nResColumn) {
      if (i >= 0) {
        pOut = pVm->pResultSet + i;
      } else {
        sqlite3Error(pVm->db, 25);
        tmp___0 = columnNullValue();
        pOut = (Mem *)tmp___0;
      }
    } else {
      sqlite3Error(pVm->db, 25);
      tmp___0 = columnNullValue();
      pOut = (Mem *)tmp___0;
    }
  } else {
    sqlite3Error(pVm->db, 25);
    tmp___0 = columnNullValue();
    pOut = (Mem *)tmp___0;
  }
  return (pOut);
}
}
static void columnMallocFailure(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  if (p) {
    p->rc = sqlite3ApiExit(p->db, p->rc);
  }
  return;
}
}
void const   *sqlite3_column_blob(sqlite3_stmt *pStmt , int i ) 
{ 
  void const   *val ;
  Mem *tmp ;

  {
  tmp = columnMem(pStmt, i);
  val = sqlite3_value_blob(tmp);
  columnMallocFailure(pStmt);
  return (val);
}
}
int sqlite3_column_bytes(sqlite3_stmt *pStmt , int i ) 
{ 
  int val ;
  Mem *tmp ;
  int tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_bytes(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
int sqlite3_column_bytes16(sqlite3_stmt *pStmt , int i ) 
{ 
  int val ;
  Mem *tmp ;
  int tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_bytes16(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
double sqlite3_column_double(sqlite3_stmt *pStmt , int i ) 
{ 
  double val ;
  Mem *tmp ;
  double tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_double(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
int sqlite3_column_int(sqlite3_stmt *pStmt , int i ) 
{ 
  int val ;
  Mem *tmp ;
  int tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_int(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
long long sqlite3_column_int64(sqlite3_stmt *pStmt , int i ) 
{ 
  sqlite_int64 val ;
  Mem *tmp ;
  long long tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_int64(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
unsigned char const   *sqlite3_column_text(sqlite3_stmt *pStmt , int i ) 
{ 
  unsigned char const   *val ;
  Mem *tmp ;
  unsigned char const   *tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_text(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt , int i ) 
{ 
  Mem *pOut ;
  Mem *tmp ;

  {
  tmp = columnMem(pStmt, i);
  pOut = tmp;
  if ((int )pOut->flags & 2048) {
    pOut->flags = (u16 )((int )pOut->flags & -2049);
    pOut->flags = (u16 )((int )pOut->flags | 4096);
  }
  columnMallocFailure(pStmt);
  return (pOut);
}
}
void const   *sqlite3_column_text16(sqlite3_stmt *pStmt , int i ) 
{ 
  void const   *val ;
  Mem *tmp ;
  void const   *tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_text16(tmp);
  val = tmp___0;
  columnMallocFailure(pStmt);
  return (val);
}
}
int sqlite3_column_type(sqlite3_stmt *pStmt , int i ) 
{ 
  int iType ;
  Mem *tmp ;
  int tmp___0 ;

  {
  tmp = columnMem(pStmt, i);
  tmp___0 = sqlite3_value_type(tmp);
  iType = tmp___0;
  columnMallocFailure(pStmt);
  return (iType);
}
}
static void const   *columnName(sqlite3_stmt *pStmt , int N , int useUtf16 , int useType ) 
{ 
  void const   *ret ;
  Vdbe *p ;
  int n ;
  sqlite3 *db ;
  unsigned char const   *tmp ;

  {
  ret = (void const   *)0;
  p = (Vdbe *)pStmt;
  db = p->db;
  n = sqlite3_column_count(pStmt);
  if (N < n) {
    if (N >= 0) {
      N += useType * n;
      if (useUtf16) {
        ret = sqlite3_value_text16(p->aColName + N);
      } else {
        tmp = sqlite3_value_text(p->aColName + N);
        ret = (void const   *)tmp;
      }
      if (db->mallocFailed) {
        sqlite3OomClear(db);
        ret = (void const   *)0;
      }
    }
  }
  return (ret);
}
}
char const   *sqlite3_column_name(sqlite3_stmt *pStmt , int N ) 
{ 
  void const   *tmp ;

  {
  tmp = columnName(pStmt, N, 0, 0);
  return ((char const   *)tmp);
}
}
void const   *sqlite3_column_name16(sqlite3_stmt *pStmt , int N ) 
{ 
  void const   *tmp ;

  {
  tmp = columnName(pStmt, N, 1, 0);
  return (tmp);
}
}
char const   *sqlite3_column_decltype(sqlite3_stmt *pStmt , int N ) 
{ 
  void const   *tmp ;

  {
  tmp = columnName(pStmt, N, 0, 1);
  return ((char const   *)tmp);
}
}
void const   *sqlite3_column_decltype16(sqlite3_stmt *pStmt , int N ) 
{ 
  void const   *tmp ;

  {
  tmp = columnName(pStmt, N, 1, 1);
  return (tmp);
}
}
static int vdbeUnbind(Vdbe *p , int i ) 
{ 
  Mem *pVar ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
  tmp___0 = vdbeSafetyNotNull(p);
  if (tmp___0) {
    tmp = sqlite3MisuseError(82921);
    return (tmp);
  }
  if (p->magic != 770837923U) {
    sqlite3Error(p->db, 21);
    sqlite3_log(21, "bind on a busy prepared statement: [%s]", p->zSql);
    tmp___1 = sqlite3MisuseError(82929);
    return (tmp___1);
  } else
  if (p->pc >= 0) {
    sqlite3Error(p->db, 21);
    sqlite3_log(21, "bind on a busy prepared statement: [%s]", p->zSql);
    tmp___1 = sqlite3MisuseError(82929);
    return (tmp___1);
  }
  if (i < 1) {
    sqlite3Error(p->db, 25);
    return (25);
  } else
  if (i > (int )p->nVar) {
    sqlite3Error(p->db, 25);
    return (25);
  }
  i --;
  pVar = p->aVar + i;
  sqlite3VdbeMemRelease(pVar);
  pVar->flags = (u16 )1;
  (p->db)->errCode = 0;
  if (p->expmask != 0U) {
    if (i >= 31) {
      tmp___2 = 2147483648U;
    } else {
      tmp___2 = 1U << i;
    }
    if ((p->expmask & tmp___2) != 0U) {
      p->expired = (bft )1;
    }
  }
  return (0);
}
}
static int bindText(sqlite3_stmt *pStmt , int i , void const   *zData , int nData ,
                    void (*xDel)(void * ) , u8 encoding ) 
{ 
  Vdbe *p ;
  Mem *pVar ;
  int rc ;

  {
  p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if (rc == 0) {
    if ((unsigned long )zData != (unsigned long )((void const   *)0)) {
      pVar = p->aVar + (i - 1);
      rc = sqlite3VdbeMemSetStr(pVar, (char const   *)zData, nData, encoding, xDel);
      if (rc == 0) {
        if ((int )encoding != 0) {
          rc = sqlite3VdbeChangeEncoding(pVar, (int )(p->db)->enc);
        }
      }
      if (rc) {
        sqlite3Error(p->db, rc);
        rc = sqlite3ApiExit(p->db, rc);
      }
    }
  } else
  if ((unsigned long )xDel != (unsigned long )((void (*)(void * ))0)) {
    if ((unsigned long )xDel != (unsigned long )((void (*)(void * ))-1)) {
      (*xDel)((void *)zData);
    }
  }
  return (rc);
}
}
int sqlite3_bind_blob(sqlite3_stmt *pStmt , int i , void const   *zData , int nData ,
                      void (*xDel)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = bindText(pStmt, i, zData, nData, xDel, (u8 )0);
  return (tmp);
}
}
int sqlite3_bind_blob64(sqlite3_stmt *pStmt , int i , void const   *zData , sqlite_uint64 nData ,
                        void (*xDel)(void * ) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (nData > 2147483647ULL) {
    tmp = invokeValueDestructor(zData, xDel, (sqlite3_context *)0);
    return (tmp);
  } else {
    tmp___0 = bindText(pStmt, i, zData, (int )nData, xDel, (u8 )0);
    return (tmp___0);
  }
}
}
int sqlite3_bind_double(sqlite3_stmt *pStmt , int i , double rValue ) 
{ 
  int rc ;
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if (rc == 0) {
    sqlite3VdbeMemSetDouble(p->aVar + (i - 1), rValue);
  }
  return (rc);
}
}
int sqlite3_bind_int(sqlite3_stmt *p , int i , int iValue___0 ) 
{ 
  int tmp ;

  {
  tmp = sqlite3_bind_int64(p, i, (i64 )iValue___0);
  return (tmp);
}
}
int sqlite3_bind_int64(sqlite3_stmt *pStmt , int i , long long iValue___0 ) 
{ 
  int rc ;
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if (rc == 0) {
    sqlite3VdbeMemSetInt64(p->aVar + (i - 1), iValue___0);
  }
  return (rc);
}
}
int sqlite3_bind_null(sqlite3_stmt *pStmt , int i ) 
{ 
  int rc ;
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  return (rc);
}
}
int sqlite3_bind_pointer(sqlite3_stmt *pStmt , int i , void *pPtr , char const   *zPTtype ,
                         void (*xDestructor)(void * ) ) 
{ 
  int rc ;
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if (rc == 0) {
    sqlite3VdbeMemSetPointer(p->aVar + (i - 1), pPtr, zPTtype, xDestructor);
  } else
  if (xDestructor) {
    (*xDestructor)(pPtr);
  }
  return (rc);
}
}
int sqlite3_bind_text(sqlite3_stmt *pStmt , int i , char const   *zData , int nData ,
                      void (*xDel)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = bindText(pStmt, i, (void const   *)zData, nData, xDel, (u8 )1);
  return (tmp);
}
}
int sqlite3_bind_text64(sqlite3_stmt *pStmt , int i , char const   *zData , sqlite_uint64 nData ,
                        void (*xDel)(void * ) , unsigned char enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (nData > 2147483647ULL) {
    tmp = invokeValueDestructor((void const   *)zData, xDel, (sqlite3_context *)0);
    return (tmp);
  } else {
    if ((int )enc == 4) {
      enc = (unsigned char)2;
    }
    tmp___0 = bindText(pStmt, i, (void const   *)zData, (int )nData, xDel, enc);
    return (tmp___0);
  }
}
}
int sqlite3_bind_text16(sqlite3_stmt *pStmt , int i , void const   *zData , int nData ,
                        void (*xDel)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = bindText(pStmt, i, zData, nData, xDel, (u8 )2);
  return (tmp);
}
}
int sqlite3_bind_value(sqlite3_stmt *pStmt , int i , sqlite3_value const   *pValue ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_value_type((sqlite3_value *)pValue);
  switch (tmp) {
  case 1: 
  rc = sqlite3_bind_int64(pStmt, i, (long long )pValue->u.i);
  break;
  case 2: 
  rc = sqlite3_bind_double(pStmt, i, (double )pValue->u.r);
  break;
  case 4: 
  if ((int const   )pValue->flags & 16384) {
    rc = sqlite3_bind_zeroblob(pStmt, i, (int )pValue->u.nZero);
  } else {
    rc = sqlite3_bind_blob(pStmt, i, (void const   *)pValue->z, (int )pValue->n, (void (*)(void * ))-1);
  }
  break;
  case 3: 
  rc = bindText(pStmt, i, (void const   *)pValue->z, (int )pValue->n, (void (*)(void * ))-1,
                (u8 )pValue->enc);
  break;
  default: 
  rc = sqlite3_bind_null(pStmt, i);
  break;
  }
  return (rc);
}
}
int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt , int i , int n ) 
{ 
  int rc ;
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if (rc == 0) {
    sqlite3VdbeMemSetZeroBlob(p->aVar + (i - 1), n);
  }
  return (rc);
}
}
int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt , int i , sqlite_uint64 n ) 
{ 
  int rc ;
  Vdbe *p ;

  {
  p = (Vdbe *)pStmt;
  if (n > (u64 )(p->db)->aLimit[0]) {
    rc = 18;
  } else {
    rc = sqlite3_bind_zeroblob(pStmt, i, (int )n);
  }
  rc = sqlite3ApiExit(p->db, rc);
  return (rc);
}
}
int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *p ;
  int tmp ;

  {
  p = (Vdbe *)pStmt;
  if (p) {
    tmp = (int )p->nVar;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
char const   *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt , int i ) 
{ 
  Vdbe *p ;
  char const   *tmp ;

  {
  p = (Vdbe *)pStmt;
  if ((unsigned long )p == (unsigned long )((Vdbe *)0)) {
    return ((char const   *)0);
  }
  tmp = sqlite3VListNumToName(p->pVList, i);
  return (tmp);
}
}
static int sqlite3VdbeParameterIndex(Vdbe *p , char const   *zName , int nName ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p == (unsigned long )((Vdbe *)0)) {
    return (0);
  } else
  if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
    return (0);
  }
  tmp = sqlite3VListNameToNum(p->pVList, zName, nName);
  return (tmp);
}
}
int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt , char const   *zName ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3Strlen30(zName);
  tmp___0 = sqlite3VdbeParameterIndex((Vdbe *)pStmt, zName, tmp);
  return (tmp___0);
}
}
static int sqlite3TransferBindings(sqlite3_stmt *pFromStmt , sqlite3_stmt *pToStmt ) 
{ 
  Vdbe *pFrom ;
  Vdbe *pTo ;
  int i ;

  {
  pFrom = (Vdbe *)pFromStmt;
  pTo = (Vdbe *)pToStmt;
  i = 0;
  while (i < (int )pFrom->nVar) {
    sqlite3VdbeMemMove(pTo->aVar + i, pFrom->aVar + i);
    i ++;
  }
  return (0);
}
}
int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt , sqlite3_stmt *pToStmt ) 
{ 
  Vdbe *pFrom ;
  Vdbe *pTo ;
  int tmp ;

  {
  pFrom = (Vdbe *)pFromStmt;
  pTo = (Vdbe *)pToStmt;
  if ((int )pFrom->nVar != (int )pTo->nVar) {
    return (1);
  }
  if (pTo->expmask) {
    pTo->expired = (bft )1;
  }
  if (pFrom->expmask) {
    pFrom->expired = (bft )1;
  }
  tmp = sqlite3TransferBindings(pFromStmt, pToStmt);
  return (tmp);
}
}
sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt ) 
{ 
  sqlite3 *tmp ;

  {
  if (pStmt) {
    tmp = ((Vdbe *)pStmt)->db;
  } else {
    tmp = (sqlite3 *)0;
  }
  return (tmp);
}
}
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt ) 
{ 
  bft tmp ;

  {
  if (pStmt) {
    tmp = ((Vdbe *)pStmt)->readOnly;
  } else {
    tmp = (bft )1;
  }
  return ((int )tmp);
}
}
int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt ) 
{ 
  bft tmp ;

  {
  if (pStmt) {
    tmp = ((Vdbe *)pStmt)->explain;
  } else {
    tmp = (bft )0;
  }
  return ((int )tmp);
}
}
int sqlite3_stmt_busy(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *v ;
  int tmp ;

  {
  v = (Vdbe *)pStmt;
  if ((unsigned long )v != (unsigned long )((Vdbe *)0)) {
    if (v->magic == 770837923U) {
      if (v->pc >= 0) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb , sqlite3_stmt *pStmt ) 
{ 
  sqlite3_stmt *pNext ;

  {
  if ((unsigned long )pStmt == (unsigned long )((sqlite3_stmt *)0)) {
    pNext = (sqlite3_stmt *)pDb->pVdbe;
  } else {
    pNext = (sqlite3_stmt *)((Vdbe *)pStmt)->pNext;
  }
  return (pNext);
}
}
int sqlite3_stmt_status(sqlite3_stmt *pStmt , int op , int resetFlag ) 
{ 
  Vdbe *pVdbe ;
  u32 v ;
  sqlite3 *db ;

  {
  pVdbe = (Vdbe *)pStmt;
  if (op == 99) {
    db = pVdbe->db;
    v = (u32 )0;
    db->pnBytesFreed = (int *)(& v);
    sqlite3VdbeClearObject(db, pVdbe);
    sqlite3DbFree(db, (void *)pVdbe);
    db->pnBytesFreed = (int *)0;
  } else {
    v = pVdbe->aCounter[op];
    if (resetFlag) {
      pVdbe->aCounter[op] = (u32 )0;
    }
  }
  return ((int )v);
}
}
char const   *sqlite3_sql(sqlite3_stmt *pStmt ) 
{ 
  Vdbe *p ;
  char *tmp ;

  {
  p = (Vdbe *)pStmt;
  if (p) {
    tmp = p->zSql;
  } else {
    tmp = (char *)0;
  }
  return ((char const   *)tmp);
}
}
char *sqlite3_expanded_sql(sqlite3_stmt *pStmt ) 
{ 
  char *z ;
  char const   *zSql ;
  char const   *tmp ;
  Vdbe *p ;

  {
  z = (char *)0;
  tmp = sqlite3_sql(pStmt);
  zSql = tmp;
  if (zSql) {
    p = (Vdbe *)pStmt;
    z = sqlite3VdbeExpandSql(p, zSql);
  }
  return (z);
}
}
static int findNextHostParameter(char const   *zSql , int *pnToken ) 
{ 
  int tokenType ;
  int nTotal ;
  int n ;

  {
  nTotal = 0;
  *pnToken = 0;
  while (*(zSql + 0)) {
    n = sqlite3GetToken((unsigned char const   *)((u8 *)zSql), & tokenType);
    if (tokenType == 151) {
      *pnToken = n;
      break;
    }
    nTotal += n;
    zSql += n;
  }
  return (nTotal);
}
}
static char *sqlite3VdbeExpandSql(Vdbe *p , char const   *zRawSql ) 
{ 
  sqlite3 *db ;
  int idx ;
  int nextIndex ;
  int n ;
  int nToken ;
  int i ;
  Mem *pVar ;
  StrAccum out ;
  Mem utf8 ;
  char zBase[100] ;
  char const   *zStart ;
  char const   *tmp ;
  int tmp___0 ;
  int nOut ;
  u8 enc ;
  int tmp___1 ;
  int nOut___0 ;
  char *tmp___2 ;

  {
  idx = 0;
  nextIndex = 1;
  db = p->db;
  sqlite3StrAccumInit(& out, (sqlite3 *)0, zBase, (int )sizeof(zBase), db->aLimit[0]);
  if (db->nVdbeExec > 1) {
    while (*zRawSql) {
      zStart = zRawSql;
      while (1) {
        tmp = zRawSql;
        zRawSql ++;
        if ((int const   )*tmp != 10) {
          if (! *zRawSql) {
            break;
          }
        } else {
          break;
        }
      }
      sqlite3_str_append(& out, "-- ", 3);
      sqlite3_str_append(& out, zStart, (int )(zRawSql - zStart));
    }
  } else
  if ((int )p->nVar == 0) {
    tmp___0 = sqlite3Strlen30(zRawSql);
    sqlite3_str_append(& out, zRawSql, tmp___0);
  } else {
    while (*(zRawSql + 0)) {
      n = findNextHostParameter(zRawSql, & nToken);
      sqlite3_str_append(& out, zRawSql, n);
      zRawSql += n;
      if (nToken == 0) {
        break;
      }
      if ((int const   )*(zRawSql + 0) == 63) {
        if (nToken > 1) {
          sqlite3GetInt32(zRawSql + 1, & idx);
        } else {
          idx = nextIndex;
        }
      } else {
        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
      }
      zRawSql += nToken;
      nextIndex = idx + 1;
      pVar = p->aVar + (idx - 1);
      if ((int )pVar->flags & 1) {
        sqlite3_str_append(& out, "NULL", 4);
      } else
      if ((int )pVar->flags & 36) {
        sqlite3_str_appendf(& out, "%lld", pVar->u.i);
      } else
      if ((int )pVar->flags & 8) {
        sqlite3_str_appendf(& out, "%!.15g", pVar->u.r);
      } else
      if ((int )pVar->flags & 2) {
        enc = db->enc;
        if ((int )enc != 1) {
          memset((void *)(& utf8), 0, sizeof(utf8));
          utf8.db = db;
          sqlite3VdbeMemSetStr(& utf8, (char const   *)pVar->z, pVar->n, enc, (void (*)(void * ))0);
          tmp___1 = sqlite3VdbeChangeEncoding(& utf8, 1);
          if (7 == tmp___1) {
            out.accError = (u8 )7;
            out.nAlloc = (u32 )0;
          }
          pVar = & utf8;
        }
        nOut = pVar->n;
        sqlite3_str_appendf(& out, "\'%.*q\'", nOut, pVar->z);
        if ((int )enc != 1) {
          sqlite3VdbeMemRelease(& utf8);
        }
      } else
      if ((int )pVar->flags & 16384) {
        sqlite3_str_appendf(& out, "zeroblob(%d)", pVar->u.nZero);
      } else {
        sqlite3_str_append(& out, "x\'", 2);
        nOut___0 = pVar->n;
        i = 0;
        while (i < nOut___0) {
          sqlite3_str_appendf(& out, "%02x", (int )*(pVar->z + i) & 255);
          i ++;
        }
        sqlite3_str_append(& out, "\'", 1);
      }
    }
  }
  if (out.accError) {
    sqlite3_str_reset(& out);
  }
  tmp___2 = sqlite3StrAccumFinish(& out);
  return (tmp___2);
}
}
static VdbeCursor *allocateCursor(Vdbe *p , int iCur , int nField , int iDb , u8 eCurType ) 
{ 
  Mem *pMem ;
  Mem *tmp ;
  int nByte ;
  VdbeCursor *pCx ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (iCur > 0) {
    tmp = p->aMem + (p->nMem - iCur);
  } else {
    tmp = p->aMem;
  }
  pMem = tmp;
  pCx = (VdbeCursor *)0;
  if ((int )eCurType == 0) {
    tmp___0 = sqlite3BtreeCursorSize();
    tmp___1 = tmp___0;
  } else {
    tmp___1 = 0;
  }
  nByte = (int )((((sizeof(VdbeCursor ) + 7UL) & 0xfffffffffffffff8UL) + (2UL * sizeof(u32 )) * (unsigned long )nField) + (unsigned long )tmp___1);
  if (*(p->apCsr + iCur)) {
    if ((unsigned long )(*(p->apCsr + iCur))->pBtx == (unsigned long )((Btree *)0)) {
      (*(p->apCsr + iCur))->isEphemeral = (Bool )0;
    }
    sqlite3VdbeFreeCursor(p, *(p->apCsr + iCur));
    *(p->apCsr + iCur) = (VdbeCursor *)0;
  }
  tmp___2 = sqlite3VdbeMemClearAndResize(pMem, nByte);
  if (0 == tmp___2) {
    pCx = (VdbeCursor *)pMem->z;
    *(p->apCsr + iCur) = pCx;
    memset((void *)pCx, 0, (unsigned long )(& ((VdbeCursor *)0)->pAltCursor));
    pCx->eCurType = eCurType;
    pCx->iDb = (i8 )iDb;
    pCx->nField = (i16 )nField;
    pCx->aOffset = & pCx->aType[nField];
    if ((int )eCurType == 0) {
      pCx->uc.pCursor = (BtCursor *)(pMem->z + (((sizeof(VdbeCursor ) + 7UL) & 0xfffffffffffffff8UL) + (2UL * sizeof(u32 )) * (unsigned long )nField));
      sqlite3BtreeCursorZero(pCx->uc.pCursor);
    }
  }
  return (pCx);
}
}
static int alsoAnInt(Mem *pRec , double rValue , i64 *piValue ) 
{ 
  i64 iValue___0 ;
  int tmp ;
  int tmp___0 ;

  {
  iValue___0 = (i64 )rValue;
  tmp = sqlite3RealSameAsInt(rValue, iValue___0);
  if (tmp) {
    *piValue = iValue___0;
    return (1);
  }
  tmp___0 = sqlite3Atoi64((char const   *)pRec->z, piValue, pRec->n, pRec->enc);
  return (0 == tmp___0);
}
}
static void applyNumericAffinity(Mem *pRec , int bTryForInt ) 
{ 
  double rValue ;
  u8 enc ;
  int rc ;
  int tmp ;

  {
  enc = pRec->enc;
  rc = sqlite3AtoF((char const   *)pRec->z, & rValue, pRec->n, enc);
  if (rc <= 0) {
    return;
  }
  if (rc == 1) {
    tmp = alsoAnInt(pRec, rValue, & pRec->u.i);
    if (tmp) {
      pRec->flags = (u16 )((int )pRec->flags | 4);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    pRec->u.r = rValue;
    pRec->flags = (u16 )((int )pRec->flags | 8);
    if (bTryForInt) {
      sqlite3VdbeIntegerAffinity(pRec);
    }
  }
  pRec->flags = (u16 )((int )pRec->flags & -3);
  return;
}
}
static void applyAffinity(Mem *pRec , char affinity , u8 enc ) 
{ 


  {
  if ((int )affinity >= 67) {
    if (((int )pRec->flags & 4) == 0) {
      if (((int )pRec->flags & 8) == 0) {
        if ((int )pRec->flags & 2) {
          applyNumericAffinity(pRec, 1);
        }
      } else {
        sqlite3VdbeIntegerAffinity(pRec);
      }
    }
  } else
  if ((int )affinity == 66) {
    if (0 == ((int )pRec->flags & 2)) {
      if ((int )pRec->flags & 44) {
        sqlite3VdbeMemStringify(pRec, enc, (u8 )1);
      }
    }
    pRec->flags = (u16 )((int )pRec->flags & -45);
  }
  return;
}
}
int sqlite3_value_numeric_type(sqlite3_value *pVal ) 
{ 
  int eType ;
  int tmp ;
  Mem *pMem ;

  {
  tmp = sqlite3_value_type(pVal);
  eType = tmp;
  if (eType == 3) {
    pMem = pVal;
    applyNumericAffinity(pMem, 0);
    eType = sqlite3_value_type(pVal);
  }
  return (eType);
}
}
static void sqlite3ValueApplyAffinity(sqlite3_value *pVal , u8 affinity , u8 enc ) 
{ 


  {
  applyAffinity(pVal, (char )affinity, enc);
  return;
}
}
static u16 ( __attribute__((__noinline__)) computeNumericType)(Mem *pMem ) 
{ 
  int rc ;
  sqlite_int64 ix ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int )pMem->flags & 16384) {
    sqlite3VdbeMemExpandBlob(pMem);
  }
  rc = sqlite3AtoF((char const   *)pMem->z, & pMem->u.r, pMem->n, pMem->enc);
  if (rc <= 0) {
    if (rc == 0) {
      tmp = sqlite3Atoi64((char const   *)pMem->z, & ix, pMem->n, pMem->enc);
      if (tmp <= 1) {
        pMem->u.i = ix;
        return ((u16 )4);
      } else {
        return ((u16 )8);
      }
    } else {
      return ((u16 )8);
    }
  } else
  if (rc == 1) {
    tmp___0 = sqlite3Atoi64((char const   *)pMem->z, & ix, pMem->n, pMem->enc);
    if (tmp___0 == 0) {
      pMem->u.i = ix;
      return ((u16 )4);
    }
  }
  return ((u16 )8);
}
}
static u16 numericType(Mem *pMem ) 
{ 
  u16 tmp ;

  {
  if ((int )pMem->flags & 44) {
    return ((u16 )((int )pMem->flags & 44));
  }
  if ((int )pMem->flags & 18) {
    tmp = computeNumericType(pMem);
    return (tmp);
  }
  return ((u16 )0);
}
}
static Mem *( __attribute__((__noinline__)) out2PrereleaseWithClear)(Mem *pOut ) 
{ 


  {
  sqlite3VdbeMemSetNull(pOut);
  pOut->flags = (u16 )4;
  return (pOut);
}
}
static Mem *out2Prerelease(Vdbe *p , VdbeOp *pOp ) 
{ 
  Mem *pOut ;
  Mem *tmp ;

  {
  pOut = p->aMem + pOp->p2;
  if (((int )pOut->flags & 9216) != 0) {
    tmp = out2PrereleaseWithClear(pOut);
    return (tmp);
  } else {
    pOut->flags = (u16 )4;
    return (pOut);
  }
}
}
static char const   * const  azType[4]  = {      (char const   * const  )"NOT NULL",      (char const   * const  )"UNIQUE",      (char const   * const  )"CHECK",      (char const   * const  )"FOREIGN KEY"};
static unsigned char const   aLTb[6]  = {      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )0};
static unsigned char const   aEQb[6]  = {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1};
static unsigned char const   aGTb[6]  = {      (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1};
static unsigned char const   and_logic[9]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2};
static unsigned char const   or_logic[9]  = 
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )2};
static u16 const   aFlag___0[2]  = {      (u16 const   )16,      (u16 const   )514};
static u8 aZero[16]  ;
static int const   vfsFlags  =    (int const   )1054;
static int sqlite3VdbeExec(Vdbe *p ) 
{ 
  Op *aOp___1 ;
  Op *pOp ;
  int rc ;
  sqlite3 *db ;
  u8 resetSchemaOnFault ;
  u8 encoding ;
  int iCompare ;
  unsigned int nVmStep ;
  unsigned int nProgressLimit ;
  Mem *aMem ;
  Mem *pIn1 ;
  Mem *pIn2 ;
  Mem *pIn3 ;
  Mem *pOut ;
  u32 iPrior ;
  int tmp ;
  VdbeOp *pCaller ;
  int pcDest ;
  VdbeFrame *pFrame ;
  int pcx ;
  int tmp___0 ;
  int cnt ;
  u16 nullFlag ;
  Mem *pVar ;
  int tmp___1 ;
  int n ;
  int p1 ;
  int p2 ;
  int tmp___2 ;
  int n___0 ;
  int tmp___3 ;
  int tmp___4 ;
  Mem *pMem ;
  int i ;
  Mem *tmp___5 ;
  int tmp___6 ;
  i64 nByte ;
  u16 flags1 ;
  u16 flags2 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  u16 flags___0 ;
  u16 type1 ;
  u16 type2 ;
  i64 iA ;
  i64 iB ;
  double rA ;
  double rB ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  i64 iA___0 ;
  u64 uA ;
  i64 iB___0 ;
  u8 op ;
  int tmp___16 ;
  int res ;
  int res2 ;
  char affinity ;
  u16 flags1___0 ;
  u16 flags3 ;
  int n___1 ;
  int i___0 ;
  int p1___0 ;
  int p2___0 ;
  KeyInfo const   *pKeyInfo ;
  int idx ;
  CollSeq *pColl ;
  int bRev ;
  int *aPermute ;
  int v1 ;
  int v2 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  i64 tmp___20 ;
  u32 iAddr ;
  int c ;
  int c___0 ;
  int tmp___21 ;
  int tmp___22 ;
  int p2___1 ;
  VdbeCursor *pC ;
  BtCursor *pCrsr ;
  u32 *aOffset ;
  int len ;
  int i___1 ;
  Mem *pDest ;
  Mem sMem ;
  u8 const   *zData ;
  u8 const   *zHdr ;
  u8 const   *zEndHdr ;
  u64 offset64 ;
  u32 t ;
  Mem *pReg ;
  u32 tmp___23 ;
  void const   *tmp___24 ;
  u8 tmp___25 ;
  int tmp___26 ;
  u8 tmp___27 ;
  u8 tmp___28 ;
  u32 tmp___29 ;
  u32 tmp___30 ;
  int tmp___31 ;
  u32 tmp___32 ;
  char const   *zAffinity ;
  Mem *pRec ;
  u64 nData ;
  int nHdr ;
  i64 nByte___0 ;
  i64 nZero ;
  int nVarint ;
  u32 serial_type ;
  Mem *pData0 ;
  Mem *pLast ;
  int nField ;
  char *zAffinity___0 ;
  int file_format ;
  u32 len___0 ;
  u8 *zHdr___0 ;
  u8 *zPayload ;
  i64 i___2 ;
  u64 uu ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  u32 tmp___41 ;
  i64 nEntry ;
  BtCursor *pCrsr___0 ;
  int p1___1 ;
  char *zName ;
  int nName ;
  Savepoint *pNew ;
  Savepoint *pSavepoint ;
  Savepoint *pTmp ;
  int iSavepoint ;
  int ii ;
  void *tmp___42 ;
  int tmp___43 ;
  int isTransaction ;
  int tmp___44 ;
  int tmp___45 ;
  int isSchemaChange ;
  int desiredAutoCommit ;
  int iRollback ;
  int tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  Btree *pBt ;
  int iMeta ;
  int iMeta___0 ;
  int iDb ;
  int iCookie ;
  Db *pDb ;
  int nField___0 ;
  KeyInfo *pKeyInfo___0 ;
  int p2___2 ;
  int iDb___0 ;
  int wrFlag ;
  Btree *pX ;
  VdbeCursor *pCur ;
  Db *pDb___0 ;
  VdbeCursor *pOrig ;
  VdbeCursor *pCx ;
  VdbeCursor *pCx___0 ;
  KeyInfo *pKeyInfo___1 ;
  KeyInfo *tmp___49 ;
  VdbeCursor *pCx___1 ;
  VdbeCursor *pC___0 ;
  i64 tmp___50 ;
  VdbeCursor *pCx___2 ;
  int res___0 ;
  int oc ;
  VdbeCursor *pC___1 ;
  UnpackedRecord r ;
  int nField___1 ;
  i64 iKey ;
  int eqOnly ;
  u16 flags3___0 ;
  u16 newType ;
  int tmp___51 ;
  VdbeCursor *pC___2 ;
  VdbeCursor *pC___3 ;
  int alreadyExists ;
  int takeJump ;
  int ii___0 ;
  VdbeCursor *pC___4 ;
  int res___1 ;
  UnpackedRecord *pFree ;
  UnpackedRecord *pIdxKey ;
  UnpackedRecord r___0 ;
  int tmp___52 ;
  VdbeCursor *pC___5 ;
  BtCursor *pCrsr___1 ;
  int res___2 ;
  u64 iKey___0 ;
  u16 origFlags ;
  int isNotInt ;
  i64 tmp___53 ;
  i64 v ;
  VdbeCursor *pC___6 ;
  int res___3 ;
  int cnt___0 ;
  Mem *pMem___0 ;
  VdbeFrame *pFrame___0 ;
  Mem *pData ;
  Mem *pKey ;
  VdbeCursor *pC___7 ;
  int seekResult ;
  char const   *zDb ;
  Table *pTab ;
  BtreePayload x___0 ;
  int tmp___54 ;
  VdbeCursor *pC___8 ;
  char const   *zDb___0 ;
  Table *pTab___0 ;
  int opflags ;
  VdbeCursor *pC___9 ;
  int res___4 ;
  int nKeyCol ;
  VdbeCursor *pC___10 ;
  VdbeCursor *pC___11 ;
  BtCursor *pCrsr___2 ;
  u32 n___2 ;
  int tmp___55 ;
  VdbeCursor *pC___12 ;
  i64 v___0 ;
  sqlite3_vtab *pVtab ;
  sqlite3_module const   *pModule ;
  VdbeCursor *pC___13 ;
  VdbeCursor *pC___14 ;
  BtCursor *pCrsr___3 ;
  int res___5 ;
  int tmp___56 ;
  VdbeCursor *pC___15 ;
  BtCursor *pCrsr___4 ;
  int res___6 ;
  i64 sz ;
  LogEst tmp___57 ;
  VdbeCursor *pC___16 ;
  BtCursor *pCrsr___5 ;
  int res___7 ;
  VdbeCursor *pC___17 ;
  VdbeCursor *pC___18 ;
  BtreePayload x___1 ;
  int tmp___58 ;
  int tmp___59 ;
  VdbeCursor *pC___19 ;
  BtCursor *pCrsr___6 ;
  int res___8 ;
  UnpackedRecord r___1 ;
  VdbeCursor *pC___20 ;
  VdbeCursor *pTabCur ;
  i64 rowid ;
  VdbeCursor *pC___21 ;
  int res___9 ;
  UnpackedRecord r___2 ;
  int iMoved ;
  int iDb___1 ;
  int nChange ;
  int *tmp___60 ;
  VdbeCursor *pC___22 ;
  int pgno ;
  Db *pDb___1 ;
  int iDb___2 ;
  char const   *zMaster ;
  char *zSql ;
  InitData initData ;
  int nRoot ;
  int *aRoot ;
  int nErr ;
  char *z ;
  Mem *pnErr ;
  int tmp___61 ;
  i64 val ;
  int tmp___62 ;
  int iSet ;
  int exists ;
  int tmp___63 ;
  int nMem ;
  int nByte___1 ;
  Mem *pRt ;
  Mem *pMem___1 ;
  Mem *pEnd ;
  VdbeFrame *pFrame___1 ;
  SubProgram *pProgram ;
  void *t___0 ;
  void *tmp___64 ;
  VdbeFrame *pFrame___2 ;
  Mem *pIn ;
  VdbeFrame *pFrame___3 ;
  i64 x___2 ;
  i64 tmp___65 ;
  int tmp___66 ;
  int n___3 ;
  sqlite3_context *pCtx ;
  void *tmp___67 ;
  int i___3 ;
  sqlite3_context *pCtx___0 ;
  Mem *pMem___2 ;
  unsigned char const   *tmp___68 ;
  Mem *pMem___3 ;
  unsigned char const   *tmp___69 ;
  int tmp___70 ;
  int i___4 ;
  int aRes[3] ;
  Mem *pMem___4 ;
  Btree *pBt___0 ;
  Pager *pPager ;
  int eNew ;
  int eOld ;
  char const   *zFilename ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  char const   *tmp___74 ;
  int tmp___75 ;
  char const   *tmp___76 ;
  Mem *tmp___77 ;
  Btree *pBt___1 ;
  u8 isWriteLock ;
  int p1___2 ;
  char const   *z___0 ;
  VTable *pVTab ;
  Mem sMem___0 ;
  char const   *zTab ;
  unsigned char const   *tmp___78 ;
  VdbeCursor *pCur___0 ;
  sqlite3_vtab_cursor *pVCur ;
  sqlite3_vtab *pVtab___0 ;
  sqlite3_module const   *pModule___0 ;
  int nArg ;
  int iQuery ;
  sqlite3_module const   *pModule___1 ;
  Mem *pQuery ;
  Mem *pArgc ;
  sqlite3_vtab_cursor *pVCur___0 ;
  sqlite3_vtab *pVtab___1 ;
  VdbeCursor *pCur___1 ;
  int res___10 ;
  int i___5 ;
  Mem **apArg ;
  sqlite3_vtab *pVtab___2 ;
  sqlite3_module const   *pModule___2 ;
  Mem *pDest___0 ;
  sqlite3_context sContext ;
  VdbeCursor *pCur___2 ;
  unsigned char const   *tmp___79 ;
  int tmp___80 ;
  sqlite3_vtab *pVtab___3 ;
  sqlite3_module const   *pModule___3 ;
  int res___11 ;
  VdbeCursor *pCur___3 ;
  sqlite3_vtab *pVtab___4 ;
  Mem *pName ;
  int isLegacy ;
  sqlite3_vtab *pVtab___5 ;
  sqlite3_module const   *pModule___4 ;
  int nArg___0 ;
  int i___6 ;
  sqlite_int64 rowid___0 ;
  Mem **apArg___0 ;
  Mem *pX___0 ;
  u8 vtabOnConflict ;
  u32 tmp___81 ;
  unsigned int newMax ;
  Btree *pBt___2 ;
  int tmp___82 ;
  int n___4 ;
  sqlite3_context *pCtx___1 ;
  void *tmp___83 ;
  int i___7 ;
  sqlite3_context *pCtx___2 ;
  unsigned char const   *tmp___84 ;
  int tmp___85 ;
  int i___8 ;
  char *zTrace ;
  void (*x___3)(void * , char const   * ) ;
  char *z___1 ;
  char *tmp___86 ;
  char *z___2 ;
  char *tmp___87 ;
  char const   *tmp___88 ;
  int tmp___89 ;
  char const   *tmp___90 ;

  {
  aOp___1 = p->aOp;
  pOp = aOp___1;
  rc = 0;
  db = p->db;
  resetSchemaOnFault = (u8 )0;
  encoding = db->enc;
  iCompare = 0;
  nVmStep = 0U;
  aMem = p->aMem;
  pIn1 = (Mem *)0;
  pIn2 = (Mem *)0;
  pIn3 = (Mem *)0;
  pOut = (Mem *)0;
  sqlite3VdbeEnter(p);
  if (db->xProgress) {
    iPrior = p->aCounter[4];
    nProgressLimit = db->nProgressOps - iPrior % db->nProgressOps;
  } else {
    nProgressLimit = 4294967295U;
  }
  if (p->rc == 7) {
    goto no_mem;
  }
  p->iCurrentTime = (i64 )0;
  p->pResultSet = (Mem *)0;
  db->busyHandler.nBusy = 0;
  if (db->u1.isInterrupted) {
    goto abort_due_to_interrupt;
  }
  pOp = aOp___1 + p->pc;
  while (1) {
    nVmStep ++;
    switch ((int )pOp->opcode) {
    jump_to_p2_and_check_for_interrupt: 
    case 11: 
    pOp = aOp___1 + (pOp->p2 - 1);
    check_for_interrupt: 
    if (db->u1.isInterrupted) {
      goto abort_due_to_interrupt;
    }
    while (1) {
      if (nVmStep >= nProgressLimit) {
        if (! ((unsigned long )db->xProgress != (unsigned long )((int (*)(void * ))0))) {
          break;
        }
      } else {
        break;
      }
      nProgressLimit += db->nProgressOps;
      tmp = (*(db->xProgress))(db->pProgressArg);
      if (tmp) {
        nProgressLimit = 4294967295U;
        rc = 9;
        goto abort_due_to_error;
      }
    }
    break;
    case 12: 
    pIn1 = aMem + pOp->p1;
    pIn1->flags = (u16 )4;
    pIn1->u.i = (i64 )((int )(pOp - aOp___1));
    jump_to_p2: 
    pOp = aOp___1 + (pOp->p2 - 1);
    break;
    case 66: 
    pIn1 = aMem + pOp->p1;
    pOp = aOp___1 + pIn1->u.i;
    pIn1->flags = (u16 )128;
    break;
    case 13: 
    pOut = aMem + pOp->p1;
    pOut->u.i = (i64 )(pOp->p3 - 1);
    pOut->flags = (u16 )4;
    if (pOp->p2) {
      goto jump_to_p2;
    }
    break;
    case 67: 
    pIn1 = aMem + pOp->p1;
    pCaller = aOp___1 + pIn1->u.i;
    pOp = aOp___1 + (pCaller->p2 - 1);
    pIn1->flags = (u16 )128;
    break;
    case 14: 
    pIn1 = aMem + pOp->p1;
    pIn1->flags = (u16 )4;
    pcDest = (int )pIn1->u.i;
    pIn1->u.i = (i64 )((int )(pOp - aOp___1));
    pOp = aOp___1 + pcDest;
    break;
    case 68: 
    pIn3 = aMem + pOp->p3;
    if (((int )pIn3->flags & 1) == 0) {
      break;
    }
    case 69: 
    pcx = (int )(pOp - aOp___1);
    if (pOp->p1 == 0) {
      if (p->pFrame) {
        pFrame = p->pFrame;
        p->pFrame = pFrame->pParent;
        (p->nFrame) --;
        sqlite3VdbeSetChanges(db, p->nChange);
        pcx = sqlite3VdbeFrameRestore(pFrame);
        if (pOp->p2 == 4) {
          pcx = (p->aOp + pcx)->p2 - 1;
        }
        aOp___1 = p->aOp;
        aMem = p->aMem;
        pOp = aOp___1 + pcx;
        break;
      }
    }
    p->rc = pOp->p1;
    p->errorAction = (u8 )pOp->p2;
    p->pc = pcx;
    if (p->rc) {
      if (pOp->p5) {
        sqlite3VdbeError(p, "%s constraint failed", azType[(int )pOp->p5 - 1]);
        if (pOp->p4.z) {
          p->zErrMsg = sqlite3MPrintf(db, "%z: %s", p->zErrMsg, pOp->p4.z);
        }
      } else {
        sqlite3VdbeError(p, "%s", pOp->p4.z);
      }
      sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pcx, p->zSql, p->zErrMsg);
    }
    rc = sqlite3VdbeHalt(p);
    if (rc == 5) {
      p->rc = 5;
    } else
    if (p->rc) {
      rc = 1;
    } else {
      rc = 101;
    }
    goto vdbe_return;
    case 70: 
    pOut = out2Prerelease(p, pOp);
    pOut->u.i = (i64 )pOp->p1;
    break;
    case 71: 
    pOut = out2Prerelease(p, pOp);
    pOut->u.i = *(pOp->p4.pI64);
    break;
    case 148: 
    pOut = out2Prerelease(p, pOp);
    pOut->flags = (u16 )8;
    pOut->u.r = *(pOp->p4.pReal);
    break;
    case 113: 
    pOut = out2Prerelease(p, pOp);
    pOp->p1 = sqlite3Strlen30((char const   *)pOp->p4.z);
    if ((int )encoding != 1) {
      rc = sqlite3VdbeMemSetStr(pOut, (char const   *)pOp->p4.z, -1, (u8 )1, (void (*)(void * ))0);
      if (rc) {
        goto too_big;
      }
      tmp___0 = sqlite3VdbeChangeEncoding(pOut, (int )encoding);
      if (0 != tmp___0) {
        goto no_mem;
      }
      pOut->szMalloc = 0;
      pOut->flags = (u16 )((int )pOut->flags | 2048);
      if ((int )pOp->p4type == -7) {
        sqlite3DbFree(db, (void *)pOp->p4.z);
      }
      pOp->p4type = (signed char)-7;
      pOp->p4.z = pOut->z;
      pOp->p1 = pOut->n;
    }
    if (pOp->p1 > db->aLimit[0]) {
      goto too_big;
    }
    pOp->opcode = (u8 )72;
    case 72: 
    pOut = out2Prerelease(p, pOp);
    pOut->flags = (u16 )2562;
    pOut->z = pOp->p4.z;
    pOut->n = pOp->p1;
    pOut->enc = encoding;
    if (pOp->p3 > 0) {
      pIn3 = aMem + pOp->p3;
      if (pIn3->u.i == (i64 )pOp->p5) {
        pOut->flags = (u16 )2576;
      }
    }
    break;
    case 73: 
    pOut = out2Prerelease(p, pOp);
    cnt = pOp->p3 - pOp->p2;
    if (pOp->p1) {
      nullFlag = (u16 )257;
    } else {
      nullFlag = (u16 )1;
    }
    pOut->flags = nullFlag;
    pOut->n = 0;
    while (cnt > 0) {
      pOut ++;
      sqlite3VdbeMemSetNull(pOut);
      pOut->flags = nullFlag;
      pOut->n = 0;
      cnt --;
    }
    break;
    case 74: 
    pOut = aMem + pOp->p1;
    pOut->flags = (u16 )(((int )pOut->flags & -192) | 1);
    break;
    case 75: 
    pOut = out2Prerelease(p, pOp);
    sqlite3VdbeMemSetStr(pOut, (char const   *)pOp->p4.z, pOp->p1, (u8 )0, (void (*)(void * ))0);
    pOut->enc = encoding;
    break;
    case 76: 
    pVar = p->aVar + (pOp->p1 - 1);
    tmp___1 = sqlite3VdbeMemTooBig(pVar);
    if (tmp___1) {
      goto too_big;
    }
    pOut = aMem + pOp->p2;
    if (((int )pOut->flags & 9216) != 0) {
      sqlite3VdbeMemSetNull(pOut);
    }
    memcpy((void * __restrict  )pOut, (void const   * __restrict  )pVar, (unsigned long )(& ((Mem *)0)->zMalloc));
    pOut->flags = (u16 )((int )pOut->flags & -5121);
    pOut->flags = (u16 )((int )pOut->flags | 2112);
    break;
    case 77: 
    n = pOp->p3;
    p1 = pOp->p1;
    p2 = pOp->p2;
    pIn1 = aMem + p1;
    pOut = aMem + p2;
    while (1) {
      sqlite3VdbeMemMove(pOut, pIn1);
      if (((int )pOut->flags & 4096) != 0) {
        tmp___2 = sqlite3VdbeMemMakeWriteable(pOut);
        if (tmp___2) {
          goto no_mem;
        }
      }
      pIn1 ++;
      pOut ++;
      n --;
      if (! n) {
        break;
      }
    }
    break;
    case 78: 
    n___0 = pOp->p3;
    pIn1 = aMem + pOp->p1;
    pOut = aMem + pOp->p2;
    while (1) {
      sqlite3VdbeMemShallowCopy(pOut, (Mem const   *)pIn1, 4096);
      if (((int )pOut->flags & 4096) != 0) {
        tmp___3 = sqlite3VdbeMemMakeWriteable(pOut);
        if (tmp___3) {
          goto no_mem;
        }
      }
      tmp___4 = n___0;
      n___0 --;
      if (tmp___4 == 0) {
        break;
      }
      pOut ++;
      pIn1 ++;
    }
    break;
    case 79: 
    pIn1 = aMem + pOp->p1;
    pOut = aMem + pOp->p2;
    sqlite3VdbeMemShallowCopy(pOut, (Mem const   *)pIn1, 4096);
    break;
    case 80: 
    pIn1 = aMem + pOp->p1;
    pOut = aMem + pOp->p2;
    sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);
    break;
    case 81: 
    rc = sqlite3VdbeCheckFk(p, 0);
    if (0 != rc) {
      goto abort_due_to_error;
    }
    rc = sqlite3VdbeCloseStatement(p, 1);
    p->cacheCtr = (p->cacheCtr + 2U) | 1U;
    tmp___5 = aMem + pOp->p1;
    p->pResultSet = tmp___5;
    pMem = tmp___5;
    i = 0;
    while (i < pOp->p2) {
      if (((int )(pMem + i)->flags & 4096) != 0) {
        tmp___6 = sqlite3VdbeMemMakeWriteable(pMem + i);
        if (tmp___6) {
          goto no_mem;
        }
      }
      sqlite3VdbeMemNulTerminate(pMem + i);
      i ++;
    }
    if (db->mallocFailed) {
      goto no_mem;
    }
    if ((int )db->mTrace & 4) {
      (*(db->xTrace))((u32 )4, db->pTraceArg, (void *)p, (void *)0);
    }
    p->pc = (int )(pOp - aOp___1) + 1;
    rc = 100;
    goto vdbe_return;
    case 108: 
    pIn1 = aMem + pOp->p1;
    pIn2 = aMem + pOp->p2;
    pOut = aMem + pOp->p3;
    flags1 = pIn1->flags;
    if (((int )flags1 | (int )pIn2->flags) & 1) {
      sqlite3VdbeMemSetNull(pOut);
      break;
    }
    if (((int )flags1 & 18) == 0) {
      tmp___7 = sqlite3VdbeMemStringify(pIn1, encoding, (u8 )0);
      if (tmp___7) {
        goto no_mem;
      }
      flags1 = (u16 )((int )pIn1->flags & -3);
    } else
    if (((int )flags1 & 16384) != 0) {
      tmp___8 = sqlite3VdbeMemExpandBlob(pIn1);
      if (tmp___8) {
        goto no_mem;
      }
      flags1 = (u16 )((int )pIn1->flags & -3);
    }
    flags2 = pIn2->flags;
    if (((int )flags2 & 18) == 0) {
      tmp___9 = sqlite3VdbeMemStringify(pIn2, encoding, (u8 )0);
      if (tmp___9) {
        goto no_mem;
      }
      flags2 = (u16 )((int )pIn2->flags & -3);
    } else
    if (((int )flags2 & 16384) != 0) {
      tmp___10 = sqlite3VdbeMemExpandBlob(pIn2);
      if (tmp___10) {
        goto no_mem;
      }
      flags2 = (u16 )((int )pIn2->flags & -3);
    }
    nByte = (i64 )(pIn1->n + pIn2->n);
    if (nByte > (i64 )db->aLimit[0]) {
      goto too_big;
    }
    tmp___11 = sqlite3VdbeMemGrow(pOut, (int )nByte + 3, (unsigned long )pOut == (unsigned long )pIn2);
    if (tmp___11) {
      goto no_mem;
    }
    pOut->flags = (u16 )(((int )pOut->flags & -49600) | 2);
    if ((unsigned long )pOut != (unsigned long )pIn2) {
      memcpy((void * __restrict  )pOut->z, (void const   * __restrict  )pIn2->z, (size_t )pIn2->n);
      pIn2->flags = flags2;
    }
    memcpy((void * __restrict  )(pOut->z + pIn2->n), (void const   * __restrict  )pIn1->z,
           (size_t )pIn1->n);
    pIn1->flags = flags1;
    *(pOut->z + nByte) = (char)0;
    *(pOut->z + (nByte + 1LL)) = (char)0;
    *(pOut->z + (nByte + 2LL)) = (char)0;
    pOut->flags = (u16 )((int )pOut->flags | 512);
    pOut->n = (int )nByte;
    pOut->enc = encoding;
    break;
    case 107: 
    case 106: 
    case 105: 
    case 104: 
    case 103: 
    pIn1 = aMem + pOp->p1;
    type1 = numericType(pIn1);
    pIn2 = aMem + pOp->p2;
    type2 = numericType(pIn2);
    pOut = aMem + pOp->p3;
    flags___0 = (u16 )((int )pIn1->flags | (int )pIn2->flags);
    if ((((int )type1 & (int )type2) & 4) != 0) {
      iA = pIn1->u.i;
      iB = pIn2->u.i;
      switch ((int )pOp->opcode) {
      case 103: 
      tmp___12 = sqlite3AddInt64(& iB, iA);
      if (tmp___12) {
        goto fp_math;
      }
      break;
      case 104: 
      tmp___13 = sqlite3SubInt64(& iB, iA);
      if (tmp___13) {
        goto fp_math;
      }
      break;
      case 105: 
      tmp___14 = sqlite3MulInt64(& iB, iA);
      if (tmp___14) {
        goto fp_math;
      }
      break;
      case 106: 
      if (iA == 0LL) {
        goto arithmetic_result_is_null;
      }
      if (iA == -1LL) {
        if (iB == -1LL - (4294967295LL | (2147483647LL << 32))) {
          goto fp_math;
        }
      }
      iB /= iA;
      break;
      default: 
      if (iA == 0LL) {
        goto arithmetic_result_is_null;
      }
      if (iA == -1LL) {
        iA = (i64 )1;
      }
      iB %= iA;
      break;
      }
      pOut->u.i = iB;
      pOut->flags = (u16 )(((int )pOut->flags & -49600) | 4);
    } else
    if (((int )flags___0 & 1) != 0) {
      goto arithmetic_result_is_null;
    } else {
      fp_math: 
      rA = sqlite3VdbeRealValue(pIn1);
      rB = sqlite3VdbeRealValue(pIn2);
      switch ((int )pOp->opcode) {
      case 103: 
      rB += rA;
      break;
      case 104: 
      rB -= rA;
      break;
      case 105: 
      rB *= rA;
      break;
      case 106: 
      if (rA == (double )0) {
        goto arithmetic_result_is_null;
      }
      rB /= rA;
      break;
      default: 
      iA = sqlite3VdbeIntValue(pIn1);
      iB = sqlite3VdbeIntValue(pIn2);
      if (iA == 0LL) {
        goto arithmetic_result_is_null;
      }
      if (iA == -1LL) {
        iA = (i64 )1;
      }
      rB = (double )(iB % iA);
      break;
      }
      tmp___15 = sqlite3IsNaN(rB);
      if (tmp___15) {
        goto arithmetic_result_is_null;
      }
      pOut->u.r = rB;
      pOut->flags = (u16 )(((int )pOut->flags & -49600) | 8);
    }
    break;
    arithmetic_result_is_null: 
    sqlite3VdbeMemSetNull(pOut);
    break;
    case 82: 
    if (pOp->p1) {
      sqlite3VdbeMemSetInt64(aMem + pOp->p1, (i64 )0);
    }
    break;
    case 102: 
    case 101: 
    case 100: 
    case 99: 
    pIn1 = aMem + pOp->p1;
    pIn2 = aMem + pOp->p2;
    pOut = aMem + pOp->p3;
    if (((int )pIn1->flags | (int )pIn2->flags) & 1) {
      sqlite3VdbeMemSetNull(pOut);
      break;
    }
    iA___0 = sqlite3VdbeIntValue(pIn2);
    iB___0 = sqlite3VdbeIntValue(pIn1);
    op = pOp->opcode;
    if ((int )op == 99) {
      iA___0 &= iB___0;
    } else
    if ((int )op == 100) {
      iA___0 |= iB___0;
    } else
    if (iB___0 != 0LL) {
      if (iB___0 < 0LL) {
        op = (u8 )(203 - (int )op);
        if (iB___0 > -64LL) {
          iB___0 = - iB___0;
        } else {
          iB___0 = (i64 )64;
        }
      }
      if (iB___0 >= 64LL) {
        if (iA___0 >= 0LL) {
          iA___0 = (i64 )0;
        } else
        if ((int )op == 101) {
          iA___0 = (i64 )0;
        } else {
          iA___0 = (i64 )-1;
        }
      } else {
        memcpy((void * __restrict  )(& uA), (void const   * __restrict  )(& iA___0),
               sizeof(uA));
        if ((int )op == 101) {
          uA <<= iB___0;
        } else {
          uA >>= iB___0;
          if (iA___0 < 0LL) {
            uA |= ((4294967295ULL << 32) | 4294967295ULL) << (64LL - iB___0);
          }
        }
        memcpy((void * __restrict  )(& iA___0), (void const   * __restrict  )(& uA),
               sizeof(iA___0));
      }
    }
    pOut->u.i = iA___0;
    pOut->flags = (u16 )(((int )pOut->flags & -49600) | 4);
    break;
    case 83: 
    pIn1 = aMem + pOp->p1;
    sqlite3VdbeMemIntegerify(pIn1);
    pIn1->u.i += (i64 )pOp->p2;
    break;
    case 15: 
    pIn1 = aMem + pOp->p1;
    if (((int )pIn1->flags & 4) == 0) {
      applyAffinity(pIn1, (char)67, encoding);
      if (((int )pIn1->flags & 4) == 0) {
        if (pOp->p2 == 0) {
          rc = 20;
          goto abort_due_to_error;
        } else {
          goto jump_to_p2;
        }
      }
    }
    pIn1->flags = (u16 )(((int )pIn1->flags & -49600) | 4);
    break;
    case 84: 
    pIn1 = aMem + pOp->p1;
    if ((int )pIn1->flags & 36) {
      sqlite3VdbeMemRealify(pIn1);
    }
    break;
    case 85: 
    pIn1 = aMem + pOp->p1;
    if ((int )pIn1->flags & 16384) {
      tmp___16 = sqlite3VdbeMemExpandBlob(pIn1);
      rc = tmp___16;
    } else {
      rc = 0;
    }
    sqlite3VdbeMemCast(pIn1, (u8 )pOp->p2, encoding);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 57: 
    case 54: 
    case 55: 
    case 56: 
    case 52: 
    case 53: 
    pIn1 = aMem + pOp->p1;
    pIn3 = aMem + pOp->p3;
    flags1___0 = pIn1->flags;
    flags3 = pIn3->flags;
    if (((int )flags1___0 | (int )flags3) & 1) {
      if ((int )pOp->p5 & 128) {
        if ((((int )flags1___0 & (int )flags3) & 1) != 0) {
          if (((int )flags3 & 256) == 0) {
            res = 0;
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if ((int )flags3 & 1) {
          res = -1;
        } else {
          res = 1;
        }
      } else {
        if ((int )pOp->p5 & 32) {
          pOut = aMem + pOp->p2;
          iCompare = 1;
          pOut->flags = (u16 )(((int )pOut->flags & -49600) | 1);
        } else
        if ((int )pOp->p5 & 16) {
          goto jump_to_p2;
        }
        break;
      }
    } else {
      affinity = (char )((int )pOp->p5 & 71);
      if ((int )affinity >= 67) {
        if (((int )flags1___0 | (int )flags3) & 2) {
          if (((int )flags1___0 & 46) == 2) {
            applyNumericAffinity(pIn1, 0);
            flags3 = pIn3->flags;
          }
          if (((int )flags3 & 46) == 2) {
            applyNumericAffinity(pIn3, 0);
          }
        }
        if ((((int )pIn1->flags & (int )pIn3->flags) & 4) != 0) {
          if (pIn3->u.i > pIn1->u.i) {
            res = 1;
            goto compare_op;
          }
          if (pIn3->u.i < pIn1->u.i) {
            res = -1;
            goto compare_op;
          }
          res = 0;
          goto compare_op;
        }
      } else
      if ((int )affinity == 66) {
        if (((int )flags1___0 & 2) == 0) {
          if (((int )flags1___0 & 44) != 0) {
            sqlite3VdbeMemStringify(pIn1, encoding, (u8 )1);
            flags1___0 = (u16 )(((int )pIn1->flags & -49600) | ((int )flags1___0 & 49599));
          }
        }
        if (((int )flags3 & 2) == 0) {
          if (((int )flags3 & 44) != 0) {
            sqlite3VdbeMemStringify(pIn3, encoding, (u8 )1);
            flags3 = (u16 )(((int )pIn3->flags & -49600) | ((int )flags3 & 49599));
          }
        }
      }
      res = sqlite3MemCompare((Mem const   *)pIn3, (Mem const   *)pIn1, (CollSeq const   *)pOp->p4.pColl);
    }
    compare_op: ;
    if (res < 0) {
      res2 = (int )aLTb[(int )pOp->opcode - 52];
    } else
    if (res == 0) {
      res2 = (int )aEQb[(int )pOp->opcode - 52];
    } else {
      res2 = (int )aGTb[(int )pOp->opcode - 52];
    }
    pIn1->flags = flags1___0;
    pIn3->flags = flags3;
    if ((int )pOp->p5 & 32) {
      pOut = aMem + pOp->p2;
      iCompare = res;
      if (((int )pOp->p5 & 8) != 0) {
        if (((int )pOp->opcode == 53) == res2) {
          break;
        }
      }
      pOut->flags = (u16 )(((int )pOut->flags & -49600) | 4);
      pOut->u.i = (i64 )res2;
    } else
    if (res2) {
      goto jump_to_p2;
    }
    break;
    case 58: 
    if (iCompare != 0) {
      goto jump_to_p2;
    }
    break;
    case 86: 
    break;
    case 87: 
    if (((int )pOp->p5 & 1) == 0) {
      aPermute = (int *)0;
    } else {
      aPermute = (pOp + -1)->p4.ai + 1;
    }
    n___1 = pOp->p3;
    pKeyInfo = (KeyInfo const   *)pOp->p4.pKeyInfo;
    p1___0 = pOp->p1;
    p2___0 = pOp->p2;
    i___0 = 0;
    while (i___0 < n___1) {
      if (aPermute) {
        idx = *(aPermute + i___0);
      } else {
        idx = i___0;
      }
      pColl = pKeyInfo->aColl[i___0];
      bRev = (int )*(pKeyInfo->aSortFlags + i___0) & 1;
      iCompare = sqlite3MemCompare((Mem const   *)(aMem + (p1___0 + idx)), (Mem const   *)(aMem + (p2___0 + idx)),
                                   (CollSeq const   *)pColl);
      if (iCompare) {
        if ((int )*(pKeyInfo->aSortFlags + i___0) & 2) {
          if ((int )(aMem + (p1___0 + idx))->flags & 1) {
            iCompare = - iCompare;
          } else
          if ((int )(aMem + (p2___0 + idx))->flags & 1) {
            iCompare = - iCompare;
          }
        }
        if (bRev) {
          iCompare = - iCompare;
        }
        break;
      }
      i___0 ++;
    }
    break;
    case 16: 
    if (iCompare < 0) {
      pOp = aOp___1 + (pOp->p1 - 1);
    } else
    if (iCompare == 0) {
      pOp = aOp___1 + (pOp->p2 - 1);
    } else {
      pOp = aOp___1 + (pOp->p3 - 1);
    }
    break;
    case 43: 
    case 44: 
    v1 = sqlite3VdbeBooleanValue(aMem + pOp->p1, 2);
    v2 = sqlite3VdbeBooleanValue(aMem + pOp->p2, 2);
    if ((int )pOp->opcode == 44) {
      v1 = (int )and_logic[v1 * 3 + v2];
    } else {
      v1 = (int )or_logic[v1 * 3 + v2];
    }
    pOut = aMem + pOp->p3;
    if (v1 == 2) {
      pOut->flags = (u16 )(((int )pOut->flags & -49600) | 1);
    } else {
      pOut->u.i = (i64 )v1;
      pOut->flags = (u16 )(((int )pOut->flags & -49600) | 4);
    }
    break;
    case 88: 
    tmp___17 = sqlite3VdbeBooleanValue(aMem + pOp->p1, pOp->p3);
    sqlite3VdbeMemSetInt64(aMem + pOp->p2, (i64 )(tmp___17 ^ pOp->p4.i));
    break;
    case 19: 
    pIn1 = aMem + pOp->p1;
    pOut = aMem + pOp->p2;
    if (((int )pIn1->flags & 1) == 0) {
      tmp___18 = sqlite3VdbeBooleanValue(pIn1, 0);
      if (tmp___18) {
        tmp___19 = 0;
      } else {
        tmp___19 = 1;
      }
      sqlite3VdbeMemSetInt64(pOut, (i64 )tmp___19);
    } else {
      sqlite3VdbeMemSetNull(pOut);
    }
    break;
    case 110: 
    pIn1 = aMem + pOp->p1;
    pOut = aMem + pOp->p2;
    sqlite3VdbeMemSetNull(pOut);
    if (((int )pIn1->flags & 1) == 0) {
      pOut->flags = (u16 )4;
      tmp___20 = sqlite3VdbeIntValue(pIn1);
      pOut->u.i = ~ tmp___20;
    }
    break;
    case 17: 
    if (p->pFrame) {
      iAddr = (u32 )((int )(pOp - p->aOp));
      if (((int )*((p->pFrame)->aOnce + iAddr / 8U) & (1 << (iAddr & 7U))) != 0) {
        goto jump_to_p2;
      }
      *((p->pFrame)->aOnce + iAddr / 8U) = (u8 )((int )*((p->pFrame)->aOnce + iAddr / 8U) | (1 << (iAddr & 7U)));
    } else
    if ((p->aOp + 0)->p1 == pOp->p1) {
      goto jump_to_p2;
    }
    pOp->p1 = (p->aOp + 0)->p1;
    break;
    case 18: 
    c = sqlite3VdbeBooleanValue(aMem + pOp->p1, pOp->p3);
    if (c) {
      goto jump_to_p2;
    }
    break;
    case 20: 
    tmp___21 = sqlite3VdbeBooleanValue(aMem + pOp->p1, ! pOp->p3);
    if (tmp___21) {
      tmp___22 = 0;
    } else {
      tmp___22 = 1;
    }
    c___0 = tmp___22;
    if (c___0) {
      goto jump_to_p2;
    }
    break;
    case 50: 
    pIn1 = aMem + pOp->p1;
    if (((int )pIn1->flags & 1) != 0) {
      goto jump_to_p2;
    }
    break;
    case 51: 
    pIn1 = aMem + pOp->p1;
    if (((int )pIn1->flags & 1) == 0) {
      goto jump_to_p2;
    }
    break;
    case 21: 
    if ((*(p->apCsr + pOp->p1))->nullRow) {
      sqlite3VdbeMemSetNull(aMem + pOp->p3);
      goto jump_to_p2;
    }
    break;
    case 90: 
    pC = *(p->apCsr + pOp->p1);
    p2___1 = pOp->p2;
    rc = sqlite3VdbeCursorMoveto(& pC, & p2___1);
    if (rc) {
      goto abort_due_to_error;
    }
    pDest = aMem + pOp->p3;
    aOffset = pC->aOffset;
    if (pC->cacheStatus != p->cacheCtr) {
      if (pC->nullRow) {
        if ((int )pC->eCurType == 3) {
          pReg = aMem + pC->seekResult;
          tmp___23 = (u32 )pReg->n;
          pC->szRow = tmp___23;
          pC->payloadSize = tmp___23;
          pC->aRow = (u8 const   *)((u8 *)pReg->z);
        } else {
          sqlite3VdbeMemSetNull(pDest);
          goto op_column_out;
        }
      } else {
        pCrsr = pC->uc.pCursor;
        pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);
        tmp___24 = sqlite3BtreePayloadFetch(pCrsr, & pC->szRow);
        pC->aRow = (u8 const   *)tmp___24;
        if (pC->payloadSize > (u32 )db->aLimit[0]) {
          goto too_big;
        }
      }
      pC->cacheStatus = p->cacheCtr;
      if ((int const   )*(pC->aRow) < 128) {
        *(aOffset + 0) = (u32 )*(pC->aRow);
        tmp___26 = 1;
      } else {
        tmp___25 = sqlite3GetVarint32(pC->aRow, aOffset + 0);
        tmp___26 = (int )tmp___25;
      }
      pC->iHdrOffset = (u32 )((u8 )tmp___26);
      pC->nHdrParsed = (u16 )0;
      if (pC->szRow < *(aOffset + 0)) {
        pC->aRow = (u8 const   *)0;
        pC->szRow = (u32 )0;
        if (*(aOffset + 0) > 98307U) {
          goto op_column_corrupt;
        } else
        if (*(aOffset + 0) > pC->payloadSize) {
          goto op_column_corrupt;
        }
      } else {
        zData = pC->aRow;
        goto op_column_read_header;
      }
    }
    if ((int )pC->nHdrParsed <= p2___1) {
      if (pC->iHdrOffset < *(aOffset + 0)) {
        if ((unsigned long )pC->aRow == (unsigned long )((u8 const   *)0)) {
          memset((void *)(& sMem), 0, sizeof(sMem));
          rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, (u32 )0, *(aOffset + 0), & sMem);
          if (rc != 0) {
            goto abort_due_to_error;
          }
          zData = (u8 const   *)((u8 *)sMem.z);
        } else {
          zData = pC->aRow;
        }
        op_column_read_header: 
        i___1 = (int )pC->nHdrParsed;
        offset64 = (u64 )*(aOffset + i___1);
        zHdr = zData + pC->iHdrOffset;
        zEndHdr = zData + *(aOffset + 0);
        while (1) {
          t = (u32 )*(zHdr + 0);
          tmp___30 = t;
          pC->aType[i___1] = tmp___30;
          if (tmp___30 < 128U) {
            zHdr ++;
            tmp___27 = sqlite3VdbeOneByteSerialTypeLen((u8 )t);
            offset64 += (u64 )tmp___27;
          } else {
            tmp___28 = sqlite3GetVarint32(zHdr, & t);
            zHdr += (int )tmp___28;
            pC->aType[i___1] = t;
            tmp___29 = sqlite3VdbeSerialTypeLen(t);
            offset64 += (u64 )tmp___29;
          }
          i___1 ++;
          *(aOffset + i___1) = (u32 )(offset64 & 4294967295ULL);
          if (i___1 <= p2___1) {
            if (! ((unsigned long )zHdr < (unsigned long )zEndHdr)) {
              break;
            }
          } else {
            break;
          }
        }
        if ((unsigned long )zHdr >= (unsigned long )zEndHdr) {
          if ((unsigned long )zHdr > (unsigned long )zEndHdr) {
            goto _L___0;
          } else
          if (offset64 != (u64 )pC->payloadSize) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
        if (offset64 > (u64 )pC->payloadSize) {
          _L___0: /* CIL Label */ 
          if (*(aOffset + 0) == 0U) {
            i___1 = 0;
            zHdr = zEndHdr;
          } else {
            if ((unsigned long )pC->aRow == (unsigned long )((u8 const   *)0)) {
              sqlite3VdbeMemRelease(& sMem);
            }
            goto op_column_corrupt;
          }
        }
        pC->nHdrParsed = (u16 )i___1;
        pC->iHdrOffset = (u32 )(zHdr - zData);
        if ((unsigned long )pC->aRow == (unsigned long )((u8 const   *)0)) {
          sqlite3VdbeMemRelease(& sMem);
        }
      } else {
        t = (u32 )0;
      }
      if ((int )pC->nHdrParsed <= p2___1) {
        if ((int )pOp->p4type == -11) {
          sqlite3VdbeMemShallowCopy(pDest, (Mem const   *)pOp->p4.pMem, 2048);
        } else {
          sqlite3VdbeMemSetNull(pDest);
        }
        goto op_column_out;
      }
    } else {
      t = pC->aType[p2___1];
    }
    if (((int )pDest->flags & 9216) != 0) {
      sqlite3VdbeMemSetNull(pDest);
    }
    if (pC->szRow >= *(aOffset + (p2___1 + 1))) {
      zData = pC->aRow + *(aOffset + p2___1);
      if (t < 12U) {
        sqlite3VdbeSerialGet(zData, t, pDest);
      } else {
        len = (int )((t - 12U) / 2U);
        pDest->n = len;
        pDest->enc = encoding;
        if (pDest->szMalloc < len + 2) {
          pDest->flags = (u16 )1;
          tmp___31 = sqlite3VdbeMemGrow(pDest, len + 2, 0);
          if (tmp___31) {
            goto no_mem;
          }
        } else {
          pDest->z = pDest->zMalloc;
        }
        memcpy((void * __restrict  )pDest->z, (void const   * __restrict  )zData,
               (size_t )len);
        *(pDest->z + len) = (char)0;
        *(pDest->z + (len + 1)) = (char)0;
        pDest->flags = (u16 )aFlag___0[t & 1U];
      }
    } else {
      pDest->enc = encoding;
      if (((int )pOp->p5 & 192) != 0) {
        if (t >= 12U) {
          if ((t & 1U) == 0U) {
            sqlite3VdbeSerialGet((unsigned char const   *)(aZero), t, pDest);
          } else {
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
        if (((int )pOp->p5 & 128) != 0) {
          sqlite3VdbeSerialGet((unsigned char const   *)(aZero), t, pDest);
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        tmp___32 = sqlite3VdbeSerialTypeLen(t);
        len = (int )tmp___32;
        if (len == 0) {
          sqlite3VdbeSerialGet((unsigned char const   *)(aZero), t, pDest);
        } else {
          rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, *(aOffset + p2___1), (u32 )len,
                                       pDest);
          if (rc != 0) {
            goto abort_due_to_error;
          }
          sqlite3VdbeSerialGet((u8 const   *)pDest->z, t, pDest);
          pDest->flags = (u16 )((int )pDest->flags & -4097);
        }
      }
    }
    op_column_out: ;
    break;
    op_column_corrupt: 
    if ((aOp___1 + 0)->p3 > 0) {
      pOp = aOp___1 + ((aOp___1 + 0)->p3 - 1);
      break;
    } else {
      rc = sqlite3CorruptError(86725);
      goto abort_due_to_error;
    }
    case 91: 
    zAffinity = (char const   *)pOp->p4.z;
    pIn1 = aMem + pOp->p1;
    while (1) {
      applyAffinity(pIn1, (char )*(zAffinity + 0), encoding);
      if ((int const   )*(zAffinity + 0) == 69) {
        if (((int )pIn1->flags & 4) != 0) {
          if (pIn1->u.i <= 140737488355327LL) {
            if (pIn1->u.i >= -140737488355328LL) {
              pIn1->flags = (u16 )((int )pIn1->flags | 32);
              pIn1->flags = (u16 )((int )pIn1->flags & -5);
            } else {
              pIn1->u.r = (double )pIn1->u.i;
              pIn1->flags = (u16 )((int )pIn1->flags | 8);
              pIn1->flags = (u16 )((int )pIn1->flags & -5);
            }
          } else {
            pIn1->u.r = (double )pIn1->u.i;
            pIn1->flags = (u16 )((int )pIn1->flags | 8);
            pIn1->flags = (u16 )((int )pIn1->flags & -5);
          }
        }
      }
      zAffinity ++;
      if ((int const   )*(zAffinity + 0) == 0) {
        break;
      }
      pIn1 ++;
    }
    break;
    case 92: 
    nData = (u64 )0;
    nHdr = 0;
    nZero = (i64 )0;
    nField = pOp->p1;
    zAffinity___0 = pOp->p4.z;
    pData0 = aMem + nField;
    nField = pOp->p2;
    pLast = pData0 + (nField - 1);
    file_format = (int )p->minWriteFileFormat;
    pOut = aMem + pOp->p3;
    if (zAffinity___0) {
      pRec = pData0;
      while (1) {
        applyAffinity(pRec, *(zAffinity___0 + 0), encoding);
        if ((int )*(zAffinity___0 + 0) == 69) {
          if ((int )pRec->flags & 4) {
            pRec->flags = (u16 )((int )pRec->flags | 32);
            pRec->flags = (u16 )((int )pRec->flags & -5);
          }
        }
        zAffinity___0 ++;
        pRec ++;
        if (! *(zAffinity___0 + 0)) {
          break;
        }
      }
    }
    pRec = pLast;
    while (1) {
      if ((int )pRec->flags & 1) {
        if ((int )pRec->flags & 16384) {
          pRec->uTemp = (u32 )10;
        } else {
          pRec->uTemp = (u32 )0;
        }
        nHdr ++;
      } else
      if ((int )pRec->flags & 36) {
        i___2 = pRec->u.i;
        if (i___2 < 0LL) {
          uu = (u64 )(~ i___2);
        } else {
          uu = (u64 )i___2;
        }
        nHdr ++;
        if (uu <= 127ULL) {
          if ((i___2 & 1LL) == i___2) {
            if (file_format >= 4) {
              pRec->uTemp = 8U + (u32 )uu;
            } else {
              nData ++;
              pRec->uTemp = (u32 )1;
            }
          } else {
            nData ++;
            pRec->uTemp = (u32 )1;
          }
        } else
        if (uu <= 32767ULL) {
          nData += 2ULL;
          pRec->uTemp = (u32 )2;
        } else
        if (uu <= 8388607ULL) {
          nData += 3ULL;
          pRec->uTemp = (u32 )3;
        } else
        if (uu <= 2147483647ULL) {
          nData += 4ULL;
          pRec->uTemp = (u32 )4;
        } else
        if (uu <= 140737488355327ULL) {
          nData += 6ULL;
          pRec->uTemp = (u32 )5;
        } else {
          nData += 8ULL;
          if ((int )pRec->flags & 32) {
            pRec->u.r = (double )pRec->u.i;
            pRec->flags = (u16 )((int )pRec->flags & -33);
            pRec->flags = (u16 )((int )pRec->flags | 8);
            pRec->uTemp = (u32 )7;
          } else {
            pRec->uTemp = (u32 )6;
          }
        }
      } else
      if ((int )pRec->flags & 8) {
        nHdr ++;
        nData += 8ULL;
        pRec->uTemp = (u32 )7;
      } else {
        len___0 = (u32 )pRec->n;
        serial_type = (len___0 * 2U + 12U) + (u32 )(((int )pRec->flags & 2) != 0);
        if ((int )pRec->flags & 16384) {
          serial_type += (u32 )(pRec->u.nZero * 2);
          if (nData) {
            tmp___33 = sqlite3VdbeMemExpandBlob(pRec);
            if (tmp___33) {
              goto no_mem;
            }
            len___0 += (u32 )pRec->u.nZero;
          } else {
            nZero += (i64 )pRec->u.nZero;
          }
        }
        nData += (u64 )len___0;
        tmp___34 = sqlite3VarintLen((u64 )serial_type);
        nHdr += tmp___34;
        pRec->uTemp = serial_type;
      }
      if ((unsigned long )pRec == (unsigned long )pData0) {
        break;
      }
      pRec --;
    }
    if (nHdr <= 126) {
      nHdr ++;
    } else {
      nVarint = sqlite3VarintLen((u64 )nHdr);
      nHdr += nVarint;
      tmp___35 = sqlite3VarintLen((u64 )nHdr);
      if (nVarint < tmp___35) {
        nHdr ++;
      }
    }
    nByte___0 = (i64 )((u64 )nHdr + nData);
    if (nByte___0 + nZero <= (i64 )pOut->szMalloc) {
      pOut->z = pOut->zMalloc;
    } else {
      if (nByte___0 + nZero > (i64 )db->aLimit[0]) {
        goto too_big;
      }
      tmp___36 = sqlite3VdbeMemClearAndResize(pOut, (int )nByte___0);
      if (tmp___36) {
        goto no_mem;
      }
    }
    pOut->n = (int )nByte___0;
    pOut->flags = (u16 )16;
    if (nZero) {
      pOut->u.nZero = (int )nZero;
      pOut->flags = (u16 )((int )pOut->flags | 16384);
    }
    zHdr___0 = (u8 *)pOut->z;
    zPayload = zHdr___0 + nHdr;
    if ((u32 )nHdr < 128U) {
      *zHdr___0 = (unsigned char )nHdr;
      tmp___38 = 1;
    } else {
      tmp___37 = sqlite3PutVarint(zHdr___0, (u64 )nHdr);
      tmp___38 = tmp___37;
    }
    zHdr___0 += (int )((u8 )tmp___38);
    pRec = pData0;
    while (1) {
      serial_type = pRec->uTemp;
      if (serial_type < 128U) {
        *zHdr___0 = (unsigned char )serial_type;
        tmp___40 = 1;
      } else {
        tmp___39 = sqlite3PutVarint(zHdr___0, (u64 )serial_type);
        tmp___40 = tmp___39;
      }
      zHdr___0 += (int )((u8 )tmp___40);
      tmp___41 = sqlite3VdbeSerialPut(zPayload, pRec, serial_type);
      zPayload += tmp___41;
      pRec ++;
      if (! ((unsigned long )pRec <= (unsigned long )pLast)) {
        break;
      }
    }
    break;
    case 93: 
    pCrsr___0 = (*(p->apCsr + pOp->p1))->uc.pCursor;
    nEntry = (i64 )0;
    rc = sqlite3BtreeCount(pCrsr___0, & nEntry);
    if (rc) {
      goto abort_due_to_error;
    }
    pOut = out2Prerelease(p, pOp);
    pOut->u.i = nEntry;
    break;
    case 0: 
    p1___1 = pOp->p1;
    zName = pOp->p4.z;
    if (p1___1 == 0) {
      if (db->nVdbeWrite > 0) {
        sqlite3VdbeError(p, "cannot open savepoint - SQL statements in progress");
        rc = 5;
      } else {
        nName = sqlite3Strlen30((char const   *)zName);
        rc = sqlite3VtabSavepoint(db, 0, db->nStatement + db->nSavepoint);
        if (rc != 0) {
          goto abort_due_to_error;
        }
        tmp___42 = sqlite3DbMallocRawNN(db, (u64 )((sizeof(Savepoint ) + (unsigned long )nName) + 1UL));
        pNew = (Savepoint *)tmp___42;
        if (pNew) {
          pNew->zName = (char *)(pNew + 1);
          memcpy((void * __restrict  )pNew->zName, (void const   * __restrict  )zName,
                 (size_t )(nName + 1));
          if (db->autoCommit) {
            db->autoCommit = (u8 )0;
            db->isTransactionSavepoint = (u8 )1;
          } else {
            (db->nSavepoint) ++;
          }
          pNew->pNext = db->pSavepoint;
          db->pSavepoint = pNew;
          pNew->nDeferredCons = db->nDeferredCons;
          pNew->nDeferredImmCons = db->nDeferredImmCons;
        }
      }
    } else {
      iSavepoint = 0;
      pSavepoint = db->pSavepoint;
      while (1) {
        if (pSavepoint) {
          tmp___43 = sqlite3StrICmp((char const   *)pSavepoint->zName, (char const   *)zName);
          if (! tmp___43) {
            break;
          }
        } else {
          break;
        }
        iSavepoint ++;
        pSavepoint = pSavepoint->pNext;
      }
      if (! pSavepoint) {
        sqlite3VdbeError(p, "no such savepoint: %s", zName);
        rc = 1;
      } else
      if (db->nVdbeWrite > 0) {
        if (p1___1 == 1) {
          sqlite3VdbeError(p, "cannot release savepoint - SQL statements in progress");
          rc = 5;
        } else {
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        if ((unsigned long )pSavepoint->pNext == (unsigned long )((Savepoint *)0)) {
          if (db->isTransactionSavepoint) {
            tmp___44 = 1;
          } else {
            tmp___44 = 0;
          }
        } else {
          tmp___44 = 0;
        }
        isTransaction = tmp___44;
        if (isTransaction) {
          if (p1___1 == 1) {
            rc = sqlite3VdbeCheckFk(p, 1);
            if (rc != 0) {
              goto vdbe_return;
            }
            db->autoCommit = (u8 )1;
            tmp___45 = sqlite3VdbeHalt(p);
            if (tmp___45 == 5) {
              p->pc = (int )(pOp - aOp___1);
              db->autoCommit = (u8 )0;
              rc = 5;
              p->rc = rc;
              goto vdbe_return;
            }
            db->isTransactionSavepoint = (u8 )0;
            rc = p->rc;
          } else {
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          iSavepoint = (db->nSavepoint - iSavepoint) - 1;
          if (p1___1 == 2) {
            isSchemaChange = (db->mDbFlags & 1U) != 0U;
            ii = 0;
            while (ii < db->nDb) {
              rc = sqlite3BtreeTripAllCursors((db->aDb + ii)->pBt, 4 | (2 << 8), isSchemaChange == 0);
              if (rc != 0) {
                goto abort_due_to_error;
              }
              ii ++;
            }
          } else {
            isSchemaChange = 0;
          }
          ii = 0;
          while (ii < db->nDb) {
            rc = sqlite3BtreeSavepoint((db->aDb + ii)->pBt, p1___1, iSavepoint);
            if (rc != 0) {
              goto abort_due_to_error;
            }
            ii ++;
          }
          if (isSchemaChange) {
            sqlite3ExpirePreparedStatements(db, 0);
            sqlite3ResetAllSchemasOfConnection(db);
            db->mDbFlags |= 1U;
          }
        }
        while ((unsigned long )db->pSavepoint != (unsigned long )pSavepoint) {
          pTmp = db->pSavepoint;
          db->pSavepoint = pTmp->pNext;
          sqlite3DbFree(db, (void *)pTmp);
          (db->nSavepoint) --;
        }
        if (p1___1 == 1) {
          db->pSavepoint = pSavepoint->pNext;
          sqlite3DbFree(db, (void *)pSavepoint);
          if (! isTransaction) {
            (db->nSavepoint) --;
          }
        } else {
          db->nDeferredCons = pSavepoint->nDeferredCons;
          db->nDeferredImmCons = pSavepoint->nDeferredImmCons;
        }
        if (! isTransaction) {
          goto _L___5;
        } else
        if (p1___1 == 2) {
          _L___5: /* CIL Label */ 
          rc = sqlite3VtabSavepoint(db, p1___1, iSavepoint);
          if (rc != 0) {
            goto abort_due_to_error;
          }
        }
      }
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 1: 
    desiredAutoCommit = pOp->p1;
    iRollback = pOp->p2;
    if (desiredAutoCommit != (int )db->autoCommit) {
      if (iRollback) {
        sqlite3RollbackAll(db, 4 | (2 << 8));
        db->autoCommit = (u8 )1;
      } else
      if (desiredAutoCommit) {
        if (db->nVdbeWrite > 0) {
          sqlite3VdbeError(p, "cannot commit transaction - SQL statements in progress");
          rc = 5;
          goto abort_due_to_error;
        } else {
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        rc = sqlite3VdbeCheckFk(p, 1);
        if (rc != 0) {
          goto vdbe_return;
        } else {
          db->autoCommit = (u8 )desiredAutoCommit;
        }
      }
      tmp___46 = sqlite3VdbeHalt(p);
      if (tmp___46 == 5) {
        p->pc = (int )(pOp - aOp___1);
        db->autoCommit = (u8 )(1 - desiredAutoCommit);
        rc = 5;
        p->rc = rc;
        goto vdbe_return;
      }
      sqlite3CloseSavepoints(db);
      if (p->rc == 0) {
        rc = 101;
      } else {
        rc = 1;
      }
      goto vdbe_return;
    } else {
      if (! desiredAutoCommit) {
        tmp___48 = "cannot start a transaction within a transaction";
      } else {
        if (iRollback) {
          tmp___47 = "cannot rollback - no transaction is active";
        } else {
          tmp___47 = "cannot commit - no transaction is active";
        }
        tmp___48 = tmp___47;
      }
      sqlite3VdbeError(p, tmp___48);
      rc = 1;
      goto abort_due_to_error;
    }
    case 2: 
    iMeta = 0;
    if (pOp->p2) {
      if ((db->flags & 1048576ULL) != 0ULL) {
        rc = 8;
        goto abort_due_to_error;
      }
    }
    pBt = (db->aDb + pOp->p1)->pBt;
    if (pBt) {
      rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, & iMeta);
      if (rc != 0) {
        if ((rc & 255) == 5) {
          p->pc = (int )(pOp - aOp___1);
          p->rc = rc;
          goto vdbe_return;
        }
        goto abort_due_to_error;
      }
      if (pOp->p2) {
        if (p->usesStmtJournal) {
          if ((int )db->autoCommit == 0) {
            goto _L___8;
          } else
          if (db->nVdbeRead > 1) {
            _L___8: /* CIL Label */ 
            if (p->iStatement == 0) {
              (db->nStatement) ++;
              p->iStatement = db->nSavepoint + db->nStatement;
            }
            rc = sqlite3VtabSavepoint(db, 0, p->iStatement - 1);
            if (rc == 0) {
              rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);
            }
            p->nStmtDefCons = db->nDeferredCons;
            p->nStmtDefImmCons = db->nDeferredImmCons;
          }
        }
      }
    }
    if (pOp->p5) {
      if (iMeta != pOp->p3) {
        goto _L___9;
      } else
      if (((db->aDb + pOp->p1)->pSchema)->iGeneration != pOp->p4.i) {
        _L___9: /* CIL Label */ 
        sqlite3DbFree(db, (void *)p->zErrMsg);
        p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");
        if (((db->aDb + pOp->p1)->pSchema)->schema_cookie != iMeta) {
          sqlite3ResetOneSchema(db, pOp->p1);
        }
        p->expired = (bft )1;
        rc = 17;
      }
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 94: 
    iDb = pOp->p1;
    iCookie = pOp->p3;
    sqlite3BtreeGetMeta((db->aDb + iDb)->pBt, iCookie, (u32 *)(& iMeta___0));
    pOut = out2Prerelease(p, pOp);
    pOut->u.i = (i64 )iMeta___0;
    break;
    case 95: 
    pDb = db->aDb + pOp->p1;
    rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, (u32 )pOp->p3);
    if (pOp->p2 == 1) {
      (pDb->pSchema)->schema_cookie = pOp->p3;
      db->mDbFlags |= 1U;
    } else
    if (pOp->p2 == 2) {
      (pDb->pSchema)->file_format = (u8 )pOp->p3;
    }
    if (pOp->p1 == 1) {
      sqlite3ExpirePreparedStatements(db, 0);
      p->expired = (bft )0;
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 96: 
    pCur = *(p->apCsr + pOp->p1);
    if (pCur) {
      if (pCur->pgnoRoot == (u32 )pOp->p2) {
        goto open_cursor_set_hints;
      }
    }
    case 98: 
    case 97: ;
    if (p->expired == 1U) {
      rc = 4 | (2 << 8);
      goto abort_due_to_error;
    }
    nField___0 = 0;
    pKeyInfo___0 = (KeyInfo *)0;
    p2___2 = pOp->p2;
    iDb___0 = pOp->p3;
    pDb___0 = db->aDb + iDb___0;
    pX = pDb___0->pBt;
    if ((int )pOp->opcode == 98) {
      wrFlag = 4 | ((int )pOp->p5 & 8);
      if ((int )(pDb___0->pSchema)->file_format < (int )p->minWriteFileFormat) {
        p->minWriteFileFormat = (pDb___0->pSchema)->file_format;
      }
    } else {
      wrFlag = 0;
    }
    if ((int )pOp->p5 & 16) {
      pIn2 = aMem + p2___2;
      sqlite3VdbeMemIntegerify(pIn2);
      p2___2 = (int )pIn2->u.i;
    }
    if ((int )pOp->p4type == -9) {
      pKeyInfo___0 = pOp->p4.pKeyInfo;
      nField___0 = (int )pKeyInfo___0->nAllField;
    } else
    if ((int )pOp->p4type == -3) {
      nField___0 = pOp->p4.i;
    }
    pCur = allocateCursor(p, pOp->p1, nField___0, iDb___0, (u8 )0);
    if ((unsigned long )pCur == (unsigned long )((VdbeCursor *)0)) {
      goto no_mem;
    }
    pCur->nullRow = (u8 )1;
    pCur->isOrdered = (Bool )1;
    pCur->pgnoRoot = (Pgno )p2___2;
    rc = sqlite3BtreeCursor(pX, p2___2, wrFlag, pKeyInfo___0, pCur->uc.pCursor);
    pCur->pKeyInfo = pKeyInfo___0;
    pCur->isTable = (u8 )((int )pOp->p4type != -9);
    open_cursor_set_hints: 
    sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (unsigned int )((int )pOp->p5 & 3));
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 109: 
    pOrig = *(p->apCsr + pOp->p2);
    pCx = allocateCursor(p, pOp->p1, (int )pOrig->nField, -1, (u8 )0);
    if ((unsigned long )pCx == (unsigned long )((VdbeCursor *)0)) {
      goto no_mem;
    }
    pCx->nullRow = (u8 )1;
    pCx->isEphemeral = (Bool )1;
    pCx->pKeyInfo = pOrig->pKeyInfo;
    pCx->isTable = pOrig->isTable;
    pCx->pgnoRoot = pOrig->pgnoRoot;
    pCx->isOrdered = pOrig->isOrdered;
    rc = sqlite3BtreeCursor(pOrig->pBtx, (int )pCx->pgnoRoot, 4, pCx->pKeyInfo, pCx->uc.pCursor);
    break;
    case 112: 
    case 111: 
    pCx___0 = *(p->apCsr + pOp->p1);
    if (pCx___0) {
      pCx___0->seqCount = (i64 )0;
      pCx___0->cacheStatus = (u32 )0;
      if (pCx___0->pBtx) {
        rc = sqlite3BtreeClearTable(pCx___0->pBtx, (int )pCx___0->pgnoRoot, (int *)0);
      }
    } else {
      pCx___0 = allocateCursor(p, pOp->p1, pOp->p2, -1, (u8 )0);
      if ((unsigned long )pCx___0 == (unsigned long )((VdbeCursor *)0)) {
        goto no_mem;
      }
      pCx___0->isEphemeral = (Bool )1;
      rc = sqlite3BtreeOpen(db->pVfs, (char const   *)0, db, & pCx___0->pBtx, 5 | (int )pOp->p5,
                            (int )vfsFlags);
      if (rc == 0) {
        rc = sqlite3BtreeBeginTrans(pCx___0->pBtx, 1, (int *)0);
      }
      if (rc == 0) {
        pKeyInfo___1 = pOp->p4.pKeyInfo;
        tmp___49 = pKeyInfo___1;
        pCx___0->pKeyInfo = tmp___49;
        if ((unsigned long )tmp___49 != (unsigned long )((KeyInfo *)0)) {
          rc = sqlite3BtreeCreateTable(pCx___0->pBtx, (int *)(& pCx___0->pgnoRoot),
                                       2 | (int )pOp->p5);
          if (rc == 0) {
            rc = sqlite3BtreeCursor(pCx___0->pBtx, (int )pCx___0->pgnoRoot, 4, pKeyInfo___1,
                                    pCx___0->uc.pCursor);
          }
          pCx___0->isTable = (u8 )0;
        } else {
          pCx___0->pgnoRoot = (Pgno )1;
          rc = sqlite3BtreeCursor(pCx___0->pBtx, 1, 4, (struct KeyInfo *)0, pCx___0->uc.pCursor);
          pCx___0->isTable = (u8 )1;
        }
      }
      pCx___0->isOrdered = (Bool )((int )pOp->p5 != 8);
    }
    if (rc) {
      goto abort_due_to_error;
    }
    pCx___0->nullRow = (u8 )1;
    break;
    case 114: 
    pCx___1 = allocateCursor(p, pOp->p1, pOp->p2, -1, (u8 )1);
    if ((unsigned long )pCx___1 == (unsigned long )((VdbeCursor *)0)) {
      goto no_mem;
    }
    pCx___1->pKeyInfo = pOp->p4.pKeyInfo;
    rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx___1);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 115: 
    pC___0 = *(p->apCsr + pOp->p1);
    tmp___50 = pC___0->seqCount;
    (pC___0->seqCount) ++;
    if (tmp___50 == 0LL) {
      goto jump_to_p2;
    }
    break;
    case 116: 
    pCx___2 = allocateCursor(p, pOp->p1, pOp->p3, -1, (u8 )3);
    if ((unsigned long )pCx___2 == (unsigned long )((VdbeCursor *)0)) {
      goto no_mem;
    }
    pCx___2->nullRow = (u8 )1;
    pCx___2->seekResult = pOp->p2;
    pCx___2->isTable = (u8 )1;
    pCx___2->uc.pCursor = sqlite3BtreeFakeValidCursor();
    break;
    case 117: 
    sqlite3VdbeFreeCursor(p, *(p->apCsr + pOp->p1));
    *(p->apCsr + pOp->p1) = (VdbeCursor *)0;
    break;
    case 25: 
    case 24: 
    case 23: 
    case 22: 
    pC___1 = *(p->apCsr + pOp->p1);
    oc = (int )pOp->opcode;
    eqOnly = 0;
    pC___1->nullRow = (u8 )0;
    pC___1->deferredMoveto = (u8 )0;
    pC___1->cacheStatus = (u32 )0;
    if (pC___1->isTable) {
      pIn3 = aMem + pOp->p3;
      flags3___0 = pIn3->flags;
      if (((int )flags3___0 & 46) == 2) {
        applyNumericAffinity(pIn3, 0);
      }
      iKey = sqlite3VdbeIntValue(pIn3);
      newType = pIn3->flags;
      pIn3->flags = flags3___0;
      if (((int )newType & 36) == 0) {
        if (((int )newType & 8) == 0) {
          if ((int )newType & 1) {
            goto jump_to_p2;
          } else
          if (oc >= 24) {
            goto jump_to_p2;
          } else {
            rc = sqlite3BtreeLast(pC___1->uc.pCursor, & res___0);
            if (rc != 0) {
              goto abort_due_to_error;
            }
            goto seek_not_found;
          }
        } else
        if (pIn3->u.r < (double )iKey) {
          if ((oc & 1) == 1) {
            oc --;
          }
        } else
        if (pIn3->u.r > (double )iKey) {
          if ((oc & 1) == 0) {
            oc ++;
          }
        }
      }
      rc = sqlite3BtreeMovetoUnpacked(pC___1->uc.pCursor, (UnpackedRecord *)0, (i64 )((u64 )iKey),
                                      0, & res___0);
      pC___1->movetoTarget = iKey;
      if (rc != 0) {
        goto abort_due_to_error;
      }
    } else {
      tmp___51 = sqlite3BtreeCursorHasHint(pC___1->uc.pCursor, 2U);
      if (tmp___51) {
        eqOnly = 1;
      }
      nField___1 = pOp->p4.i;
      r.pKeyInfo = pC___1->pKeyInfo;
      r.nField = (u16 )nField___1;
      if (1 & (oc - 22)) {
        r.default_rc = (i8 )-1;
      } else {
        r.default_rc = (i8 )1;
      }
      r.aMem = aMem + pOp->p3;
      r.eqSeen = (u8 )0;
      rc = sqlite3BtreeMovetoUnpacked(pC___1->uc.pCursor, & r, (i64 )0, 0, & res___0);
      if (rc != 0) {
        goto abort_due_to_error;
      }
      if (eqOnly) {
        if ((int )r.eqSeen == 0) {
          goto seek_not_found;
        }
      }
    }
    if (oc >= 24) {
      if (res___0 < 0) {
        goto _L___10;
      } else
      if (res___0 == 0) {
        if (oc == 25) {
          _L___10: /* CIL Label */ 
          res___0 = 0;
          rc = sqlite3BtreeNext(pC___1->uc.pCursor, 0);
          if (rc != 0) {
            if (rc == 101) {
              rc = 0;
              res___0 = 1;
            } else {
              goto abort_due_to_error;
            }
          }
        } else {
          res___0 = 0;
        }
      } else {
        res___0 = 0;
      }
    } else
    if (res___0 > 0) {
      goto _L___11;
    } else
    if (res___0 == 0) {
      if (oc == 22) {
        _L___11: /* CIL Label */ 
        res___0 = 0;
        rc = sqlite3BtreePrevious(pC___1->uc.pCursor, 0);
        if (rc != 0) {
          if (rc == 101) {
            rc = 0;
            res___0 = 1;
          } else {
            goto abort_due_to_error;
          }
        }
      } else {
        res___0 = sqlite3BtreeEof(pC___1->uc.pCursor);
      }
    } else {
      res___0 = sqlite3BtreeEof(pC___1->uc.pCursor);
    }
    seek_not_found: ;
    if (res___0) {
      goto jump_to_p2;
    } else
    if (eqOnly) {
      pOp ++;
    }
    break;
    case 119: 
    pC___2 = *(p->apCsr + pOp->p1);
    pC___2->seekHit = (Bool )(pOp->p2 & 1);
    break;
    case 26: 
    pC___3 = *(p->apCsr + pOp->p1);
    if (pC___3->seekHit) {
      break;
    }
    case 29: 
    case 28: 
    case 27: 
    pC___4 = *(p->apCsr + pOp->p1);
    pIn3 = aMem + pOp->p3;
    if (pOp->p4.i > 0) {
      r___0.pKeyInfo = pC___4->pKeyInfo;
      r___0.nField = (u16 )pOp->p4.i;
      r___0.aMem = pIn3;
      pIdxKey = & r___0;
      pFree = (UnpackedRecord *)0;
    } else {
      if ((int )pIn3->flags & 16384) {
        tmp___52 = sqlite3VdbeMemExpandBlob(pIn3);
        rc = tmp___52;
      } else {
        rc = 0;
      }
      if (rc) {
        goto no_mem;
      }
      pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC___4->pKeyInfo);
      pFree = pIdxKey;
      if ((unsigned long )pIdxKey == (unsigned long )((UnpackedRecord *)0)) {
        goto no_mem;
      }
      sqlite3VdbeRecordUnpack(pC___4->pKeyInfo, pIn3->n, (void const   *)pIn3->z,
                              pIdxKey);
    }
    pIdxKey->default_rc = (i8 )0;
    takeJump = 0;
    if ((int )pOp->opcode == 27) {
      ii___0 = 0;
      while (ii___0 < (int )pIdxKey->nField) {
        if ((int )(pIdxKey->aMem + ii___0)->flags & 1) {
          takeJump = 1;
          break;
        }
        ii___0 ++;
      }
    }
    rc = sqlite3BtreeMovetoUnpacked(pC___4->uc.pCursor, pIdxKey, (i64 )0, 0, & res___1);
    if (pFree) {
      sqlite3DbFreeNN(db, (void *)pFree);
    }
    if (rc != 0) {
      goto abort_due_to_error;
    }
    pC___4->seekResult = res___1;
    alreadyExists = res___1 == 0;
    pC___4->nullRow = (u8 )(1 - alreadyExists);
    pC___4->deferredMoveto = (u8 )0;
    pC___4->cacheStatus = (u32 )0;
    if ((int )pOp->opcode == 29) {
      if (alreadyExists) {
        goto jump_to_p2;
      }
    } else
    if (takeJump) {
      goto jump_to_p2;
    } else
    if (! alreadyExists) {
      goto jump_to_p2;
    }
    break;
    case 30: 
    pIn3 = aMem + pOp->p3;
    if (((int )pIn3->flags & 36) == 0) {
      origFlags = pIn3->flags;
      applyAffinity(pIn3, (char)67, encoding);
      isNotInt = ((int )pIn3->flags & 4) == 0;
      pIn3->flags = origFlags;
      if (isNotInt) {
        goto jump_to_p2;
      }
    }
    case 31: 
    pIn3 = aMem + pOp->p3;
    pC___5 = *(p->apCsr + pOp->p1);
    pCrsr___1 = pC___5->uc.pCursor;
    res___2 = 0;
    iKey___0 = (u64 )pIn3->u.i;
    rc = sqlite3BtreeMovetoUnpacked(pCrsr___1, (UnpackedRecord *)0, (i64 )iKey___0,
                                    0, & res___2);
    pC___5->movetoTarget = (i64 )iKey___0;
    pC___5->nullRow = (u8 )0;
    pC___5->cacheStatus = (u32 )0;
    pC___5->deferredMoveto = (u8 )0;
    pC___5->seekResult = res___2;
    if (res___2 != 0) {
      if (pOp->p2 == 0) {
        rc = sqlite3CorruptError(88508);
      } else {
        goto jump_to_p2;
      }
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 120: 
    pOut = out2Prerelease(p, pOp);
    tmp___53 = (*(p->apCsr + pOp->p1))->seqCount;
    ((*(p->apCsr + pOp->p1))->seqCount) ++;
    pOut->u.i = tmp___53;
    break;
    case 121: 
    v = (i64 )0;
    res___3 = 0;
    pOut = out2Prerelease(p, pOp);
    pC___6 = *(p->apCsr + pOp->p1);
    if (! pC___6->useRandomRowid) {
      rc = sqlite3BtreeLast(pC___6->uc.pCursor, & res___3);
      if (rc != 0) {
        goto abort_due_to_error;
      }
      if (res___3) {
        v = (i64 )1;
      } else {
        v = sqlite3BtreeIntegerKey(pC___6->uc.pCursor);
        if (v >= (i64 )((2147483647ULL << 32) | 4294967295ULL)) {
          pC___6->useRandomRowid = (Bool )1;
        } else {
          v ++;
        }
      }
    }
    if (pOp->p3) {
      if (p->pFrame) {
        pFrame___0 = p->pFrame;
        while (pFrame___0->pParent) {
          pFrame___0 = pFrame___0->pParent;
        }
        pMem___0 = pFrame___0->aMem + pOp->p3;
      } else {
        pMem___0 = aMem + pOp->p3;
      }
      sqlite3VdbeMemIntegerify(pMem___0);
      if (pMem___0->u.i == (i64 )((2147483647ULL << 32) | 4294967295ULL)) {
        rc = 13;
        goto abort_due_to_error;
      } else
      if (pC___6->useRandomRowid) {
        rc = 13;
        goto abort_due_to_error;
      }
      if (v < pMem___0->u.i + 1LL) {
        v = pMem___0->u.i + 1LL;
      }
      pMem___0->u.i = v;
    }
    if (pC___6->useRandomRowid) {
      cnt___0 = 0;
      while (1) {
        sqlite3_randomness((int )sizeof(v), (void *)(& v));
        v &= (i64 )((2147483647ULL << 32) | 4294967295ULL) >> 1;
        v ++;
        rc = sqlite3BtreeMovetoUnpacked(pC___6->uc.pCursor, (UnpackedRecord *)0, (i64 )((u64 )v),
                                        0, & res___3);
        if (rc == 0) {
          if (res___3 == 0) {
            cnt___0 ++;
            if (! (cnt___0 < 100)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (rc) {
        goto abort_due_to_error;
      }
      if (res___3 == 0) {
        rc = 13;
        goto abort_due_to_error;
      }
    }
    pC___6->deferredMoveto = (u8 )0;
    pC___6->cacheStatus = (u32 )0;
    pOut->u.i = v;
    break;
    case 122: 
    pData = aMem + pOp->p2;
    pC___7 = *(p->apCsr + pOp->p1);
    pKey = aMem + pOp->p3;
    x___0.nKey = pKey->u.i;
    if ((int )pOp->p4type == -6) {
      if (db->xUpdateCallback) {
        zDb = (char const   *)(db->aDb + pC___7->iDb)->zDbSName;
        pTab = pOp->p4.pTab;
      } else {
        pTab = (Table *)0;
        zDb = (char const   *)0;
      }
    } else {
      pTab = (Table *)0;
      zDb = (char const   *)0;
    }
    if ((int )pOp->p5 & 1) {
      (p->nChange) ++;
    }
    if ((int )pOp->p5 & 32) {
      db->lastRowid = x___0.nKey;
    }
    x___0.pData = (void const   *)pData->z;
    x___0.nData = pData->n;
    if ((int )pOp->p5 & 16) {
      seekResult = pC___7->seekResult;
    } else {
      seekResult = 0;
    }
    if ((int )pData->flags & 16384) {
      x___0.nZero = pData->u.nZero;
    } else {
      x___0.nZero = 0;
    }
    x___0.pKey = (void const   *)0;
    rc = sqlite3BtreeInsert(pC___7->uc.pCursor, (BtreePayload const   *)(& x___0),
                            (int )pOp->p5 & 10, seekResult);
    pC___7->deferredMoveto = (u8 )0;
    pC___7->cacheStatus = (u32 )0;
    if (rc) {
      goto abort_due_to_error;
    }
    if (pTab) {
      if ((int )pOp->p5 & 4) {
        tmp___54 = 23;
      } else {
        tmp___54 = 18;
      }
      (*(db->xUpdateCallback))(db->pUpdateArg, tmp___54, zDb, (char const   *)pTab->zName,
                               x___0.nKey);
    }
    break;
    case 123: 
    opflags = pOp->p2;
    pC___8 = *(p->apCsr + pOp->p1);
    if ((int )pOp->p4type == -6) {
      if (db->xUpdateCallback) {
        zDb___0 = (char const   *)(db->aDb + pC___8->iDb)->zDbSName;
        pTab___0 = pOp->p4.pTab;
        if (((int )pOp->p5 & 2) != 0) {
          if (pC___8->isTable) {
            pC___8->movetoTarget = sqlite3BtreeIntegerKey(pC___8->uc.pCursor);
          }
        }
      } else {
        zDb___0 = (char const   *)0;
        pTab___0 = (Table *)0;
      }
    } else {
      zDb___0 = (char const   *)0;
      pTab___0 = (Table *)0;
    }
    rc = sqlite3BtreeDelete(pC___8->uc.pCursor, (u8 )pOp->p5);
    pC___8->cacheStatus = (u32 )0;
    pC___8->seekResult = 0;
    if (rc) {
      goto abort_due_to_error;
    }
    if (opflags & 1) {
      (p->nChange) ++;
      if (db->xUpdateCallback) {
        if ((pTab___0->tabFlags & 32U) == 0U) {
          (*(db->xUpdateCallback))(db->pUpdateArg, 9, zDb___0, (char const   *)pTab___0->zName,
                                   pC___8->movetoTarget);
        }
      }
    }
    break;
    case 124: 
    sqlite3VdbeSetChanges(db, p->nChange);
    p->nChange = 0;
    break;
    case 125: 
    pC___9 = *(p->apCsr + pOp->p1);
    pIn3 = aMem + pOp->p3;
    nKeyCol = pOp->p4.i;
    res___4 = 0;
    rc = sqlite3VdbeSorterCompare((VdbeCursor const   *)pC___9, pIn3, nKeyCol, & res___4);
    if (rc) {
      goto abort_due_to_error;
    }
    if (res___4) {
      goto jump_to_p2;
    }
    break;
    case 126: 
    pOut = aMem + pOp->p2;
    pC___10 = *(p->apCsr + pOp->p1);
    rc = sqlite3VdbeSorterRowkey((VdbeCursor const   *)pC___10, pOut);
    if (rc) {
      goto abort_due_to_error;
    }
    (*(p->apCsr + pOp->p3))->cacheStatus = (u32 )0;
    break;
    case 127: 
    pOut = out2Prerelease(p, pOp);
    pC___11 = *(p->apCsr + pOp->p1);
    pCrsr___2 = pC___11->uc.pCursor;
    n___2 = sqlite3BtreePayloadSize(pCrsr___2);
    if (n___2 > (u32 )db->aLimit[0]) {
      goto too_big;
    }
    rc = sqlite3VdbeMemFromBtree(pCrsr___2, (u32 )0, n___2, pOut);
    if (rc) {
      goto abort_due_to_error;
    }
    if (! pOp->p3) {
      if (((int )pOut->flags & 4096) != 0) {
        tmp___55 = sqlite3VdbeMemMakeWriteable(pOut);
        if (tmp___55) {
          goto no_mem;
        }
      }
    }
    break;
    case 128: 
    pOut = out2Prerelease(p, pOp);
    pC___12 = *(p->apCsr + pOp->p1);
    if (pC___12->nullRow) {
      pOut->flags = (u16 )1;
      break;
    } else
    if (pC___12->deferredMoveto) {
      v___0 = pC___12->movetoTarget;
    } else
    if ((int )pC___12->eCurType == 2) {
      pVtab = (pC___12->uc.pVCur)->pVtab;
      pModule = pVtab->pModule;
      rc = (*(pModule->xRowid))(pC___12->uc.pVCur, & v___0);
      sqlite3VtabImportErrmsg(p, pVtab);
      if (rc) {
        goto abort_due_to_error;
      }
    } else {
      rc = sqlite3VdbeCursorRestore(pC___12);
      if (rc) {
        goto abort_due_to_error;
      }
      if (pC___12->nullRow) {
        pOut->flags = (u16 )1;
        break;
      }
      v___0 = sqlite3BtreeIntegerKey(pC___12->uc.pCursor);
    }
    pOut->u.i = v___0;
    break;
    case 129: 
    pC___13 = *(p->apCsr + pOp->p1);
    pC___13->nullRow = (u8 )1;
    pC___13->cacheStatus = (u32 )0;
    if ((int )pC___13->eCurType == 0) {
      sqlite3BtreeClearCursor(pC___13->uc.pCursor);
    }
    break;
    case 32: 
    case 130: 
    pC___14 = *(p->apCsr + pOp->p1);
    pCrsr___3 = pC___14->uc.pCursor;
    res___5 = 0;
    if ((int )pOp->opcode == 130) {
      pC___14->seekResult = -1;
      tmp___56 = sqlite3BtreeCursorIsValidNN(pCrsr___3);
      if (tmp___56) {
        break;
      }
    }
    rc = sqlite3BtreeLast(pCrsr___3, & res___5);
    pC___14->nullRow = (u8 )res___5;
    pC___14->deferredMoveto = (u8 )0;
    pC___14->cacheStatus = (u32 )0;
    if (rc) {
      goto abort_due_to_error;
    }
    if (pOp->p2 > 0) {
      if (res___5) {
        goto jump_to_p2;
      }
    }
    break;
    case 33: 
    pC___15 = *(p->apCsr + pOp->p1);
    pCrsr___4 = pC___15->uc.pCursor;
    rc = sqlite3BtreeFirst(pCrsr___4, & res___6);
    if (rc) {
      goto abort_due_to_error;
    }
    if (res___6 == 0) {
      sz = sqlite3BtreeRowCountEst(pCrsr___4);
      if (sz >= 0LL) {
        tmp___57 = sqlite3LogEst((u64 )sz);
        if ((int )tmp___57 < pOp->p3) {
          res___6 = 1;
        }
      }
    }
    if (res___6) {
      goto jump_to_p2;
    }
    break;
    case 35: 
    case 34: 
    (p->aCounter[2]) ++;
    case 36: 
    pC___16 = *(p->apCsr + pOp->p1);
    res___7 = 1;
    if ((int )pC___16->eCurType == 1) {
      rc = sqlite3VdbeSorterRewind((VdbeCursor const   *)pC___16, & res___7);
    } else {
      pCrsr___5 = pC___16->uc.pCursor;
      rc = sqlite3BtreeFirst(pCrsr___5, & res___7);
      pC___16->deferredMoveto = (u8 )0;
      pC___16->cacheStatus = (u32 )0;
    }
    if (rc) {
      goto abort_due_to_error;
    }
    pC___16->nullRow = (u8 )res___7;
    if (res___7) {
      goto jump_to_p2;
    }
    break;
    case 3: 
    pC___17 = *(p->apCsr + pOp->p1);
    rc = sqlite3VdbeSorterNext(db, (VdbeCursor const   *)pC___17);
    goto next_tail;
    case 5: 
    case 4: 
    pC___17 = *(p->apCsr + pOp->p1);
    rc = (*(pOp->p4.xAdvance))(pC___17->uc.pCursor, pOp->p3);
    next_tail: 
    pC___17->cacheStatus = (u32 )0;
    if (rc == 0) {
      pC___17->nullRow = (u8 )0;
      (p->aCounter[pOp->p5]) ++;
      goto jump_to_p2_and_check_for_interrupt;
    }
    if (rc != 101) {
      goto abort_due_to_error;
    }
    rc = 0;
    pC___17->nullRow = (u8 )1;
    goto check_for_interrupt;
    case 132: 
    case 131: 
    pC___18 = *(p->apCsr + pOp->p1);
    pIn2 = aMem + pOp->p2;
    if ((int )pOp->p5 & 1) {
      (p->nChange) ++;
    }
    if ((int )pIn2->flags & 16384) {
      tmp___58 = sqlite3VdbeMemExpandBlob(pIn2);
      rc = tmp___58;
    } else {
      rc = 0;
    }
    if (rc) {
      goto abort_due_to_error;
    }
    if ((int )pOp->opcode == 131) {
      rc = sqlite3VdbeSorterWrite((VdbeCursor const   *)pC___18, pIn2);
    } else {
      x___1.nKey = (sqlite_int64 )pIn2->n;
      x___1.pKey = (void const   *)pIn2->z;
      x___1.aMem = aMem + pOp->p3;
      x___1.nMem = (u16 )pOp->p4.i;
      if ((int )pOp->p5 & 16) {
        tmp___59 = pC___18->seekResult;
      } else {
        tmp___59 = 0;
      }
      rc = sqlite3BtreeInsert(pC___18->uc.pCursor, (BtreePayload const   *)(& x___1),
                              (int )pOp->p5 & 10, tmp___59);
      pC___18->cacheStatus = (u32 )0;
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 133: 
    pC___19 = *(p->apCsr + pOp->p1);
    pCrsr___6 = pC___19->uc.pCursor;
    r___1.pKeyInfo = pC___19->pKeyInfo;
    r___1.nField = (u16 )pOp->p3;
    r___1.default_rc = (i8 )0;
    r___1.aMem = aMem + pOp->p2;
    rc = sqlite3BtreeMovetoUnpacked(pCrsr___6, & r___1, (i64 )0, 0, & res___8);
    if (rc) {
      goto abort_due_to_error;
    }
    if (res___8 == 0) {
      rc = sqlite3BtreeDelete(pCrsr___6, (u8 )4);
      if (rc) {
        goto abort_due_to_error;
      }
    }
    pC___19->cacheStatus = (u32 )0;
    pC___19->seekResult = 0;
    break;
    case 135: 
    case 134: 
    pC___20 = *(p->apCsr + pOp->p1);
    rc = sqlite3VdbeCursorRestore(pC___20);
    if (rc != 0) {
      goto abort_due_to_error;
    }
    if (! pC___20->nullRow) {
      rowid = (i64 )0;
      rc = sqlite3VdbeIdxRowid(db, pC___20->uc.pCursor, & rowid);
      if (rc != 0) {
        goto abort_due_to_error;
      }
      if ((int )pOp->opcode == 134) {
        pTabCur = *(p->apCsr + pOp->p3);
        pTabCur->nullRow = (u8 )0;
        pTabCur->movetoTarget = rowid;
        pTabCur->deferredMoveto = (u8 )1;
        pTabCur->aAltMap = pOp->p4.ai;
        pTabCur->pAltCursor = pC___20;
      } else {
        pOut = out2Prerelease(p, pOp);
        pOut->u.i = rowid;
      }
    } else {
      sqlite3VdbeMemSetNull(aMem + pOp->p2);
    }
    break;
    case 40: 
    case 39: 
    case 38: 
    case 37: 
    pC___21 = *(p->apCsr + pOp->p1);
    r___2.pKeyInfo = pC___21->pKeyInfo;
    r___2.nField = (u16 )pOp->p4.i;
    if ((int )pOp->opcode < 39) {
      r___2.default_rc = (i8 )-1;
    } else {
      r___2.default_rc = (i8 )0;
    }
    r___2.aMem = aMem + pOp->p3;
    res___9 = 0;
    rc = sqlite3VdbeIdxKeyCompare(db, pC___21, & r___2, & res___9);
    if (((int )pOp->opcode & 1) == 1) {
      res___9 = - res___9;
    } else {
      res___9 ++;
    }
    if (rc) {
      goto abort_due_to_error;
    }
    if (res___9 > 0) {
      goto jump_to_p2;
    }
    break;
    case 136: 
    pOut = out2Prerelease(p, pOp);
    pOut->flags = (u16 )1;
    if (db->nVdbeRead > db->nVDestroy + 1) {
      rc = 6;
      p->errorAction = (u8 )2;
      goto abort_due_to_error;
    } else {
      iDb___1 = pOp->p3;
      iMoved = 0;
      rc = sqlite3BtreeDropTable((db->aDb + iDb___1)->pBt, pOp->p1, & iMoved);
      pOut->flags = (u16 )4;
      pOut->u.i = (i64 )iMoved;
      if (rc) {
        goto abort_due_to_error;
      }
      if (iMoved != 0) {
        sqlite3RootPageMoved(db, iDb___1, iMoved, pOp->p1);
        resetSchemaOnFault = (u8 )(iDb___1 + 1);
      }
    }
    break;
    case 137: 
    nChange = 0;
    if (pOp->p3) {
      tmp___60 = & nChange;
    } else {
      tmp___60 = (int *)0;
    }
    rc = sqlite3BtreeClearTable((db->aDb + pOp->p2)->pBt, pOp->p1, tmp___60);
    if (pOp->p3) {
      p->nChange += nChange;
      if (pOp->p3 > 0) {
        (aMem + pOp->p3)->u.i += (i64 )nChange;
      }
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 138: 
    pC___22 = *(p->apCsr + pOp->p1);
    if ((int )pC___22->eCurType == 1) {
      sqlite3VdbeSorterReset(db, pC___22->uc.pSorter);
    } else {
      rc = sqlite3BtreeClearTableOfCursor(pC___22->uc.pCursor);
      if (rc) {
        goto abort_due_to_error;
      }
    }
    break;
    case 139: 
    pOut = out2Prerelease(p, pOp);
    pgno = 0;
    pDb___1 = db->aDb + pOp->p1;
    rc = sqlite3BtreeCreateTable(pDb___1->pBt, & pgno, pOp->p3);
    if (rc) {
      goto abort_due_to_error;
    }
    pOut->u.i = (i64 )pgno;
    break;
    case 140: 
    db->nSqlExec = (u8 )((int )db->nSqlExec + 1);
    rc = sqlite3_exec(db, (char const   *)pOp->p4.z, (int (*)(void * , int  , char ** ,
                                                              char ** ))0, (void *)0,
                      (char **)0);
    db->nSqlExec = (u8 )((int )db->nSqlExec - 1);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 141: 
    iDb___2 = pOp->p1;
    if ((unsigned long )pOp->p4.z == (unsigned long )((char *)0)) {
      sqlite3SchemaClear((void *)(db->aDb + iDb___2)->pSchema);
      db->mDbFlags &= 4294967279U;
      rc = sqlite3InitOne(db, iDb___2, & p->zErrMsg, (u32 )1);
      db->mDbFlags |= 1U;
      p->expired = (bft )0;
    } else {
      zMaster = "sqlite_master";
      initData.db = db;
      initData.iDb = iDb___2;
      initData.pzErrMsg = & p->zErrMsg;
      initData.mInitFlags = (u32 )0;
      zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid", (db->aDb + iDb___2)->zDbSName,
                            zMaster, pOp->p4.z);
      if ((unsigned long )zSql == (unsigned long )((char *)0)) {
        rc = 7;
      } else {
        db->init.busy = (u8 )1;
        initData.rc = 0;
        initData.nInitRow = (u32 )0;
        rc = sqlite3_exec(db, (char const   *)zSql, & sqlite3InitCallback, (void *)(& initData),
                          (char **)0);
        if (rc == 0) {
          rc = initData.rc;
        }
        if (rc == 0) {
          if (initData.nInitRow == 0U) {
            rc = sqlite3CorruptError(89918);
          }
        }
        sqlite3DbFreeNN(db, (void *)zSql);
        db->init.busy = (u8 )0;
      }
    }
    if (rc) {
      sqlite3ResetAllSchemasOfConnection(db);
      if (rc == 7) {
        goto no_mem;
      }
      goto abort_due_to_error;
    }
    break;
    case 142: 
    rc = sqlite3AnalysisLoad(db, pOp->p1);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 143: 
    sqlite3UnlinkAndDeleteTable(db, pOp->p1, (char const   *)pOp->p4.z);
    break;
    case 144: 
    sqlite3UnlinkAndDeleteIndex(db, pOp->p1, (char const   *)pOp->p4.z);
    break;
    case 145: 
    sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, (char const   *)pOp->p4.z);
    break;
    case 146: 
    nRoot = pOp->p2;
    aRoot = pOp->p4.ai;
    pnErr = aMem + pOp->p3;
    pIn1 = aMem + pOp->p1;
    z = sqlite3BtreeIntegrityCheck((db->aDb + pOp->p5)->pBt, aRoot + 1, nRoot, (int )pnErr->u.i + 1,
                                   & nErr);
    sqlite3VdbeMemSetNull(pIn1);
    if (! (nErr == 0)) {
      if ((unsigned long )z == (unsigned long )((char *)0)) {
        goto no_mem;
      } else {
        pnErr->u.i -= (i64 )(nErr - 1);
        sqlite3VdbeMemSetStr(pIn1, (char const   *)z, -1, (u8 )1, & sqlite3_free);
      }
    }
    sqlite3VdbeChangeEncoding(pIn1, (int )encoding);
    break;
    case 147: 
    pIn1 = aMem + pOp->p1;
    pIn2 = aMem + pOp->p2;
    if (((int )pIn1->flags & 16) == 0) {
      tmp___61 = sqlite3VdbeMemSetRowSet(pIn1);
      if (tmp___61) {
        goto no_mem;
      }
    }
    sqlite3RowSetInsert((RowSet *)pIn1->z, pIn2->u.i);
    break;
    case 41: 
    pIn1 = aMem + pOp->p1;
    if (((int )pIn1->flags & 16) == 0) {
      sqlite3VdbeMemSetNull(pIn1);
      goto jump_to_p2_and_check_for_interrupt;
    } else {
      tmp___62 = sqlite3RowSetNext((RowSet *)pIn1->z, & val);
      if (tmp___62 == 0) {
        sqlite3VdbeMemSetNull(pIn1);
        goto jump_to_p2_and_check_for_interrupt;
      } else {
        sqlite3VdbeMemSetInt64(aMem + pOp->p3, val);
      }
    }
    goto check_for_interrupt;
    case 42: 
    pIn1 = aMem + pOp->p1;
    pIn3 = aMem + pOp->p3;
    iSet = pOp->p4.i;
    if (((int )pIn1->flags & 16) == 0) {
      tmp___63 = sqlite3VdbeMemSetRowSet(pIn1);
      if (tmp___63) {
        goto no_mem;
      }
    }
    if (iSet) {
      exists = sqlite3RowSetTest((RowSet *)pIn1->z, iSet, pIn3->u.i);
      if (exists) {
        goto jump_to_p2;
      }
    }
    if (iSet >= 0) {
      sqlite3RowSetInsert((RowSet *)pIn1->z, pIn3->u.i);
    }
    break;
    case 45: 
    pProgram = pOp->p4.pProgram;
    pRt = aMem + pOp->p3;
    if (pOp->p5) {
      t___0 = pProgram->token;
      pFrame___1 = p->pFrame;
      while (1) {
        if (pFrame___1) {
          if (! ((unsigned long )pFrame___1->token != (unsigned long )t___0)) {
            break;
          }
        } else {
          break;
        }
        pFrame___1 = pFrame___1->pParent;
      }
      if (pFrame___1) {
        break;
      }
    }
    if (p->nFrame >= db->aLimit[10]) {
      rc = 1;
      sqlite3VdbeError(p, "too many levels of trigger recursion");
      goto abort_due_to_error;
    }
    if (((int )pRt->flags & 16) == 0) {
      nMem = pProgram->nMem + pProgram->nCsr;
      if (pProgram->nCsr == 0) {
        nMem ++;
      }
      nByte___1 = (int )(((((sizeof(VdbeFrame ) + 7UL) & 0xfffffffffffffff8UL) + (unsigned long )nMem * sizeof(Mem )) + (unsigned long )pProgram->nCsr * sizeof(VdbeCursor *)) + (unsigned long )((pProgram->nOp + 7) / 8));
      tmp___64 = sqlite3DbMallocZero(db, (u64 )nByte___1);
      pFrame___1 = (VdbeFrame *)tmp___64;
      if (! pFrame___1) {
        goto no_mem;
      }
      sqlite3VdbeMemRelease(pRt);
      pRt->flags = (u16 )1040;
      pRt->z = (char *)pFrame___1;
      pRt->n = nByte___1;
      pRt->xDel = & sqlite3VdbeFrameMemDel;
      pFrame___1->v = p;
      pFrame___1->nChildMem = nMem;
      pFrame___1->nChildCsr = pProgram->nCsr;
      pFrame___1->pc = (int )(pOp - aOp___1);
      pFrame___1->aMem = p->aMem;
      pFrame___1->nMem = p->nMem;
      pFrame___1->apCsr = p->apCsr;
      pFrame___1->nCursor = p->nCursor;
      pFrame___1->aOp = p->aOp;
      pFrame___1->nOp = p->nOp;
      pFrame___1->token = pProgram->token;
      pEnd = (Mem *)((u8 *)pFrame___1 + ((sizeof(VdbeFrame ) + 7UL) & 0xfffffffffffffff8UL)) + pFrame___1->nChildMem;
      pMem___1 = (Mem *)((u8 *)pFrame___1 + ((sizeof(VdbeFrame ) + 7UL) & 0xfffffffffffffff8UL));
      while ((unsigned long )pMem___1 != (unsigned long )pEnd) {
        pMem___1->flags = (u16 )128;
        pMem___1->db = db;
        pMem___1 ++;
      }
    } else {
      pFrame___1 = (VdbeFrame *)pRt->z;
    }
    (p->nFrame) ++;
    pFrame___1->pParent = p->pFrame;
    pFrame___1->lastRowid = db->lastRowid;
    pFrame___1->nChange = p->nChange;
    pFrame___1->nDbChange = (p->db)->nChange;
    pFrame___1->pAuxData = p->pAuxData;
    p->pAuxData = (AuxData *)0;
    p->nChange = 0;
    p->pFrame = pFrame___1;
    aMem = (Mem *)((u8 *)pFrame___1 + ((sizeof(VdbeFrame ) + 7UL) & 0xfffffffffffffff8UL));
    p->aMem = aMem;
    p->nMem = pFrame___1->nChildMem;
    p->nCursor = (int )((u16 )pFrame___1->nChildCsr);
    p->apCsr = (VdbeCursor **)(aMem + p->nMem);
    pFrame___1->aOnce = (u8 *)(p->apCsr + pProgram->nCsr);
    memset((void *)pFrame___1->aOnce, 0, (size_t )((pProgram->nOp + 7) / 8));
    aOp___1 = pProgram->aOp;
    p->aOp = aOp___1;
    p->nOp = pProgram->nOp;
    pOp = aOp___1 + -1;
    goto check_for_interrupt;
    case 149: 
    pOut = out2Prerelease(p, pOp);
    pFrame___2 = p->pFrame;
    pIn = pFrame___2->aMem + (pOp->p1 + (pFrame___2->aOp + pFrame___2->pc)->p1);
    sqlite3VdbeMemShallowCopy(pOut, (Mem const   *)pIn, 4096);
    break;
    case 150: 
    if (db->flags & 524288ULL) {
      db->nDeferredImmCons += (i64 )pOp->p2;
    } else
    if (pOp->p1) {
      db->nDeferredCons += (i64 )pOp->p2;
    } else {
      p->nFkConstraint += (i64 )pOp->p2;
    }
    break;
    case 46: 
    if (pOp->p1) {
      if (db->nDeferredCons == 0LL) {
        if (db->nDeferredImmCons == 0LL) {
          goto jump_to_p2;
        }
      }
    } else
    if (p->nFkConstraint == 0LL) {
      if (db->nDeferredImmCons == 0LL) {
        goto jump_to_p2;
      }
    }
    break;
    case 151: 
    if (p->pFrame) {
      pFrame___3 = p->pFrame;
      while (pFrame___3->pParent) {
        pFrame___3 = pFrame___3->pParent;
      }
      pIn1 = pFrame___3->aMem + pOp->p1;
    } else {
      pIn1 = aMem + pOp->p1;
    }
    sqlite3VdbeMemIntegerify(pIn1);
    pIn2 = aMem + pOp->p2;
    sqlite3VdbeMemIntegerify(pIn2);
    if (pIn1->u.i < pIn2->u.i) {
      pIn1->u.i = pIn2->u.i;
    }
    break;
    case 47: 
    pIn1 = aMem + pOp->p1;
    if (pIn1->u.i > 0LL) {
      pIn1->u.i -= (i64 )pOp->p3;
      goto jump_to_p2;
    }
    break;
    case 152: 
    pIn1 = aMem + pOp->p1;
    pIn3 = aMem + pOp->p3;
    pOut = out2Prerelease(p, pOp);
    x___2 = pIn1->u.i;
    if (x___2 <= 0LL) {
      pOut->u.i = (i64 )-1;
    } else {
      if (pIn3->u.i > 0LL) {
        tmp___65 = pIn3->u.i;
      } else {
        tmp___65 = (i64 )0;
      }
      tmp___66 = sqlite3AddInt64(& x___2, tmp___65);
      if (tmp___66) {
        pOut->u.i = (i64 )-1;
      } else {
        pOut->u.i = x___2;
      }
    }
    break;
    case 48: 
    pIn1 = aMem + pOp->p1;
    if (pIn1->u.i) {
      if (pIn1->u.i > 0LL) {
        (pIn1->u.i) --;
      }
      goto jump_to_p2;
    }
    break;
    case 49: 
    pIn1 = aMem + pOp->p1;
    if (pIn1->u.i > -1LL - (4294967295LL | (2147483647LL << 32))) {
      (pIn1->u.i) --;
    }
    if (pIn1->u.i == 0LL) {
      goto jump_to_p2;
    }
    break;
    case 154: 
    case 153: 
    n___3 = (int )pOp->p5;
    tmp___67 = sqlite3DbMallocRawNN(db, (u64 )((unsigned long )n___3 * sizeof(sqlite3_value *) + ((sizeof(*(pCtx + 0)) + sizeof(Mem )) - sizeof(sqlite3_value *))));
    pCtx = (sqlite3_context *)tmp___67;
    if ((unsigned long )pCtx == (unsigned long )((sqlite3_context *)0)) {
      goto no_mem;
    }
    pCtx->pMem = (Mem *)0;
    pCtx->pOut = (Mem *)(& pCtx->argv[n___3]);
    sqlite3VdbeMemInit(pCtx->pOut, db, (u16 )1);
    pCtx->pFunc = pOp->p4.pFunc;
    pCtx->iOp = (int )(pOp - aOp___1);
    pCtx->pVdbe = p;
    pCtx->skipFlag = (u8 )0;
    pCtx->isError = 0;
    pCtx->argc = (u8 )n___3;
    pOp->p4type = (signed char)-16;
    pOp->p4.pCtx = pCtx;
    pOp->opcode = (u8 )155;
    case 155: 
    pCtx___0 = pOp->p4.pCtx;
    pMem___2 = aMem + pOp->p3;
    if ((unsigned long )pCtx___0->pMem != (unsigned long )pMem___2) {
      pCtx___0->pMem = pMem___2;
      i___3 = (int )pCtx___0->argc - 1;
      while (i___3 >= 0) {
        pCtx___0->argv[i___3] = aMem + (pOp->p2 + i___3);
        i___3 --;
      }
    }
    (pMem___2->n) ++;
    if (pOp->p1) {
      (*((pCtx___0->pFunc)->xInverse))(pCtx___0, (int )pCtx___0->argc, pCtx___0->argv);
    } else {
      (*((pCtx___0->pFunc)->xSFunc))(pCtx___0, (int )pCtx___0->argc, pCtx___0->argv);
    }
    if (pCtx___0->isError) {
      if (pCtx___0->isError > 0) {
        tmp___68 = sqlite3_value_text(pCtx___0->pOut);
        sqlite3VdbeError(p, "%s", tmp___68);
        rc = pCtx___0->isError;
      }
      if (pCtx___0->skipFlag) {
        i___3 = (pOp + -1)->p1;
        if (i___3) {
          sqlite3VdbeMemSetInt64(aMem + i___3, (i64 )1);
        }
        pCtx___0->skipFlag = (u8 )0;
      }
      sqlite3VdbeMemRelease(pCtx___0->pOut);
      (pCtx___0->pOut)->flags = (u16 )1;
      pCtx___0->isError = 0;
      if (rc) {
        goto abort_due_to_error;
      }
    }
    break;
    case 157: 
    case 156: 
    pMem___3 = aMem + pOp->p1;
    if (pOp->p3) {
      rc = sqlite3VdbeMemAggValue(pMem___3, aMem + pOp->p3, pOp->p4.pFunc);
      pMem___3 = aMem + pOp->p3;
    } else {
      rc = sqlite3VdbeMemFinalize(pMem___3, pOp->p4.pFunc);
    }
    if (rc) {
      tmp___69 = sqlite3_value_text(pMem___3);
      sqlite3VdbeError(p, "%s", tmp___69);
      goto abort_due_to_error;
    }
    sqlite3VdbeChangeEncoding(pMem___3, (int )encoding);
    tmp___70 = sqlite3VdbeMemTooBig(pMem___3);
    if (tmp___70) {
      goto too_big;
    }
    break;
    case 6: 
    aRes[0] = 0;
    aRes[2] = -1;
    aRes[1] = aRes[2];
    rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, & aRes[1], & aRes[2]);
    if (rc) {
      if (rc != 5) {
        goto abort_due_to_error;
      }
      rc = 0;
      aRes[0] = 1;
    }
    i___4 = 0;
    pMem___4 = aMem + pOp->p3;
    while (i___4 < 3) {
      sqlite3VdbeMemSetInt64(pMem___4, (i64 )aRes[i___4]);
      i___4 ++;
      pMem___4 ++;
    }
    break;
    case 7: 
    pOut = out2Prerelease(p, pOp);
    eNew = pOp->p3;
    pBt___0 = (db->aDb + pOp->p1)->pBt;
    pPager = sqlite3BtreePager(pBt___0);
    eOld = sqlite3PagerGetJournalMode(pPager);
    if (eNew == -1) {
      eNew = eOld;
    }
    tmp___71 = sqlite3PagerOkToChangeJournalMode(pPager);
    if (! tmp___71) {
      eNew = eOld;
    }
    zFilename = sqlite3PagerFilename(pPager, 1);
    if (eNew == 5) {
      tmp___72 = sqlite3Strlen30(zFilename);
      if (tmp___72 == 0) {
        eNew = eOld;
      } else {
        tmp___73 = sqlite3PagerWalSupported(pPager);
        if (! tmp___73) {
          eNew = eOld;
        }
      }
    }
    if (eNew != eOld) {
      if (eOld == 5) {
        goto _L___13;
      } else
      if (eNew == 5) {
        _L___13: /* CIL Label */ 
        if (! db->autoCommit) {
          goto _L___12;
        } else
        if (db->nVdbeRead > 1) {
          _L___12: /* CIL Label */ 
          rc = 1;
          if (eNew == 5) {
            tmp___74 = "into";
          } else {
            tmp___74 = "out of";
          }
          sqlite3VdbeError(p, "cannot change %s wal mode from within a transaction",
                           tmp___74);
          goto abort_due_to_error;
        } else {
          if (eOld == 5) {
            rc = sqlite3PagerCloseWal(pPager, db);
            if (rc == 0) {
              sqlite3PagerSetJournalMode(pPager, eNew);
            }
          } else
          if (eOld == 4) {
            sqlite3PagerSetJournalMode(pPager, 2);
          }
          if (rc == 0) {
            if (eNew == 5) {
              tmp___75 = 2;
            } else {
              tmp___75 = 1;
            }
            rc = sqlite3BtreeSetVersion(pBt___0, tmp___75);
          }
        }
      }
    }
    if (rc) {
      eNew = eOld;
    }
    eNew = sqlite3PagerSetJournalMode(pPager, eNew);
    pOut->flags = (u16 )2562;
    tmp___76 = sqlite3JournalModename(eNew);
    pOut->z = (char *)tmp___76;
    pOut->n = sqlite3Strlen30((char const   *)pOut->z);
    pOut->enc = (u8 )1;
    sqlite3VdbeChangeEncoding(pOut, (int )encoding);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 8: 
    if (pOp->p2) {
      tmp___77 = aMem + pOp->p2;
    } else {
      tmp___77 = (Mem *)0;
    }
    rc = sqlite3RunVacuum(& p->zErrMsg, db, pOp->p1, tmp___77);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 59: 
    pBt___1 = (db->aDb + pOp->p1)->pBt;
    rc = sqlite3BtreeIncrVacuum(pBt___1);
    if (rc) {
      if (rc != 101) {
        goto abort_due_to_error;
      }
      rc = 0;
      goto jump_to_p2;
    }
    break;
    case 158: 
    if (! pOp->p1) {
      sqlite3ExpirePreparedStatements(db, pOp->p2);
    } else {
      p->expired = (bft )(pOp->p2 + 1);
    }
    break;
    case 159: 
    isWriteLock = (u8 )pOp->p3;
    if (isWriteLock) {
      goto _L___14;
    } else
    if (0ULL == (db->flags & 1024ULL)) {
      _L___14: /* CIL Label */ 
      p1___2 = pOp->p1;
      rc = sqlite3BtreeLockTable((db->aDb + p1___2)->pBt, pOp->p2, isWriteLock);
      if (rc) {
        if ((rc & 255) == 6) {
          z___0 = (char const   *)pOp->p4.z;
          sqlite3VdbeError(p, "database table is locked: %s", z___0);
        }
        goto abort_due_to_error;
      }
    }
    break;
    case 160: 
    pVTab = pOp->p4.pVtab;
    rc = sqlite3VtabBegin(db, pVTab);
    if (pVTab) {
      sqlite3VtabImportErrmsg(p, pVTab->pVtab);
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 161: 
    memset((void *)(& sMem___0), 0, sizeof(sMem___0));
    sMem___0.db = db;
    rc = sqlite3VdbeMemCopy(& sMem___0, (Mem const   *)(aMem + pOp->p2));
    tmp___78 = sqlite3_value_text(& sMem___0);
    zTab = (char const   *)tmp___78;
    if (zTab) {
      rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, & p->zErrMsg);
    }
    sqlite3VdbeMemRelease(& sMem___0);
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 162: 
    (db->nVDestroy) ++;
    rc = sqlite3VtabCallDestroy(db, pOp->p1, (char const   *)pOp->p4.z);
    (db->nVDestroy) --;
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 163: 
    pCur___0 = (VdbeCursor *)0;
    pVCur = (sqlite3_vtab_cursor *)0;
    pVtab___0 = (pOp->p4.pVtab)->pVtab;
    if ((unsigned long )pVtab___0 == (unsigned long )((sqlite3_vtab *)0)) {
      rc = 6;
      goto abort_due_to_error;
    } else
    if ((unsigned long )pVtab___0->pModule == (unsigned long )((sqlite3_module const   *)0)) {
      rc = 6;
      goto abort_due_to_error;
    }
    pModule___0 = pVtab___0->pModule;
    rc = (*(pModule___0->xOpen))(pVtab___0, & pVCur);
    sqlite3VtabImportErrmsg(p, pVtab___0);
    if (rc) {
      goto abort_due_to_error;
    }
    pVCur->pVtab = pVtab___0;
    pCur___0 = allocateCursor(p, pOp->p1, 0, -1, (u8 )2);
    if (pCur___0) {
      pCur___0->uc.pVCur = pVCur;
      (pVtab___0->nRef) ++;
    } else {
      (*(pModule___0->xClose))(pVCur);
      goto no_mem;
    }
    break;
    case 9: 
    pQuery = aMem + pOp->p3;
    pArgc = pQuery + 1;
    pCur___1 = *(p->apCsr + pOp->p1);
    pVCur___0 = pCur___1->uc.pVCur;
    pVtab___1 = pVCur___0->pVtab;
    pModule___1 = pVtab___1->pModule;
    nArg = (int )pArgc->u.i;
    iQuery = (int )pQuery->u.i;
    res___10 = 0;
    apArg = p->apArg;
    i___5 = 0;
    while (i___5 < nArg) {
      *(apArg + i___5) = pArgc + (i___5 + 1);
      i___5 ++;
    }
    rc = (*(pModule___1->xFilter))(pVCur___0, iQuery, (char const   *)pOp->p4.z, nArg,
                                   apArg);
    sqlite3VtabImportErrmsg(p, pVtab___1);
    if (rc) {
      goto abort_due_to_error;
    }
    res___10 = (*(pModule___1->xEof))(pVCur___0);
    pCur___1->nullRow = (u8 )0;
    if (res___10) {
      goto jump_to_p2;
    }
    break;
    case 164: 
    pCur___2 = *(p->apCsr + pOp->p1);
    pDest___0 = aMem + pOp->p3;
    if (pCur___2->nullRow) {
      sqlite3VdbeMemSetNull(pDest___0);
      break;
    }
    pVtab___2 = (pCur___2->uc.pVCur)->pVtab;
    pModule___2 = pVtab___2->pModule;
    memset((void *)(& sContext), 0, sizeof(sContext));
    sContext.pOut = pDest___0;
    if ((int )pOp->p5 & 1) {
      sqlite3VdbeMemSetNull(pDest___0);
      pDest___0->flags = (u16 )16385;
      pDest___0->u.nZero = 0;
    } else {
      pDest___0->flags = (u16 )(((int )pDest___0->flags & -49600) | 1);
    }
    rc = (*(pModule___2->xColumn))(pCur___2->uc.pVCur, & sContext, pOp->p2);
    sqlite3VtabImportErrmsg(p, pVtab___2);
    if (sContext.isError > 0) {
      tmp___79 = sqlite3_value_text(pDest___0);
      sqlite3VdbeError(p, "%s", tmp___79);
      rc = sContext.isError;
    }
    sqlite3VdbeChangeEncoding(pDest___0, (int )encoding);
    tmp___80 = sqlite3VdbeMemTooBig(pDest___0);
    if (tmp___80) {
      goto too_big;
    }
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 60: 
    res___11 = 0;
    pCur___3 = *(p->apCsr + pOp->p1);
    if (pCur___3->nullRow) {
      break;
    }
    pVtab___3 = (pCur___3->uc.pVCur)->pVtab;
    pModule___3 = pVtab___3->pModule;
    rc = (*(pModule___3->xNext))(pCur___3->uc.pVCur);
    sqlite3VtabImportErrmsg(p, pVtab___3);
    if (rc) {
      goto abort_due_to_error;
    }
    res___11 = (*(pModule___3->xEof))(pCur___3->uc.pVCur);
    if (! res___11) {
      goto jump_to_p2_and_check_for_interrupt;
    }
    goto check_for_interrupt;
    case 165: 
    isLegacy = (int )(db->flags & 67108864ULL);
    db->flags |= 67108864ULL;
    pVtab___4 = (pOp->p4.pVtab)->pVtab;
    pName = aMem + pOp->p1;
    rc = sqlite3VdbeChangeEncoding(pName, 1);
    if (rc) {
      goto abort_due_to_error;
    }
    rc = (*((pVtab___4->pModule)->xRename))(pVtab___4, (char const   *)pName->z);
    if (isLegacy == 0) {
      db->flags &= 0xfffffffffbffffffULL;
    }
    sqlite3VtabImportErrmsg(p, pVtab___4);
    p->expired = (bft )0;
    if (rc) {
      goto abort_due_to_error;
    }
    break;
    case 10: 
    if (db->mallocFailed) {
      goto no_mem;
    }
    pVtab___5 = (pOp->p4.pVtab)->pVtab;
    if ((unsigned long )pVtab___5 == (unsigned long )((sqlite3_vtab *)0)) {
      rc = 6;
      goto abort_due_to_error;
    } else
    if ((unsigned long )pVtab___5->pModule == (unsigned long )((sqlite3_module const   *)0)) {
      rc = 6;
      goto abort_due_to_error;
    }
    pModule___4 = pVtab___5->pModule;
    nArg___0 = pOp->p2;
    if (pModule___4->xUpdate) {
      vtabOnConflict = db->vtabOnConflict;
      apArg___0 = p->apArg;
      pX___0 = aMem + pOp->p3;
      i___6 = 0;
      while (i___6 < nArg___0) {
        *(apArg___0 + i___6) = pX___0;
        pX___0 ++;
        i___6 ++;
      }
      db->vtabOnConflict = (u8 )pOp->p5;
      rc = (*(pModule___4->xUpdate))(pVtab___5, nArg___0, apArg___0, & rowid___0);
      db->vtabOnConflict = vtabOnConflict;
      sqlite3VtabImportErrmsg(p, pVtab___5);
      if (rc == 0) {
        if (pOp->p1) {
          db->lastRowid = rowid___0;
        }
      }
      if ((rc & 255) == 19) {
        if ((pOp->p4.pVtab)->bConstraint) {
          if ((int )pOp->p5 == 4) {
            rc = 0;
          } else
          if ((int )pOp->p5 == 5) {
            p->errorAction = (u8 )2;
          } else {
            p->errorAction = (u8 )pOp->p5;
          }
        } else {
          (p->nChange) ++;
        }
      } else {
        (p->nChange) ++;
      }
      if (rc) {
        goto abort_due_to_error;
      }
    }
    break;
    case 166: 
    pOut = out2Prerelease(p, pOp);
    tmp___81 = sqlite3BtreeLastPage((db->aDb + pOp->p1)->pBt);
    pOut->u.i = (i64 )tmp___81;
    break;
    case 167: 
    pOut = out2Prerelease(p, pOp);
    pBt___2 = (db->aDb + pOp->p1)->pBt;
    newMax = 0U;
    if (pOp->p3) {
      newMax = sqlite3BtreeLastPage(pBt___2);
      if (newMax < (unsigned int )pOp->p3) {
        newMax = (unsigned int )pOp->p3;
      }
    }
    tmp___82 = sqlite3BtreeMaxPageCount(pBt___2, (int )newMax);
    pOut->u.i = (i64 )tmp___82;
    break;
    case 63: 
    case 62: 
    n___4 = (int )pOp->p5;
    tmp___83 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(*pCtx___1) + (unsigned long )(n___4 - 1) * sizeof(sqlite3_value *)));
    pCtx___1 = (sqlite3_context *)tmp___83;
    if ((unsigned long )pCtx___1 == (unsigned long )((sqlite3_context *)0)) {
      goto no_mem;
    }
    pCtx___1->pOut = (Mem *)0;
    pCtx___1->pFunc = pOp->p4.pFunc;
    pCtx___1->iOp = (int )(pOp - aOp___1);
    pCtx___1->pVdbe = p;
    pCtx___1->isError = 0;
    pCtx___1->argc = (u8 )n___4;
    pOp->p4type = (signed char)-16;
    pOp->p4.pCtx = pCtx___1;
    pOp->opcode = (u8 )((int )pOp->opcode + 2);
    case 65: 
    case 64: 
    pCtx___2 = pOp->p4.pCtx;
    pOut = aMem + pOp->p3;
    if ((unsigned long )pCtx___2->pOut != (unsigned long )pOut) {
      pCtx___2->pOut = pOut;
      i___7 = (int )pCtx___2->argc - 1;
      while (i___7 >= 0) {
        pCtx___2->argv[i___7] = aMem + (pOp->p2 + i___7);
        i___7 --;
      }
    }
    pOut->flags = (u16 )(((int )pOut->flags & -49600) | 1);
    (*((pCtx___2->pFunc)->xSFunc))(pCtx___2, (int )pCtx___2->argc, pCtx___2->argv);
    if (pCtx___2->isError) {
      if (pCtx___2->isError > 0) {
        tmp___84 = sqlite3_value_text(pOut);
        sqlite3VdbeError(p, "%s", tmp___84);
        rc = pCtx___2->isError;
      }
      sqlite3VdbeDeleteAuxData(db, & p->pAuxData, pCtx___2->iOp, pOp->p1);
      pCtx___2->isError = 0;
      if (rc) {
        goto abort_due_to_error;
      }
    }
    if ((int )pOut->flags & 18) {
      sqlite3VdbeChangeEncoding(pOut, (int )encoding);
      tmp___85 = sqlite3VdbeMemTooBig(pOut);
      if (tmp___85) {
        goto too_big;
      }
    }
    break;
    case 61: 
    case 168: 
    if (((int )db->mTrace & 65) != 0) {
      if (! p->doingRerun) {
        if (pOp->p4.z) {
          zTrace = pOp->p4.z;
        } else {
          zTrace = p->zSql;
        }
        if ((unsigned long )zTrace != (unsigned long )((char *)0)) {
          if ((int )db->mTrace & 64) {
            x___3 = (void (*)(void * , char const   * ))db->xTrace;
            tmp___86 = sqlite3VdbeExpandSql(p, (char const   *)zTrace);
            z___1 = tmp___86;
            (*x___3)(db->pTraceArg, (char const   *)z___1);
            sqlite3_free((void *)z___1);
          } else
          if (db->nVdbeExec > 1) {
            tmp___87 = sqlite3MPrintf(db, "-- %s", zTrace);
            z___2 = tmp___87;
            (*(db->xTrace))((u32 )1, db->pTraceArg, (void *)p, (void *)z___2);
            sqlite3DbFree(db, (void *)z___2);
          } else {
            (*(db->xTrace))((u32 )1, db->pTraceArg, (void *)p, (void *)zTrace);
          }
        }
      }
    }
    if (pOp->p1 >= sqlite3Config.iOnceResetThreshold) {
      if ((int )pOp->opcode == 168) {
        break;
      }
      i___8 = 1;
      while (i___8 < p->nOp) {
        if ((int )(p->aOp + i___8)->opcode == 17) {
          (p->aOp + i___8)->p1 = 0;
        }
        i___8 ++;
      }
      pOp->p1 = 0;
    }
    (pOp->p1) ++;
    (p->aCounter[6]) ++;
    goto jump_to_p2;
    default: 
    break;
    }
    pOp ++;
  }
  abort_due_to_error: 
  if (db->mallocFailed) {
    rc = 7;
  }
  if ((unsigned long )p->zErrMsg == (unsigned long )((char *)0)) {
    if (rc != (10 | (12 << 8))) {
      tmp___88 = sqlite3ErrStr(rc);
      sqlite3VdbeError(p, "%s", tmp___88);
    }
  }
  p->rc = rc;
  sqlite3SystemError(db, rc);
  sqlite3_log(rc, "statement aborts at %d: [%s] %s", (int )(pOp - aOp___1), p->zSql,
              p->zErrMsg);
  sqlite3VdbeHalt(p);
  if (rc == (10 | (12 << 8))) {
    sqlite3OomFault(db);
  }
  rc = 1;
  if ((int )resetSchemaOnFault > 0) {
    sqlite3ResetOneSchema(db, (int )resetSchemaOnFault - 1);
  }
  vdbe_return: 
  while (1) {
    if (nVmStep >= nProgressLimit) {
      if (! ((unsigned long )db->xProgress != (unsigned long )((int (*)(void * ))0))) {
        break;
      }
    } else {
      break;
    }
    nProgressLimit += db->nProgressOps;
    tmp___89 = (*(db->xProgress))(db->pProgressArg);
    if (tmp___89) {
      nProgressLimit = 4294967295U;
      rc = 9;
      goto abort_due_to_error;
    }
  }
  p->aCounter[4] += (u32 )((int )nVmStep);
  return (rc);
  too_big: 
  sqlite3VdbeError(p, "string or blob too big");
  rc = 18;
  goto abort_due_to_error;
  no_mem: 
  sqlite3OomFault(db);
  sqlite3VdbeError(p, "out of memory");
  rc = 7;
  goto abort_due_to_error;
  abort_due_to_interrupt: ;
  if (db->mallocFailed) {
    rc = 7;
  } else {
    rc = 9;
  }
  p->rc = rc;
  tmp___90 = sqlite3ErrStr(rc);
  sqlite3VdbeError(p, "%s", tmp___90);
  goto abort_due_to_error;
}
}
static int blobSeekToRow(Incrblob *p , sqlite_int64 iRow , char **pzErr ) 
{ 
  int rc ;
  char *zErr ;
  Vdbe *v ;
  VdbeCursor *pC ;
  u32 type ;
  u32 tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u32 tmp___2 ;
  char const   *tmp___3 ;

  {
  zErr = (char *)0;
  v = (Vdbe *)p->pStmt;
  (v->aMem + 1)->flags = (u16 )4;
  (v->aMem + 1)->u.i = iRow;
  if (v->pc > 4) {
    v->pc = 4;
    rc = sqlite3VdbeExec(v);
  } else {
    rc = sqlite3_step(p->pStmt);
  }
  if (rc == 100) {
    pC = *(v->apCsr + 0);
    if ((int )pC->nHdrParsed > (int )p->iCol) {
      tmp = pC->aType[p->iCol];
    } else {
      tmp = (u32 )0;
    }
    type = tmp;
    if (type < 12U) {
      if (type == 0U) {
        tmp___1 = "null";
      } else {
        if (type == 7U) {
          tmp___0 = "real";
        } else {
          tmp___0 = "integer";
        }
        tmp___1 = tmp___0;
      }
      zErr = sqlite3MPrintf(p->db, "cannot open value of type %s", tmp___1);
      rc = 1;
      sqlite3_finalize(p->pStmt);
      p->pStmt = (sqlite3_stmt *)0;
    } else {
      p->iOffset = (int )pC->aType[(int )p->iCol + (int )pC->nField];
      tmp___2 = sqlite3VdbeSerialTypeLen(type);
      p->nByte = (int )tmp___2;
      p->pCsr = pC->uc.pCursor;
      sqlite3BtreeIncrblobCursor(p->pCsr);
    }
  }
  if (rc == 100) {
    rc = 0;
  } else
  if (p->pStmt) {
    rc = sqlite3_finalize(p->pStmt);
    p->pStmt = (sqlite3_stmt *)0;
    if (rc == 0) {
      zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);
      rc = 1;
    } else {
      tmp___3 = sqlite3_errmsg(p->db);
      zErr = sqlite3MPrintf(p->db, "%s", tmp___3);
    }
  }
  *pzErr = zErr;
  return (rc);
}
}
static int const   iLn  =    (int const   )0;
static VdbeOpList const   openBlob[6]  = {      {(u8 )159, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )97, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )31, (signed char)0, (signed char)5, (signed char)1}, 
        {(u8 )90, (signed char)0, (signed char)0, (signed char)1}, 
        {(u8 )81, (signed char)1, (signed char)0, (signed char)0}, 
        {(u8 )69, (signed char)0, (signed char)0, (signed char)0}};
int sqlite3_blob_open(sqlite3 *db , char const   *zDb , char const   *zTable , char const   *zColumn ,
                      long long iRow , int wrFlag , sqlite3_blob **ppBlob ) 
{ 
  int nAttempt ;
  int iCol ;
  int rc ;
  char *zErr ;
  Table *pTab ;
  Incrblob *pBlob ;
  Parse sParse ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *zFault ;
  Index *pIdx ;
  FKey *pFKey ;
  int j ;
  int j___0 ;
  Vdbe *tmp___2 ;
  Vdbe *v ;
  int iDb ;
  int tmp___3 ;
  VdbeOp *aOp___1 ;
  char const   *tmp___4 ;

  {
  nAttempt = 0;
  rc = 0;
  zErr = (char *)0;
  pBlob = (Incrblob *)0;
  *ppBlob = (sqlite3_blob *)0;
  wrFlag = ! (! wrFlag);
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(Incrblob ));
  pBlob = (Incrblob *)tmp;
  while (1) {
    memset((void *)(& sParse), 0, sizeof(Parse ));
    if (! pBlob) {
      goto blob_open_out;
    }
    sParse.db = db;
    sqlite3DbFree(db, (void *)zErr);
    zErr = (char *)0;
    sqlite3BtreeEnterAll(db);
    pTab = sqlite3LocateTable(& sParse, (u32 )0, zTable, zDb);
    if (pTab) {
      if (pTab->nModuleArg) {
        pTab = (Table *)0;
        sqlite3ErrorMsg(& sParse, "cannot open virtual table: %s", zTable);
      }
    }
    if (pTab) {
      if (! ((pTab->tabFlags & 32U) == 0U)) {
        pTab = (Table *)0;
        sqlite3ErrorMsg(& sParse, "cannot open table without rowid: %s", zTable);
      }
    }
    if (pTab) {
      if (pTab->pSelect) {
        pTab = (Table *)0;
        sqlite3ErrorMsg(& sParse, "cannot open view: %s", zTable);
      }
    }
    if (! pTab) {
      if (sParse.zErrMsg) {
        sqlite3DbFree(db, (void *)zErr);
        zErr = sParse.zErrMsg;
        sParse.zErrMsg = (char *)0;
      }
      rc = 1;
      goto blob_open_out;
    }
    pBlob->pTab = pTab;
    tmp___0 = sqlite3SchemaToIndex(db, pTab->pSchema);
    pBlob->zDb = (db->aDb + tmp___0)->zDbSName;
    iCol = 0;
    while (iCol < (int )pTab->nCol) {
      tmp___1 = sqlite3StrICmp((char const   *)(pTab->aCol + iCol)->zName, zColumn);
      if (tmp___1 == 0) {
        break;
      }
      iCol ++;
    }
    if (iCol == (int )pTab->nCol) {
      sqlite3DbFree(db, (void *)zErr);
      zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
      rc = 1;
      goto blob_open_out;
    }
    if (wrFlag) {
      zFault = (char const   *)0;
      if (db->flags & 16384ULL) {
        pFKey = pTab->pFKey;
        while (pFKey) {
          j = 0;
          while (j < pFKey->nCol) {
            if (pFKey->aCol[j].iFrom == iCol) {
              zFault = "foreign key";
            }
            j ++;
          }
          pFKey = pFKey->pNextFrom;
        }
      }
      pIdx = pTab->pIndex;
      while (pIdx) {
        j___0 = 0;
        while (j___0 < (int )pIdx->nKeyCol) {
          if ((int )*(pIdx->aiColumn + j___0) == iCol) {
            zFault = "indexed";
          } else
          if ((int )*(pIdx->aiColumn + j___0) == -2) {
            zFault = "indexed";
          }
          j___0 ++;
        }
        pIdx = pIdx->pNext;
      }
      if (zFault) {
        sqlite3DbFree(db, (void *)zErr);
        zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
        rc = 1;
        goto blob_open_out;
      }
    }
    tmp___2 = sqlite3VdbeCreate(& sParse);
    pBlob->pStmt = (sqlite3_stmt *)tmp___2;
    if (pBlob->pStmt) {
      v = (Vdbe *)pBlob->pStmt;
      tmp___3 = sqlite3SchemaToIndex(db, pTab->pSchema);
      iDb = tmp___3;
      sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag, (pTab->pSchema)->schema_cookie, (pTab->pSchema)->iGeneration);
      sqlite3VdbeChangeP5(v, (u16 )1);
      aOp___1 = sqlite3VdbeAddOpList(v, (int )(sizeof(openBlob) / sizeof(openBlob[0])),
                                     openBlob, (int )iLn);
      sqlite3VdbeUsesBtree(v, iDb);
      if ((int )db->mallocFailed == 0) {
        (aOp___1 + 0)->p1 = iDb;
        (aOp___1 + 0)->p2 = pTab->tnum;
        (aOp___1 + 0)->p3 = wrFlag;
        sqlite3VdbeChangeP4(v, 2, (char const   *)pTab->zName, 0);
      }
      if ((int )db->mallocFailed == 0) {
        if (wrFlag) {
          (aOp___1 + 1)->opcode = (u8 )98;
        }
        (aOp___1 + 1)->p2 = pTab->tnum;
        (aOp___1 + 1)->p3 = iDb;
        (aOp___1 + 1)->p4type = (signed char)-3;
        (aOp___1 + 1)->p4.i = (int )pTab->nCol + 1;
        (aOp___1 + 3)->p2 = (int )pTab->nCol;
        sParse.nVar = (ynVar )0;
        sParse.nMem = 1;
        sParse.nTab = 1;
        sqlite3VdbeMakeReady(v, & sParse);
      }
    }
    pBlob->iCol = (u16 )iCol;
    pBlob->db = db;
    if (db->mallocFailed) {
      goto blob_open_out;
    }
    rc = blobSeekToRow(pBlob, iRow, & zErr);
    nAttempt ++;
    if (nAttempt < 50) {
      if (! (rc == 17)) {
        break;
      }
    } else {
      break;
    }
  }
  blob_open_out: 
  if (rc == 0) {
    if ((int )db->mallocFailed == 0) {
      *ppBlob = (sqlite3_blob *)pBlob;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (pBlob) {
      if (pBlob->pStmt) {
        sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);
      }
    }
    sqlite3DbFree(db, (void *)pBlob);
  }
  if (zErr) {
    tmp___4 = "%s";
  } else {
    tmp___4 = (char const   *)0;
  }
  sqlite3ErrorWithMsg(db, rc, tmp___4, zErr);
  sqlite3DbFree(db, (void *)zErr);
  sqlite3ParserReset(& sParse);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_blob_close(sqlite3_blob *pBlob ) 
{ 
  Incrblob *p ;
  int rc ;
  sqlite3 *db ;
  sqlite3_stmt *pStmt ;

  {
  p = (Incrblob *)pBlob;
  if (p) {
    pStmt = p->pStmt;
    db = p->db;
    sqlite3DbFree(db, (void *)p);
    rc = sqlite3_finalize(pStmt);
  } else {
    rc = 0;
  }
  return (rc);
}
}
static int blobReadWrite(sqlite3_blob *pBlob , void *z , int n , int iOffset___0 ,
                         int (*xCall)(BtCursor * , u32  , u32  , void * ) ) 
{ 
  int rc ;
  Incrblob *p ;
  Vdbe *v ;
  sqlite3 *db ;
  int tmp ;

  {
  p = (Incrblob *)pBlob;
  if ((unsigned long )p == (unsigned long )((Incrblob *)0)) {
    tmp = sqlite3MisuseError(92136);
    return (tmp);
  }
  db = p->db;
  v = (Vdbe *)p->pStmt;
  if (n < 0) {
    rc = 1;
  } else
  if (iOffset___0 < 0) {
    rc = 1;
  } else
  if ((sqlite_int64 )iOffset___0 + (sqlite_int64 )n > (sqlite_int64 )p->nByte) {
    rc = 1;
  } else
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    rc = 4;
  } else {
    sqlite3BtreeEnterCursor(p->pCsr);
    rc = (*xCall)(p->pCsr, (u32 )(iOffset___0 + p->iOffset), (u32 )n, z);
    if (rc == 4) {
      sqlite3VdbeFinalize(v);
      p->pStmt = (sqlite3_stmt *)0;
    } else {
      v->rc = rc;
    }
  }
  sqlite3Error(db, rc);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_blob_read(sqlite3_blob *pBlob , void *z , int n , int iOffset___0 ) 
{ 
  int tmp ;

  {
  tmp = blobReadWrite(pBlob, z, n, iOffset___0, & sqlite3BtreePayloadChecked);
  return (tmp);
}
}
int sqlite3_blob_write(sqlite3_blob *pBlob , void const   *z , int n , int iOffset___0 ) 
{ 
  int tmp ;

  {
  tmp = blobReadWrite(pBlob, (void *)z, n, iOffset___0, & sqlite3BtreePutData);
  return (tmp);
}
}
int sqlite3_blob_bytes(sqlite3_blob *pBlob ) 
{ 
  Incrblob *p ;
  int tmp ;

  {
  p = (Incrblob *)pBlob;
  if (p) {
    if (p->pStmt) {
      tmp = p->nByte;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int sqlite3_blob_reopen(sqlite3_blob *pBlob , sqlite_int64 iRow ) 
{ 
  int rc ;
  Incrblob *p ;
  sqlite3 *db ;
  int tmp ;
  char *zErr ;
  char const   *tmp___0 ;

  {
  p = (Incrblob *)pBlob;
  if ((unsigned long )p == (unsigned long )((Incrblob *)0)) {
    tmp = sqlite3MisuseError(92234);
    return (tmp);
  }
  db = p->db;
  if ((unsigned long )p->pStmt == (unsigned long )((sqlite3_stmt *)0)) {
    rc = 4;
  } else {
    rc = blobSeekToRow(p, iRow, & zErr);
    if (rc != 0) {
      if (zErr) {
        tmp___0 = "%s";
      } else {
        tmp___0 = (char const   *)0;
      }
      sqlite3ErrorWithMsg(db, rc, tmp___0, zErr);
      sqlite3DbFree(db, (void *)zErr);
    }
  }
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
static int vdbeIncrSwap(IncrMerger *pIncr ) ;
static void vdbeIncrFree(IncrMerger *pIncr ) ;
static void vdbePmaReaderClear(PmaReader *pReadr ) 
{ 


  {
  sqlite3_free((void *)pReadr->aAlloc);
  sqlite3_free((void *)pReadr->aBuffer);
  if (pReadr->aMap) {
    sqlite3OsUnfetch(pReadr->pFd, (i64 )0, (void *)pReadr->aMap);
  }
  vdbeIncrFree(pReadr->pIncr);
  memset((void *)pReadr, 0, sizeof(PmaReader ));
  return;
}
}
static int vdbePmaReadBlob(PmaReader *p , int nByte , u8 **ppOut ) 
{ 
  int iBuf ;
  int nAvail ;
  int nRead ;
  int rc ;
  int nRem ;
  u8 *aNew ;
  sqlite_int64 nNew ;
  sqlite_int64 tmp ;
  void *tmp___0 ;
  int rc___0 ;
  int nCopy ;
  u8 *aNext ;

  {
  if (p->aMap) {
    *ppOut = p->aMap + p->iReadOff;
    p->iReadOff += (i64 )nByte;
    return (0);
  }
  iBuf = (int )(p->iReadOff % (long long )p->nBuffer);
  if (iBuf == 0) {
    if (p->iEof - p->iReadOff > (i64 )p->nBuffer) {
      nRead = p->nBuffer;
    } else {
      nRead = (int )(p->iEof - p->iReadOff);
    }
    rc = sqlite3OsRead(p->pFd, (void *)p->aBuffer, nRead, p->iReadOff);
    if (rc != 0) {
      return (rc);
    }
  }
  nAvail = p->nBuffer - iBuf;
  if (nByte <= nAvail) {
    *ppOut = p->aBuffer + iBuf;
    p->iReadOff += (i64 )nByte;
  } else {
    if (p->nAlloc < nByte) {
      if (128LL > 2LL * (sqlite_int64 )p->nAlloc) {
        tmp = (sqlite_int64 )128;
      } else {
        tmp = 2LL * (sqlite_int64 )p->nAlloc;
      }
      nNew = tmp;
      while ((sqlite_int64 )nByte > nNew) {
        nNew *= 2LL;
      }
      tmp___0 = sqlite3Realloc((void *)p->aAlloc, (u64 )nNew);
      aNew = (u8 *)tmp___0;
      if (! aNew) {
        return (7);
      }
      p->nAlloc = (int )nNew;
      p->aAlloc = aNew;
    }
    memcpy((void * __restrict  )p->aAlloc, (void const   * __restrict  )(p->aBuffer + iBuf),
           (size_t )nAvail);
    p->iReadOff += (i64 )nAvail;
    nRem = nByte - nAvail;
    while (nRem > 0) {
      nCopy = nRem;
      if (nRem > p->nBuffer) {
        nCopy = p->nBuffer;
      }
      rc___0 = vdbePmaReadBlob(p, nCopy, & aNext);
      if (rc___0 != 0) {
        return (rc___0);
      }
      memcpy((void * __restrict  )(p->aAlloc + (nByte - nRem)), (void const   * __restrict  )aNext,
             (size_t )nCopy);
      nRem -= nCopy;
    }
    *ppOut = p->aAlloc;
  }
  return (0);
}
}
static int vdbePmaReadVarint(PmaReader *p , u64 *pnOut ) 
{ 
  int iBuf ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 aVarint[16] ;
  u8 *a___0 ;
  int i ;
  int rc ;
  int tmp___1 ;

  {
  if (p->aMap) {
    tmp = sqlite3GetVarint((unsigned char const   *)(p->aMap + p->iReadOff), pnOut);
    p->iReadOff += (i64 )tmp;
  } else {
    iBuf = (int )(p->iReadOff % (long long )p->nBuffer);
    if (iBuf) {
      if (p->nBuffer - iBuf >= 9) {
        tmp___0 = sqlite3GetVarint((unsigned char const   *)(p->aBuffer + iBuf), pnOut);
        p->iReadOff += (i64 )tmp___0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      i = 0;
      while (1) {
        rc = vdbePmaReadBlob(p, 1, & a___0);
        if (rc) {
          return (rc);
        }
        tmp___1 = i;
        i ++;
        aVarint[tmp___1 & 15] = *(a___0 + 0);
        if (! (((int )*(a___0 + 0) & 128) != 0)) {
          break;
        }
      }
      sqlite3GetVarint((unsigned char const   *)(aVarint), pnOut);
    }
  }
  return (0);
}
}
static int vdbeSorterMapFile(SortSubtask *pTask , SorterFile *pFile , u8 **pp ) 
{ 
  int rc ;
  sqlite3_file *pFd ;

  {
  rc = 0;
  if (pFile->iEof <= (i64 )((pTask->pSorter)->db)->nMaxSorterMmap) {
    pFd = pFile->pFd;
    if ((pFd->pMethods)->iVersion >= 3) {
      rc = sqlite3OsFetch(pFd, (i64 )0, (int )pFile->iEof, (void **)pp);
    }
  }
  return (rc);
}
}
static int vdbePmaReaderSeek(SortSubtask *pTask , PmaReader *pReadr , SorterFile *pFile ,
                             i64 iOff ) 
{ 
  int rc ;
  int tmp ;
  int pgsz___0 ;
  int iBuf ;
  void *tmp___0 ;
  int nRead ;

  {
  rc = 0;
  tmp = sqlite3FaultSim(201);
  if (tmp) {
    return (10 | (1 << 8));
  }
  if (pReadr->aMap) {
    sqlite3OsUnfetch(pReadr->pFd, (i64 )0, (void *)pReadr->aMap);
    pReadr->aMap = (u8 *)0;
  }
  pReadr->iReadOff = iOff;
  pReadr->iEof = pFile->iEof;
  pReadr->pFd = pFile->pFd;
  rc = vdbeSorterMapFile(pTask, pFile, & pReadr->aMap);
  if (rc == 0) {
    if ((unsigned long )pReadr->aMap == (unsigned long )((u8 *)0)) {
      pgsz___0 = (pTask->pSorter)->pgsz;
      iBuf = (int )(pReadr->iReadOff % (long long )pgsz___0);
      if ((unsigned long )pReadr->aBuffer == (unsigned long )((u8 *)0)) {
        tmp___0 = sqlite3Malloc((u64 )pgsz___0);
        pReadr->aBuffer = (u8 *)tmp___0;
        if ((unsigned long )pReadr->aBuffer == (unsigned long )((u8 *)0)) {
          rc = 7;
        }
        pReadr->nBuffer = pgsz___0;
      }
      if (rc == 0) {
        if (iBuf) {
          nRead = pgsz___0 - iBuf;
          if (pReadr->iReadOff + (i64 )nRead > pReadr->iEof) {
            nRead = (int )(pReadr->iEof - pReadr->iReadOff);
          }
          rc = sqlite3OsRead(pReadr->pFd, (void *)(pReadr->aBuffer + iBuf), nRead,
                             pReadr->iReadOff);
        }
      }
    }
  }
  return (rc);
}
}
static int vdbePmaReaderNext(PmaReader *pReadr ) 
{ 
  int rc ;
  u64 nRec ;
  IncrMerger *pIncr ;
  int bEof ;

  {
  rc = 0;
  nRec = (u64 )0;
  if (pReadr->iReadOff >= pReadr->iEof) {
    pIncr = pReadr->pIncr;
    bEof = 1;
    if (pIncr) {
      rc = vdbeIncrSwap(pIncr);
      if (rc == 0) {
        if (pIncr->bEof == 0) {
          rc = vdbePmaReaderSeek(pIncr->pTask, pReadr, & pIncr->aFile[0], pIncr->iStartOff);
          bEof = 0;
        }
      }
    }
    if (bEof) {
      vdbePmaReaderClear(pReadr);
      return (rc);
    }
  }
  if (rc == 0) {
    rc = vdbePmaReadVarint(pReadr, & nRec);
  }
  if (rc == 0) {
    pReadr->nKey = (int )nRec;
    rc = vdbePmaReadBlob(pReadr, (int )nRec, & pReadr->aKey);
  }
  return (rc);
}
}
static int vdbePmaReaderInit(SortSubtask *pTask , SorterFile *pFile , i64 iStart ,
                             PmaReader *pReadr , i64 *pnByte ) 
{ 
  int rc ;
  u64 nByte ;

  {
  rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);
  if (rc == 0) {
    nByte = (u64 )0;
    rc = vdbePmaReadVarint(pReadr, & nByte);
    pReadr->iEof = (i64 )((u64 )pReadr->iReadOff + nByte);
    *pnByte = (i64 )((u64 )*pnByte + nByte);
  }
  if (rc == 0) {
    rc = vdbePmaReaderNext(pReadr);
  }
  return (rc);
}
}
static int vdbeSorterCompareTail(SortSubtask *pTask , int *pbKey2Cached , void const   *pKey1 ,
                                 int nKey1 , void const   *pKey2 , int nKey2 ) 
{ 
  UnpackedRecord *r2 ;
  int tmp ;

  {
  r2 = pTask->pUnpacked;
  if (*pbKey2Cached == 0) {
    sqlite3VdbeRecordUnpack((pTask->pSorter)->pKeyInfo, nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  tmp = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);
  return (tmp);
}
}
static int vdbeSorterCompare(SortSubtask *pTask , int *pbKey2Cached , void const   *pKey1 ,
                             int nKey1 , void const   *pKey2 , int nKey2 ) 
{ 
  UnpackedRecord *r2 ;
  int tmp ;

  {
  r2 = pTask->pUnpacked;
  if (! *pbKey2Cached) {
    sqlite3VdbeRecordUnpack((pTask->pSorter)->pKeyInfo, nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  tmp = sqlite3VdbeRecordCompare(nKey1, pKey1, r2);
  return (tmp);
}
}
static int vdbeSorterCompareText(SortSubtask *pTask , int *pbKey2Cached , void const   *pKey1 ,
                                 int nKey1 , void const   *pKey2 , int nKey2 ) 
{ 
  u8 const   *p1 ;
  u8 const   *p2 ;
  u8 const   *v1 ;
  u8 const   *v2 ;
  int n1 ;
  int n2 ;
  int res ;
  int tmp ;

  {
  p1 = (u8 const   *)((u8 const   * const  )pKey1);
  p2 = (u8 const   *)((u8 const   * const  )pKey2);
  v1 = p1 + *(p1 + 0);
  v2 = p2 + *(p2 + 0);
  if ((int const   )*(p1 + 1) < 128) {
    n1 = (int )((u32 )*(p1 + 1));
  } else {
    sqlite3GetVarint32(p1 + 1, (u32 *)(& n1));
  }
  if ((int const   )*(p2 + 1) < 128) {
    n2 = (int )((u32 )*(p2 + 1));
  } else {
    sqlite3GetVarint32(p2 + 1, (u32 *)(& n2));
  }
  if (n1 < n2) {
    tmp = n1;
  } else {
    tmp = n2;
  }
  res = memcmp((void const   *)v1, (void const   *)v2, (size_t )((tmp - 13) / 2));
  if (res == 0) {
    res = n1 - n2;
  }
  if (res == 0) {
    if ((int )((pTask->pSorter)->pKeyInfo)->nKeyField > 1) {
      res = vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2);
    }
  } else
  if (*(((pTask->pSorter)->pKeyInfo)->aSortFlags + 0)) {
    res *= -1;
  }
  return (res);
}
}
static int vdbeSorterCompareInt(SortSubtask *pTask , int *pbKey2Cached , void const   *pKey1 ,
                                int nKey1 , void const   *pKey2 , int nKey2 ) ;
static u8 const   aLen[10]  = 
  {      (u8 const   )0,      (u8 const   )1,      (u8 const   )2,      (u8 const   )3, 
        (u8 const   )4,      (u8 const   )6,      (u8 const   )8,      (u8 const   )0, 
        (u8 const   )0,      (u8 const   )0};
static int vdbeSorterCompareInt(SortSubtask *pTask , int *pbKey2Cached , void const   *pKey1 ,
                                int nKey1 , void const   *pKey2 , int nKey2 ) 
{ 
  u8 const   *p1 ;
  u8 const   *p2 ;
  int s1 ;
  int s2 ;
  u8 const   *v1 ;
  u8 const   *v2 ;
  int res ;
  u8 n ;
  int i ;

  {
  p1 = (u8 const   *)((u8 const   * const  )pKey1);
  p2 = (u8 const   *)((u8 const   * const  )pKey2);
  s1 = (int )*(p1 + 1);
  s2 = (int )*(p2 + 1);
  v1 = p1 + *(p1 + 0);
  v2 = p2 + *(p2 + 0);
  if (s1 == s2) {
    n = (u8 )aLen[s1];
    res = 0;
    i = 0;
    while (i < (int )n) {
      res = (int )((int const   )*(v1 + i) - (int const   )*(v2 + i));
      if (res != 0) {
        if ((((int const   )*(v1 + 0) ^ (int const   )*(v2 + 0)) & 128) != 0) {
          if ((int const   )*(v1 + 0) & 128) {
            res = -1;
          } else {
            res = 1;
          }
        }
        break;
      }
      i ++;
    }
  } else
  if (s1 > 7) {
    if (s2 > 7) {
      res = s1 - s2;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (s2 > 7) {
      res = 1;
    } else
    if (s1 > 7) {
      res = -1;
    } else {
      res = s1 - s2;
    }
    if (res > 0) {
      if ((int const   )*v1 & 128) {
        res = -1;
      }
    } else
    if ((int const   )*v2 & 128) {
      res = 1;
    }
  }
  if (res == 0) {
    if ((int )((pTask->pSorter)->pKeyInfo)->nKeyField > 1) {
      res = vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2);
    }
  } else
  if (*(((pTask->pSorter)->pKeyInfo)->aSortFlags + 0)) {
    res *= -1;
  }
  return (res);
}
}
static int sqlite3VdbeSorterInit(sqlite3 *db , int nField , VdbeCursor *pCsr ) 
{ 
  int pgsz___0 ;
  int i ;
  VdbeSorter *pSorter ;
  KeyInfo *pKeyInfo ;
  int szKeyInfo ;
  int sz ;
  int rc ;
  void *tmp ;
  SortSubtask *pTask ;
  i64 mxCache ;
  u32 szPma ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  rc = 0;
  szKeyInfo = (int )(sizeof(KeyInfo ) + (unsigned long )((int )(pCsr->pKeyInfo)->nKeyField - 1) * sizeof(CollSeq *));
  sz = (int )sizeof(VdbeSorter );
  tmp = sqlite3DbMallocZero(db, (u64 )(sz + szKeyInfo));
  pSorter = (VdbeSorter *)tmp;
  pCsr->uc.pSorter = pSorter;
  if ((unsigned long )pSorter == (unsigned long )((VdbeSorter *)0)) {
    rc = 7;
  } else {
    pKeyInfo = (KeyInfo *)((u8 *)pSorter + sz);
    pSorter->pKeyInfo = pKeyInfo;
    memcpy((void * __restrict  )pKeyInfo, (void const   * __restrict  )pCsr->pKeyInfo,
           (size_t )szKeyInfo);
    pKeyInfo->db = (sqlite3 *)0;
    if (nField) {
      pKeyInfo->nKeyField = (u16 )nField;
    }
    pgsz___0 = sqlite3BtreeGetPageSize((db->aDb + 0)->pBt);
    pSorter->pgsz = pgsz___0;
    pSorter->nTask = (u8 )1;
    pSorter->iPrev = (u8 )-1;
    pSorter->bUseThreads = (u8 )((int )pSorter->nTask > 1);
    pSorter->db = db;
    i = 0;
    while (i < (int )pSorter->nTask) {
      pTask = & pSorter->aTask[i];
      pTask->pSorter = pSorter;
      i ++;
    }
    tmp___1 = sqlite3TempInMemory((sqlite3 const   *)db);
    if (! tmp___1) {
      szPma = sqlite3Config.szPma;
      pSorter->mnPmaSize = (int )(szPma * (u32 )pgsz___0);
      mxCache = (i64 )((db->aDb + 0)->pSchema)->cache_size;
      if (mxCache < 0LL) {
        mxCache *= -1024LL;
      } else {
        mxCache *= (i64 )pgsz___0;
      }
      if (mxCache < (i64 )(1 << 29)) {
        mxCache = mxCache;
      } else {
        mxCache = (i64 )(1 << 29);
      }
      if (pSorter->mnPmaSize > (int )mxCache) {
        pSorter->mxPmaSize = pSorter->mnPmaSize;
      } else {
        pSorter->mxPmaSize = (int )mxCache;
      }
      if ((int )sqlite3Config.bSmallMalloc == 0) {
        pSorter->nMemory = pgsz___0;
        tmp___0 = sqlite3Malloc((u64 )pgsz___0);
        pSorter->list.aMemory = (u8 *)tmp___0;
        if (! pSorter->list.aMemory) {
          rc = 7;
        }
      }
    }
    if ((int )pKeyInfo->nAllField < 13) {
      if ((unsigned long )pKeyInfo->aColl[0] == (unsigned long )((CollSeq *)0)) {
        goto _L;
      } else
      if ((unsigned long )pKeyInfo->aColl[0] == (unsigned long )db->pDfltColl) {
        _L: /* CIL Label */ 
        if (((int )*(pKeyInfo->aSortFlags + 0) & 2) == 0) {
          pSorter->typeMask = (u8 )3;
        }
      }
    }
  }
  return (rc);
}
}
static void vdbeSorterRecordFree(sqlite3 *db , SorterRecord *pRecord ) 
{ 
  SorterRecord *p ;
  SorterRecord *pNext ;

  {
  p = pRecord;
  while (p) {
    pNext = p->u.pNext;
    sqlite3DbFree(db, (void *)p);
    p = pNext;
  }
  return;
}
}
static void vdbeSortSubtaskCleanup(sqlite3 *db , SortSubtask *pTask ) 
{ 


  {
  sqlite3DbFree(db, (void *)pTask->pUnpacked);
  vdbeSorterRecordFree((sqlite3 *)0, pTask->list.pList);
  if (pTask->file.pFd) {
    sqlite3OsCloseFree(pTask->file.pFd);
  }
  if (pTask->file2.pFd) {
    sqlite3OsCloseFree(pTask->file2.pFd);
  }
  memset((void *)pTask, 0, sizeof(SortSubtask ));
  return;
}
}
static MergeEngine *vdbeMergeEngineNew(int nReader ) 
{ 
  int N ;
  int nByte ;
  MergeEngine *pNew ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  N = 2;
  while (N < nReader) {
    N += N;
  }
  nByte = (int )(sizeof(MergeEngine ) + (unsigned long )N * (sizeof(int ) + sizeof(PmaReader )));
  tmp___1 = sqlite3FaultSim(100);
  if (tmp___1) {
    pNew = (MergeEngine *)0;
  } else {
    tmp___0 = sqlite3MallocZero((u64 )nByte);
    pNew = (MergeEngine *)tmp___0;
  }
  if (pNew) {
    pNew->nTree = N;
    pNew->pTask = (SortSubtask *)0;
    pNew->aReadr = (PmaReader *)(pNew + 1);
    pNew->aTree = (int *)(pNew->aReadr + N);
  }
  return (pNew);
}
}
static void vdbeMergeEngineFree(MergeEngine *pMerger ) 
{ 
  int i ;

  {
  if (pMerger) {
    i = 0;
    while (i < pMerger->nTree) {
      vdbePmaReaderClear(pMerger->aReadr + i);
      i ++;
    }
  }
  sqlite3_free((void *)pMerger);
  return;
}
}
static void vdbeIncrFree(IncrMerger *pIncr ) 
{ 


  {
  if (pIncr) {
    vdbeMergeEngineFree(pIncr->pMerger);
    sqlite3_free((void *)pIncr);
  }
  return;
}
}
static void sqlite3VdbeSorterReset(sqlite3 *db , VdbeSorter *pSorter ) 
{ 
  int i ;
  SortSubtask *pTask ;

  {
  vdbeMergeEngineFree(pSorter->pMerger);
  pSorter->pMerger = (MergeEngine *)0;
  i = 0;
  while (i < (int )pSorter->nTask) {
    pTask = & pSorter->aTask[i];
    vdbeSortSubtaskCleanup(db, pTask);
    pTask->pSorter = pSorter;
    i ++;
  }
  if ((unsigned long )pSorter->list.aMemory == (unsigned long )((u8 *)0)) {
    vdbeSorterRecordFree((sqlite3 *)0, pSorter->list.pList);
  }
  pSorter->list.pList = (SorterRecord *)0;
  pSorter->list.szPMA = 0;
  pSorter->bUsePMA = (u8 )0;
  pSorter->iMemory = 0;
  pSorter->mxKeysize = 0;
  sqlite3DbFree(db, (void *)pSorter->pUnpacked);
  pSorter->pUnpacked = (UnpackedRecord *)0;
  return;
}
}
static void sqlite3VdbeSorterClose(sqlite3 *db , VdbeCursor *pCsr ) 
{ 
  VdbeSorter *pSorter ;

  {
  pSorter = pCsr->uc.pSorter;
  if (pSorter) {
    sqlite3VdbeSorterReset(db, pSorter);
    sqlite3_free((void *)pSorter->list.aMemory);
    sqlite3DbFree(db, (void *)pSorter);
    pCsr->uc.pSorter = (VdbeSorter *)0;
  }
  return;
}
}
static void vdbeSorterExtendFile(sqlite3 *db , sqlite3_file *pFd , i64 nByte ) 
{ 
  void *p ;
  int chunksize ;

  {
  if (nByte <= (i64 )db->nMaxSorterMmap) {
    if ((pFd->pMethods)->iVersion >= 3) {
      p = (void *)0;
      chunksize = 4096;
      sqlite3OsFileControlHint(pFd, 6, (void *)(& chunksize));
      sqlite3OsFileControlHint(pFd, 5, (void *)(& nByte));
      sqlite3OsFetch(pFd, (i64 )0, (int )nByte, & p);
      sqlite3OsUnfetch(pFd, (i64 )0, p);
    }
  }
  return;
}
}
static int vdbeSorterOpenTempFile(sqlite3 *db , i64 nExtend , sqlite3_file **ppFd ) 
{ 
  int rc ;
  int tmp ;
  i64 max ;

  {
  tmp = sqlite3FaultSim(202);
  if (tmp) {
    return (10 | (13 << 8));
  }
  rc = sqlite3OsOpenMalloc(db->pVfs, (char const   *)0, ppFd, 4126, & rc);
  if (rc == 0) {
    max = (i64 )2147418112;
    sqlite3OsFileControlHint(*ppFd, 18, (void *)(& max));
    if (nExtend > 0LL) {
      vdbeSorterExtendFile(db, *ppFd, nExtend);
    }
  }
  return (rc);
}
}
static int vdbeSortAllocUnpacked(SortSubtask *pTask ) 
{ 


  {
  if ((unsigned long )pTask->pUnpacked == (unsigned long )((UnpackedRecord *)0)) {
    pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord((pTask->pSorter)->pKeyInfo);
    if ((unsigned long )pTask->pUnpacked == (unsigned long )((UnpackedRecord *)0)) {
      return (7);
    }
    (pTask->pUnpacked)->nField = ((pTask->pSorter)->pKeyInfo)->nKeyField;
    (pTask->pUnpacked)->errCode = (u8 )0;
  }
  return (0);
}
}
static SorterRecord *vdbeSorterMerge(SortSubtask *pTask , SorterRecord *p1 , SorterRecord *p2 ) 
{ 
  SorterRecord *pFinal ;
  SorterRecord **pp ;
  int bCached ;
  int res ;

  {
  pFinal = (SorterRecord *)0;
  pp = & pFinal;
  bCached = 0;
  while (1) {
    res = (*(pTask->xCompare))(pTask, & bCached, (void const   *)((void *)(p1 + 1)),
                               p1->nVal, (void const   *)((void *)(p2 + 1)), p2->nVal);
    if (res <= 0) {
      *pp = p1;
      pp = & p1->u.pNext;
      p1 = p1->u.pNext;
      if ((unsigned long )p1 == (unsigned long )((SorterRecord *)0)) {
        *pp = p2;
        break;
      }
    } else {
      *pp = p2;
      pp = & p2->u.pNext;
      p2 = p2->u.pNext;
      bCached = 0;
      if ((unsigned long )p2 == (unsigned long )((SorterRecord *)0)) {
        *pp = p1;
        break;
      }
    }
  }
  return (pFinal);
}
}
static SorterCompare vdbeSorterGetCompare(VdbeSorter *p ) 
{ 


  {
  if ((int )p->typeMask == 1) {
    return (& vdbeSorterCompareInt);
  } else
  if ((int )p->typeMask == 2) {
    return (& vdbeSorterCompareText);
  }
  return (& vdbeSorterCompare);
}
}
static int vdbeSorterSort(SortSubtask *pTask , SorterList *pList ) 
{ 
  int i ;
  SorterRecord **aSlot ;
  SorterRecord *p ;
  int rc ;
  void *tmp ;
  SorterRecord *pNext ;
  SorterRecord *tmp___0 ;

  {
  rc = vdbeSortAllocUnpacked(pTask);
  if (rc != 0) {
    return (rc);
  }
  p = pList->pList;
  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);
  tmp = sqlite3MallocZero((u64 )(64UL * sizeof(SorterRecord *)));
  aSlot = (SorterRecord **)tmp;
  if (! aSlot) {
    return (7);
  }
  while (p) {
    if (pList->aMemory) {
      if ((unsigned long )((u8 *)p) == (unsigned long )pList->aMemory) {
        pNext = (SorterRecord *)0;
      } else {
        pNext = (SorterRecord *)(pList->aMemory + p->u.iNext);
      }
    } else {
      pNext = p->u.pNext;
    }
    p->u.pNext = (SorterRecord *)0;
    i = 0;
    while (*(aSlot + i)) {
      p = vdbeSorterMerge(pTask, p, *(aSlot + i));
      *(aSlot + i) = (SorterRecord *)0;
      i ++;
    }
    *(aSlot + i) = p;
    p = pNext;
  }
  p = (SorterRecord *)0;
  i = 0;
  while (i < 64) {
    if ((unsigned long )*(aSlot + i) == (unsigned long )((SorterRecord *)0)) {
      goto __Cont;
    }
    if (p) {
      tmp___0 = vdbeSorterMerge(pTask, p, *(aSlot + i));
      p = tmp___0;
    } else {
      p = *(aSlot + i);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  pList->pList = p;
  sqlite3_free((void *)aSlot);
  return ((int )(pTask->pUnpacked)->errCode);
}
}
static void vdbePmaWriterInit(sqlite3_file *pFd , PmaWriter *p , int nBuf , i64 iStart ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  memset((void *)p, 0, sizeof(PmaWriter ));
  tmp = sqlite3Malloc((u64 )nBuf);
  p->aBuffer = (u8 *)tmp;
  if (! p->aBuffer) {
    p->eFWErr = 7;
  } else {
    tmp___0 = (int )(iStart % (long long )nBuf);
    p->iBufStart = tmp___0;
    p->iBufEnd = tmp___0;
    p->iWriteOff = iStart - (i64 )p->iBufStart;
    p->nBuffer = nBuf;
    p->pFd = pFd;
  }
  return;
}
}
static void vdbePmaWriteBlob(PmaWriter *p , u8 *pData , int nData ) 
{ 
  int nRem ;
  int nCopy ;
  int tmp ;

  {
  nRem = nData;
  while (1) {
    if (nRem > 0) {
      if (! (p->eFWErr == 0)) {
        break;
      }
    } else {
      break;
    }
    nCopy = nRem;
    if (nCopy > p->nBuffer - p->iBufEnd) {
      nCopy = p->nBuffer - p->iBufEnd;
    }
    memcpy((void * __restrict  )(p->aBuffer + p->iBufEnd), (void const   * __restrict  )(pData + (nData - nRem)),
           (size_t )nCopy);
    p->iBufEnd += nCopy;
    if (p->iBufEnd == p->nBuffer) {
      p->eFWErr = sqlite3OsWrite(p->pFd, (void const   *)(p->aBuffer + p->iBufStart),
                                 p->iBufEnd - p->iBufStart, p->iWriteOff + (i64 )p->iBufStart);
      tmp = 0;
      p->iBufEnd = tmp;
      p->iBufStart = tmp;
      p->iWriteOff += (i64 )p->nBuffer;
    }
    nRem -= nCopy;
  }
  return;
}
}
static int vdbePmaWriterFinish(PmaWriter *p , i64 *piEof ) 
{ 
  int rc ;

  {
  if (p->eFWErr == 0) {
    if (p->aBuffer) {
      if (p->iBufEnd > p->iBufStart) {
        p->eFWErr = sqlite3OsWrite(p->pFd, (void const   *)(p->aBuffer + p->iBufStart),
                                   p->iBufEnd - p->iBufStart, p->iWriteOff + (i64 )p->iBufStart);
      }
    }
  }
  *piEof = p->iWriteOff + (i64 )p->iBufEnd;
  sqlite3_free((void *)p->aBuffer);
  rc = p->eFWErr;
  memset((void *)p, 0, sizeof(PmaWriter ));
  return (rc);
}
}
static void vdbePmaWriteVarint(PmaWriter *p , u64 iVal ) 
{ 
  int nByte ;
  u8 aByte[10] ;

  {
  nByte = sqlite3PutVarint(aByte, iVal);
  vdbePmaWriteBlob(p, aByte, nByte);
  return;
}
}
static int vdbeSorterListToPMA(SortSubtask *pTask , SorterList *pList ) 
{ 
  sqlite3 *db ;
  int rc ;
  PmaWriter writer ;
  SorterRecord *p ;
  SorterRecord *pNext ;

  {
  db = (pTask->pSorter)->db;
  rc = 0;
  memset((void *)(& writer), 0, sizeof(PmaWriter ));
  if ((unsigned long )pTask->file.pFd == (unsigned long )((sqlite3_file *)0)) {
    rc = vdbeSorterOpenTempFile(db, (i64 )0, & pTask->file.pFd);
  }
  if (rc == 0) {
    vdbeSorterExtendFile(db, pTask->file.pFd, (pTask->file.iEof + (i64 )pList->szPMA) + 9LL);
  }
  if (rc == 0) {
    rc = vdbeSorterSort(pTask, pList);
  }
  if (rc == 0) {
    pNext = (SorterRecord *)0;
    vdbePmaWriterInit(pTask->file.pFd, & writer, (pTask->pSorter)->pgsz, pTask->file.iEof);
    (pTask->nPMA) ++;
    vdbePmaWriteVarint(& writer, (u64 )pList->szPMA);
    p = pList->pList;
    while (p) {
      pNext = p->u.pNext;
      vdbePmaWriteVarint(& writer, (u64 )p->nVal);
      vdbePmaWriteBlob(& writer, (u8 *)((void *)(p + 1)), p->nVal);
      if ((unsigned long )pList->aMemory == (unsigned long )((u8 *)0)) {
        sqlite3_free((void *)p);
      }
      p = pNext;
    }
    pList->pList = p;
    rc = vdbePmaWriterFinish(& writer, & pTask->file.iEof);
  }
  return (rc);
}
}
static int vdbeMergeEngineStep(MergeEngine *pMerger , int *pbEof ) 
{ 
  int rc ;
  int iPrev ;
  SortSubtask *pTask ;
  int i ;
  PmaReader *pReadr1 ;
  PmaReader *pReadr2 ;
  int bCached ;
  int iRes ;
  int tmp ;

  {
  iPrev = *(pMerger->aTree + 1);
  pTask = pMerger->pTask;
  rc = vdbePmaReaderNext(pMerger->aReadr + iPrev);
  if (rc == 0) {
    bCached = 0;
    pReadr1 = pMerger->aReadr + (iPrev & 65534);
    pReadr2 = pMerger->aReadr + (iPrev | 1);
    i = (pMerger->nTree + iPrev) / 2;
    while (i > 0) {
      if ((unsigned long )pReadr1->pFd == (unsigned long )((sqlite3_file *)0)) {
        iRes = 1;
      } else
      if ((unsigned long )pReadr2->pFd == (unsigned long )((sqlite3_file *)0)) {
        iRes = -1;
      } else {
        iRes = (*(pTask->xCompare))(pTask, & bCached, (void const   *)pReadr1->aKey,
                                    pReadr1->nKey, (void const   *)pReadr2->aKey,
                                    pReadr2->nKey);
      }
      if (iRes < 0) {
        *(pMerger->aTree + i) = (int )(pReadr1 - pMerger->aReadr);
        pReadr2 = pMerger->aReadr + *(pMerger->aTree + (i ^ 1));
        bCached = 0;
      } else
      if (iRes == 0) {
        if ((unsigned long )pReadr1 < (unsigned long )pReadr2) {
          *(pMerger->aTree + i) = (int )(pReadr1 - pMerger->aReadr);
          pReadr2 = pMerger->aReadr + *(pMerger->aTree + (i ^ 1));
          bCached = 0;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if (pReadr1->pFd) {
          bCached = 0;
        }
        *(pMerger->aTree + i) = (int )(pReadr2 - pMerger->aReadr);
        pReadr1 = pMerger->aReadr + *(pMerger->aTree + (i ^ 1));
      }
      i /= 2;
    }
    *pbEof = (unsigned long )(pMerger->aReadr + *(pMerger->aTree + 1))->pFd == (unsigned long )((sqlite3_file *)0);
  }
  if (rc == 0) {
    tmp = (int )(pTask->pUnpacked)->errCode;
  } else {
    tmp = rc;
  }
  return (tmp);
}
}
static int vdbeSorterFlushPMA(VdbeSorter *pSorter ) 
{ 
  int tmp ;

  {
  pSorter->bUsePMA = (u8 )1;
  tmp = vdbeSorterListToPMA(& pSorter->aTask[0], & pSorter->list);
  return (tmp);
}
}
static int sqlite3VdbeSorterWrite(VdbeCursor const   *pCsr , Mem *pVal ) 
{ 
  VdbeSorter *pSorter ;
  int rc ;
  SorterRecord *pNew ;
  int bFlush ;
  int nReq ;
  int nPMA ;
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int nMin ;
  u8 *aNew ;
  sqlite_int64 nNew ;
  int iListOff ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  rc = 0;
  pSorter = (VdbeSorter *)pCsr->uc.pSorter;
  if ((int const   )*((u8 const   *)(pVal->z + 1)) < 128) {
    t = (int )((u32 )*((u8 const   *)(pVal->z + 1)));
  } else {
    sqlite3GetVarint32((u8 const   *)(pVal->z + 1), (u32 *)(& t));
  }
  if (t > 0) {
    if (t < 10) {
      if (t != 7) {
        pSorter->typeMask = (u8 )((int )pSorter->typeMask & 1);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (t > 10) {
    if (t & 1) {
      pSorter->typeMask = (u8 )((int )pSorter->typeMask & 2);
    } else {
      pSorter->typeMask = (u8 )0;
    }
  } else {
    pSorter->typeMask = (u8 )0;
  }
  nReq = (int )((unsigned long )pVal->n + sizeof(SorterRecord ));
  tmp = sqlite3VarintLen((u64 )pVal->n);
  nPMA = pVal->n + tmp;
  if (pSorter->mxPmaSize) {
    if (pSorter->list.aMemory) {
      if (pSorter->iMemory) {
        if (pSorter->iMemory + nReq > pSorter->mxPmaSize) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      bFlush = tmp___0;
    } else {
      if (pSorter->list.szPMA > pSorter->mxPmaSize) {
        tmp___2 = 1;
      } else
      if (pSorter->list.szPMA > pSorter->mnPmaSize) {
        tmp___1 = sqlite3HeapNearlyFull();
        if (tmp___1) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      bFlush = tmp___2;
    }
    if (bFlush) {
      rc = vdbeSorterFlushPMA(pSorter);
      pSorter->list.szPMA = 0;
      pSorter->iMemory = 0;
    }
  }
  pSorter->list.szPMA += nPMA;
  if (nPMA > pSorter->mxKeysize) {
    pSorter->mxKeysize = nPMA;
  }
  if (pSorter->list.aMemory) {
    nMin = pSorter->iMemory + nReq;
    if (nMin > pSorter->nMemory) {
      nNew = 2LL * (sqlite_int64 )pSorter->nMemory;
      iListOff = -1;
      if (pSorter->list.pList) {
        iListOff = (int )((u8 *)pSorter->list.pList - pSorter->list.aMemory);
      }
      while (nNew < (sqlite_int64 )nMin) {
        nNew *= 2LL;
      }
      if (nNew > (sqlite_int64 )pSorter->mxPmaSize) {
        nNew = (sqlite_int64 )pSorter->mxPmaSize;
      }
      if (nNew < (sqlite_int64 )nMin) {
        nNew = (sqlite_int64 )nMin;
      }
      tmp___3 = sqlite3Realloc((void *)pSorter->list.aMemory, (u64 )nNew);
      aNew = (u8 *)tmp___3;
      if (! aNew) {
        return (7);
      }
      if (iListOff >= 0) {
        pSorter->list.pList = (SorterRecord *)(aNew + iListOff);
      }
      pSorter->list.aMemory = aNew;
      pSorter->nMemory = (int )nNew;
    }
    pNew = (SorterRecord *)(pSorter->list.aMemory + pSorter->iMemory);
    pSorter->iMemory += (nReq + 7) & -8;
    if (pSorter->list.pList) {
      pNew->u.iNext = (int )((u8 *)pSorter->list.pList - pSorter->list.aMemory);
    }
  } else {
    tmp___4 = sqlite3Malloc((u64 )nReq);
    pNew = (SorterRecord *)tmp___4;
    if ((unsigned long )pNew == (unsigned long )((SorterRecord *)0)) {
      return (7);
    }
    pNew->u.pNext = pSorter->list.pList;
  }
  memcpy((void * __restrict  )((void *)(pNew + 1)), (void const   * __restrict  )pVal->z,
         (size_t )pVal->n);
  pNew->nVal = pVal->n;
  pSorter->list.pList = pNew;
  return (rc);
}
}
static int vdbeIncrPopulate(IncrMerger *pIncr ) 
{ 
  int rc ;
  int rc2 ;
  i64 iStart ;
  SorterFile *pOut ;
  SortSubtask *pTask ;
  MergeEngine *pMerger ;
  PmaWriter writer ;
  int dummy___0 ;
  PmaReader *pReader ;
  int nKey ;
  i64 iEof ;
  int tmp ;

  {
  rc = 0;
  iStart = pIncr->iStartOff;
  pOut = & pIncr->aFile[1];
  pTask = pIncr->pTask;
  pMerger = pIncr->pMerger;
  vdbePmaWriterInit(pOut->pFd, & writer, (pTask->pSorter)->pgsz, iStart);
  while (rc == 0) {
    pReader = pMerger->aReadr + *(pMerger->aTree + 1);
    nKey = pReader->nKey;
    iEof = writer.iWriteOff + (i64 )writer.iBufEnd;
    if ((unsigned long )pReader->pFd == (unsigned long )((sqlite3_file *)0)) {
      break;
    }
    tmp = sqlite3VarintLen((u64 )nKey);
    if ((iEof + (i64 )nKey) + (i64 )tmp > iStart + (i64 )pIncr->mxSz) {
      break;
    }
    vdbePmaWriteVarint(& writer, (u64 )nKey);
    vdbePmaWriteBlob(& writer, pReader->aKey, nKey);
    rc = vdbeMergeEngineStep(pIncr->pMerger, & dummy___0);
  }
  rc2 = vdbePmaWriterFinish(& writer, & pOut->iEof);
  if (rc == 0) {
    rc = rc2;
  }
  return (rc);
}
}
static int vdbeIncrSwap(IncrMerger *pIncr ) 
{ 
  int rc ;

  {
  rc = 0;
  rc = vdbeIncrPopulate(pIncr);
  pIncr->aFile[0] = pIncr->aFile[1];
  if (pIncr->aFile[0].iEof == pIncr->iStartOff) {
    pIncr->bEof = 1;
  }
  return (rc);
}
}
static int vdbeIncrMergerNew(SortSubtask *pTask , MergeEngine *pMerger , IncrMerger **ppOut ) 
{ 
  int rc ;
  IncrMerger *pIncr ;
  IncrMerger *tmp ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  rc = 0;
  tmp___3 = sqlite3FaultSim(100);
  if (tmp___3) {
    tmp___2 = (void *)0;
  } else {
    tmp___1 = sqlite3MallocZero((u64 )sizeof(*pIncr));
    tmp___2 = tmp___1;
  }
  tmp = (IncrMerger *)tmp___2;
  *ppOut = tmp;
  pIncr = tmp;
  if (pIncr) {
    pIncr->pMerger = pMerger;
    pIncr->pTask = pTask;
    if ((pTask->pSorter)->mxKeysize + 9 > (pTask->pSorter)->mxPmaSize / 2) {
      pIncr->mxSz = (pTask->pSorter)->mxKeysize + 9;
    } else {
      pIncr->mxSz = (pTask->pSorter)->mxPmaSize / 2;
    }
    pTask->file2.iEof += (i64 )pIncr->mxSz;
  } else {
    vdbeMergeEngineFree(pMerger);
    rc = 7;
  }
  return (rc);
}
}
static void vdbeMergeEngineCompare(MergeEngine *pMerger , int iOut ) 
{ 
  int i1 ;
  int i2 ;
  int iRes ;
  PmaReader *p1 ;
  PmaReader *p2 ;
  SortSubtask *pTask ;
  int bCached ;
  int res ;

  {
  if (iOut >= pMerger->nTree / 2) {
    i1 = (iOut - pMerger->nTree / 2) * 2;
    i2 = i1 + 1;
  } else {
    i1 = *(pMerger->aTree + iOut * 2);
    i2 = *(pMerger->aTree + (iOut * 2 + 1));
  }
  p1 = pMerger->aReadr + i1;
  p2 = pMerger->aReadr + i2;
  if ((unsigned long )p1->pFd == (unsigned long )((sqlite3_file *)0)) {
    iRes = i2;
  } else
  if ((unsigned long )p2->pFd == (unsigned long )((sqlite3_file *)0)) {
    iRes = i1;
  } else {
    pTask = pMerger->pTask;
    bCached = 0;
    res = (*(pTask->xCompare))(pTask, & bCached, (void const   *)p1->aKey, p1->nKey,
                               (void const   *)p2->aKey, p2->nKey);
    if (res <= 0) {
      iRes = i1;
    } else {
      iRes = i2;
    }
  }
  *(pMerger->aTree + iOut) = iRes;
  return;
}
}
static int vdbePmaReaderIncrInit(PmaReader *pReadr , int eMode ) ;
static int vdbeMergeEngineInit(SortSubtask *pTask , MergeEngine *pMerger , int eMode ) 
{ 
  int rc ;
  int i ;
  int nTree ;

  {
  rc = 0;
  pMerger->pTask = pTask;
  nTree = pMerger->nTree;
  i = 0;
  while (i < nTree) {
    rc = vdbePmaReaderIncrInit(pMerger->aReadr + i, 0);
    if (rc != 0) {
      return (rc);
    }
    i ++;
  }
  i = pMerger->nTree - 1;
  while (i > 0) {
    vdbeMergeEngineCompare(pMerger, i);
    i --;
  }
  return ((int )(pTask->pUnpacked)->errCode);
}
}
static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr , int eMode ) 
{ 
  int rc ;
  IncrMerger *pIncr ;
  SortSubtask *pTask ;
  sqlite3 *db ;
  int mxSz ;

  {
  rc = 0;
  pIncr = pReadr->pIncr;
  pTask = pIncr->pTask;
  db = (pTask->pSorter)->db;
  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);
  if (rc == 0) {
    mxSz = pIncr->mxSz;
    if ((unsigned long )pTask->file2.pFd == (unsigned long )((sqlite3_file *)0)) {
      rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, & pTask->file2.pFd);
      pTask->file2.iEof = (i64 )0;
    }
    if (rc == 0) {
      pIncr->aFile[1].pFd = pTask->file2.pFd;
      pIncr->iStartOff = pTask->file2.iEof;
      pTask->file2.iEof += (i64 )mxSz;
    }
  }
  if (rc == 0) {
    rc = vdbePmaReaderNext(pReadr);
  }
  return (rc);
}
}
static int vdbePmaReaderIncrInit(PmaReader *pReadr , int eMode ) 
{ 
  IncrMerger *pIncr ;
  int rc ;

  {
  pIncr = pReadr->pIncr;
  rc = 0;
  if (pIncr) {
    rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);
  }
  return (rc);
}
}
static int vdbeMergeEngineLevel0(SortSubtask *pTask , int nPMA , i64 *piOffset , MergeEngine **ppOut ) 
{ 
  MergeEngine *pNew ;
  i64 iOff ;
  int i ;
  int rc ;
  i64 nDummy ;
  PmaReader *pReadr ;

  {
  iOff = *piOffset;
  rc = 0;
  pNew = vdbeMergeEngineNew(nPMA);
  *ppOut = pNew;
  if ((unsigned long )pNew == (unsigned long )((MergeEngine *)0)) {
    rc = 7;
  }
  i = 0;
  while (1) {
    if (i < nPMA) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    nDummy = (i64 )0;
    pReadr = pNew->aReadr + i;
    rc = vdbePmaReaderInit(pTask, & pTask->file, iOff, pReadr, & nDummy);
    iOff = pReadr->iEof;
    i ++;
  }
  if (rc != 0) {
    vdbeMergeEngineFree(pNew);
    *ppOut = (MergeEngine *)0;
  }
  *piOffset = iOff;
  return (rc);
}
}
static int vdbeSorterTreeDepth(int nPMA ) 
{ 
  int nDepth ;
  i64 nDiv ;

  {
  nDepth = 0;
  nDiv = (i64 )16;
  while (nDiv < (i64 )nPMA) {
    nDiv *= 16LL;
    nDepth ++;
  }
  return (nDepth);
}
}
static int vdbeSorterAddToTree(SortSubtask *pTask , int nDepth , int iSeq , MergeEngine *pRoot ,
                               MergeEngine *pLeaf ) 
{ 
  int rc ;
  int nDiv ;
  int i ;
  MergeEngine *p ;
  IncrMerger *pIncr ;
  int iIter ;
  PmaReader *pReadr ;
  MergeEngine *pNew ;
  MergeEngine *tmp ;

  {
  rc = 0;
  nDiv = 1;
  p = pRoot;
  rc = vdbeIncrMergerNew(pTask, pLeaf, & pIncr);
  i = 1;
  while (i < nDepth) {
    nDiv *= 16;
    i ++;
  }
  i = 1;
  while (1) {
    if (i < nDepth) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    iIter = (iSeq / nDiv) % 16;
    pReadr = p->aReadr + iIter;
    if ((unsigned long )pReadr->pIncr == (unsigned long )((IncrMerger *)0)) {
      tmp = vdbeMergeEngineNew(16);
      pNew = tmp;
      if ((unsigned long )pNew == (unsigned long )((MergeEngine *)0)) {
        rc = 7;
      } else {
        rc = vdbeIncrMergerNew(pTask, pNew, & pReadr->pIncr);
      }
    }
    if (rc == 0) {
      p = (pReadr->pIncr)->pMerger;
      nDiv /= 16;
    }
    i ++;
  }
  if (rc == 0) {
    (p->aReadr + iSeq % 16)->pIncr = pIncr;
  } else {
    vdbeIncrFree(pIncr);
  }
  return (rc);
}
}
static int vdbeSorterMergeTreeBuild(VdbeSorter *pSorter , MergeEngine **ppOut ) 
{ 
  MergeEngine *pMain ;
  int rc ;
  int iTask ;
  SortSubtask *pTask ;
  MergeEngine *pRoot ;
  int nDepth ;
  int tmp ;
  i64 iReadOff ;
  int i ;
  int iSeq ;
  MergeEngine *pMerger ;
  int nReader ;
  int tmp___0 ;

  {
  pMain = (MergeEngine *)0;
  rc = 0;
  iTask = 0;
  while (1) {
    if (rc == 0) {
      if (! (iTask < (int )pSorter->nTask)) {
        break;
      }
    } else {
      break;
    }
    pTask = & pSorter->aTask[iTask];
    pRoot = (MergeEngine *)0;
    tmp = vdbeSorterTreeDepth(pTask->nPMA);
    nDepth = tmp;
    iReadOff = (i64 )0;
    if (pTask->nPMA <= 16) {
      rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, & iReadOff, & pRoot);
    } else {
      iSeq = 0;
      pRoot = vdbeMergeEngineNew(16);
      if ((unsigned long )pRoot == (unsigned long )((MergeEngine *)0)) {
        rc = 7;
      }
      i = 0;
      while (1) {
        if (i < pTask->nPMA) {
          if (! (rc == 0)) {
            break;
          }
        } else {
          break;
        }
        pMerger = (MergeEngine *)0;
        if (pTask->nPMA - i < 16) {
          nReader = pTask->nPMA - i;
        } else {
          nReader = 16;
        }
        rc = vdbeMergeEngineLevel0(pTask, nReader, & iReadOff, & pMerger);
        if (rc == 0) {
          tmp___0 = iSeq;
          iSeq ++;
          rc = vdbeSorterAddToTree(pTask, nDepth, tmp___0, pRoot, pMerger);
        }
        i += 16;
      }
    }
    if (rc == 0) {
      pMain = pRoot;
    } else {
      vdbeMergeEngineFree(pRoot);
    }
    iTask ++;
  }
  if (rc != 0) {
    vdbeMergeEngineFree(pMain);
    pMain = (MergeEngine *)0;
  }
  *ppOut = pMain;
  return (rc);
}
}
static int vdbeSorterSetupMerge(VdbeSorter *pSorter ) 
{ 
  int rc ;
  SortSubtask *pTask0 ;
  MergeEngine *pMain ;

  {
  pTask0 = & pSorter->aTask[0];
  pMain = (MergeEngine *)0;
  rc = vdbeSorterMergeTreeBuild(pSorter, & pMain);
  if (rc == 0) {
    rc = vdbeMergeEngineInit(pTask0, pMain, 0);
    pSorter->pMerger = pMain;
    pMain = (MergeEngine *)0;
  }
  if (rc != 0) {
    vdbeMergeEngineFree(pMain);
  }
  return (rc);
}
}
static int sqlite3VdbeSorterRewind(VdbeCursor const   *pCsr , int *pbEof ) 
{ 
  VdbeSorter *pSorter ;
  int rc ;

  {
  rc = 0;
  pSorter = (VdbeSorter *)pCsr->uc.pSorter;
  if ((int )pSorter->bUsePMA == 0) {
    if (pSorter->list.pList) {
      *pbEof = 0;
      rc = vdbeSorterSort(& pSorter->aTask[0], & pSorter->list);
    } else {
      *pbEof = 1;
    }
    return (rc);
  }
  rc = vdbeSorterFlushPMA(pSorter);
  rc = rc;
  if (rc == 0) {
    rc = vdbeSorterSetupMerge(pSorter);
    *pbEof = 0;
  }
  return (rc);
}
}
static int sqlite3VdbeSorterNext(sqlite3 *db , VdbeCursor const   *pCsr ) 
{ 
  VdbeSorter *pSorter ;
  int rc ;
  int res ;
  SorterRecord *pFree ;

  {
  pSorter = (VdbeSorter *)pCsr->uc.pSorter;
  if (pSorter->bUsePMA) {
    res = 0;
    rc = vdbeMergeEngineStep(pSorter->pMerger, & res);
    if (rc == 0) {
      if (res) {
        rc = 101;
      }
    }
  } else {
    pFree = pSorter->list.pList;
    pSorter->list.pList = pFree->u.pNext;
    pFree->u.pNext = (SorterRecord *)0;
    if ((unsigned long )pSorter->list.aMemory == (unsigned long )((u8 *)0)) {
      vdbeSorterRecordFree(db, pFree);
    }
    if (pSorter->list.pList) {
      rc = 0;
    } else {
      rc = 101;
    }
  }
  return (rc);
}
}
static void *vdbeSorterRowkey(VdbeSorter const   *pSorter , int *pnKey ) 
{ 
  void *pKey ;
  PmaReader *pReader ;

  {
  if (pSorter->bUsePMA) {
    pReader = (pSorter->pMerger)->aReadr + *((pSorter->pMerger)->aTree + 1);
    *pnKey = pReader->nKey;
    pKey = (void *)pReader->aKey;
  } else {
    *pnKey = (pSorter->list.pList)->nVal;
    pKey = (void *)((SorterRecord *)pSorter->list.pList + 1);
  }
  return (pKey);
}
}
static int sqlite3VdbeSorterRowkey(VdbeCursor const   *pCsr , Mem *pOut ) 
{ 
  VdbeSorter *pSorter ;
  void *pKey ;
  int nKey ;
  int tmp ;

  {
  pSorter = (VdbeSorter *)pCsr->uc.pSorter;
  pKey = vdbeSorterRowkey((VdbeSorter const   *)pSorter, & nKey);
  tmp = sqlite3VdbeMemClearAndResize(pOut, nKey);
  if (tmp) {
    return (7);
  }
  pOut->n = nKey;
  pOut->flags = (u16 )(((int )pOut->flags & -49600) | 16);
  memcpy((void * __restrict  )pOut->z, (void const   * __restrict  )pKey, (size_t )nKey);
  return (0);
}
}
static int sqlite3VdbeSorterCompare(VdbeCursor const   *pCsr , Mem *pVal , int nKeyCol ,
                                    int *pRes ) 
{ 
  VdbeSorter *pSorter ;
  UnpackedRecord *r2 ;
  KeyInfo *pKeyInfo ;
  int i ;
  void *pKey ;
  int nKey ;
  UnpackedRecord *tmp ;

  {
  pSorter = (VdbeSorter *)pCsr->uc.pSorter;
  r2 = pSorter->pUnpacked;
  pKeyInfo = (KeyInfo *)pCsr->pKeyInfo;
  if ((unsigned long )r2 == (unsigned long )((UnpackedRecord *)0)) {
    tmp = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    pSorter->pUnpacked = tmp;
    r2 = tmp;
    if ((unsigned long )r2 == (unsigned long )((UnpackedRecord *)0)) {
      return (7);
    }
    r2->nField = (u16 )nKeyCol;
  }
  pKey = vdbeSorterRowkey((VdbeSorter const   *)pSorter, & nKey);
  sqlite3VdbeRecordUnpack(pKeyInfo, nKey, (void const   *)pKey, r2);
  i = 0;
  while (i < nKeyCol) {
    if ((int )(r2->aMem + i)->flags & 1) {
      *pRes = -1;
      return (0);
    }
    i ++;
  }
  *pRes = sqlite3VdbeRecordCompare(pVal->n, (void const   *)pVal->z, r2);
  return (0);
}
}
static int memjrnlRead(sqlite3_file *pJfd , void *zBuf , int iAmt , sqlite_int64 iOfst ) 
{ 
  MemJournal *p ;
  u8 *zOut ;
  int nRead ;
  int iChunkOffset ;
  FileChunk *pChunk ;
  sqlite_int64 iOff ;
  int iSpace ;
  int nCopy ;
  int tmp ;

  {
  p = (MemJournal *)pJfd;
  zOut = (u8 *)zBuf;
  nRead = iAmt;
  if ((sqlite_int64 )iAmt + iOfst > p->endpoint.iOffset) {
    return (10 | (2 << 8));
  }
  if (p->readpoint.iOffset != iOfst) {
    goto _L;
  } else
  if (iOfst == 0LL) {
    _L: /* CIL Label */ 
    iOff = (sqlite_int64 )0;
    pChunk = p->pFirst;
    while (1) {
      if (pChunk) {
        if (! (iOff + (sqlite_int64 )p->nChunkSize <= iOfst)) {
          break;
        }
      } else {
        break;
      }
      iOff += (sqlite_int64 )p->nChunkSize;
      pChunk = pChunk->pNext;
    }
  } else {
    pChunk = p->readpoint.pChunk;
  }
  iChunkOffset = (int )(iOfst % (long long )p->nChunkSize);
  while (1) {
    iSpace = p->nChunkSize - iChunkOffset;
    if (nRead < p->nChunkSize - iChunkOffset) {
      tmp = nRead;
    } else {
      tmp = p->nChunkSize - iChunkOffset;
    }
    nCopy = tmp;
    memcpy((void * __restrict  )zOut, (void const   * __restrict  )(pChunk->zChunk + iChunkOffset),
           (size_t )nCopy);
    zOut += nCopy;
    nRead -= iSpace;
    iChunkOffset = 0;
    if (nRead >= 0) {
      pChunk = pChunk->pNext;
      if ((unsigned long )pChunk != (unsigned long )((FileChunk *)0)) {
        if (! (nRead > 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  if (pChunk) {
    p->readpoint.iOffset = iOfst + (sqlite_int64 )iAmt;
  } else {
    p->readpoint.iOffset = (sqlite_int64 )0;
  }
  p->readpoint.pChunk = pChunk;
  return (0);
}
}
static void memjrnlFreeChunks(MemJournal *p ) 
{ 
  FileChunk *pIter ;
  FileChunk *pNext ;

  {
  pIter = p->pFirst;
  while (pIter) {
    pNext = pIter->pNext;
    sqlite3_free((void *)pIter);
    pIter = pNext;
  }
  p->pFirst = (FileChunk *)0;
  return;
}
}
static int memjrnlCreateFile(MemJournal *p ) 
{ 
  int rc ;
  sqlite3_file *pReal ;
  MemJournal copy ;
  int nChunk ;
  i64 iOff ;
  FileChunk *pIter ;

  {
  pReal = (sqlite3_file *)p;
  copy = *p;
  memset((void *)p, 0, sizeof(MemJournal ));
  rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, (int *)0);
  if (rc == 0) {
    nChunk = copy.nChunkSize;
    iOff = (i64 )0;
    pIter = copy.pFirst;
    while (pIter) {
      if (iOff + (i64 )nChunk > copy.endpoint.iOffset) {
        nChunk = (int )(copy.endpoint.iOffset - iOff);
      }
      rc = sqlite3OsWrite(pReal, (void const   *)(pIter->zChunk), nChunk, iOff);
      if (rc) {
        break;
      }
      iOff += (i64 )nChunk;
      pIter = pIter->pNext;
    }
    if (rc == 0) {
      memjrnlFreeChunks(& copy);
    }
  }
  if (rc != 0) {
    sqlite3OsClose(pReal);
    *p = copy;
  }
  return (rc);
}
}
static int memjrnlWrite(sqlite3_file *pJfd , void const   *zBuf , int iAmt , sqlite_int64 iOfst ) 
{ 
  MemJournal *p ;
  int nWrite ;
  u8 *zWrite ;
  int rc ;
  int tmp ;
  FileChunk *pChunk ;
  int iChunkOffset ;
  int iSpace ;
  int tmp___0 ;
  FileChunk *pNew ;
  void *tmp___1 ;

  {
  p = (MemJournal *)pJfd;
  nWrite = iAmt;
  zWrite = (u8 *)zBuf;
  if (p->nSpill > 0) {
    if ((sqlite_int64 )iAmt + iOfst > (sqlite_int64 )p->nSpill) {
      tmp = memjrnlCreateFile(p);
      rc = tmp;
      if (rc == 0) {
        rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);
      }
      return (rc);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    while (nWrite > 0) {
      pChunk = p->endpoint.pChunk;
      iChunkOffset = (int )(p->endpoint.iOffset % (long long )p->nChunkSize);
      if (nWrite < p->nChunkSize - iChunkOffset) {
        tmp___0 = nWrite;
      } else {
        tmp___0 = p->nChunkSize - iChunkOffset;
      }
      iSpace = tmp___0;
      if (iChunkOffset == 0) {
        tmp___1 = sqlite3_malloc((int )(sizeof(FileChunk ) + (unsigned long )(p->nChunkSize - 8)));
        pNew = (FileChunk *)tmp___1;
        if (! pNew) {
          return (10 | (12 << 8));
        }
        pNew->pNext = (FileChunk *)0;
        if (pChunk) {
          pChunk->pNext = pNew;
        } else {
          p->pFirst = pNew;
        }
        p->endpoint.pChunk = pNew;
      }
      memcpy((void * __restrict  )((p->endpoint.pChunk)->zChunk + iChunkOffset), (void const   * __restrict  )zWrite,
             (size_t )iSpace);
      zWrite += iSpace;
      nWrite -= iSpace;
      p->endpoint.iOffset += (sqlite_int64 )iSpace;
    }
    p->nSize = (int )((sqlite_int64 )iAmt + iOfst);
  }
  return (0);
}
}
static int memjrnlTruncate(sqlite3_file *pJfd , sqlite_int64 size ) 
{ 
  MemJournal *p ;

  {
  p = (MemJournal *)pJfd;
  if (size == 0LL) {
    memjrnlFreeChunks(p);
    p->nSize = 0;
    p->endpoint.pChunk = (FileChunk *)0;
    p->endpoint.iOffset = (sqlite_int64 )0;
    p->readpoint.pChunk = (FileChunk *)0;
    p->readpoint.iOffset = (sqlite_int64 )0;
  }
  return (0);
}
}
static int memjrnlClose(sqlite3_file *pJfd ) 
{ 
  MemJournal *p ;

  {
  p = (MemJournal *)pJfd;
  memjrnlFreeChunks(p);
  return (0);
}
}
static int memjrnlSync(sqlite3_file *pJfd , int flags___0 ) 
{ 


  {
  return (0);
}
}
static int memjrnlFileSize(sqlite3_file *pJfd , sqlite_int64 *pSize ) 
{ 
  MemJournal *p ;

  {
  p = (MemJournal *)pJfd;
  *pSize = p->endpoint.iOffset;
  return (0);
}
}
static struct sqlite3_io_methods  const  MemJournalMethods  = 
     {1, & memjrnlClose, & memjrnlRead, & memjrnlWrite, & memjrnlTruncate, & memjrnlSync,
    & memjrnlFileSize, (int (*)(sqlite3_file * , int  ))0, (int (*)(sqlite3_file * ,
                                                                    int  ))0, (int (*)(sqlite3_file * ,
                                                                                       int *pResOut ))0,
    (int (*)(sqlite3_file * , int op , void *pArg ))0, (int (*)(sqlite3_file * ))0,
    (int (*)(sqlite3_file * ))0, (int (*)(sqlite3_file * , int iPg , int pgsz , int  ,
                                          void volatile   ** ))0, (int (*)(sqlite3_file * ,
                                                                           int offset ,
                                                                           int n ,
                                                                           int flags ))0,
    (void (*)(sqlite3_file * ))0, (int (*)(sqlite3_file * , int deleteFlag ))0, (int (*)(sqlite3_file * ,
                                                                                         sqlite_int64 iOfst ,
                                                                                         int iAmt ,
                                                                                         void **pp ))0,
    (int (*)(sqlite3_file * , sqlite_int64 iOfst , void *p ))0};
static int sqlite3JournalOpen(sqlite3_vfs *pVfs , char const   *zName , sqlite3_file *pJfd ,
                              int flags___0 , int nSpill ) 
{ 
  MemJournal *p ;
  int tmp ;

  {
  p = (MemJournal *)pJfd;
  memset((void *)p, 0, sizeof(MemJournal ));
  if (nSpill == 0) {
    tmp = sqlite3OsOpen(pVfs, zName, pJfd, flags___0, (int *)0);
    return (tmp);
  }
  if (nSpill > 0) {
    p->nChunkSize = nSpill;
  } else {
    p->nChunkSize = (int )(1032UL - sizeof(FileChunk ));
  }
  p->pMethod = & MemJournalMethods;
  p->nSpill = nSpill;
  p->flags = flags___0;
  p->zJournal = zName;
  p->pVfs = pVfs;
  return (0);
}
}
static void sqlite3MemJournalOpen(sqlite3_file *pJfd ) 
{ 


  {
  sqlite3JournalOpen((sqlite3_vfs *)0, (char const   *)0, pJfd, 0, -1);
  return;
}
}
static int sqlite3JournalIsInMemory(sqlite3_file *p ) 
{ 


  {
  return ((unsigned long )p->pMethods == (unsigned long )(& MemJournalMethods));
}
}
static int sqlite3JournalSize(sqlite3_vfs *pVfs ) 
{ 
  int tmp ;

  {
  if (pVfs->szOsFile > (int )sizeof(MemJournal )) {
    tmp = pVfs->szOsFile;
  } else {
    tmp = (int )sizeof(MemJournal );
  }
  return (tmp);
}
}
static int walkWindowList(Walker *pWalker , Window *pList ) 
{ 
  Window *pWin ;
  int rc ;

  {
  pWin = pList;
  while (pWin) {
    rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);
    if (rc) {
      return (2);
    }
    rc = sqlite3WalkExprList(pWalker, pWin->pPartition);
    if (rc) {
      return (2);
    }
    rc = sqlite3WalkExpr(pWalker, pWin->pFilter);
    if (rc) {
      return (2);
    }
    rc = sqlite3WalkExpr(pWalker, pWin->pStart);
    if (rc) {
      return (2);
    }
    rc = sqlite3WalkExpr(pWalker, pWin->pEnd);
    if (rc) {
      return (2);
    }
    pWin = pWin->pNextWin;
  }
  return (0);
}
}
static int ( __attribute__((__noinline__)) walkExpr)(Walker *pWalker , Expr *pExpr ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  while (1) {
    rc = (*(pWalker->xExprCallback))(pWalker, pExpr);
    if (rc) {
      return (rc & 2);
    }
    if (! ((pExpr->flags & 8404992U) != 0U)) {
      if (pExpr->pLeft) {
        tmp = walkExpr(pWalker, pExpr->pLeft);
        if (tmp) {
          return (2);
        }
      }
      if (pExpr->pRight) {
        pExpr = pExpr->pRight;
        continue;
      } else
      if ((pExpr->flags & 2048U) != 0U) {
        tmp___0 = sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
        if (tmp___0) {
          return (2);
        }
      } else {
        if (pExpr->x.pList) {
          tmp___1 = sqlite3WalkExprList(pWalker, pExpr->x.pList);
          if (tmp___1) {
            return (2);
          }
        }
        if ((pExpr->flags & 16777216U) != 0U) {
          tmp___2 = walkWindowList(pWalker, pExpr->y.pWin);
          if (tmp___2) {
            return (2);
          }
        }
      }
    }
    break;
  }
  return (0);
}
}
static int sqlite3WalkExpr(Walker *pWalker , Expr *pExpr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (pExpr) {
    tmp = walkExpr(pWalker, pExpr);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3WalkExprList(Walker *pWalker , ExprList *p ) 
{ 
  int i ;
  struct ExprList_item *pItem ;
  int tmp ;

  {
  if (p) {
    i = p->nExpr;
    pItem = p->a;
    while (i > 0) {
      tmp = sqlite3WalkExpr(pWalker, pItem->pExpr);
      if (tmp) {
        return (2);
      }
      i --;
      pItem ++;
    }
  }
  return (0);
}
}
static int sqlite3WalkSelectExpr(Walker *pWalker , Select *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Parse *pParse ;
  int rc ;
  int tmp___5 ;

  {
  tmp = sqlite3WalkExprList(pWalker, p->pEList);
  if (tmp) {
    return (2);
  }
  tmp___0 = sqlite3WalkExpr(pWalker, p->pWhere);
  if (tmp___0) {
    return (2);
  }
  tmp___1 = sqlite3WalkExprList(pWalker, p->pGroupBy);
  if (tmp___1) {
    return (2);
  }
  tmp___2 = sqlite3WalkExpr(pWalker, p->pHaving);
  if (tmp___2) {
    return (2);
  }
  tmp___3 = sqlite3WalkExprList(pWalker, p->pOrderBy);
  if (tmp___3) {
    return (2);
  }
  tmp___4 = sqlite3WalkExpr(pWalker, p->pLimit);
  if (tmp___4) {
    return (2);
  }
  pParse = pWalker->pParse;
  if (pParse) {
    if ((int )pParse->eParseMode >= 2) {
      tmp___5 = walkWindowList(pWalker, p->pWinDefn);
      rc = tmp___5;
      return (rc);
    }
  }
  return (0);
}
}
static int sqlite3WalkSelectFrom(Walker *pWalker , Select *p ) 
{ 
  SrcList *pSrc ;
  int i ;
  struct SrcList_item *pItem ;
  int tmp ;
  int tmp___0 ;

  {
  pSrc = p->pSrc;
  i = pSrc->nSrc;
  pItem = pSrc->a;
  while (i > 0) {
    if (pItem->pSelect) {
      tmp = sqlite3WalkSelect(pWalker, pItem->pSelect);
      if (tmp) {
        return (2);
      }
    }
    if (pItem->fg.isTabFunc) {
      tmp___0 = sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg);
      if (tmp___0) {
        return (2);
      }
    }
    i --;
    pItem ++;
  }
  return (0);
}
}
static int sqlite3WalkSelect(Walker *pWalker , Select *p ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )p == (unsigned long )((Select *)0)) {
    return (0);
  }
  if ((unsigned long )pWalker->xSelectCallback == (unsigned long )((int (*)(Walker * ,
                                                                            Select * ))0)) {
    return (0);
  }
  while (1) {
    rc = (*(pWalker->xSelectCallback))(pWalker, p);
    if (rc) {
      return (rc & 2);
    }
    tmp = sqlite3WalkSelectExpr(pWalker, p);
    if (tmp) {
      return (2);
    } else {
      tmp___0 = sqlite3WalkSelectFrom(pWalker, p);
      if (tmp___0) {
        return (2);
      }
    }
    if (pWalker->xSelectCallback2) {
      (*(pWalker->xSelectCallback2))(pWalker, p);
    }
    p = p->pPrior;
    if (! ((unsigned long )p != (unsigned long )((Select *)0))) {
      break;
    }
  }
  return (0);
}
}
static int incrAggDepth(Walker *pWalker , Expr *pExpr ) 
{ 


  {
  if ((int )pExpr->op == 163) {
    pExpr->op2 = (u8 )((int )pExpr->op2 + pWalker->u.n);
  }
  return (0);
}
}
static void incrAggFunctionDepth(Expr *pExpr , int N ) 
{ 
  Walker w ;

  {
  if (N > 0) {
    memset((void *)(& w), 0, sizeof(w));
    w.xExprCallback = & incrAggDepth;
    w.u.n = N;
    sqlite3WalkExpr(& w, pExpr);
  }
  return;
}
}
static void resolveAlias(Parse *pParse , ExprList *pEList , int iCol , Expr *pExpr ,
                         char const   *zType , int nSubquery ) 
{ 
  Expr *pOrig ;
  Expr *pDup ;
  sqlite3 *db ;

  {
  pOrig = pEList->a[iCol].pExpr;
  db = pParse->db;
  pDup = sqlite3ExprDup(db, pOrig, 0);
  if ((unsigned long )pDup != (unsigned long )((Expr *)0)) {
    if ((int const   )*(zType + 0) != 71) {
      incrAggFunctionDepth(pDup, nSubquery);
    }
    if ((int )pExpr->op == 109) {
      pDup = sqlite3ExprAddCollateString(pParse, pDup, (char const   *)pExpr->u.zToken);
    }
    pExpr->flags |= 134217728U;
    sqlite3ExprDelete(db, pExpr);
    memcpy((void * __restrict  )pExpr, (void const   * __restrict  )pDup, sizeof(*pExpr));
    if (! ((pExpr->flags & 1024U) != 0U)) {
      if ((unsigned long )pExpr->u.zToken != (unsigned long )((char *)0)) {
        pExpr->u.zToken = sqlite3DbStrDup(db, (char const   *)pExpr->u.zToken);
        pExpr->flags |= 65536U;
      }
    }
    if ((pExpr->flags & 16777216U) != 0U) {
      if ((unsigned long )pExpr->y.pWin != (unsigned long )((Window *)0)) {
        (pExpr->y.pWin)->pOwner = pExpr;
      }
    }
    sqlite3DbFree(db, (void *)pDup);
  }
  pExpr->flags |= 4194304U;
  return;
}
}
static int nameInUsingClause(IdList *pUsing , char const   *zCol ) 
{ 
  int k ;
  int tmp ;

  {
  if (pUsing) {
    k = 0;
    while (k < pUsing->nId) {
      tmp = sqlite3StrICmp((char const   *)(pUsing->a + k)->zName, zCol);
      if (tmp == 0) {
        return (1);
      }
      k ++;
    }
  }
  return (0);
}
}
static int sqlite3MatchSpanName(char const   *zSpan , char const   *zCol , char const   *zTab ,
                                char const   *zDb ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  n = 0;
  while (1) {
    if (*(zSpan + n)) {
      if (! ((int const   )*(zSpan + n) != 46)) {
        break;
      }
    } else {
      break;
    }
    n ++;
  }
  if (zDb) {
    tmp = sqlite3_strnicmp(zSpan, zDb, n);
    if (tmp != 0) {
      return (0);
    } else
    if ((int const   )*(zDb + n) != 0) {
      return (0);
    }
  }
  zSpan += n + 1;
  n = 0;
  while (1) {
    if (*(zSpan + n)) {
      if (! ((int const   )*(zSpan + n) != 46)) {
        break;
      }
    } else {
      break;
    }
    n ++;
  }
  if (zTab) {
    tmp___0 = sqlite3_strnicmp(zSpan, zTab, n);
    if (tmp___0 != 0) {
      return (0);
    } else
    if ((int const   )*(zTab + n) != 0) {
      return (0);
    }
  }
  zSpan += n + 1;
  if (zCol) {
    tmp___1 = sqlite3StrICmp(zSpan, zCol);
    if (tmp___1 != 0) {
      return (0);
    }
  }
  return (1);
}
}
static int areDoubleQuotedStringsEnabled(sqlite3 *db , NameContext *pTopNC ) 
{ 
  int tmp ;

  {
  if (db->init.busy) {
    return (1);
  }
  if (pTopNC->ncFlags & 65536) {
    tmp = sqlite3WritableSchema(db);
    if (tmp) {
      if ((db->flags & 1073741824ULL) != 0ULL) {
        return (1);
      }
    }
    return ((db->flags & 536870912ULL) != 0ULL);
  } else {
    return ((db->flags & 1073741824ULL) != 0ULL);
  }
}
}
static int lookupName(Parse *pParse , char const   *zDb , char const   *zTab , char const   *zCol ,
                      NameContext *pNC , Expr *pExpr ) 
{ 
  int i ;
  int j ;
  int cnt ;
  int cntTab ;
  int nSubquery ;
  sqlite3 *db ;
  struct SrcList_item *pItem ;
  struct SrcList_item *pMatch ;
  NameContext *pTopNC ;
  Schema *pSchema ;
  int eNewExprOp ;
  Table *pTab ;
  Column *pCol ;
  int tmp ;
  ExprList *pEList ;
  SrcList *pSrcList ;
  int hit ;
  int tmp___0 ;
  char const   *zTabName ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int op ;
  int tmp___6 ;
  int tmp___7 ;
  Upsert *pUpsert ;
  int tmp___8 ;
  int iCol ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  char *zAs ;
  Expr *pOrig ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *zErr ;
  int n ;

  {
  cnt = 0;
  cntTab = 0;
  nSubquery = 0;
  db = pParse->db;
  pMatch = (struct SrcList_item *)0;
  pTopNC = pNC;
  pSchema = (Schema *)0;
  eNewExprOp = 162;
  pTab = (Table *)0;
  pExpr->iTable = -1;
  if (zDb) {
    if ((pNC->ncFlags & 6) != 0) {
      zDb = (char const   *)0;
    } else {
      i = 0;
      while (i < db->nDb) {
        tmp = sqlite3StrICmp((char const   *)(db->aDb + i)->zDbSName, zDb);
        if (tmp == 0) {
          pSchema = (db->aDb + i)->pSchema;
          break;
        }
        i ++;
      }
    }
  }
  while (1) {
    pSrcList = pNC->pSrcList;
    if (pSrcList) {
      i = 0;
      pItem = pSrcList->a;
      while (i < pSrcList->nSrc) {
        pTab = pItem->pTab;
        if (pItem->pSelect) {
          if (((pItem->pSelect)->selFlags & 2048U) != 0U) {
            hit = 0;
            pEList = (pItem->pSelect)->pEList;
            j = 0;
            while (j < pEList->nExpr) {
              tmp___0 = sqlite3MatchSpanName((char const   *)pEList->a[j].zSpan, zCol,
                                             zTab, zDb);
              if (tmp___0) {
                cnt ++;
                cntTab = 2;
                pMatch = pItem;
                pExpr->iColumn = (ynVar )j;
                hit = 1;
              }
              j ++;
            }
            if (hit) {
              goto __Cont;
            } else
            if ((unsigned long )zTab == (unsigned long )((char const   *)0)) {
              goto __Cont;
            }
          }
        }
        if (zDb) {
          if ((unsigned long )pTab->pSchema != (unsigned long )pSchema) {
            goto __Cont;
          }
        }
        if (zTab) {
          if (pItem->zAlias) {
            tmp___1 = pItem->zAlias;
          } else {
            tmp___1 = pTab->zName;
          }
          zTabName = (char const   *)tmp___1;
          tmp___2 = sqlite3StrICmp(zTabName, zTab);
          if (tmp___2 != 0) {
            goto __Cont;
          }
          if ((int )pParse->eParseMode >= 2) {
            if (pItem->zAlias) {
              sqlite3RenameTokenRemap(pParse, (void *)0, (void *)(& pExpr->y.pTab));
            }
          }
        }
        tmp___3 = cntTab;
        cntTab ++;
        if (0 == tmp___3) {
          pMatch = pItem;
        }
        j = 0;
        pCol = pTab->aCol;
        while (j < (int )pTab->nCol) {
          tmp___5 = sqlite3StrICmp((char const   *)pCol->zName, zCol);
          if (tmp___5 == 0) {
            if (cnt == 1) {
              if ((int )pItem->fg.jointype & 4) {
                goto __Cont___0;
              }
              tmp___4 = nameInUsingClause(pItem->pUsing, zCol);
              if (tmp___4) {
                goto __Cont___0;
              }
            }
            cnt ++;
            pMatch = pItem;
            if (j == (int )pTab->iPKey) {
              pExpr->iColumn = (ynVar )-1;
            } else {
              pExpr->iColumn = (i16 )j;
            }
            break;
          }
          __Cont___0: /* CIL Label */ 
          j ++;
          pCol ++;
        }
        __Cont: /* CIL Label */ 
        i ++;
        pItem ++;
      }
      if (pMatch) {
        pExpr->iTable = pMatch->iCursor;
        pExpr->y.pTab = pMatch->pTab;
        if (((int )pMatch->fg.jointype & 8) != 0) {
          pExpr->flags |= 1048576U;
        }
        pSchema = (pExpr->y.pTab)->pSchema;
      }
    }
    if ((unsigned long )zDb == (unsigned long )((char const   *)0)) {
      if ((unsigned long )zTab != (unsigned long )((char const   *)0)) {
        if (cntTab == 0) {
          pTab = (Table *)0;
          if ((unsigned long )pParse->pTriggerTab != (unsigned long )((Table *)0)) {
            op = (int )pParse->eTriggerOp;
            if (op != 124) {
              tmp___7 = sqlite3StrICmp("new", zTab);
              if (tmp___7 == 0) {
                pExpr->iTable = 1;
                pTab = pParse->pTriggerTab;
              } else {
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
            if (op != 123) {
              tmp___6 = sqlite3StrICmp("old", zTab);
              if (tmp___6 == 0) {
                pExpr->iTable = 0;
                pTab = pParse->pTriggerTab;
              }
            }
          }
          if ((pNC->ncFlags & 512) != 0) {
            pUpsert = pNC->uNC.pUpsert;
            if (pUpsert) {
              tmp___8 = sqlite3StrICmp("excluded", zTab);
              if (tmp___8 == 0) {
                pTab = (pUpsert->pUpsertSrc)->a[0].pTab;
                pExpr->iTable = 2;
              }
            }
          }
          if (pTab) {
            pSchema = pTab->pSchema;
            cntTab ++;
            iCol = 0;
            pCol = pTab->aCol;
            while (iCol < (int )pTab->nCol) {
              tmp___9 = sqlite3StrICmp((char const   *)pCol->zName, zCol);
              if (tmp___9 == 0) {
                if (iCol == (int )pTab->iPKey) {
                  iCol = -1;
                }
                break;
              }
              iCol ++;
              pCol ++;
            }
            if (iCol >= (int )pTab->nCol) {
              tmp___10 = sqlite3IsRowid(zCol);
              if (tmp___10) {
                if ((pTab->tabFlags & 64U) == 0U) {
                  iCol = -1;
                }
              }
            }
            if (iCol < (int )pTab->nCol) {
              cnt ++;
              if (pExpr->iTable == 2) {
                if ((int )pParse->eParseMode >= 2) {
                  pExpr->iColumn = (ynVar )iCol;
                  pExpr->y.pTab = pTab;
                  eNewExprOp = 162;
                } else {
                  pExpr->iTable = (pNC->uNC.pUpsert)->regData + iCol;
                  eNewExprOp = 171;
                  pExpr->flags |= 4194304U;
                }
              } else {
                if (iCol < 0) {
                  pExpr->affExpr = (char)68;
                } else
                if (pExpr->iTable == 0) {
                  if (iCol >= 32) {
                    tmp___11 = 4294967295U;
                  } else {
                    tmp___11 = 1U << iCol;
                  }
                  pParse->oldmask |= tmp___11;
                } else {
                  if (iCol >= 32) {
                    tmp___12 = 4294967295U;
                  } else {
                    tmp___12 = 1U << iCol;
                  }
                  pParse->newmask |= tmp___12;
                }
                pExpr->y.pTab = pTab;
                pExpr->iColumn = (i16 )iCol;
                eNewExprOp = 77;
              }
            }
          }
        }
      }
    }
    if (cnt == 0) {
      if (cntTab == 1) {
        if (pMatch) {
          if ((pNC->ncFlags & 32) == 0) {
            tmp___13 = sqlite3IsRowid(zCol);
            if (tmp___13) {
              if (((pMatch->pTab)->tabFlags & 64U) == 0U) {
                cnt = 1;
                pExpr->iColumn = (ynVar )-1;
                pExpr->affExpr = (char)68;
              }
            }
          }
        }
      }
    }
    if ((pNC->ncFlags & 128) != 0) {
      if (cnt == 0) {
        if ((unsigned long )zTab == (unsigned long )((char const   *)0)) {
          pEList = pNC->uNC.pEList;
          j = 0;
          while (j < pEList->nExpr) {
            zAs = pEList->a[j].zName;
            if ((unsigned long )zAs != (unsigned long )((char *)0)) {
              tmp___15 = sqlite3StrICmp((char const   *)zAs, zCol);
              if (tmp___15 == 0) {
                pOrig = pEList->a[j].pExpr;
                if ((pNC->ncFlags & 1) == 0) {
                  if ((pOrig->flags & 16U) != 0U) {
                    sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
                    return (2);
                  }
                }
                if ((pNC->ncFlags & 16384) == 0) {
                  if ((pOrig->flags & 32768U) != 0U) {
                    sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",
                                    zAs);
                    return (2);
                  }
                }
                tmp___14 = sqlite3ExprVectorSize(pOrig);
                if (tmp___14 != 1) {
                  sqlite3ErrorMsg(pParse, "row value misused");
                  return (2);
                }
                resolveAlias(pParse, pEList, j, pExpr, "", nSubquery);
                cnt = 1;
                pMatch = (struct SrcList_item *)0;
                if ((int )pParse->eParseMode >= 2) {
                  sqlite3RenameTokenRemap(pParse, (void *)0, (void *)pExpr);
                }
                goto lookupname_end;
              }
            }
            j ++;
          }
        }
      }
    }
    if (cnt) {
      break;
    }
    pNC = pNC->pNext;
    nSubquery ++;
    if (! pNC) {
      break;
    }
  }
  if (cnt == 0) {
    if ((unsigned long )zTab == (unsigned long )((char const   *)0)) {
      if ((pExpr->flags & 64U) != 0U) {
        tmp___16 = areDoubleQuotedStringsEnabled(db, pTopNC);
        if (tmp___16) {
          sqlite3_log(28, "double-quoted string literal: \"%w\"", zCol);
          pExpr->op = (u8 )113;
          pExpr->y.pTab = (Table *)0;
          return (1);
        }
      }
      tmp___17 = sqlite3ExprIdToTrueFalse(pExpr);
      if (tmp___17) {
        return (1);
      }
    }
  }
  if (cnt != 1) {
    if (cnt == 0) {
      zErr = "no such column";
    } else {
      zErr = "ambiguous column name";
    }
    if (zDb) {
      sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
    } else
    if (zTab) {
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
    } else {
      sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
    }
    pParse->checkSchema = (u8 )1;
    (pTopNC->nErr) ++;
  }
  if ((int )pExpr->iColumn >= 0) {
    if ((unsigned long )pMatch != (unsigned long )((struct SrcList_item *)0)) {
      n = (int )pExpr->iColumn;
      if (n >= (int )(sizeof(Bitmask ) * 8UL)) {
        n = (int )(sizeof(Bitmask ) * 8UL) - 1;
      }
      pMatch->colUsed |= 1ULL << n;
    }
  }
  sqlite3ExprDelete(db, pExpr->pLeft);
  pExpr->pLeft = (Expr *)0;
  sqlite3ExprDelete(db, pExpr->pRight);
  pExpr->pRight = (Expr *)0;
  pExpr->op = (u8 )eNewExprOp;
  pExpr->flags |= 8388608U;
  lookupname_end: 
  if (cnt == 1) {
    if (! ((pExpr->flags & 4194304U) != 0U)) {
      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
    }
    while (1) {
      (pTopNC->nRef) ++;
      if ((unsigned long )pTopNC == (unsigned long )pNC) {
        break;
      }
      pTopNC = pTopNC->pNext;
    }
    return (1);
  } else {
    return (2);
  }
}
}
static Expr *sqlite3CreateColumnExpr(sqlite3 *db , SrcList *pSrc , int iSrc , int iCol ) 
{ 
  Expr *p ;
  Expr *tmp ;
  struct SrcList_item *pItem ;
  int tmp___0 ;

  {
  tmp = sqlite3ExprAlloc(db, 162, (Token const   *)0, 0);
  p = tmp;
  if (p) {
    pItem = & pSrc->a[iSrc];
    p->y.pTab = pItem->pTab;
    p->iTable = pItem->iCursor;
    if ((int )(p->y.pTab)->iPKey == iCol) {
      p->iColumn = (ynVar )-1;
    } else {
      p->iColumn = (ynVar )iCol;
      if (iCol >= (int )(sizeof(Bitmask ) * 8UL)) {
        tmp___0 = (int )(sizeof(Bitmask ) * 8UL) - 1;
      } else {
        tmp___0 = iCol;
      }
      pItem->colUsed |= 1ULL << tmp___0;
    }
  }
  return (p);
}
}
static void notValid(Parse *pParse , NameContext *pNC , char const   *zMsg , int validMask ) 
{ 
  char const   *zIn ;

  {
  if ((pNC->ncFlags & validMask) != 0) {
    zIn = "partial index WHERE clauses";
    if (pNC->ncFlags & 32) {
      zIn = "index expressions";
    } else
    if (pNC->ncFlags & 4) {
      zIn = "CHECK constraints";
    }
    sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
  }
  return;
}
}
static int exprProbability(Expr *p ) 
{ 
  double r ;
  int tmp ;

  {
  r = - 1.0;
  if ((int )p->op != 148) {
    return (-1);
  }
  tmp = sqlite3Strlen30((char const   *)p->u.zToken);
  sqlite3AtoF((char const   *)p->u.zToken, & r, tmp, (u8 )1);
  if (r > 1.0) {
    return (-1);
  }
  return ((int )(r * 134217728.0));
}
}
static int resolveExprStep(Walker *pWalker , Expr *pExpr ) 
{ 
  NameContext *pNC ;
  Parse *pParse ;
  char const   *zColumn ;
  char const   *zTable ;
  char const   *zDb ;
  Expr *pRight ;
  Expr *pLeft ;
  int tmp ;
  ExprList *pList ;
  int n ;
  int tmp___0 ;
  int no_such_func ;
  int wrong_num_args ;
  int is_agg ;
  int nId ;
  char const   *zId ;
  FuncDef *pDef ;
  u8 enc ;
  int savedAllowFlags ;
  Window *pWin ;
  Window *tmp___1 ;
  int auth ;
  int tmp___2 ;
  char const   *zType ;
  int tmp___3 ;
  Select *pSel ;
  NameContext *pNC2 ;
  int tmp___4 ;
  int nRef ;
  Expr *pRight___0 ;
  Expr *tmp___5 ;
  int rc ;
  int tmp___6 ;
  int nLeft ;
  int nRight ;
  int tmp___7 ;

  {
  pNC = pWalker->u.pNC;
  pParse = pNC->pParse;
  switch ((int )pExpr->op) {
  case 137: 
  case 59: 
  if ((int )pExpr->op == 59) {
    zDb = (char const   *)0;
    zTable = (char const   *)0;
    zColumn = (char const   *)pExpr->u.zToken;
  } else {
    pLeft = pExpr->pLeft;
    notValid(pParse, pNC, "the \".\" operator", 32);
    pRight = pExpr->pRight;
    if ((int )pRight->op == 59) {
      zDb = (char const   *)0;
    } else {
      zDb = (char const   *)pLeft->u.zToken;
      pLeft = pRight->pLeft;
      pRight = pRight->pRight;
    }
    zTable = (char const   *)pLeft->u.zToken;
    zColumn = (char const   *)pRight->u.zToken;
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameTokenRemap(pParse, (void *)pExpr, (void *)pRight);
      sqlite3RenameTokenRemap(pParse, (void *)(& pExpr->y.pTab), (void *)pLeft);
    }
  }
  tmp = lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);
  return (tmp);
  case 167: 
  pList = pExpr->x.pList;
  if (pList) {
    tmp___0 = pList->nExpr;
  } else {
    tmp___0 = 0;
  }
  n = tmp___0;
  no_such_func = 0;
  wrong_num_args = 0;
  is_agg = 0;
  enc = (pParse->db)->enc;
  savedAllowFlags = pNC->ncFlags & 16385;
  if ((pExpr->flags & 16777216U) != 0U) {
    if ((int )(pExpr->y.pWin)->eFrmType != 161) {
      tmp___1 = pExpr->y.pWin;
    } else {
      tmp___1 = (Window *)0;
    }
  } else {
    tmp___1 = (Window *)0;
  }
  pWin = tmp___1;
  zId = (char const   *)pExpr->u.zToken;
  nId = sqlite3Strlen30(zId);
  pDef = sqlite3FindFunction(pParse->db, zId, n, enc, (u8 )0);
  if ((unsigned long )pDef == (unsigned long )((FuncDef *)0)) {
    pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, (u8 )0);
    if ((unsigned long )pDef == (unsigned long )((FuncDef *)0)) {
      no_such_func = 1;
    } else {
      wrong_num_args = 1;
    }
  } else {
    is_agg = (unsigned long )pDef->xFinalize != (unsigned long )((void (*)(sqlite3_context * ))0);
    if (pDef->funcFlags & 1024U) {
      pExpr->flags |= 262144U;
      if (n == 2) {
        pExpr->iTable = exprProbability(pList->a[1].pExpr);
        if (pExpr->iTable < 0) {
          sqlite3ErrorMsg(pParse, "second argument to likelihood() must be a constant between 0.0 and 1.0");
          (pNC->nErr) ++;
        }
      } else
      if ((int const   )*(pDef->zName + 0) == 117) {
        pExpr->iTable = 8388608;
      } else {
        pExpr->iTable = 125829120;
      }
    }
    tmp___2 = sqlite3AuthCheck(pParse, 31, (char const   *)0, pDef->zName, (char const   *)0);
    auth = tmp___2;
    if (auth != 0) {
      if (auth == 1) {
        sqlite3ErrorMsg(pParse, "not authorized to use function: %s", pDef->zName);
        (pNC->nErr) ++;
      }
      pExpr->op = (u8 )117;
      return (1);
    }
    if (pDef->funcFlags & 10240U) {
      pExpr->flags |= 524288U;
    }
    if ((pDef->funcFlags & 2048U) == 0U) {
      notValid(pParse, pNC, "non-deterministic functions", 34);
    }
    if ((pDef->funcFlags & 262144U) != 0U) {
      if ((int )pParse->nested == 0) {
        if (sqlite3Config.bInternalFunctions == 0) {
          no_such_func = 1;
          pDef = (FuncDef *)0;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if ((pDef->funcFlags & 524288U) != 0U) {
      if ((pExpr->flags & 1073741824U) != 0U) {
        if (! ((int )pParse->eParseMode >= 2)) {
          sqlite3ErrorMsg(pParse, "%s() prohibited in triggers and views", pDef->zName);
        }
      }
    }
  }
  if (0 == ((int )pParse->eParseMode >= 2)) {
    if (pDef) {
      if ((unsigned long )pDef->xValue == (unsigned long )((void (*)(sqlite3_context * ))0)) {
        if (pWin) {
          sqlite3ErrorMsg(pParse, "%.*s() may not be used as a window function", nId,
                          zId);
          (pNC->nErr) ++;
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
    if (is_agg) {
      if ((pNC->ncFlags & 1) == 0) {
        goto _L___2;
      } else {
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
    if (is_agg) {
      if (pDef->funcFlags & 65536U) {
        if (! pWin) {
          goto _L___2;
        } else {
          goto _L___6;
        }
      } else {
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
    if (is_agg) {
      if (pWin) {
        if ((pNC->ncFlags & 16384) == 0) {
          _L___2: /* CIL Label */ 
          if (pDef->funcFlags & 65536U) {
            zType = "window";
          } else
          if (pWin) {
            zType = "window";
          } else {
            zType = "aggregate";
          }
          sqlite3ErrorMsg(pParse, "misuse of %s function %.*s()", zType, nId, zId);
          (pNC->nErr) ++;
          is_agg = 0;
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (no_such_func) {
      if ((int )(pParse->db)->init.busy == 0) {
        sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);
        (pNC->nErr) ++;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (wrong_num_args) {
      sqlite3ErrorMsg(pParse, "wrong number of arguments to function %.*s()", nId,
                      zId);
      (pNC->nErr) ++;
    } else
    if (is_agg == 0) {
      if ((pExpr->flags & 16777216U) != 0U) {
        sqlite3ErrorMsg(pParse, "FILTER may not be used with non-aggregate %.*s()",
                        nId, zId);
        (pNC->nErr) ++;
      }
    }
    if (is_agg) {
      if (! pWin) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      pNC->ncFlags &= ~ (16384 | tmp___3);
    }
  } else
  if ((pExpr->flags & 16777216U) != 0U) {
    is_agg = 1;
  }
  sqlite3WalkExprList(pWalker, pList);
  if (is_agg) {
    if (pWin) {
      pSel = pNC->pWinSelect;
      if (((int )pParse->eParseMode >= 2) == 0) {
        sqlite3WindowUpdate(pParse, pSel->pWinDefn, pWin, pDef);
      }
      sqlite3WalkExprList(pWalker, pWin->pPartition);
      sqlite3WalkExprList(pWalker, pWin->pOrderBy);
      sqlite3WalkExpr(pWalker, pWin->pFilter);
      sqlite3WindowLink(pSel, pWin);
      pNC->ncFlags |= 32768;
    } else {
      pNC2 = pNC;
      pExpr->op = (u8 )163;
      pExpr->op2 = (u8 )0;
      if ((pExpr->flags & 16777216U) != 0U) {
        sqlite3WalkExpr(pWalker, (pExpr->y.pWin)->pFilter);
      }
      while (1) {
        if (pNC2) {
          tmp___4 = sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList);
          if (tmp___4) {
            break;
          }
        } else {
          break;
        }
        pExpr->op2 = (u8 )((int )pExpr->op2 + 1);
        pNC2 = pNC2->pNext;
      }
      if (pNC2) {
        if (pDef) {
          pNC2->ncFlags = (int )((unsigned int )pNC2->ncFlags | (16U | (pDef->funcFlags & 4096U)));
        }
      }
    }
    pNC->ncFlags |= savedAllowFlags;
  }
  return (1);
  case 20: 
  case 134: ;
  case 49: 
  if ((pExpr->flags & 2048U) != 0U) {
    nRef = pNC->nRef;
    notValid(pParse, pNC, "subqueries", 38);
    sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
    if (nRef != pNC->nRef) {
      pExpr->flags |= 32U;
      pNC->ncFlags |= 64;
    }
  }
  break;
  case 151: 
  notValid(pParse, pNC, "parameters", 38);
  break;
  case 166: 
  case 45: 
  tmp___5 = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);
  pRight___0 = tmp___5;
  if ((int )pRight___0->op == 59) {
    tmp___6 = resolveExprStep(pWalker, pRight___0);
    rc = tmp___6;
    if (rc == 2) {
      return (2);
    }
    if ((int )pRight___0->op == 165) {
      pExpr->op2 = pExpr->op;
      pExpr->op = (u8 )170;
      return (0);
    }
  }
  case 57: 
  case 54: 
  case 55: 
  case 56: 
  case 52: 
  case 53: 
  case 48: 
  if ((pParse->db)->mallocFailed) {
    break;
  }
  nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
  if ((int )pExpr->op == 48) {
    nRight = sqlite3ExprVectorSize((pExpr->x.pList)->a[0].pExpr);
    if (nRight == nLeft) {
      nRight = sqlite3ExprVectorSize((pExpr->x.pList)->a[1].pExpr);
    }
  } else {
    nRight = sqlite3ExprVectorSize(pExpr->pRight);
  }
  if (nLeft != nRight) {
    sqlite3ErrorMsg(pParse, "row value misused");
  }
  break;
  }
  if (pParse->nErr) {
    tmp___7 = 2;
  } else
  if ((pParse->db)->mallocFailed) {
    tmp___7 = 2;
  } else {
    tmp___7 = 0;
  }
  return (tmp___7);
}
}
static int resolveAsName(Parse *pParse , ExprList *pEList , Expr *pE ) 
{ 
  int i ;
  char *zCol ;
  char *zAs ;
  int tmp ;

  {
  if ((int )pE->op == 59) {
    zCol = pE->u.zToken;
    i = 0;
    while (i < pEList->nExpr) {
      zAs = pEList->a[i].zName;
      if ((unsigned long )zAs != (unsigned long )((char *)0)) {
        tmp = sqlite3StrICmp((char const   *)zAs, (char const   *)zCol);
        if (tmp == 0) {
          return (i + 1);
        }
      }
      i ++;
    }
  }
  return (0);
}
}
static int resolveOrderByTermToExprList(Parse *pParse , Select *pSelect , Expr *pE ) 
{ 
  int i ;
  ExprList *pEList ;
  NameContext nc ;
  sqlite3 *db ;
  int rc ;
  u8 savedSuppErr ;
  int tmp ;

  {
  pEList = pSelect->pEList;
  memset((void *)(& nc), 0, sizeof(nc));
  nc.pParse = pParse;
  nc.pSrcList = pSelect->pSrc;
  nc.uNC.pEList = pEList;
  nc.ncFlags = 129;
  nc.nErr = 0;
  db = pParse->db;
  savedSuppErr = db->suppressErr;
  db->suppressErr = (u8 )1;
  rc = sqlite3ResolveExprNames(& nc, pE);
  db->suppressErr = savedSuppErr;
  if (rc) {
    return (0);
  }
  i = 0;
  while (i < pEList->nExpr) {
    tmp = sqlite3ExprCompare((Parse *)0, pEList->a[i].pExpr, pE, -1);
    if (tmp < 2) {
      return (i + 1);
    }
    i ++;
  }
  return (0);
}
}
static void resolveOutOfRangeError(Parse *pParse , char const   *zType , int i , int mx ) 
{ 


  {
  sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be between 1 and %d",
                  i, zType, mx);
  return;
}
}
static int resolveCompoundOrderBy(Parse *pParse , Select *pSelect ) 
{ 
  int i ;
  ExprList *pOrderBy ;
  ExprList *pEList ;
  sqlite3 *db ;
  int moreToDo ;
  struct ExprList_item *pItem ;
  int iCol ;
  Expr *pE ;
  Expr *pDup ;
  int tmp ;
  Expr *pNew ;
  Expr *tmp___0 ;
  Expr *pParent ;

  {
  moreToDo = 1;
  pOrderBy = pSelect->pOrderBy;
  if ((unsigned long )pOrderBy == (unsigned long )((ExprList *)0)) {
    return (0);
  }
  db = pParse->db;
  if (pOrderBy->nExpr > db->aLimit[2]) {
    sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    return (1);
  }
  i = 0;
  while (i < pOrderBy->nExpr) {
    pOrderBy->a[i].done = 0U;
    i ++;
  }
  pSelect->pNext = (Select *)0;
  while (pSelect->pPrior) {
    (pSelect->pPrior)->pNext = pSelect;
    pSelect = pSelect->pPrior;
  }
  while (1) {
    if (pSelect) {
      if (! moreToDo) {
        break;
      }
    } else {
      break;
    }
    moreToDo = 0;
    pEList = pSelect->pEList;
    i = 0;
    pItem = pOrderBy->a;
    while (i < pOrderBy->nExpr) {
      iCol = -1;
      if (pItem->done) {
        goto __Cont;
      }
      pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
      tmp = sqlite3ExprIsInteger(pE, & iCol);
      if (tmp) {
        if (iCol <= 0) {
          resolveOutOfRangeError(pParse, "ORDER", i + 1, pEList->nExpr);
          return (1);
        } else
        if (iCol > pEList->nExpr) {
          resolveOutOfRangeError(pParse, "ORDER", i + 1, pEList->nExpr);
          return (1);
        }
      } else {
        iCol = resolveAsName(pParse, pEList, pE);
        if (iCol == 0) {
          if ((int )pParse->eParseMode >= 2) {
            pDup = pE;
          } else {
            pDup = sqlite3ExprDup(db, pE, 0);
          }
          if (! db->mallocFailed) {
            iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);
          }
          if (! ((int )pParse->eParseMode >= 2)) {
            sqlite3ExprDelete(db, pDup);
          }
        }
      }
      if (iCol > 0) {
        if (! ((int )pParse->eParseMode >= 2)) {
          tmp___0 = sqlite3Expr(db, 150, (char const   *)0);
          pNew = tmp___0;
          if ((unsigned long )pNew == (unsigned long )((Expr *)0)) {
            return (1);
          }
          pNew->flags |= 1024U;
          pNew->u.iValue = iCol;
          if ((unsigned long )pItem->pExpr == (unsigned long )pE) {
            pItem->pExpr = pNew;
          } else {
            pParent = pItem->pExpr;
            while ((int )(pParent->pLeft)->op == 109) {
              pParent = pParent->pLeft;
            }
            pParent->pLeft = pNew;
          }
          sqlite3ExprDelete(db, pE);
          pItem->u.x.iOrderByCol = (u16 )iCol;
        }
        pItem->done = 1U;
      } else {
        moreToDo = 1;
      }
      __Cont: /* CIL Label */ 
      i ++;
      pItem ++;
    }
    pSelect = pSelect->pNext;
  }
  i = 0;
  while (i < pOrderBy->nExpr) {
    if (pOrderBy->a[i].done == 0U) {
      sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any column in the result set",
                      i + 1);
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static int sqlite3ResolveOrderGroupBy(Parse *pParse , Select *pSelect , ExprList *pOrderBy ,
                                      char const   *zType ) 
{ 
  int i ;
  sqlite3 *db ;
  ExprList *pEList ;
  struct ExprList_item *pItem ;

  {
  db = pParse->db;
  if ((unsigned long )pOrderBy == (unsigned long )((ExprList *)0)) {
    return (0);
  } else
  if ((pParse->db)->mallocFailed) {
    return (0);
  } else
  if ((int )pParse->eParseMode >= 2) {
    return (0);
  }
  if (pOrderBy->nExpr > db->aLimit[2]) {
    sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
    return (1);
  }
  pEList = pSelect->pEList;
  i = 0;
  pItem = pOrderBy->a;
  while (i < pOrderBy->nExpr) {
    if (pItem->u.x.iOrderByCol) {
      if ((int )pItem->u.x.iOrderByCol > pEList->nExpr) {
        resolveOutOfRangeError(pParse, zType, i + 1, pEList->nExpr);
        return (1);
      }
      resolveAlias(pParse, pEList, (int )pItem->u.x.iOrderByCol - 1, pItem->pExpr,
                   zType, 0);
    }
    i ++;
    pItem ++;
  }
  return (0);
}
}
static int resolveRemoveWindowsCb(Walker *pWalker , Expr *pExpr ) 
{ 
  Window *pWin ;

  {
  if ((pExpr->flags & 16777216U) != 0U) {
    pWin = pExpr->y.pWin;
    sqlite3WindowUnlinkFromSelect(pWin);
  }
  return (0);
}
}
static void windowRemoveExprFromSelect(Select *pSelect , Expr *pExpr ) 
{ 
  Walker sWalker ;

  {
  if (pSelect->pWin) {
    memset((void *)(& sWalker), 0, sizeof(Walker ));
    sWalker.xExprCallback = & resolveRemoveWindowsCb;
    sWalker.u.pSelect = pSelect;
    sqlite3WalkExpr(& sWalker, pExpr);
  }
  return;
}
}
static int resolveOrderGroupBy(NameContext *pNC , Select *pSelect , ExprList *pOrderBy ,
                               char const   *zType ) 
{ 
  int i ;
  int j ;
  int iCol ;
  struct ExprList_item *pItem ;
  Parse *pParse ;
  int nResult ;
  Expr *pE ;
  Expr *pE2 ;
  Expr *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )pOrderBy == (unsigned long )((ExprList *)0)) {
    return (0);
  }
  nResult = (pSelect->pEList)->nExpr;
  pParse = pNC->pParse;
  i = 0;
  pItem = pOrderBy->a;
  while (i < pOrderBy->nExpr) {
    pE = pItem->pExpr;
    tmp = sqlite3ExprSkipCollateAndLikely(pE);
    pE2 = tmp;
    if ((int const   )*(zType + 0) != 71) {
      iCol = resolveAsName(pParse, pSelect->pEList, pE2);
      if (iCol > 0) {
        pItem->u.x.iOrderByCol = (u16 )iCol;
        goto __Cont;
      }
    }
    tmp___0 = sqlite3ExprIsInteger(pE2, & iCol);
    if (tmp___0) {
      if (iCol < 1) {
        resolveOutOfRangeError(pParse, zType, i + 1, nResult);
        return (1);
      } else
      if (iCol > 65535) {
        resolveOutOfRangeError(pParse, zType, i + 1, nResult);
        return (1);
      }
      pItem->u.x.iOrderByCol = (u16 )iCol;
      goto __Cont;
    }
    pItem->u.x.iOrderByCol = (u16 )0;
    tmp___1 = sqlite3ResolveExprNames(pNC, pE);
    if (tmp___1) {
      return (1);
    }
    j = 0;
    while (j < (pSelect->pEList)->nExpr) {
      tmp___2 = sqlite3ExprCompare((Parse *)0, pE, (pSelect->pEList)->a[j].pExpr,
                                   -1);
      if (tmp___2 == 0) {
        windowRemoveExprFromSelect(pSelect, pE);
        pItem->u.x.iOrderByCol = (u16 )(j + 1);
      }
      j ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
    pItem ++;
  }
  tmp___3 = sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
  return (tmp___3);
}
}
static int resolveSelectStep(Walker *pWalker , Select *p ) 
{ 
  NameContext *pOuterNC ;
  NameContext sNC ;
  int isCompound ;
  int nCompound ;
  Parse *pParse ;
  int i ;
  ExprList *pGroupBy ;
  Select *pLeftmost ;
  sqlite3 *db ;
  int tmp ;
  int tmp___0 ;
  Select *pSub ;
  struct SrcList_item *pItem ;
  NameContext *pNC ;
  int nRef ;
  char const   *zSavedContext ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct SrcList_item *pItem___0 ;
  int tmp___4 ;
  Select *pSub___0 ;
  int tmp___5 ;
  struct ExprList_item *pItem___1 ;
  int tmp___6 ;
  Window *pWin ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  if (p->selFlags & 4U) {
    return (1);
  }
  pOuterNC = pWalker->u.pNC;
  pParse = pWalker->pParse;
  db = pParse->db;
  if ((p->selFlags & 64U) == 0U) {
    sqlite3SelectPrep(pParse, p, pOuterNC);
    if (pParse->nErr) {
      tmp = 2;
    } else
    if (db->mallocFailed) {
      tmp = 2;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
  isCompound = (unsigned long )p->pPrior != (unsigned long )((Select *)0);
  nCompound = 0;
  pLeftmost = p;
  while (p) {
    p->selFlags |= 4U;
    memset((void *)(& sNC), 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pWinSelect = p;
    tmp___0 = sqlite3ResolveExprNames(& sNC, p->pLimit);
    if (tmp___0) {
      return (2);
    }
    if (p->selFlags & 65536U) {
      pSub = (p->pSrc)->a[0].pSelect;
      pSub->pOrderBy = p->pOrderBy;
      p->pOrderBy = (ExprList *)0;
    }
    i = 0;
    while (i < (p->pSrc)->nSrc) {
      pItem = & (p->pSrc)->a[i];
      if (pItem->pSelect) {
        if (((pItem->pSelect)->selFlags & 4U) == 0U) {
          nRef = 0;
          zSavedContext = pParse->zAuthContext;
          pNC = pOuterNC;
          while (pNC) {
            nRef += pNC->nRef;
            pNC = pNC->pNext;
          }
          if (pItem->zName) {
            pParse->zAuthContext = (char const   *)pItem->zName;
          }
          sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);
          pParse->zAuthContext = zSavedContext;
          if (pParse->nErr) {
            return (2);
          } else
          if (db->mallocFailed) {
            return (2);
          }
          pNC = pOuterNC;
          while (pNC) {
            nRef -= pNC->nRef;
            pNC = pNC->pNext;
          }
          pItem->fg.isCorrelated = (unsigned int )(nRef != 0);
        }
      }
      i ++;
    }
    sNC.ncFlags = 16385;
    sNC.pSrcList = p->pSrc;
    sNC.pNext = pOuterNC;
    tmp___1 = sqlite3ResolveExprListNames(& sNC, p->pEList);
    if (tmp___1) {
      return (2);
    }
    sNC.ncFlags &= -16385;
    pGroupBy = p->pGroupBy;
    if (pGroupBy) {
      p->selFlags |= (unsigned int )(8 | (sNC.ncFlags & 4096));
    } else
    if ((sNC.ncFlags & 16) != 0) {
      p->selFlags |= (unsigned int )(8 | (sNC.ncFlags & 4096));
    } else {
      sNC.ncFlags &= -2;
    }
    if (p->pHaving) {
      if (! pGroupBy) {
        sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
        return (2);
      }
    }
    sNC.uNC.pEList = p->pEList;
    sNC.ncFlags |= 128;
    tmp___2 = sqlite3ResolveExprNames(& sNC, p->pHaving);
    if (tmp___2) {
      return (2);
    }
    tmp___3 = sqlite3ResolveExprNames(& sNC, p->pWhere);
    if (tmp___3) {
      return (2);
    }
    i = 0;
    while (i < (p->pSrc)->nSrc) {
      pItem___0 = & (p->pSrc)->a[i];
      if (pItem___0->fg.isTabFunc) {
        tmp___4 = sqlite3ResolveExprListNames(& sNC, pItem___0->u1.pFuncArg);
        if (tmp___4) {
          return (2);
        }
      }
      i ++;
    }
    sNC.pNext = (NameContext *)0;
    sNC.ncFlags |= 16385;
    if (p->selFlags & 65536U) {
      pSub___0 = (p->pSrc)->a[0].pSelect;
      p->pOrderBy = pSub___0->pOrderBy;
      pSub___0->pOrderBy = (ExprList *)0;
    }
    if (isCompound <= nCompound) {
      tmp___5 = resolveOrderGroupBy(& sNC, p, p->pOrderBy, "ORDER");
      if (tmp___5) {
        return (2);
      }
    }
    if (db->mallocFailed) {
      return (2);
    }
    sNC.ncFlags &= -16385;
    if (pGroupBy) {
      tmp___6 = resolveOrderGroupBy(& sNC, p, pGroupBy, "GROUP");
      if (tmp___6) {
        return (2);
      } else
      if (db->mallocFailed) {
        return (2);
      }
      i = 0;
      pItem___1 = pGroupBy->a;
      while (i < pGroupBy->nExpr) {
        if (((pItem___1->pExpr)->flags & 16U) != 0U) {
          sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in the GROUP BY clause");
          return (2);
        }
        i ++;
        pItem___1 ++;
      }
    }
    if ((int )pParse->eParseMode >= 2) {
      pWin = p->pWinDefn;
      while (pWin) {
        tmp___7 = sqlite3ResolveExprListNames(& sNC, pWin->pOrderBy);
        if (tmp___7) {
          return (2);
        } else {
          tmp___8 = sqlite3ResolveExprListNames(& sNC, pWin->pPartition);
          if (tmp___8) {
            return (2);
          }
        }
        pWin = pWin->pNextWin;
      }
    }
    if (p->pNext) {
      if ((p->pEList)->nExpr != ((p->pNext)->pEList)->nExpr) {
        sqlite3SelectWrongNumTermsError(pParse, p->pNext);
        return (2);
      }
    }
    p = p->pPrior;
    nCompound ++;
  }
  if (isCompound) {
    tmp___9 = resolveCompoundOrderBy(pParse, pLeftmost);
    if (tmp___9) {
      return (2);
    }
  }
  return (1);
}
}
static int sqlite3ResolveExprNames(NameContext *pNC , Expr *pExpr ) 
{ 
  int savedHasAgg ;
  Walker w ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return (0);
  }
  savedHasAgg = pNC->ncFlags & 36880;
  pNC->ncFlags &= -36881;
  w.pParse = pNC->pParse;
  w.xExprCallback = & resolveExprStep;
  w.xSelectCallback = & resolveSelectStep;
  w.xSelectCallback2 = (void (*)(Walker * , Select * ))0;
  w.u.pNC = pNC;
  (w.pParse)->nHeight += pExpr->nHeight;
  tmp = sqlite3ExprCheckHeight(w.pParse, (w.pParse)->nHeight);
  if (tmp) {
    return (1);
  }
  sqlite3WalkExpr(& w, pExpr);
  (w.pParse)->nHeight -= pExpr->nHeight;
  pExpr->flags |= (unsigned int )(pNC->ncFlags & 32784);
  pNC->ncFlags |= savedHasAgg;
  if (pNC->nErr > 0) {
    tmp___0 = 1;
  } else
  if ((w.pParse)->nErr > 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int sqlite3ResolveExprListNames(NameContext *pNC , ExprList *pList ) 
{ 
  int i ;
  int tmp ;

  {
  if (pList) {
    i = 0;
    while (i < pList->nExpr) {
      tmp = sqlite3ResolveExprNames(pNC, pList->a[i].pExpr);
      if (tmp) {
        return (2);
      }
      i ++;
    }
  }
  return (0);
}
}
static void sqlite3ResolveSelectNames(Parse *pParse , Select *p , NameContext *pOuterNC ) 
{ 
  Walker w ;

  {
  w.xExprCallback = & resolveExprStep;
  w.xSelectCallback = & resolveSelectStep;
  w.xSelectCallback2 = (void (*)(Walker * , Select * ))0;
  w.pParse = pParse;
  w.u.pNC = pOuterNC;
  sqlite3WalkSelect(& w, p);
  return;
}
}
static int sqlite3ResolveSelfReference(Parse *pParse , Table *pTab , int type , Expr *pExpr ,
                                       ExprList *pList ) 
{ 
  SrcList sSrc ;
  NameContext sNC ;
  int rc ;

  {
  memset((void *)(& sNC), 0, sizeof(sNC));
  memset((void *)(& sSrc), 0, sizeof(sSrc));
  if (pTab) {
    sSrc.nSrc = 1;
    sSrc.a[0].zName = pTab->zName;
    sSrc.a[0].pTab = pTab;
    sSrc.a[0].iCursor = -1;
  }
  sNC.pParse = pParse;
  sNC.pSrcList = & sSrc;
  sNC.ncFlags = type | 65536;
  rc = sqlite3ResolveExprNames(& sNC, pExpr);
  if (rc != 0) {
    return (rc);
  }
  if (pList) {
    rc = sqlite3ResolveExprListNames(& sNC, pList);
  }
  return (rc);
}
}
static void exprCodeBetween(Parse *pParse , Expr *pExpr , int dest , void (*xJump)(Parse * ,
                                                                                   Expr * ,
                                                                                   int  ,
                                                                                   int  ) ,
                            int jumpIfNull ) ;
static int exprCodeVector(Parse *pParse , Expr *p , int *piFreeable ) ;
static char sqlite3TableColumnAffinity(Table *pTab , int iCol ) 
{ 
  int tmp ;

  {
  if (iCol >= 0) {
    tmp = (int )(pTab->aCol + iCol)->affinity;
  } else {
    tmp = 68;
  }
  return ((char )tmp);
}
}
static char sqlite3ExprAffinity(Expr *pExpr ) 
{ 
  int op ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
  while ((pExpr->flags & 4096U) != 0U) {
    pExpr = pExpr->pLeft;
  }
  op = (int )pExpr->op;
  if (op == 134) {
    tmp = sqlite3ExprAffinity(((pExpr->x.pSelect)->pEList)->a[0].pExpr);
    return (tmp);
  }
  if (op == 171) {
    op = (int )pExpr->op2;
  }
  if (op == 36) {
    tmp___0 = sqlite3AffinityType((char const   *)pExpr->u.zToken, (Column *)0);
    return (tmp___0);
  }
  if (op == 164) {
    goto _L;
  } else
  if (op == 162) {
    _L: /* CIL Label */ 
    if (pExpr->y.pTab) {
      tmp___1 = sqlite3TableColumnAffinity(pExpr->y.pTab, (int )pExpr->iColumn);
      return (tmp___1);
    }
  }
  if (op == 173) {
    tmp___2 = sqlite3ExprAffinity((((pExpr->pLeft)->x.pSelect)->pEList)->a[pExpr->iColumn].pExpr);
    return (tmp___2);
  }
  return (pExpr->affExpr);
}
}
static Expr *sqlite3ExprAddCollateToken(Parse *pParse , Expr *pExpr , Token const   *pCollName ,
                                        int dequote ) 
{ 
  Expr *pNew ;
  Expr *tmp ;

  {
  if (pCollName->n > 0U) {
    tmp = sqlite3ExprAlloc(pParse->db, 109, pCollName, dequote);
    pNew = tmp;
    if (pNew) {
      pNew->pLeft = pExpr;
      pNew->flags |= 4352U;
      pExpr = pNew;
    }
  }
  return (pExpr);
}
}
static Expr *sqlite3ExprAddCollateString(Parse *pParse , Expr *pExpr , char const   *zC ) 
{ 
  Token s ;
  Expr *tmp ;

  {
  sqlite3TokenInit(& s, (char *)zC);
  tmp = sqlite3ExprAddCollateToken(pParse, pExpr, (Token const   *)(& s), 0);
  return (tmp);
}
}
static Expr *sqlite3ExprSkipCollate(Expr *pExpr ) 
{ 


  {
  while (1) {
    if (pExpr) {
      if (! ((pExpr->flags & 4096U) != 0U)) {
        break;
      }
    } else {
      break;
    }
    pExpr = pExpr->pLeft;
  }
  return (pExpr);
}
}
static Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr ) 
{ 


  {
  while (1) {
    if (pExpr) {
      if (! ((pExpr->flags & 266240U) != 0U)) {
        break;
      }
    } else {
      break;
    }
    if ((pExpr->flags & 262144U) != 0U) {
      pExpr = (pExpr->x.pList)->a[0].pExpr;
    } else {
      pExpr = pExpr->pLeft;
    }
  }
  return (pExpr);
}
}
static CollSeq *sqlite3ExprCollSeq(Parse *pParse , Expr *pExpr ) 
{ 
  sqlite3 *db ;
  CollSeq *pColl ;
  Expr *p ;
  int op ;
  int j ;
  char const   *zColl ;
  Expr *pNext ;
  int i ;
  int tmp ;

  {
  db = pParse->db;
  pColl = (CollSeq *)0;
  p = pExpr;
  while (p) {
    op = (int )p->op;
    if (op == 171) {
      op = (int )p->op2;
    }
    if (op == 164) {
      goto _L;
    } else
    if (op == 162) {
      goto _L;
    } else
    if (op == 77) {
      _L: /* CIL Label */ 
      if ((unsigned long )p->y.pTab != (unsigned long )((Table *)0)) {
        j = (int )p->iColumn;
        if (j >= 0) {
          zColl = (char const   *)((p->y.pTab)->aCol + j)->zColl;
          pColl = sqlite3FindCollSeq(db, db->enc, zColl, 0);
        }
        break;
      }
    }
    if (op == 36) {
      p = p->pLeft;
      continue;
    } else
    if (op == 169) {
      p = p->pLeft;
      continue;
    }
    if (op == 109) {
      pColl = sqlite3GetCollSeq(pParse, db->enc, (CollSeq *)0, (char const   *)p->u.zToken);
      break;
    }
    if (p->flags & 256U) {
      if (p->pLeft) {
        if (((p->pLeft)->flags & 256U) != 0U) {
          p = p->pLeft;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        pNext = p->pRight;
        if ((unsigned long )p->x.pList != (unsigned long )((ExprList *)0)) {
          if (! ((p->flags & 2048U) != 0U)) {
            i = 0;
            while (i < (p->x.pList)->nExpr) {
              if ((((p->x.pList)->a[i].pExpr)->flags & 256U) != 0U) {
                pNext = (p->x.pList)->a[i].pExpr;
                break;
              }
              i ++;
            }
          }
        }
        p = pNext;
      }
    } else {
      break;
    }
  }
  tmp = sqlite3CheckCollSeq(pParse, pColl);
  if (tmp) {
    pColl = (CollSeq *)0;
  }
  return (pColl);
}
}
static CollSeq *sqlite3ExprNNCollSeq(Parse *pParse , Expr *pExpr ) 
{ 
  CollSeq *p ;
  CollSeq *tmp ;

  {
  tmp = sqlite3ExprCollSeq(pParse, pExpr);
  p = tmp;
  if ((unsigned long )p == (unsigned long )((CollSeq *)0)) {
    p = (pParse->db)->pDfltColl;
  }
  return (p);
}
}
static int sqlite3ExprCollSeqMatch(Parse *pParse , Expr *pE1 , Expr *pE2 ) 
{ 
  CollSeq *pColl1 ;
  CollSeq *tmp ;
  CollSeq *pColl2 ;
  CollSeq *tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3ExprNNCollSeq(pParse, pE1);
  pColl1 = tmp;
  tmp___0 = sqlite3ExprNNCollSeq(pParse, pE2);
  pColl2 = tmp___0;
  tmp___1 = sqlite3StrICmp((char const   *)pColl1->zName, (char const   *)pColl2->zName);
  return (tmp___1 == 0);
}
}
static char sqlite3CompareAffinity(Expr *pExpr , char aff2 ) 
{ 
  char aff1 ;
  char tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3ExprAffinity(pExpr);
  aff1 = tmp;
  if ((int )aff1 > 64) {
    if ((int )aff2 > 64) {
      if ((int )aff1 >= 67) {
        return ((char)67);
      } else
      if ((int )aff2 >= 67) {
        return ((char)67);
      } else {
        return ((char)65);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if ((int )aff1 <= 64) {
      tmp___0 = (int )aff2;
    } else {
      tmp___0 = (int )aff1;
    }
    return ((char )(tmp___0 | 64));
  }
}
}
static char comparisonAffinity(Expr *pExpr ) 
{ 
  char aff ;

  {
  aff = sqlite3ExprAffinity(pExpr->pLeft);
  if (pExpr->pRight) {
    aff = sqlite3CompareAffinity(pExpr->pRight, aff);
  } else
  if ((pExpr->flags & 2048U) != 0U) {
    aff = sqlite3CompareAffinity(((pExpr->x.pSelect)->pEList)->a[0].pExpr, aff);
  } else
  if ((int )aff == 0) {
    aff = (char)65;
  }
  return (aff);
}
}
static int sqlite3IndexAffinityOk(Expr *pExpr , char idx_affinity ) 
{ 
  char aff ;
  char tmp ;

  {
  tmp = comparisonAffinity(pExpr);
  aff = tmp;
  if ((int )aff < 66) {
    return (1);
  }
  if ((int )aff == 66) {
    return ((int )idx_affinity == 66);
  }
  return ((int )idx_affinity >= 67);
}
}
static u8 binaryCompareP5(Expr *pExpr1 , Expr *pExpr2 , int jumpIfNull ) 
{ 
  u8 aff ;
  char tmp ;
  char tmp___0 ;

  {
  tmp = sqlite3ExprAffinity(pExpr2);
  aff = (u8 )tmp;
  tmp___0 = sqlite3CompareAffinity(pExpr1, (char )aff);
  aff = (u8 )((int )((u8 )tmp___0) | (int )((u8 )jumpIfNull));
  return (aff);
}
}
static CollSeq *sqlite3BinaryCompareCollSeq(Parse *pParse , Expr *pLeft , Expr *pRight ) 
{ 
  CollSeq *pColl ;

  {
  if (pLeft->flags & 256U) {
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
  } else
  if (pRight) {
    if ((pRight->flags & 256U) != 0U) {
      pColl = sqlite3ExprCollSeq(pParse, pRight);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
    if (! pColl) {
      pColl = sqlite3ExprCollSeq(pParse, pRight);
    }
  }
  return (pColl);
}
}
static int codeCompare(Parse *pParse , Expr *pLeft , Expr *pRight , int opcode , int in1 ,
                       int in2 , int dest , int jumpIfNull ) 
{ 
  int p5 ;
  int addr ;
  CollSeq *p4 ;
  u8 tmp ;

  {
  p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
  tmp = binaryCompareP5(pLeft, pRight, jumpIfNull);
  p5 = (int )tmp;
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1, (char const   *)((void *)p4),
                           -2);
  sqlite3VdbeChangeP5(pParse->pVdbe, (u16 )((u8 )p5));
  return (addr);
}
}
static int sqlite3ExprIsVector(Expr *pExpr ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ExprVectorSize(pExpr);
  return (tmp > 1);
}
}
static int sqlite3ExprVectorSize(Expr *pExpr ) 
{ 
  u8 op ;

  {
  op = pExpr->op;
  if ((int )op == 171) {
    op = pExpr->op2;
  }
  if ((int )op == 172) {
    return ((pExpr->x.pList)->nExpr);
  } else
  if ((int )op == 134) {
    return (((pExpr->x.pSelect)->pEList)->nExpr);
  } else {
    return (1);
  }
}
}
static Expr *sqlite3VectorFieldSubexpr(Expr *pVector , int i ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ExprIsVector(pVector);
  if (tmp) {
    if ((int )pVector->op == 134) {
      return (((pVector->x.pSelect)->pEList)->a[i].pExpr);
    } else
    if ((int )pVector->op2 == 134) {
      return (((pVector->x.pSelect)->pEList)->a[i].pExpr);
    } else {
      return ((pVector->x.pList)->a[i].pExpr);
    }
  }
  return (pVector);
}
}
static Expr *sqlite3ExprForVectorField(Parse *pParse , Expr *pVector , int iField ) 
{ 
  Expr *pRet ;

  {
  if ((int )pVector->op == 134) {
    pRet = sqlite3PExpr(pParse, 173, (Expr *)0, (Expr *)0);
    if (pRet) {
      pRet->iColumn = (ynVar )iField;
      pRet->pLeft = pVector;
    }
  } else {
    if ((int )pVector->op == 172) {
      pVector = (pVector->x.pList)->a[iField].pExpr;
    }
    pRet = sqlite3ExprDup(pParse->db, pVector, 0);
    sqlite3RenameTokenRemap(pParse, (void *)pRet, (void *)pVector);
  }
  return (pRet);
}
}
static int exprCodeSubselect(Parse *pParse , Expr *pExpr ) 
{ 
  int reg ;

  {
  reg = 0;
  if ((int )pExpr->op == 134) {
    reg = sqlite3CodeSubselect(pParse, pExpr);
  }
  return (reg);
}
}
static int exprVectorRegister(Parse *pParse , Expr *pVector , int iField , int regSelect ,
                              Expr **ppExpr , int *pRegFree ) 
{ 
  u8 op ;
  int tmp ;

  {
  op = pVector->op;
  if ((int )op == 171) {
    *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);
    return (pVector->iTable + iField);
  }
  if ((int )op == 134) {
    *ppExpr = ((pVector->x.pSelect)->pEList)->a[iField].pExpr;
    return (regSelect + iField);
  }
  *ppExpr = (pVector->x.pList)->a[iField].pExpr;
  tmp = sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);
  return (tmp);
}
}
static void codeVectorCompare(Parse *pParse , Expr *pExpr , int dest , u8 op , u8 p5 ) 
{ 
  Vdbe *v ;
  Expr *pLeft ;
  Expr *pRight ;
  int nLeft ;
  int tmp ;
  int i ;
  int regLeft ;
  int regRight ;
  u8 opx ;
  int addrDone ;
  int tmp___0 ;
  int tmp___1 ;
  int regFree1 ;
  int regFree2 ;
  Expr *pL ;
  Expr *pR ;
  int r1 ;
  int r2 ;

  {
  v = pParse->pVdbe;
  pLeft = pExpr->pLeft;
  pRight = pExpr->pRight;
  tmp = sqlite3ExprVectorSize(pLeft);
  nLeft = tmp;
  regLeft = 0;
  regRight = 0;
  opx = op;
  tmp___0 = sqlite3VdbeMakeLabel(pParse);
  addrDone = tmp___0;
  tmp___1 = sqlite3ExprVectorSize(pRight);
  if (nLeft != tmp___1) {
    sqlite3ErrorMsg(pParse, "row value misused");
    return;
  }
  p5 = (u8 )((int )p5 | 32);
  if ((int )opx == 55) {
    opx = (u8 )56;
  }
  if ((int )opx == 57) {
    opx = (u8 )54;
  }
  regLeft = exprCodeSubselect(pParse, pLeft);
  regRight = exprCodeSubselect(pParse, pRight);
  i = 0;
  while (1) {
    regFree1 = 0;
    regFree2 = 0;
    r1 = exprVectorRegister(pParse, pLeft, i, regLeft, & pL, & regFree1);
    r2 = exprVectorRegister(pParse, pRight, i, regRight, & pR, & regFree2);
    codeCompare(pParse, pL, pR, (int )opx, r1, r2, dest, (int )p5);
    sqlite3ReleaseTempReg(pParse, regFree1);
    sqlite3ReleaseTempReg(pParse, regFree2);
    if (i == nLeft - 1) {
      break;
    }
    if ((int )opx == 53) {
      sqlite3VdbeAddOp2(v, 20, dest, addrDone);
      p5 = (u8 )((int )p5 | 8);
    } else
    if ((int )opx == 52) {
      sqlite3VdbeAddOp2(v, 18, dest, addrDone);
      p5 = (u8 )((int )p5 | 8);
    } else {
      sqlite3VdbeAddOp2(v, 58, 0, addrDone);
      if (i == nLeft - 2) {
        opx = op;
      }
    }
    i ++;
  }
  sqlite3VdbeResolveLabel(v, addrDone);
  return;
}
}
static int sqlite3ExprCheckHeight(Parse *pParse , int nHeight ) 
{ 
  int rc ;
  int mxHeight ;

  {
  rc = 0;
  mxHeight = (pParse->db)->aLimit[3];
  if (nHeight > mxHeight) {
    sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", mxHeight);
    rc = 1;
  }
  return (rc);
}
}
static void heightOfExpr(Expr *p , int *pnHeight ) 
{ 


  {
  if (p) {
    if (p->nHeight > *pnHeight) {
      *pnHeight = p->nHeight;
    }
  }
  return;
}
}
static void heightOfExprList(ExprList *p , int *pnHeight ) 
{ 
  int i ;

  {
  if (p) {
    i = 0;
    while (i < p->nExpr) {
      heightOfExpr(p->a[i].pExpr, pnHeight);
      i ++;
    }
  }
  return;
}
}
static void heightOfSelect(Select *pSelect , int *pnHeight ) 
{ 
  Select *p ;

  {
  p = pSelect;
  while (p) {
    heightOfExpr(p->pWhere, pnHeight);
    heightOfExpr(p->pHaving, pnHeight);
    heightOfExpr(p->pLimit, pnHeight);
    heightOfExprList(p->pEList, pnHeight);
    heightOfExprList(p->pGroupBy, pnHeight);
    heightOfExprList(p->pOrderBy, pnHeight);
    p = p->pPrior;
  }
  return;
}
}
static void exprSetHeight(Expr *p ) 
{ 
  int nHeight ;
  u32 tmp ;

  {
  nHeight = 0;
  heightOfExpr(p->pLeft, & nHeight);
  heightOfExpr(p->pRight, & nHeight);
  if ((p->flags & 2048U) != 0U) {
    heightOfSelect(p->x.pSelect, & nHeight);
  } else
  if (p->x.pList) {
    heightOfExprList(p->x.pList, & nHeight);
    tmp = sqlite3ExprListFlags((ExprList const   *)p->x.pList);
    p->flags |= 2097412U & tmp;
  }
  p->nHeight = nHeight + 1;
  return;
}
}
static void sqlite3ExprSetHeightAndFlags(Parse *pParse , Expr *p ) 
{ 


  {
  if (pParse->nErr) {
    return;
  }
  exprSetHeight(p);
  sqlite3ExprCheckHeight(pParse, p->nHeight);
  return;
}
}
static int sqlite3SelectExprHeight(Select *p ) 
{ 
  int nHeight ;

  {
  nHeight = 0;
  heightOfSelect(p, & nHeight);
  return (nHeight);
}
}
static Expr *sqlite3ExprAlloc(sqlite3 *db , int op , Token const   *pToken , int dequote ) 
{ 
  Expr *pNew ;
  int nExtra ;
  int iValue___0 ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  nExtra = 0;
  iValue___0 = 0;
  if (pToken) {
    if (op != 150) {
      nExtra = (int )(pToken->n + 1U);
    } else
    if ((unsigned long )pToken->z == (unsigned long )((char const   * const  )0)) {
      nExtra = (int )(pToken->n + 1U);
    } else {
      tmp = sqlite3GetInt32((char const   *)pToken->z, & iValue___0);
      if (tmp == 0) {
        nExtra = (int )(pToken->n + 1U);
      }
    }
  }
  tmp___0 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(Expr ) + (unsigned long )nExtra));
  pNew = (Expr *)tmp___0;
  if (pNew) {
    memset((void *)pNew, 0, sizeof(Expr ));
    pNew->op = (u8 )op;
    pNew->iAgg = (i16 )-1;
    if (pToken) {
      if (nExtra == 0) {
        if (iValue___0) {
          tmp___1 = 268435456;
        } else {
          tmp___1 = 536870912;
        }
        pNew->flags |= (unsigned int )(8389632 | tmp___1);
        pNew->u.iValue = iValue___0;
      } else {
        pNew->u.zToken = (char *)(pNew + 1);
        if (pToken->n) {
          memcpy((void * __restrict  )pNew->u.zToken, (void const   * __restrict  )pToken->z,
                 (size_t )pToken->n);
        }
        *(pNew->u.zToken + pToken->n) = (char)0;
        if (dequote) {
          if ((int const   )sqlite3CtypeMap[(unsigned char )*(pNew->u.zToken + 0)] & 128) {
            sqlite3DequoteExpr(pNew);
          }
        }
      }
    }
    pNew->nHeight = 1;
  }
  return (pNew);
}
}
static Expr *sqlite3Expr(sqlite3 *db , int op , char const   *zToken ) 
{ 
  Token x___0 ;
  int tmp ;
  Expr *tmp___0 ;

  {
  x___0.z = zToken;
  tmp = sqlite3Strlen30(zToken);
  x___0.n = (unsigned int )tmp;
  tmp___0 = sqlite3ExprAlloc(db, op, (Token const   *)(& x___0), 0);
  return (tmp___0);
}
}
static void sqlite3ExprAttachSubtrees(sqlite3 *db , Expr *pRoot , Expr *pLeft , Expr *pRight ) 
{ 


  {
  if ((unsigned long )pRoot == (unsigned long )((Expr *)0)) {
    sqlite3ExprDelete(db, pLeft);
    sqlite3ExprDelete(db, pRight);
  } else {
    if (pRight) {
      pRoot->pRight = pRight;
      pRoot->flags |= 2097412U & pRight->flags;
    }
    if (pLeft) {
      pRoot->pLeft = pLeft;
      pRoot->flags |= 2097412U & pLeft->flags;
    }
    exprSetHeight(pRoot);
  }
  return;
}
}
static Expr *sqlite3PExpr(Parse *pParse , int op , Expr *pLeft , Expr *pRight ) 
{ 
  Expr *p ;
  void *tmp ;

  {
  tmp = sqlite3DbMallocRawNN(pParse->db, (u64 )sizeof(Expr ));
  p = (Expr *)tmp;
  if (p) {
    memset((void *)p, 0, sizeof(Expr ));
    p->op = (u8 )(op & 255);
    p->iAgg = (i16 )-1;
    sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
    sqlite3ExprCheckHeight(pParse, p->nHeight);
  } else {
    sqlite3ExprDelete(pParse->db, pLeft);
    sqlite3ExprDelete(pParse->db, pRight);
  }
  return (p);
}
}
static void sqlite3PExprAddSelect(Parse *pParse , Expr *pExpr , Select *pSelect ) 
{ 


  {
  if (pExpr) {
    pExpr->x.pSelect = pSelect;
    pExpr->flags |= 2099200U;
    sqlite3ExprSetHeightAndFlags(pParse, pExpr);
  } else {
    sqlite3SelectDelete(pParse->db, pSelect);
  }
  return;
}
}
static Expr *sqlite3ExprAnd(Parse *pParse , Expr *pLeft , Expr *pRight ) 
{ 
  sqlite3 *db ;
  Expr *tmp ;
  Expr *tmp___0 ;

  {
  db = pParse->db;
  if ((unsigned long )pLeft == (unsigned long )((Expr *)0)) {
    return (pRight);
  } else
  if ((unsigned long )pRight == (unsigned long )((Expr *)0)) {
    return (pLeft);
  } else
  if ((pLeft->flags & 536870913U) == 536870912U) {
    sqlite3ExprUnmapAndDelete(pParse, pLeft);
    sqlite3ExprUnmapAndDelete(pParse, pRight);
    tmp = sqlite3Expr(db, 150, "0");
    return (tmp);
  } else
  if ((pRight->flags & 536870913U) == 536870912U) {
    sqlite3ExprUnmapAndDelete(pParse, pLeft);
    sqlite3ExprUnmapAndDelete(pParse, pRight);
    tmp = sqlite3Expr(db, 150, "0");
    return (tmp);
  } else {
    tmp___0 = sqlite3PExpr(pParse, 44, pLeft, pRight);
    return (tmp___0);
  }
}
}
static Expr *sqlite3ExprFunction(Parse *pParse , ExprList *pList , Token *pToken ,
                                 int eDistinct ) 
{ 
  Expr *pNew ;
  sqlite3 *db ;

  {
  db = pParse->db;
  pNew = sqlite3ExprAlloc(db, 167, (Token const   *)pToken, 1);
  if ((unsigned long )pNew == (unsigned long )((Expr *)0)) {
    sqlite3ExprListDelete(db, pList);
    return ((Expr *)0);
  }
  if (pList) {
    if (pList->nExpr > (pParse->db)->aLimit[6]) {
      sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
    }
  }
  pNew->x.pList = pList;
  pNew->flags |= 4U;
  sqlite3ExprSetHeightAndFlags(pParse, pNew);
  if (eDistinct == 1) {
    pNew->flags |= 2U;
  }
  return (pNew);
}
}
static void sqlite3ExprAssignVarNumber(Parse *pParse , Expr *pExpr , u32 n ) 
{ 
  sqlite3 *db ;
  char const   *z ;
  ynVar x___0 ;
  int doAdd ;
  i64 i ;
  int bOk ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  db = pParse->db;
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return;
  }
  z = (char const   *)pExpr->u.zToken;
  if ((int const   )*(z + 1) == 0) {
    pParse->nVar = (ynVar )((int )pParse->nVar + 1);
    x___0 = pParse->nVar;
  } else {
    doAdd = 0;
    if ((int const   )*(z + 0) == 63) {
      if (n == 2U) {
        i = (i64 )((int const   )*(z + 1) - 48);
        bOk = 1;
      } else {
        tmp = sqlite3Atoi64(z + 1, & i, (int )(n - 1U), (u8 )1);
        bOk = 0 == tmp;
      }
      if (bOk == 0) {
        sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", db->aLimit[9]);
        return;
      } else
      if (i < 1LL) {
        sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", db->aLimit[9]);
        return;
      } else
      if (i > (i64 )db->aLimit[9]) {
        sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", db->aLimit[9]);
        return;
      }
      x___0 = (ynVar )i;
      if ((int )x___0 > (int )pParse->nVar) {
        pParse->nVar = (ynVar )((int )x___0);
        doAdd = 1;
      } else {
        tmp___0 = sqlite3VListNumToName(pParse->pVList, (int )x___0);
        if ((unsigned long )tmp___0 == (unsigned long )((char const   *)0)) {
          doAdd = 1;
        }
      }
    } else {
      tmp___1 = sqlite3VListNameToNum(pParse->pVList, z, (int )n);
      x___0 = (ynVar )tmp___1;
      if ((int )x___0 == 0) {
        pParse->nVar = (ynVar )((int )pParse->nVar + 1);
        x___0 = pParse->nVar;
        doAdd = 1;
      }
    }
    if (doAdd) {
      pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, (int )n, (int )x___0);
    }
  }
  pExpr->iColumn = x___0;
  if ((int )x___0 > db->aLimit[9]) {
    sqlite3ErrorMsg(pParse, "too many SQL variables");
  }
  return;
}
}
static void ( __attribute__((__noinline__)) sqlite3ExprDeleteNN)(sqlite3 *db , Expr *p ) 
{ 


  {
  if (! ((p->flags & 8404992U) != 0U)) {
    if (p->pLeft) {
      if ((int )p->op != 173) {
        sqlite3ExprDeleteNN(db, p->pLeft);
      }
    }
    if (p->pRight) {
      sqlite3ExprDeleteNN(db, p->pRight);
    } else
    if ((p->flags & 2048U) != 0U) {
      sqlite3SelectDelete(db, p->x.pSelect);
    } else {
      sqlite3ExprListDelete(db, p->x.pList);
      if ((p->flags & 16777216U) != 0U) {
        sqlite3WindowDelete(db, p->y.pWin);
      }
    }
  }
  if ((p->flags & 65536U) != 0U) {
    sqlite3DbFree(db, (void *)p->u.zToken);
  }
  if (! ((p->flags & 134217728U) != 0U)) {
    sqlite3DbFreeNN(db, (void *)p);
  }
  return;
}
}
static void sqlite3ExprDelete(sqlite3 *db , Expr *p ) 
{ 


  {
  if (p) {
    sqlite3ExprDeleteNN(db, p);
  }
  return;
}
}
static void sqlite3ExprUnmapAndDelete(Parse *pParse , Expr *p ) 
{ 


  {
  if (p) {
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameExprUnmap(pParse, p);
    }
    sqlite3ExprDeleteNN(pParse->db, p);
  }
  return;
}
}
static int exprStructSize(Expr *p ) 
{ 


  {
  if ((p->flags & 16384U) != 0U) {
    return ((int )((unsigned long )(& ((Expr *)0)->pLeft)));
  }
  if ((p->flags & 8192U) != 0U) {
    return ((int )((unsigned long )(& ((Expr *)0)->iTable)));
  }
  return ((int )sizeof(Expr ));
}
}
static int dupedExprStructSize(Expr *p , int flags___0 ) 
{ 
  int nSize ;

  {
  if (0 == flags___0) {
    nSize = (int )sizeof(Expr );
  } else
  if ((int )p->op == 173) {
    nSize = (int )sizeof(Expr );
  } else
  if ((p->flags & 16777216U) != 0U) {
    nSize = (int )sizeof(Expr );
  } else
  if (p->pLeft) {
    nSize = (int )((unsigned long )(& ((Expr *)0)->iTable) | 8192UL);
  } else
  if (p->x.pList) {
    nSize = (int )((unsigned long )(& ((Expr *)0)->iTable) | 8192UL);
  } else {
    nSize = (int )((unsigned long )(& ((Expr *)0)->pLeft) | 16384UL);
  }
  return (nSize);
}
}
static int dupedExprNodeSize(Expr *p , int flags___0 ) 
{ 
  int nByte ;
  int tmp ;
  size_t tmp___0 ;

  {
  tmp = dupedExprStructSize(p, flags___0);
  nByte = tmp & 4095;
  if (! ((p->flags & 1024U) != 0U)) {
    if (p->u.zToken) {
      tmp___0 = strlen((char const   *)p->u.zToken);
      nByte = (int )((unsigned long )nByte + ((tmp___0 & 1073741823UL) + 1UL));
    }
  }
  return ((nByte + 7) & -8);
}
}
static int dupedExprSize(Expr *p , int flags___0 ) 
{ 
  int nByte ;
  int tmp ;
  int tmp___0 ;

  {
  nByte = 0;
  if (p) {
    nByte = dupedExprNodeSize(p, flags___0);
    if (flags___0 & 1) {
      tmp = dupedExprSize(p->pLeft, flags___0);
      tmp___0 = dupedExprSize(p->pRight, flags___0);
      nByte += tmp + tmp___0;
    }
  }
  return (nByte);
}
}
static Expr *exprDup(sqlite3 *db , Expr *p , int dupFlags , u8 **pzBuffer ) 
{ 
  Expr *pNew ;
  u8 *zAlloc ;
  u32 staticFlag ;
  int tmp ;
  void *tmp___0 ;
  unsigned int nStructSize ;
  int tmp___1 ;
  int nNewSize ;
  int nToken ;
  int tmp___2 ;
  u32 nSize ;
  int tmp___3 ;
  char *zToken ;
  char *tmp___4 ;
  int tmp___5 ;
  Expr *tmp___6 ;
  Expr *tmp___7 ;

  {
  if (pzBuffer) {
    zAlloc = *pzBuffer;
    staticFlag = (u32 )134217728;
  } else {
    tmp = dupedExprSize(p, dupFlags);
    tmp___0 = sqlite3DbMallocRawNN(db, (u64 )tmp);
    zAlloc = (u8 *)tmp___0;
    staticFlag = (u32 )0;
  }
  pNew = (Expr *)zAlloc;
  if (pNew) {
    tmp___1 = dupedExprStructSize(p, dupFlags);
    nStructSize = (unsigned int )tmp___1;
    nNewSize = (int )(nStructSize & 4095U);
    if (! ((p->flags & 1024U) != 0U)) {
      if (p->u.zToken) {
        tmp___2 = sqlite3Strlen30((char const   *)p->u.zToken);
        nToken = tmp___2 + 1;
      } else {
        nToken = 0;
      }
    } else {
      nToken = 0;
    }
    if (dupFlags) {
      memcpy((void * __restrict  )zAlloc, (void const   * __restrict  )p, (size_t )nNewSize);
    } else {
      tmp___3 = exprStructSize(p);
      nSize = (u32 )tmp___3;
      memcpy((void * __restrict  )zAlloc, (void const   * __restrict  )p, (size_t )nSize);
      if ((unsigned long )nSize < sizeof(Expr )) {
        memset((void *)(zAlloc + nSize), 0, sizeof(Expr ) - (unsigned long )nSize);
      }
    }
    pNew->flags &= 4160659455U;
    pNew->flags |= nStructSize & 24576U;
    pNew->flags |= staticFlag;
    if (nToken) {
      tmp___4 = (char *)(zAlloc + nNewSize);
      pNew->u.zToken = tmp___4;
      zToken = tmp___4;
      memcpy((void * __restrict  )zToken, (void const   * __restrict  )p->u.zToken,
             (size_t )nToken);
    }
    if (0U == ((p->flags | pNew->flags) & 8404992U)) {
      if ((p->flags & 2048U) != 0U) {
        pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);
      } else {
        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);
      }
    }
    if ((pNew->flags & 16801792U) != 0U) {
      tmp___5 = dupedExprNodeSize(p, dupFlags);
      zAlloc += tmp___5;
      if (! ((pNew->flags & 8404992U) != 0U)) {
        if (p->pLeft) {
          tmp___6 = exprDup(db, p->pLeft, 1, & zAlloc);
          pNew->pLeft = tmp___6;
        } else {
          pNew->pLeft = (Expr *)0;
        }
        if (p->pRight) {
          tmp___7 = exprDup(db, p->pRight, 1, & zAlloc);
          pNew->pRight = tmp___7;
        } else {
          pNew->pRight = (Expr *)0;
        }
      }
      if ((p->flags & 16777216U) != 0U) {
        pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);
      }
      if (pzBuffer) {
        *pzBuffer = zAlloc;
      }
    } else
    if (! ((p->flags & 8404992U) != 0U)) {
      if ((int )pNew->op == 173) {
        pNew->pLeft = p->pLeft;
      } else {
        pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);
      }
      pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);
    }
  }
  return (pNew);
}
}
static With *withDup(sqlite3 *db , With *p ) 
{ 
  With *pRet ;
  sqlite_int64 nByte ;
  void *tmp ;
  int i ;

  {
  pRet = (With *)0;
  if (p) {
    nByte = (sqlite_int64 )(sizeof(*p) + sizeof(p->a[0]) * (unsigned long )(p->nCte - 1));
    tmp = sqlite3DbMallocZero(db, (u64 )nByte);
    pRet = (With *)tmp;
    if (pRet) {
      pRet->nCte = p->nCte;
      i = 0;
      while (i < p->nCte) {
        pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);
        pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);
        pRet->a[i].zName = sqlite3DbStrDup(db, (char const   *)p->a[i].zName);
        i ++;
      }
    }
  }
  return (pRet);
}
}
static int gatherSelectWindowsCallback(Walker *pWalker , Expr *pExpr ) 
{ 
  Select *pSelect ;
  Window *pWin ;

  {
  if ((int )pExpr->op == 167) {
    if ((pExpr->flags & 16777216U) != 0U) {
      pSelect = pWalker->u.pSelect;
      pWin = pExpr->y.pWin;
      sqlite3WindowLink(pSelect, pWin);
    }
  }
  return (0);
}
}
static int gatherSelectWindowsSelectCallback(Walker *pWalker , Select *p ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p == (unsigned long )pWalker->u.pSelect) {
    tmp = 0;
  } else {
    tmp = 1;
  }
  return (tmp);
}
}
static void gatherSelectWindows(Select *p ) 
{ 
  Walker w ;

  {
  w.xExprCallback = & gatherSelectWindowsCallback;
  w.xSelectCallback = & gatherSelectWindowsSelectCallback;
  w.xSelectCallback2 = (void (*)(Walker * , Select * ))0;
  w.pParse = (Parse *)0;
  w.u.pSelect = p;
  sqlite3WalkSelect(& w, p);
  return;
}
}
static Expr *sqlite3ExprDup(sqlite3 *db , Expr *p , int flags___0 ) 
{ 
  Expr *tmp ;
  Expr *tmp___0 ;

  {
  if (p) {
    tmp = exprDup(db, p, flags___0, (u8 **)0);
    tmp___0 = tmp;
  } else {
    tmp___0 = (Expr *)0;
  }
  return (tmp___0);
}
}
static ExprList *sqlite3ExprListDup(sqlite3 *db , ExprList *p , int flags___0 ) 
{ 
  ExprList *pNew ;
  struct ExprList_item *pItem ;
  struct ExprList_item *pOldItem ;
  int i ;
  Expr *pPriorSelectCol ;
  int tmp ;
  void *tmp___0 ;
  Expr *pOldExpr ;
  Expr *pNewExpr ;
  Expr *tmp___1 ;

  {
  pPriorSelectCol = (Expr *)0;
  if ((unsigned long )p == (unsigned long )((ExprList *)0)) {
    return ((ExprList *)0);
  }
  tmp = sqlite3DbMallocSize(db, (void *)p);
  tmp___0 = sqlite3DbMallocRawNN(db, (u64 )tmp);
  pNew = (ExprList *)tmp___0;
  if ((unsigned long )pNew == (unsigned long )((ExprList *)0)) {
    return ((ExprList *)0);
  }
  pNew->nExpr = p->nExpr;
  pItem = pNew->a;
  pOldItem = p->a;
  i = 0;
  while (i < p->nExpr) {
    pOldExpr = pOldItem->pExpr;
    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags___0);
    if (pOldExpr) {
      if ((int )pOldExpr->op == 173) {
        pNewExpr = pItem->pExpr;
        if ((unsigned long )pNewExpr != (unsigned long )((Expr *)0)) {
          if ((int )pNewExpr->iColumn == 0) {
            tmp___1 = pNewExpr->pRight;
            pNewExpr->pLeft = tmp___1;
            pPriorSelectCol = tmp___1;
          } else {
            pNewExpr->pLeft = pPriorSelectCol;
          }
        }
      }
    }
    pItem->zName = sqlite3DbStrDup(db, (char const   *)pOldItem->zName);
    pItem->zSpan = sqlite3DbStrDup(db, (char const   *)pOldItem->zSpan);
    pItem->sortFlags = pOldItem->sortFlags;
    pItem->done = 0U;
    pItem->bNulls = pOldItem->bNulls;
    pItem->bSpanIsTab = pOldItem->bSpanIsTab;
    pItem->bSorterRef = pOldItem->bSorterRef;
    pItem->u = pOldItem->u;
    i ++;
    pItem ++;
    pOldItem ++;
  }
  return (pNew);
}
}
static SrcList *sqlite3SrcListDup(sqlite3 *db , SrcList *p , int flags___0 ) 
{ 
  SrcList *pNew ;
  int i ;
  int nByte ;
  unsigned long tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  struct SrcList_item *pNewItem ;
  struct SrcList_item *pOldItem ;
  Table *pTab ;
  Table *tmp___2 ;

  {
  if ((unsigned long )p == (unsigned long )((SrcList *)0)) {
    return ((SrcList *)0);
  }
  if (p->nSrc > 0) {
    tmp = sizeof(p->a[0]) * (unsigned long )(p->nSrc - 1);
  } else {
    tmp = 0UL;
  }
  nByte = (int )(sizeof(*p) + tmp);
  tmp___0 = sqlite3DbMallocRawNN(db, (u64 )nByte);
  pNew = (SrcList *)tmp___0;
  if ((unsigned long )pNew == (unsigned long )((SrcList *)0)) {
    return ((SrcList *)0);
  }
  tmp___1 = (u32 )p->nSrc;
  pNew->nAlloc = tmp___1;
  pNew->nSrc = (int )tmp___1;
  i = 0;
  while (i < p->nSrc) {
    pNewItem = & pNew->a[i];
    pOldItem = & p->a[i];
    pNewItem->pSchema = pOldItem->pSchema;
    pNewItem->zDatabase = sqlite3DbStrDup(db, (char const   *)pOldItem->zDatabase);
    pNewItem->zName = sqlite3DbStrDup(db, (char const   *)pOldItem->zName);
    pNewItem->zAlias = sqlite3DbStrDup(db, (char const   *)pOldItem->zAlias);
    pNewItem->fg = pOldItem->fg;
    pNewItem->iCursor = pOldItem->iCursor;
    pNewItem->addrFillSub = pOldItem->addrFillSub;
    pNewItem->regReturn = pOldItem->regReturn;
    if (pNewItem->fg.isIndexedBy) {
      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, (char const   *)pOldItem->u1.zIndexedBy);
    }
    pNewItem->pIBIndex = pOldItem->pIBIndex;
    if (pNewItem->fg.isTabFunc) {
      pNewItem->u1.pFuncArg = sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags___0);
    }
    tmp___2 = pOldItem->pTab;
    pNewItem->pTab = tmp___2;
    pTab = tmp___2;
    if (pTab) {
      (pTab->nTabRef) ++;
    }
    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags___0);
    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags___0);
    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);
    pNewItem->colUsed = pOldItem->colUsed;
    i ++;
  }
  return (pNew);
}
}
static IdList *sqlite3IdListDup(sqlite3 *db , IdList *p ) 
{ 
  IdList *pNew ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  struct IdList_item *pNewItem ;
  struct IdList_item *pOldItem ;

  {
  if ((unsigned long )p == (unsigned long )((IdList *)0)) {
    return ((IdList *)0);
  }
  tmp = sqlite3DbMallocRawNN(db, (u64 )sizeof(*pNew));
  pNew = (IdList *)tmp;
  if ((unsigned long )pNew == (unsigned long )((IdList *)0)) {
    return ((IdList *)0);
  }
  pNew->nId = p->nId;
  tmp___0 = sqlite3DbMallocRawNN(db, (u64 )((unsigned long )p->nId * sizeof(*(p->a + 0))));
  pNew->a = (struct IdList_item *)tmp___0;
  if ((unsigned long )pNew->a == (unsigned long )((struct IdList_item *)0)) {
    sqlite3DbFreeNN(db, (void *)pNew);
    return ((IdList *)0);
  }
  i = 0;
  while (i < p->nId) {
    pNewItem = pNew->a + i;
    pOldItem = p->a + i;
    pNewItem->zName = sqlite3DbStrDup(db, (char const   *)pOldItem->zName);
    pNewItem->idx = pOldItem->idx;
    i ++;
  }
  return (pNew);
}
}
static Select *sqlite3SelectDup(sqlite3 *db , Select *pDup , int flags___0 ) 
{ 
  Select *pRet ;
  Select *pNext ;
  Select **pp ;
  Select *p ;
  Select *pNew ;
  void *tmp ;

  {
  pRet = (Select *)0;
  pNext = (Select *)0;
  pp = & pRet;
  p = pDup;
  while (p) {
    tmp = sqlite3DbMallocRawNN(db, (u64 )sizeof(*p));
    pNew = (Select *)tmp;
    if ((unsigned long )pNew == (unsigned long )((Select *)0)) {
      break;
    }
    pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags___0);
    pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags___0);
    pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags___0);
    pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags___0);
    pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags___0);
    pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags___0);
    pNew->op = p->op;
    pNew->pNext = pNext;
    pNew->pPrior = (Select *)0;
    pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags___0);
    pNew->iLimit = 0;
    pNew->iOffset = 0;
    pNew->selFlags = p->selFlags & 4294967263U;
    pNew->addrOpenEphm[0] = -1;
    pNew->addrOpenEphm[1] = -1;
    pNew->nSelectRow = p->nSelectRow;
    pNew->pWith = withDup(db, p->pWith);
    pNew->pWin = (Window *)0;
    pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);
    if (p->pWin) {
      if ((int )db->mallocFailed == 0) {
        gatherSelectWindows(pNew);
      }
    }
    pNew->selId = p->selId;
    *pp = pNew;
    pp = & pNew->pPrior;
    pNext = pNew;
    p = p->pPrior;
  }
  return (pRet);
}
}
static ExprList *sqlite3ExprListAppend(Parse *pParse , ExprList *pList , Expr *pExpr ) 
{ 
  struct ExprList_item *pItem ;
  sqlite3 *db ;
  void *tmp ;
  ExprList *pNew ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  db = pParse->db;
  if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
    tmp = sqlite3DbMallocRawNN(db, (u64 )sizeof(ExprList ));
    pList = (ExprList *)tmp;
    if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
      goto no_mem;
    }
    pList->nExpr = 0;
  } else
  if ((pList->nExpr & (pList->nExpr - 1)) == 0) {
    tmp___0 = sqlite3DbRealloc(db, (void *)pList, (unsigned long long )sizeof(*pList) + (unsigned long long )(2LL * (sqlite_int64 )pList->nExpr - 1LL) * (unsigned long long )sizeof(pList->a[0]));
    pNew = (ExprList *)tmp___0;
    if ((unsigned long )pNew == (unsigned long )((ExprList *)0)) {
      goto no_mem;
    }
    pList = pNew;
  }
  tmp___1 = pList->nExpr;
  (pList->nExpr) ++;
  pItem = & pList->a[tmp___1];
  memset((void *)(& pItem->zName), 0, sizeof(*pItem) - (unsigned long )(& ((struct ExprList_item *)0)->zName));
  pItem->pExpr = pExpr;
  return (pList);
  no_mem: 
  sqlite3ExprDelete(db, pExpr);
  sqlite3ExprListDelete(db, pList);
  return ((ExprList *)0);
}
}
static ExprList *sqlite3ExprListAppendVector(Parse *pParse , ExprList *pList , IdList *pColumns ,
                                             Expr *pExpr ) 
{ 
  sqlite3 *db ;
  int n ;
  int i ;
  int iFirst ;
  int tmp ;
  Expr *pSubExpr ;
  Expr *tmp___0 ;
  Expr *pFirst ;

  {
  db = pParse->db;
  if (pList) {
    tmp = pList->nExpr;
  } else {
    tmp = 0;
  }
  iFirst = tmp;
  if ((unsigned long )pColumns == (unsigned long )((IdList *)0)) {
    goto vector_append_error;
  }
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    goto vector_append_error;
  }
  if ((int )pExpr->op != 134) {
    n = sqlite3ExprVectorSize(pExpr);
    if (pColumns->nId != n) {
      sqlite3ErrorMsg(pParse, "%d columns assigned %d values", pColumns->nId, n);
      goto vector_append_error;
    }
  }
  i = 0;
  while (i < pColumns->nId) {
    tmp___0 = sqlite3ExprForVectorField(pParse, pExpr, i);
    pSubExpr = tmp___0;
    if ((unsigned long )pSubExpr == (unsigned long )((Expr *)0)) {
      goto __Cont;
    }
    pSubExpr->iTable = pColumns->nId;
    pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
    if (pList) {
      pList->a[pList->nExpr - 1].zName = (pColumns->a + i)->zName;
      (pColumns->a + i)->zName = (char *)0;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! db->mallocFailed) {
    if ((int )pExpr->op == 134) {
      if ((unsigned long )pList != (unsigned long )((ExprList *)0)) {
        pFirst = pList->a[iFirst].pExpr;
        pFirst->pRight = pExpr;
        pExpr = (Expr *)0;
        pFirst->iTable = pColumns->nId;
      }
    }
  }
  vector_append_error: 
  sqlite3ExprUnmapAndDelete(pParse, pExpr);
  sqlite3IdListDelete(db, pColumns);
  return (pList);
}
}
static void sqlite3ExprListSetSortOrder(ExprList *p , int iSortOrder , int eNulls ) 
{ 
  struct ExprList_item *pItem ;

  {
  if ((unsigned long )p == (unsigned long )((ExprList *)0)) {
    return;
  }
  pItem = & p->a[p->nExpr - 1];
  if (iSortOrder == -1) {
    iSortOrder = 0;
  }
  pItem->sortFlags = (u8 )iSortOrder;
  if (eNulls != -1) {
    pItem->bNulls = 1U;
    if (iSortOrder != eNulls) {
      pItem->sortFlags = (u8 )((int )pItem->sortFlags | 2);
    }
  }
  return;
}
}
static void sqlite3ExprListSetName(Parse *pParse , ExprList *pList , Token *pName ,
                                   int dequote ) 
{ 
  struct ExprList_item *pItem ;

  {
  if (pList) {
    pItem = & pList->a[pList->nExpr - 1];
    pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, (u64 )pName->n);
    if (dequote) {
      sqlite3Dequote(pItem->zName);
    }
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameTokenMap(pParse, (void *)pItem->zName, pName);
    }
  }
  return;
}
}
static void sqlite3ExprListSetSpan(Parse *pParse , ExprList *pList , char const   *zStart ,
                                   char const   *zEnd ) 
{ 
  sqlite3 *db ;
  struct ExprList_item *pItem ;

  {
  db = pParse->db;
  if (pList) {
    pItem = & pList->a[pList->nExpr - 1];
    sqlite3DbFree(db, (void *)pItem->zSpan);
    pItem->zSpan = sqlite3DbSpanDup(db, zStart, zEnd);
  }
  return;
}
}
static void sqlite3ExprListCheckLength(Parse *pParse , ExprList *pEList , char const   *zObject ) 
{ 
  int mx ;

  {
  mx = (pParse->db)->aLimit[2];
  if (pEList) {
    if (pEList->nExpr > mx) {
      sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
    }
  }
  return;
}
}
static void ( __attribute__((__noinline__)) exprListDeleteNN)(sqlite3 *db , ExprList *pList ) 
{ 
  int i ;
  struct ExprList_item *pItem ;

  {
  i = pList->nExpr;
  pItem = pList->a;
  while (1) {
    sqlite3ExprDelete(db, pItem->pExpr);
    sqlite3DbFree(db, (void *)pItem->zName);
    sqlite3DbFree(db, (void *)pItem->zSpan);
    pItem ++;
    i --;
    if (! (i > 0)) {
      break;
    }
  }
  sqlite3DbFreeNN(db, (void *)pList);
  return;
}
}
static void sqlite3ExprListDelete(sqlite3 *db , ExprList *pList ) 
{ 


  {
  if (pList) {
    exprListDeleteNN(db, pList);
  }
  return;
}
}
static u32 sqlite3ExprListFlags(ExprList const   *pList ) 
{ 
  int i ;
  u32 m ;
  Expr *pExpr ;

  {
  m = (u32 )0;
  i = 0;
  while (i < (int )pList->nExpr) {
    pExpr = (Expr *)pList->a[i].pExpr;
    m |= pExpr->flags;
    i ++;
  }
  return (m);
}
}
static int sqlite3SelectWalkFail(Walker *pWalker , Select *NotUsed ) 
{ 


  {
  pWalker->eCode = (u8 )0;
  return (2);
}
}
static int sqlite3ExprIdToTrueFalse(Expr *pExpr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! ((pExpr->flags & 67108864U) != 0U)) {
    tmp___0 = sqlite3StrICmp((char const   *)pExpr->u.zToken, "true");
    if (tmp___0 == 0) {
      goto _L;
    } else {
      tmp___1 = sqlite3StrICmp((char const   *)pExpr->u.zToken, "false");
      if (tmp___1 == 0) {
        _L: /* CIL Label */ 
        pExpr->op = (u8 )165;
        if ((int )*(pExpr->u.zToken + 4) == 0) {
          tmp = 268435456;
        } else {
          tmp = 536870912;
        }
        pExpr->flags |= (unsigned int )tmp;
        return (1);
      }
    }
  }
  return (0);
}
}
static int sqlite3ExprTruthValue(Expr const   *pExpr ) 
{ 
  Expr *tmp ;

  {
  tmp = sqlite3ExprSkipCollate((Expr *)pExpr);
  pExpr = (Expr const   *)tmp;
  return ((int )*(pExpr->u.zToken + 4) == 0);
}
}
static Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr ) 
{ 
  Expr *pRight ;
  Expr *tmp ;
  Expr *pLeft ;
  Expr *tmp___0 ;

  {
  if ((int )pExpr->op == 44) {
    goto _L___1;
  } else
  if ((int )pExpr->op == 43) {
    _L___1: /* CIL Label */ 
    tmp = sqlite3ExprSimplifiedAndOr(pExpr->pRight);
    pRight = tmp;
    tmp___0 = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);
    pLeft = tmp___0;
    if ((pLeft->flags & 268435457U) == 268435456U) {
      goto _L___0;
    } else
    if ((pRight->flags & 536870913U) == 536870912U) {
      _L___0: /* CIL Label */ 
      if ((int )pExpr->op == 44) {
        pExpr = pRight;
      } else {
        pExpr = pLeft;
      }
    } else
    if ((pRight->flags & 268435457U) == 268435456U) {
      goto _L;
    } else
    if ((pLeft->flags & 536870913U) == 536870912U) {
      _L: /* CIL Label */ 
      if ((int )pExpr->op == 44) {
        pExpr = pLeft;
      } else {
        pExpr = pRight;
      }
    }
  }
  return (pExpr);
}
}
static int exprNodeIsConstant(Walker *pWalker , Expr *pExpr ) 
{ 
  int tmp ;

  {
  if ((int )pWalker->eCode == 2) {
    if ((pExpr->flags & 1U) != 0U) {
      pWalker->eCode = (u8 )0;
      return (2);
    }
  }
  switch ((int )pExpr->op) {
  case 167: 
  if ((int )pWalker->eCode >= 4) {
    return (0);
  } else
  if ((pExpr->flags & 524288U) != 0U) {
    return (0);
  } else {
    pWalker->eCode = (u8 )0;
    return (2);
  }
  case 59: 
  tmp = sqlite3ExprIdToTrueFalse(pExpr);
  if (tmp) {
    return (1);
  }
  case 164: 
  case 163: 
  case 162: ;
  if ((pExpr->flags & 8U) != 0U) {
    if ((int )pWalker->eCode != 2) {
      return (0);
    }
  }
  if ((int )pWalker->eCode == 3) {
    if (pExpr->iTable == pWalker->u.iCur) {
      return (0);
    }
  }
  case 171: 
  case 174: 
  pWalker->eCode = (u8 )0;
  return (2);
  case 151: 
  if ((int )pWalker->eCode == 5) {
    pExpr->op = (u8 )117;
  } else
  if ((int )pWalker->eCode == 4) {
    pWalker->eCode = (u8 )0;
    return (2);
  }
  default: ;
  return (0);
  }
}
}
static int exprIsConst(Expr *p , int initFlag , int iCur ) 
{ 
  Walker w ;

  {
  w.eCode = (u8 )initFlag;
  w.xExprCallback = & exprNodeIsConstant;
  w.xSelectCallback = & sqlite3SelectWalkFail;
  w.u.iCur = iCur;
  sqlite3WalkExpr(& w, p);
  return ((int )w.eCode);
}
}
static int sqlite3ExprIsConstant(Expr *p ) 
{ 
  int tmp ;

  {
  tmp = exprIsConst(p, 1, 0);
  return (tmp);
}
}
static int sqlite3ExprIsConstantNotJoin(Expr *p ) 
{ 
  int tmp ;

  {
  tmp = exprIsConst(p, 2, 0);
  return (tmp);
}
}
static int sqlite3ExprIsTableConstant(Expr *p , int iCur ) 
{ 
  int tmp ;

  {
  tmp = exprIsConst(p, 3, iCur);
  return (tmp);
}
}
static int exprNodeIsConstantOrGroupBy(Walker *pWalker , Expr *pExpr ) 
{ 
  ExprList *pGroupBy ;
  int i ;
  Expr *p ;
  CollSeq *pColl ;
  CollSeq *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pGroupBy = pWalker->u.pGroupBy;
  i = 0;
  while (i < pGroupBy->nExpr) {
    p = pGroupBy->a[i].pExpr;
    tmp___1 = sqlite3ExprCompare((Parse *)0, pExpr, p, -1);
    if (tmp___1 < 2) {
      tmp = sqlite3ExprNNCollSeq(pWalker->pParse, p);
      pColl = tmp;
      tmp___0 = sqlite3IsBinary((CollSeq const   *)pColl);
      if (tmp___0) {
        return (1);
      }
    }
    i ++;
  }
  if ((pExpr->flags & 2048U) != 0U) {
    pWalker->eCode = (u8 )0;
    return (2);
  }
  tmp___2 = exprNodeIsConstant(pWalker, pExpr);
  return (tmp___2);
}
}
static int sqlite3ExprIsConstantOrGroupBy(Parse *pParse , Expr *p , ExprList *pGroupBy ) 
{ 
  Walker w ;

  {
  w.eCode = (u8 )1;
  w.xExprCallback = & exprNodeIsConstantOrGroupBy;
  w.xSelectCallback = (int (*)(Walker * , Select * ))0;
  w.u.pGroupBy = pGroupBy;
  w.pParse = pParse;
  sqlite3WalkExpr(& w, p);
  return ((int )w.eCode);
}
}
static int sqlite3ExprIsConstantOrFunction(Expr *p , u8 isInit ) 
{ 
  int tmp ;

  {
  tmp = exprIsConst(p, 4 + (int )isInit, 0);
  return (tmp);
}
}
static int sqlite3ExprIsInteger(Expr *p , int *pValue ) 
{ 
  int rc ;
  int v ;
  int tmp ;

  {
  rc = 0;
  if ((unsigned long )p == (unsigned long )((Expr *)0)) {
    return (0);
  }
  if (p->flags & 1024U) {
    *pValue = p->u.iValue;
    return (1);
  }
  switch ((int )p->op) {
  case 169: 
  rc = sqlite3ExprIsInteger(p->pLeft, pValue);
  break;
  case 168: 
  tmp = sqlite3ExprIsInteger(p->pLeft, & v);
  if (tmp) {
    *pValue = - v;
    rc = 1;
  }
  break;
  default: 
  break;
  }
  return (rc);
}
}
static int sqlite3ExprCanBeNull(Expr const   *p ) 
{ 
  u8 op ;
  int tmp ;

  {
  while (1) {
    if (! ((int const   )p->op == 169)) {
      if (! ((int const   )p->op == 168)) {
        break;
      }
    }
    p = (Expr const   *)p->pLeft;
  }
  op = (u8 )p->op;
  if ((int )op == 171) {
    op = (u8 )p->op2;
  }
  switch ((int )op) {
  case 149: 
  case 148: 
  case 113: 
  case 150: 
  return (0);
  case 162: 
  if ((p->flags & 1048576U) != 0U) {
    tmp = 1;
  } else
  if ((unsigned long )p->y.pTab == (unsigned long )((Table * const  )0)) {
    tmp = 1;
  } else
  if ((int const   )p->iColumn >= 0) {
    if ((int )((p->y.pTab)->aCol + p->iColumn)->notNull == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
  default: 
  return (1);
  }
}
}
static int sqlite3ExprNeedsNoAffinityChange(Expr const   *p , char aff ) 
{ 
  u8 op ;
  int unaryMinus ;
  int tmp ;
  int tmp___0 ;

  {
  unaryMinus = 0;
  if ((int )aff == 65) {
    return (1);
  }
  while (1) {
    if (! ((int const   )p->op == 169)) {
      if (! ((int const   )p->op == 168)) {
        break;
      }
    }
    if ((int const   )p->op == 168) {
      unaryMinus = 1;
    }
    p = (Expr const   *)p->pLeft;
  }
  op = (u8 )p->op;
  if ((int )op == 171) {
    op = (u8 )p->op2;
  }
  switch ((int )op) {
  case 150: 
  return ((int )aff >= 67);
  case 148: 
  return ((int )aff >= 67);
  case 113: 
  if (! unaryMinus) {
    if ((int )aff == 66) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
  case 149: 
  return (! unaryMinus);
  case 162: 
  if ((int )aff >= 67) {
    if ((int const   )p->iColumn < 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
  default: 
  return (0);
  }
}
}
static int sqlite3IsRowid(char const   *z ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3StrICmp(z, "_ROWID_");
  if (tmp == 0) {
    return (1);
  }
  tmp___0 = sqlite3StrICmp(z, "ROWID");
  if (tmp___0 == 0) {
    return (1);
  }
  tmp___1 = sqlite3StrICmp(z, "OID");
  if (tmp___1 == 0) {
    return (1);
  }
  return (0);
}
}
static Select *isCandidateForInOpt(Expr *pX ) 
{ 
  Select *p ;
  SrcList *pSrc ;
  ExprList *pEList ;
  Table *pTab ;
  int i ;
  Expr *pRes ;

  {
  if (! ((pX->flags & 2048U) != 0U)) {
    return ((Select *)0);
  }
  if ((pX->flags & 32U) != 0U) {
    return ((Select *)0);
  }
  p = pX->x.pSelect;
  if (p->pPrior) {
    return ((Select *)0);
  }
  if (p->selFlags & 9U) {
    return ((Select *)0);
  }
  if (p->pLimit) {
    return ((Select *)0);
  }
  if (p->pWhere) {
    return ((Select *)0);
  }
  pSrc = p->pSrc;
  if (pSrc->nSrc != 1) {
    return ((Select *)0);
  }
  if (pSrc->a[0].pSelect) {
    return ((Select *)0);
  }
  pTab = pSrc->a[0].pTab;
  if (pTab->nModuleArg) {
    return ((Select *)0);
  }
  pEList = p->pEList;
  i = 0;
  while (i < pEList->nExpr) {
    pRes = pEList->a[i].pExpr;
    if ((int )pRes->op != 162) {
      return ((Select *)0);
    }
    i ++;
  }
  return (p);
}
}
static void sqlite3SetHasNullFlag(Vdbe *v , int iCur , int regHasNull ) 
{ 
  int addr1 ;

  {
  sqlite3VdbeAddOp2(v, 70, 0, regHasNull);
  addr1 = sqlite3VdbeAddOp1(v, 36, iCur);
  sqlite3VdbeAddOp3(v, 90, iCur, 0, regHasNull);
  sqlite3VdbeChangeP5(v, (u16 )128);
  sqlite3VdbeJumpHere(v, addr1);
  return;
}
}
static int sqlite3InRhsIsConstant(Expr *pIn ) 
{ 
  Expr *pLHS ;
  int res ;

  {
  pLHS = pIn->pLeft;
  pIn->pLeft = (Expr *)0;
  res = sqlite3ExprIsConstant(pIn);
  pIn->pLeft = pLHS;
  return (res);
}
}
static int sqlite3FindInIndex(Parse *pParse , Expr *pX , u32 inFlags , int *prRhsHasNull ,
                              int *aiMap , int *piTab ) 
{ 
  Select *p ;
  int eType ;
  int iTab ;
  int tmp ;
  int mustBeUnique ;
  Vdbe *v ;
  Vdbe *tmp___0 ;
  int i ;
  ExprList *pEList ;
  int tmp___1 ;
  sqlite3 *db ;
  Table *pTab ;
  i16 iDb ;
  ExprList *pEList___0 ;
  int nExpr ;
  int tmp___2 ;
  int iAddr ;
  int tmp___3 ;
  Index *pIdx ;
  int affinity_ok ;
  int i___0 ;
  Expr *pLhs ;
  Expr *tmp___4 ;
  int iCol ;
  char idxaff ;
  char tmp___5 ;
  char cmpaff ;
  char tmp___6 ;
  Bitmask colUsed ;
  Bitmask mCol ;
  Expr *pLhs___0 ;
  Expr *tmp___7 ;
  Expr *pRhs ;
  CollSeq *pReq ;
  CollSeq *tmp___8 ;
  int j ;
  int tmp___9 ;
  int iAddr___0 ;
  int tmp___10 ;
  int tmp___11 ;
  u32 savedNQueryLoop ;
  int rMayHaveNull ;
  int i___1 ;
  int n ;

  {
  eType = 0;
  tmp = pParse->nTab;
  (pParse->nTab) ++;
  iTab = tmp;
  tmp___0 = sqlite3GetVdbe(pParse);
  v = tmp___0;
  mustBeUnique = (inFlags & 4U) != 0U;
  if (prRhsHasNull) {
    if (pX->flags & 2048U) {
      pEList = (pX->x.pSelect)->pEList;
      i = 0;
      while (i < pEList->nExpr) {
        tmp___1 = sqlite3ExprCanBeNull((Expr const   *)pEList->a[i].pExpr);
        if (tmp___1) {
          break;
        }
        i ++;
      }
      if (i == pEList->nExpr) {
        prRhsHasNull = (int *)0;
      }
    }
  }
  if (pParse->nErr == 0) {
    p = isCandidateForInOpt(pX);
    if ((unsigned long )p != (unsigned long )((Select *)0)) {
      db = pParse->db;
      pEList___0 = p->pEList;
      nExpr = pEList___0->nExpr;
      pTab = (p->pSrc)->a[0].pTab;
      tmp___2 = sqlite3SchemaToIndex(db, pTab->pSchema);
      iDb = (i16 )tmp___2;
      sqlite3CodeVerifySchema(pParse, (int )iDb);
      sqlite3TableLock(pParse, (int )iDb, pTab->tnum, (u8 )0, (char const   *)pTab->zName);
      if (nExpr == 1) {
        if ((int )(pEList___0->a[0].pExpr)->iColumn < 0) {
          tmp___3 = sqlite3VdbeAddOp0(v, 17);
          iAddr = tmp___3;
          sqlite3OpenTable(pParse, iTab, (int )iDb, pTab, 97);
          eType = 1;
          sqlite3VdbeExplain(pParse, (u8 )0, "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR",
                             pTab->zName);
          sqlite3VdbeJumpHere(v, iAddr);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        affinity_ok = 1;
        i___0 = 0;
        while (1) {
          if (i___0 < nExpr) {
            if (! affinity_ok) {
              break;
            }
          } else {
            break;
          }
          tmp___4 = sqlite3VectorFieldSubexpr(pX->pLeft, i___0);
          pLhs = tmp___4;
          iCol = (int )(pEList___0->a[i___0].pExpr)->iColumn;
          tmp___5 = sqlite3TableColumnAffinity(pTab, iCol);
          idxaff = tmp___5;
          tmp___6 = sqlite3CompareAffinity(pLhs, idxaff);
          cmpaff = tmp___6;
          switch ((int )cmpaff) {
          case 65: 
          break;
          case 66: ;
          break;
          default: 
          affinity_ok = (int )idxaff >= 67;
          }
          i___0 ++;
        }
        if (affinity_ok) {
          pIdx = pTab->pIndex;
          while (1) {
            if (pIdx) {
              if (! (eType == 0)) {
                break;
              }
            } else {
              break;
            }
            if ((int )pIdx->nColumn < nExpr) {
              goto __Cont;
            }
            if ((unsigned long )pIdx->pPartIdxWhere != (unsigned long )((Expr *)0)) {
              goto __Cont;
            }
            if ((int )pIdx->nColumn >= (int )(sizeof(Bitmask ) * 8UL) - 1) {
              goto __Cont;
            }
            if (mustBeUnique) {
              if ((int )pIdx->nKeyCol > nExpr) {
                goto __Cont;
              } else
              if ((int )pIdx->nColumn > nExpr) {
                if (! ((int )pIdx->onError != 0)) {
                  goto __Cont;
                }
              }
            }
            colUsed = (Bitmask )0;
            i___0 = 0;
            while (i___0 < nExpr) {
              tmp___7 = sqlite3VectorFieldSubexpr(pX->pLeft, i___0);
              pLhs___0 = tmp___7;
              pRhs = pEList___0->a[i___0].pExpr;
              tmp___8 = sqlite3BinaryCompareCollSeq(pParse, pLhs___0, pRhs);
              pReq = tmp___8;
              j = 0;
              while (j < nExpr) {
                if ((int )*(pIdx->aiColumn + j) != (int )pRhs->iColumn) {
                  goto __Cont___0;
                }
                if ((unsigned long )pReq != (unsigned long )((CollSeq *)0)) {
                  tmp___9 = sqlite3StrICmp((char const   *)pReq->zName, *(pIdx->azColl + j));
                  if (tmp___9 != 0) {
                    goto __Cont___0;
                  }
                }
                break;
                __Cont___0: /* CIL Label */ 
                j ++;
              }
              if (j == nExpr) {
                break;
              }
              mCol = 1ULL << j;
              if (mCol & colUsed) {
                break;
              }
              colUsed |= mCol;
              if (aiMap) {
                *(aiMap + i___0) = j;
              }
              i___0 ++;
            }
            if (colUsed == (1ULL << nExpr) - 1ULL) {
              tmp___10 = sqlite3VdbeAddOp0(v, 17);
              iAddr___0 = tmp___10;
              sqlite3VdbeExplain(pParse, (u8 )0, "USING INDEX %s FOR IN-OPERATOR",
                                 pIdx->zName);
              sqlite3VdbeAddOp3(v, 97, iTab, pIdx->tnum, (int )iDb);
              sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
              eType = 3 + (int )*(pIdx->aSortOrder + 0);
              if (prRhsHasNull) {
                (pParse->nMem) ++;
                *prRhsHasNull = pParse->nMem;
                if (nExpr == 1) {
                  sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);
                }
              }
              sqlite3VdbeJumpHere(v, iAddr___0);
            }
            __Cont: /* CIL Label */ 
            pIdx = pIdx->pNext;
          }
        }
      }
    }
  }
  if (eType == 0) {
    if (inFlags & 1U) {
      if (! ((pX->flags & 2048U) != 0U)) {
        tmp___11 = sqlite3InRhsIsConstant(pX);
        if (tmp___11) {
          if ((pX->x.pList)->nExpr <= 2) {
            eType = 5;
          }
        } else {
          eType = 5;
        }
      }
    }
  }
  if (eType == 0) {
    savedNQueryLoop = pParse->nQueryLoop;
    rMayHaveNull = 0;
    eType = 2;
    if (inFlags & 4U) {
      pParse->nQueryLoop = (u32 )0;
    } else
    if (prRhsHasNull) {
      (pParse->nMem) ++;
      rMayHaveNull = pParse->nMem;
      *prRhsHasNull = rMayHaveNull;
    }
    sqlite3CodeRhsOfIN(pParse, pX, iTab);
    if (rMayHaveNull) {
      sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);
    }
    pParse->nQueryLoop = savedNQueryLoop;
  }
  if (aiMap) {
    if (eType != 3) {
      if (eType != 4) {
        n = sqlite3ExprVectorSize(pX->pLeft);
        i___1 = 0;
        while (i___1 < n) {
          *(aiMap + i___1) = i___1;
          i___1 ++;
        }
      }
    }
  }
  *piTab = iTab;
  return (eType);
}
}
static char *exprINAffinity(Parse *pParse , Expr *pExpr ) 
{ 
  Expr *pLeft ;
  int nVal ;
  int tmp ;
  Select *pSelect ;
  Select *tmp___0 ;
  char *zRet ;
  void *tmp___1 ;
  int i ;
  Expr *pA ;
  Expr *tmp___2 ;
  char a___0 ;
  char tmp___3 ;

  {
  pLeft = pExpr->pLeft;
  tmp = sqlite3ExprVectorSize(pLeft);
  nVal = tmp;
  if (pExpr->flags & 2048U) {
    tmp___0 = pExpr->x.pSelect;
  } else {
    tmp___0 = (Select *)0;
  }
  pSelect = tmp___0;
  tmp___1 = sqlite3DbMallocRaw(pParse->db, (u64 )(nVal + 1));
  zRet = (char *)tmp___1;
  if (zRet) {
    i = 0;
    while (i < nVal) {
      tmp___2 = sqlite3VectorFieldSubexpr(pLeft, i);
      pA = tmp___2;
      tmp___3 = sqlite3ExprAffinity(pA);
      a___0 = tmp___3;
      if (pSelect) {
        *(zRet + i) = sqlite3CompareAffinity((pSelect->pEList)->a[i].pExpr, a___0);
      } else {
        *(zRet + i) = a___0;
      }
      i ++;
    }
    *(zRet + nVal) = (char )'\000';
  }
  return (zRet);
}
}
static void sqlite3SubselectError(Parse *pParse , int nActual , int nExpect ) 
{ 
  char const   *zFmt ;

  {
  zFmt = "sub-select returns %d columns - expected %d";
  sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);
  return;
}
}
static void sqlite3VectorErrorMsg(Parse *pParse , Expr *pExpr ) 
{ 


  {
  if (pExpr->flags & 2048U) {
    sqlite3SubselectError(pParse, ((pExpr->x.pSelect)->pEList)->nExpr, 1);
  } else {
    sqlite3ErrorMsg(pParse, "row value misused");
  }
  return;
}
}
static void sqlite3CodeRhsOfIN(Parse *pParse , Expr *pExpr , int iTab ) 
{ 
  int addrOnce ;
  int addr ;
  Expr *pLeft ;
  KeyInfo *pKeyInfo ;
  int nVal ;
  Vdbe *v ;
  int tmp ;
  Select *pSelect ;
  ExprList *pEList ;
  char const   *tmp___0 ;
  SelectDest dest ;
  int i ;
  int tmp___1 ;
  Expr *p ;
  Expr *tmp___2 ;
  char affinity ;
  int i___0 ;
  ExprList *pList ;
  struct ExprList_item *pItem ;
  int r1 ;
  int r2 ;
  Expr *pE2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  addrOnce = 0;
  pKeyInfo = (KeyInfo *)0;
  v = pParse->pVdbe;
  if (! ((pExpr->flags & 32U) != 0U)) {
    if (pParse->iSelfTab == 0) {
      if ((pExpr->flags & 33554432U) != 0U) {
        addrOnce = sqlite3VdbeAddOp0(v, 17);
        if ((pExpr->flags & 2048U) != 0U) {
          sqlite3VdbeExplain(pParse, (u8 )0, "REUSE LIST SUBQUERY %d", (pExpr->x.pSelect)->selId);
        }
        sqlite3VdbeAddOp2(v, 12, pExpr->y.sub.regReturn, pExpr->y.sub.iAddr);
        sqlite3VdbeAddOp2(v, 109, iTab, pExpr->iTable);
        sqlite3VdbeJumpHere(v, addrOnce);
        return;
      }
      pExpr->flags |= 33554432U;
      (pParse->nMem) ++;
      pExpr->y.sub.regReturn = pParse->nMem;
      tmp = sqlite3VdbeAddOp2(v, 70, 0, pExpr->y.sub.regReturn);
      pExpr->y.sub.iAddr = tmp + 1;
      addrOnce = sqlite3VdbeAddOp0(v, 17);
    }
  }
  pLeft = pExpr->pLeft;
  nVal = sqlite3ExprVectorSize(pLeft);
  pExpr->iTable = iTab;
  addr = sqlite3VdbeAddOp2(v, 112, pExpr->iTable, nVal);
  pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);
  if ((pExpr->flags & 2048U) != 0U) {
    pSelect = pExpr->x.pSelect;
    pEList = pSelect->pEList;
    if (addrOnce) {
      tmp___0 = "";
    } else {
      tmp___0 = "CORRELATED ";
    }
    sqlite3VdbeExplain(pParse, (u8 )1, "%sLIST SUBQUERY %d", tmp___0, pSelect->selId);
    if (pEList->nExpr == nVal) {
      sqlite3SelectDestInit(& dest, 11, iTab);
      dest.zAffSdst = exprINAffinity(pParse, pExpr);
      pSelect->iLimit = 0;
      tmp___1 = sqlite3Select(pParse, pSelect, & dest);
      if (tmp___1) {
        sqlite3DbFree(pParse->db, (void *)dest.zAffSdst);
        sqlite3KeyInfoUnref(pKeyInfo);
        return;
      }
      sqlite3DbFree(pParse->db, (void *)dest.zAffSdst);
      i = 0;
      while (i < nVal) {
        tmp___2 = sqlite3VectorFieldSubexpr(pLeft, i);
        p = tmp___2;
        pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(pParse, p, pEList->a[i].pExpr);
        i ++;
      }
    }
  } else
  if ((unsigned long )pExpr->x.pList != (unsigned long )((ExprList *)0)) {
    pList = pExpr->x.pList;
    affinity = sqlite3ExprAffinity(pLeft);
    if ((int )affinity <= 64) {
      affinity = (char)65;
    }
    if (pKeyInfo) {
      pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    }
    r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3GetTempReg(pParse);
    i___0 = pList->nExpr;
    pItem = pList->a;
    while (i___0 > 0) {
      pE2 = pItem->pExpr;
      if (addrOnce) {
        tmp___3 = sqlite3ExprIsConstant(pE2);
        if (! tmp___3) {
          sqlite3VdbeChangeToNoop(v, addrOnce);
          pExpr->flags &= 4261412863U;
          addrOnce = 0;
        }
      }
      sqlite3ExprCode(pParse, pE2, r1);
      sqlite3VdbeAddOp4(v, 92, r1, 1, r2, (char const   *)(& affinity), 1);
      sqlite3VdbeAddOp4Int(v, 132, iTab, r2, r1, 1);
      i___0 --;
      pItem ++;
    }
    sqlite3ReleaseTempReg(pParse, r1);
    sqlite3ReleaseTempReg(pParse, r2);
  }
  if (pKeyInfo) {
    sqlite3VdbeChangeP4(v, addr, (char const   *)((void *)pKeyInfo), -9);
  }
  if (addrOnce) {
    sqlite3VdbeJumpHere(v, addrOnce);
    sqlite3VdbeAddOp1(v, 66, pExpr->y.sub.regReturn);
    tmp___4 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr - 1, tmp___4 - 1);
    sqlite3ClearTempRegCache(pParse);
  }
  return;
}
}
static int sqlite3CodeSubselect(Parse *pParse , Expr *pExpr ) 
{ 
  int addrOnce ;
  int rReg ;
  Select *pSel ;
  SelectDest dest ;
  int nReg ;
  Expr *pLimit ;
  Vdbe *v ;
  int tmp ;
  char const   *tmp___0 ;
  sqlite3 *db ;
  Expr *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  addrOnce = 0;
  rReg = 0;
  v = pParse->pVdbe;
  pSel = pExpr->x.pSelect;
  if (! ((pExpr->flags & 32U) != 0U)) {
    if ((pExpr->flags & 33554432U) != 0U) {
      sqlite3VdbeExplain(pParse, (u8 )0, "REUSE SUBQUERY %d", pSel->selId);
      sqlite3VdbeAddOp2(v, 12, pExpr->y.sub.regReturn, pExpr->y.sub.iAddr);
      return (pExpr->iTable);
    }
    pExpr->flags |= 33554432U;
    (pParse->nMem) ++;
    pExpr->y.sub.regReturn = pParse->nMem;
    tmp = sqlite3VdbeAddOp2(v, 70, 0, pExpr->y.sub.regReturn);
    pExpr->y.sub.iAddr = tmp + 1;
    addrOnce = sqlite3VdbeAddOp0(v, 17);
  }
  if (addrOnce) {
    tmp___0 = "";
  } else {
    tmp___0 = "CORRELATED ";
  }
  sqlite3VdbeExplain(pParse, (u8 )1, "%sSCALAR SUBQUERY %d", tmp___0, pSel->selId);
  if ((int )pExpr->op == 134) {
    nReg = (pSel->pEList)->nExpr;
  } else {
    nReg = 1;
  }
  sqlite3SelectDestInit(& dest, 0, pParse->nMem + 1);
  pParse->nMem += nReg;
  if ((int )pExpr->op == 134) {
    dest.eDest = (u8 )10;
    dest.iSdst = dest.iSDParm;
    dest.nSdst = nReg;
    sqlite3VdbeAddOp3(v, 73, 0, dest.iSDParm, (dest.iSDParm + nReg) - 1);
  } else {
    dest.eDest = (u8 )3;
    sqlite3VdbeAddOp2(v, 70, 0, dest.iSDParm);
  }
  if (pSel->pLimit) {
    db = pParse->db;
    pLimit = sqlite3Expr(db, 150, "0");
    if (pLimit) {
      pLimit->affExpr = (char)67;
      tmp___1 = sqlite3ExprDup(db, (pSel->pLimit)->pLeft, 0);
      pLimit = sqlite3PExpr(pParse, 52, tmp___1, pLimit);
    }
    sqlite3ExprDelete(db, (pSel->pLimit)->pLeft);
    (pSel->pLimit)->pLeft = pLimit;
  } else {
    pLimit = sqlite3Expr(pParse->db, 150, "1");
    pSel->pLimit = sqlite3PExpr(pParse, 144, pLimit, (Expr *)0);
  }
  pSel->iLimit = 0;
  tmp___2 = sqlite3Select(pParse, pSel, & dest);
  if (tmp___2) {
    return (0);
  }
  rReg = dest.iSDParm;
  pExpr->iTable = rReg;
  if (addrOnce) {
    sqlite3VdbeJumpHere(v, addrOnce);
    sqlite3VdbeAddOp1(v, 66, pExpr->y.sub.regReturn);
    tmp___3 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr - 1, tmp___3 - 1);
    sqlite3ClearTempRegCache(pParse);
  }
  return (rReg);
}
}
static int sqlite3ExprCheckIN(Parse *pParse , Expr *pIn ) 
{ 
  int nVector ;
  int tmp ;

  {
  tmp = sqlite3ExprVectorSize(pIn->pLeft);
  nVector = tmp;
  if (pIn->flags & 2048U) {
    if (nVector != ((pIn->x.pSelect)->pEList)->nExpr) {
      sqlite3SubselectError(pParse, ((pIn->x.pSelect)->pEList)->nExpr, nVector);
      return (1);
    }
  } else
  if (nVector != 1) {
    sqlite3VectorErrorMsg(pParse, pIn->pLeft);
    return (1);
  }
  return (0);
}
}
static void sqlite3ExprCodeIN(Parse *pParse , Expr *pExpr , int destIfFalse , int destIfNull ) 
{ 
  int rRhsHasNull ;
  int eType ;
  int rLhs ;
  int rLhsOrig ;
  Vdbe *v ;
  int *aiMap ;
  char *zAff___0 ;
  int nVector ;
  int iDummy ;
  Expr *pLeft ;
  int i ;
  int destStep2 ;
  int destStep6 ;
  int addrTruthOp ;
  int destNotNull ;
  int addrTop ;
  int iTab ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  ExprList *pList ;
  CollSeq *pColl ;
  CollSeq *tmp___2 ;
  int labelOk ;
  int tmp___3 ;
  int r2 ;
  int regToFree ;
  int regCkNull ;
  int ii ;
  int bLhsReal ;
  char tmp___4 ;
  int tmp___5 ;
  Expr *p ;
  Expr *tmp___6 ;
  int tmp___7 ;
  Expr *p___0 ;
  CollSeq *pColl___0 ;
  int r3 ;
  int tmp___8 ;

  {
  rRhsHasNull = 0;
  aiMap = (int *)0;
  zAff___0 = (char *)0;
  destStep6 = 0;
  iTab = 0;
  pLeft = pExpr->pLeft;
  tmp = sqlite3ExprCheckIN(pParse, pExpr);
  if (tmp) {
    return;
  }
  zAff___0 = exprINAffinity(pParse, pExpr);
  nVector = sqlite3ExprVectorSize(pExpr->pLeft);
  tmp___0 = sqlite3DbMallocZero(pParse->db, (u64 )((unsigned long )nVector * (sizeof(int ) + sizeof(char )) + 1UL));
  aiMap = (int *)tmp___0;
  if ((pParse->db)->mallocFailed) {
    goto sqlite3ExprCodeIN_oom_error;
  }
  v = pParse->pVdbe;
  if (destIfFalse == destIfNull) {
    tmp___1 = (int *)0;
  } else {
    tmp___1 = & rRhsHasNull;
  }
  eType = sqlite3FindInIndex(pParse, pExpr, (u32 )3, tmp___1, aiMap, & iTab);
  rLhsOrig = exprCodeVector(pParse, pLeft, & iDummy);
  i = 0;
  while (1) {
    if (i < nVector) {
      if (! (*(aiMap + i) == i)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (i == nVector) {
    rLhs = rLhsOrig;
  } else {
    rLhs = sqlite3GetTempRange(pParse, nVector);
    i = 0;
    while (i < nVector) {
      sqlite3VdbeAddOp3(v, 78, rLhsOrig + i, rLhs + *(aiMap + i), 0);
      i ++;
    }
  }
  if (eType == 5) {
    pList = pExpr->x.pList;
    tmp___2 = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    pColl = tmp___2;
    tmp___3 = sqlite3VdbeMakeLabel(pParse);
    labelOk = tmp___3;
    regCkNull = 0;
    if (destIfNull != destIfFalse) {
      regCkNull = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 99, rLhs, rLhs, regCkNull);
    }
    tmp___4 = sqlite3ExprAffinity(pExpr->pLeft);
    bLhsReal = (int )tmp___4 == 69;
    ii = 0;
    while (ii < pList->nExpr) {
      if (bLhsReal) {
        regToFree = sqlite3GetTempReg(pParse);
        r2 = regToFree;
        sqlite3ExprCode(pParse, pList->a[ii].pExpr, r2);
        sqlite3VdbeAddOp4(v, 91, r2, 1, 0, "E", -1);
      } else {
        r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, & regToFree);
      }
      if (regCkNull) {
        tmp___5 = sqlite3ExprCanBeNull((Expr const   *)pList->a[ii].pExpr);
        if (tmp___5) {
          sqlite3VdbeAddOp3(v, 99, regCkNull, r2, regCkNull);
        }
      }
      if (ii < pList->nExpr - 1) {
        sqlite3VdbeAddOp4(v, 53, rLhs, labelOk, r2, (char const   *)((void *)pColl),
                          -2);
        sqlite3VdbeChangeP5(v, (u16 )*(zAff___0 + 0));
      } else
      if (destIfNull != destIfFalse) {
        sqlite3VdbeAddOp4(v, 53, rLhs, labelOk, r2, (char const   *)((void *)pColl),
                          -2);
        sqlite3VdbeChangeP5(v, (u16 )*(zAff___0 + 0));
      } else {
        sqlite3VdbeAddOp4(v, 52, rLhs, destIfFalse, r2, (char const   *)((void *)pColl),
                          -2);
        sqlite3VdbeChangeP5(v, (u16 )((int )*(zAff___0 + 0) | 16));
      }
      sqlite3ReleaseTempReg(pParse, regToFree);
      ii ++;
    }
    if (regCkNull) {
      sqlite3VdbeAddOp2(v, 50, regCkNull, destIfNull);
      sqlite3VdbeGoto(v, destIfFalse);
    }
    sqlite3VdbeResolveLabel(v, labelOk);
    sqlite3ReleaseTempReg(pParse, regCkNull);
    goto sqlite3ExprCodeIN_finished;
  }
  if (destIfNull == destIfFalse) {
    destStep2 = destIfFalse;
  } else {
    destStep6 = sqlite3VdbeMakeLabel(pParse);
    destStep2 = destStep6;
  }
  i = 0;
  while (i < nVector) {
    tmp___6 = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);
    p = tmp___6;
    tmp___7 = sqlite3ExprCanBeNull((Expr const   *)p);
    if (tmp___7) {
      sqlite3VdbeAddOp2(v, 50, rLhs + i, destStep2);
    }
    i ++;
  }
  if (eType == 1) {
    sqlite3VdbeAddOp3(v, 30, iTab, destIfFalse, rLhs);
    addrTruthOp = sqlite3VdbeAddOp0(v, 11);
  } else {
    sqlite3VdbeAddOp4(v, 91, rLhs, nVector, 0, (char const   *)zAff___0, nVector);
    if (destIfFalse == destIfNull) {
      sqlite3VdbeAddOp4Int(v, 28, iTab, destIfFalse, rLhs, nVector);
      goto sqlite3ExprCodeIN_finished;
    }
    addrTruthOp = sqlite3VdbeAddOp4Int(v, 29, iTab, 0, rLhs, nVector);
  }
  if (rRhsHasNull) {
    if (nVector == 1) {
      sqlite3VdbeAddOp2(v, 51, rRhsHasNull, destIfFalse);
    }
  }
  if (destIfFalse == destIfNull) {
    sqlite3VdbeGoto(v, destIfFalse);
  }
  if (destStep6) {
    sqlite3VdbeResolveLabel(v, destStep6);
  }
  addrTop = sqlite3VdbeAddOp2(v, 36, iTab, destIfFalse);
  if (nVector > 1) {
    destNotNull = sqlite3VdbeMakeLabel(pParse);
  } else {
    destNotNull = destIfFalse;
  }
  i = 0;
  while (i < nVector) {
    tmp___8 = sqlite3GetTempReg(pParse);
    r3 = tmp___8;
    p___0 = sqlite3VectorFieldSubexpr(pLeft, i);
    pColl___0 = sqlite3ExprCollSeq(pParse, p___0);
    sqlite3VdbeAddOp3(v, 90, iTab, i, r3);
    sqlite3VdbeAddOp4(v, 52, rLhs + i, destNotNull, r3, (char const   *)((void *)pColl___0),
                      -2);
    sqlite3ReleaseTempReg(pParse, r3);
    i ++;
  }
  sqlite3VdbeAddOp2(v, 11, 0, destIfNull);
  if (nVector > 1) {
    sqlite3VdbeResolveLabel(v, destNotNull);
    sqlite3VdbeAddOp2(v, 5, iTab, addrTop + 1);
    sqlite3VdbeAddOp2(v, 11, 0, destIfFalse);
  }
  sqlite3VdbeJumpHere(v, addrTruthOp);
  sqlite3ExprCodeIN_finished: 
  if (rLhs != rLhsOrig) {
    sqlite3ReleaseTempReg(pParse, rLhs);
  }
  sqlite3ExprCodeIN_oom_error: 
  sqlite3DbFree(pParse->db, (void *)aiMap);
  sqlite3DbFree(pParse->db, (void *)zAff___0);
  return;
}
}
static void codeReal(Vdbe *v , char const   *z , int negateFlag , int iMem ) 
{ 
  double value ;
  int tmp ;

  {
  if ((unsigned long )z != (unsigned long )((char const   *)0)) {
    tmp = sqlite3Strlen30(z);
    sqlite3AtoF(z, & value, tmp, (u8 )1);
    if (negateFlag) {
      value = - value;
    }
    sqlite3VdbeAddOp4Dup8(v, 148, 0, iMem, 0, (u8 const   *)((u8 *)(& value)), -13);
  }
  return;
}
}
static void codeInteger(Parse *pParse , Expr *pExpr , int negFlag , int iMem ) 
{ 
  Vdbe *v ;
  int i ;
  int c ;
  i64 value ;
  char const   *z ;
  char const   *tmp ;
  int tmp___0 ;

  {
  v = pParse->pVdbe;
  if (pExpr->flags & 1024U) {
    i = pExpr->u.iValue;
    if (negFlag) {
      i = - i;
    }
    sqlite3VdbeAddOp2(v, 70, i, iMem);
  } else {
    z = (char const   *)pExpr->u.zToken;
    c = sqlite3DecOrHexToI64(z, & value);
    if (c == 3) {
      if (! negFlag) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (c == 2) {
      goto _L;
    } else
    if (negFlag) {
      if (value == -1LL - (4294967295LL | (2147483647LL << 32))) {
        _L: /* CIL Label */ 
        tmp___0 = sqlite3_strnicmp(z, "0x", 2);
        if (tmp___0 == 0) {
          if (negFlag) {
            tmp = "-";
          } else {
            tmp = "";
          }
          sqlite3ErrorMsg(pParse, "hex literal too big: %s%s", tmp, z);
        } else {
          codeReal(v, z, negFlag, iMem);
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if (negFlag) {
        if (c == 3) {
          value = -1LL - (4294967295LL | (2147483647LL << 32));
        } else {
          value = - value;
        }
      }
      sqlite3VdbeAddOp4Dup8(v, 71, 0, iMem, 0, (u8 const   *)((u8 *)(& value)), -14);
    }
  }
  return;
}
}
static void sqlite3ExprCodeLoadIndexColumn(Parse *pParse , Index *pIdx , int iTabCur ,
                                           int iIdxCol , int regOut ) 
{ 
  i16 iTabCol ;

  {
  iTabCol = *(pIdx->aiColumn + iIdxCol);
  if ((int )iTabCol == -2) {
    pParse->iSelfTab = iTabCur + 1;
    sqlite3ExprCodeCopy(pParse, (pIdx->aColExpr)->a[iIdxCol].pExpr, regOut);
    pParse->iSelfTab = 0;
  } else {
    sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur, (int )iTabCol,
                                    regOut);
  }
  return;
}
}
static void sqlite3ExprCodeGetColumnOfTable(Vdbe *v , Table *pTab , int iTabCur ,
                                            int iCol , int regOut ) 
{ 
  int op ;
  int tmp ;
  int x___0 ;
  Index *tmp___0 ;
  i16 tmp___1 ;

  {
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    sqlite3VdbeAddOp3(v, 90, iTabCur, iCol, regOut);
    return;
  }
  if (iCol < 0) {
    sqlite3VdbeAddOp2(v, 128, iTabCur, regOut);
  } else
  if (iCol == (int )pTab->iPKey) {
    sqlite3VdbeAddOp2(v, 128, iTabCur, regOut);
  } else {
    if (pTab->nModuleArg) {
      tmp = 164;
    } else {
      tmp = 90;
    }
    op = tmp;
    x___0 = iCol;
    if (! ((pTab->tabFlags & 32U) == 0U)) {
      if (! pTab->nModuleArg) {
        tmp___0 = sqlite3PrimaryKeyIndex(pTab);
        tmp___1 = sqlite3ColumnOfIndex(tmp___0, (i16 )iCol);
        x___0 = (int )tmp___1;
      }
    }
    sqlite3VdbeAddOp3(v, op, iTabCur, x___0, regOut);
  }
  if (iCol >= 0) {
    sqlite3ColumnDefault(v, pTab, iCol, regOut);
  }
  return;
}
}
static int sqlite3ExprCodeGetColumn(Parse *pParse , Table *pTab , int iColumn , int iTable ,
                                    int iReg , u8 p5 ) 
{ 
  Vdbe *v ;

  {
  v = pParse->pVdbe;
  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);
  if (p5) {
    sqlite3VdbeChangeP5(v, (u16 )p5);
  }
  return (iReg);
}
}
static void sqlite3ExprCodeMove(Parse *pParse , int iFrom , int iTo , int nReg ) 
{ 


  {
  sqlite3VdbeAddOp3(pParse->pVdbe, 77, iFrom, iTo, nReg);
  return;
}
}
static void exprToRegister(Expr *pExpr , int iReg ) 
{ 
  Expr *p ;
  Expr *tmp ;

  {
  tmp = sqlite3ExprSkipCollateAndLikely(pExpr);
  p = tmp;
  p->op2 = p->op;
  p->op = (u8 )171;
  p->iTable = iReg;
  p->flags &= 4294963199U;
  return;
}
}
static int exprCodeVector(Parse *pParse , Expr *p , int *piFreeable ) 
{ 
  int iResult ;
  int nResult ;
  int tmp ;
  int i ;

  {
  tmp = sqlite3ExprVectorSize(p);
  nResult = tmp;
  if (nResult == 1) {
    iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);
  } else {
    *piFreeable = 0;
    if ((int )p->op == 134) {
      iResult = sqlite3CodeSubselect(pParse, p);
    } else {
      iResult = pParse->nMem + 1;
      pParse->nMem += nResult;
      i = 0;
      while (i < nResult) {
        sqlite3ExprCodeFactorable(pParse, (p->x.pList)->a[i].pExpr, i + iResult);
        i ++;
      }
    }
  }
  return (iResult);
}
}
static char const   zAff[8]  = 
  {      (char const   )'B',      (char const   )'\000',      (char const   )'C',      (char const   )'\000', 
        (char const   )'D',      (char const   )'\000',      (char const   )'E',      (char const   )'\000'};
static int sqlite3ExprCodeTarget(Parse *pParse , Expr *pExpr , int target ) 
{ 
  Vdbe *v ;
  int op ;
  int inReg ;
  int regFree1 ;
  int regFree2 ;
  int r1 ;
  int r2 ;
  Expr tempX ;
  int p5 ;
  AggInfo *pAggInfo ;
  struct AggInfo_col *pCol ;
  int iTab ;
  int iReg ;
  int tmp ;
  int aff ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int n ;
  char const   *z ;
  char *zBlob ;
  int tmp___3 ;
  sqlite3 *tmp___4 ;
  void *tmp___5 ;
  char const   *z___0 ;
  char const   *tmp___6 ;
  char tmp___7 ;
  Expr *pLeft ;
  int tmp___8 ;
  Expr *pLeft___0 ;
  int isTrue ;
  int bNormal ;
  int addr ;
  AggInfo *pInfo ;
  ExprList *pFarg ;
  int nFarg ;
  FuncDef *pDef ;
  char const   *zId ;
  u32 constMask ;
  int i ;
  sqlite3 *db ;
  u8 enc ;
  CollSeq *pColl ;
  int tmp___9 ;
  int tmp___10 ;
  int endCoalesce ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  u8 exprOp ;
  int tmp___14 ;
  int nCol ;
  int tmp___15 ;
  int n___0 ;
  int destIfFalse ;
  int tmp___16 ;
  int destIfNull ;
  int tmp___17 ;
  Table *pTab ;
  int p1 ;
  int addrINR ;
  u8 okConstFactor ;
  int endLabel ;
  int nextCase ;
  int nExpr ;
  int i___0 ;
  ExprList *pEList ;
  struct ExprList_item *aListelem ;
  Expr opCompare ;
  Expr *pX ;
  Expr *pTest ;
  Expr *pDel ;
  sqlite3 *db___0 ;
  int tmp___18 ;

  {
  v = pParse->pVdbe;
  inReg = target;
  regFree1 = 0;
  regFree2 = 0;
  p5 = 0;
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return (0);
  }
  expr_code_doover: 
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    op = 117;
  } else {
    op = (int )pExpr->op;
  }
  switch (op) {
  case 164: 
  pAggInfo = pExpr->pAggInfo;
  pCol = pAggInfo->aCol + pExpr->iAgg;
  if (! pAggInfo->directMode) {
    return (pCol->iMem);
  } else
  if (pAggInfo->useSortingIdx) {
    sqlite3VdbeAddOp3(v, 90, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);
    return (target);
  }
  case 162: 
  iTab = pExpr->iTable;
  if ((pExpr->flags & 8U) != 0U) {
    tmp = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
    iReg = tmp;
    tmp___0 = sqlite3TableColumnAffinity(pExpr->y.pTab, (int )pExpr->iColumn);
    aff = (int )tmp___0;
    if (aff > 65) {
      if (iReg != target) {
        sqlite3VdbeAddOp2(v, 79, iReg, target);
        iReg = target;
      }
      sqlite3VdbeAddOp4(v, 91, iReg, 1, 0, & zAff[(aff - 66) * 2], -1);
    }
    return (iReg);
  }
  if (iTab < 0) {
    if (pParse->iSelfTab < 0) {
      if ((int )pExpr->iColumn >= 0) {
        if ((int )((pExpr->y.pTab)->aCol + pExpr->iColumn)->affinity == 69) {
          sqlite3VdbeAddOp2(v, 79, (int )pExpr->iColumn - pParse->iSelfTab, target);
          sqlite3VdbeAddOp1(v, 84, target);
          return (target);
        } else {
          return ((int )pExpr->iColumn - pParse->iSelfTab);
        }
      } else {
        return ((int )pExpr->iColumn - pParse->iSelfTab);
      }
    } else {
      iTab = pParse->iSelfTab - 1;
    }
  }
  tmp___1 = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab, (int )pExpr->iColumn,
                                     iTab, target, pExpr->op2);
  return (tmp___1);
  case 150: 
  codeInteger(pParse, pExpr, 0, target);
  return (target);
  case 165: 
  tmp___2 = sqlite3ExprTruthValue((Expr const   *)pExpr);
  sqlite3VdbeAddOp2(v, 70, tmp___2, target);
  return (target);
  case 148: 
  codeReal(v, (char const   *)pExpr->u.zToken, 0, target);
  return (target);
  case 113: 
  sqlite3VdbeLoadString(v, target, (char const   *)pExpr->u.zToken);
  return (target);
  case 117: 
  sqlite3VdbeAddOp2(v, 73, 0, target);
  return (target);
  case 149: 
  z = (char const   *)(pExpr->u.zToken + 2);
  tmp___3 = sqlite3Strlen30(z);
  n = tmp___3 - 1;
  tmp___4 = sqlite3VdbeDb(v);
  tmp___5 = sqlite3HexToBlob(tmp___4, z, n);
  zBlob = (char *)tmp___5;
  sqlite3VdbeAddOp4(v, 75, n / 2, target, 0, (char const   *)zBlob, -7);
  return (target);
  case 151: 
  sqlite3VdbeAddOp2(v, 76, (int )pExpr->iColumn, target);
  if ((int )*(pExpr->u.zToken + 1) != 0) {
    tmp___6 = sqlite3VListNumToName(pParse->pVList, (int )pExpr->iColumn);
    z___0 = tmp___6;
    *(pParse->pVList + 0) = 0;
    sqlite3VdbeAppendP4(v, (void *)((char *)z___0), -1);
  }
  return (target);
  case 171: 
  return (pExpr->iTable);
  case 36: 
  inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
  if (inReg != target) {
    sqlite3VdbeAddOp2(v, 79, inReg, target);
    inReg = target;
  }
  tmp___7 = sqlite3AffinityType((char const   *)pExpr->u.zToken, (Column *)0);
  sqlite3VdbeAddOp2(v, 85, target, (int )tmp___7);
  return (inReg);
  case 166: 
  case 45: 
  if (op == 45) {
    op = 53;
  } else {
    op = 52;
  }
  p5 = 128;
  case 53: 
  case 52: 
  case 57: 
  case 54: 
  case 55: 
  case 56: 
  pLeft = pExpr->pLeft;
  tmp___8 = sqlite3ExprIsVector(pLeft);
  if (tmp___8) {
    codeVectorCompare(pParse, pExpr, target, (u8 )op, (u8 )p5);
  } else {
    r1 = sqlite3ExprCodeTemp(pParse, pLeft, & regFree1);
    r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, & regFree2);
    codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2, inReg, 32 | p5);
  }
  break;
  case 108: 
  case 102: 
  case 101: 
  case 106: 
  case 100: 
  case 99: 
  case 107: 
  case 104: 
  case 105: 
  case 103: 
  case 43: 
  case 44: 
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, & regFree2);
  sqlite3VdbeAddOp3(v, op, r2, r1, target);
  break;
  case 168: 
  pLeft___0 = pExpr->pLeft;
  if ((int )pLeft___0->op == 150) {
    codeInteger(pParse, pLeft___0, 1, target);
    return (target);
  } else
  if ((int )pLeft___0->op == 148) {
    codeReal(v, (char const   *)pLeft___0->u.zToken, 1, target);
    return (target);
  } else {
    tempX.op = (u8 )150;
    tempX.flags = (u32 )17408;
    tempX.u.iValue = 0;
    r1 = sqlite3ExprCodeTemp(pParse, & tempX, & regFree1);
    r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree2);
    sqlite3VdbeAddOp3(v, 104, r2, r1, target);
  }
  break;
  case 19: 
  case 110: 
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  sqlite3VdbeAddOp2(v, op, r1, inReg);
  break;
  case 170: 
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  isTrue = sqlite3ExprTruthValue((Expr const   *)pExpr->pRight);
  bNormal = (int )pExpr->op2 == 45;
  sqlite3VdbeAddOp4Int(v, 88, r1, inReg, ! isTrue, isTrue ^ bNormal);
  break;
  case 51: 
  case 50: 
  sqlite3VdbeAddOp2(v, 70, 1, target);
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  addr = sqlite3VdbeAddOp1(v, op, r1);
  sqlite3VdbeAddOp2(v, 70, 0, target);
  sqlite3VdbeJumpHere(v, addr);
  break;
  case 163: 
  pInfo = pExpr->pAggInfo;
  if ((unsigned long )pInfo == (unsigned long )((AggInfo *)0)) {
    sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
  } else {
    return ((pInfo->aFunc + pExpr->iAgg)->iMem);
  }
  break;
  case 167: 
  constMask = (u32 )0;
  db = pParse->db;
  enc = db->enc;
  pColl = (CollSeq *)0;
  if ((pExpr->flags & 16777216U) != 0U) {
    return ((pExpr->y.pWin)->regResult);
  }
  if (pParse->okConstFactor) {
    tmp___10 = sqlite3ExprIsConstantNotJoin(pExpr);
    if (tmp___10) {
      tmp___9 = sqlite3ExprCodeAtInit(pParse, pExpr, -1);
      return (tmp___9);
    }
  }
  if ((pExpr->flags & 16384U) != 0U) {
    pFarg = (ExprList *)0;
  } else {
    pFarg = pExpr->x.pList;
  }
  if (pFarg) {
    nFarg = pFarg->nExpr;
  } else {
    nFarg = 0;
  }
  zId = (char const   *)pExpr->u.zToken;
  pDef = sqlite3FindFunction(db, zId, nFarg, enc, (u8 )0);
  if ((unsigned long )pDef == (unsigned long )((FuncDef *)0)) {
    sqlite3ErrorMsg(pParse, "unknown function: %s()", zId);
    break;
  } else
  if ((unsigned long )pDef->xFinalize != (unsigned long )((void (*)(sqlite3_context * ))0)) {
    sqlite3ErrorMsg(pParse, "unknown function: %s()", zId);
    break;
  }
  if (pDef->funcFlags & 512U) {
    tmp___11 = sqlite3VdbeMakeLabel(pParse);
    endCoalesce = tmp___11;
    sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
    i = 1;
    while (i < nFarg) {
      sqlite3VdbeAddOp2(v, 51, target, endCoalesce);
      sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
      i ++;
    }
    sqlite3VdbeResolveLabel(v, endCoalesce);
    break;
  }
  if (pDef->funcFlags & 1024U) {
    tmp___12 = sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);
    return (tmp___12);
  }
  i = 0;
  while (i < nFarg) {
    if (i < 32) {
      tmp___13 = sqlite3ExprIsConstant(pFarg->a[i].pExpr);
      if (tmp___13) {
        constMask |= 1U << i;
      }
    }
    if ((pDef->funcFlags & 32U) != 0U) {
      if (! pColl) {
        pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);
      }
    }
    i ++;
  }
  if (pFarg) {
    if (constMask) {
      r1 = pParse->nMem + 1;
      pParse->nMem += nFarg;
    } else {
      r1 = sqlite3GetTempRange(pParse, nFarg);
    }
    if ((pDef->funcFlags & 192U) != 0U) {
      exprOp = (pFarg->a[0].pExpr)->op;
      if ((int )exprOp == 162) {
        (pFarg->a[0].pExpr)->op2 = (u8 )(pDef->funcFlags & 192U);
      } else
      if ((int )exprOp == 164) {
        (pFarg->a[0].pExpr)->op2 = (u8 )(pDef->funcFlags & 192U);
      }
    }
    sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, (u8 )3);
  } else {
    r1 = 0;
  }
  if (nFarg >= 2) {
    if ((pExpr->flags & 128U) != 0U) {
      pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (nFarg > 0) {
    pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);
  }
  if (pDef->funcFlags & 32U) {
    if (! pColl) {
      pColl = db->pDfltColl;
    }
    sqlite3VdbeAddOp4(v, 82, 0, 0, 0, (char const   *)((char *)pColl), -2);
  }
  if (pParse->iSelfTab) {
    tmp___14 = 62;
  } else {
    tmp___14 = 63;
  }
  sqlite3VdbeAddOp4(v, tmp___14, (int )constMask, r1, target, (char const   *)((char *)pDef),
                    -8);
  sqlite3VdbeChangeP5(v, (u16 )((u8 )nFarg));
  if (nFarg) {
    if (constMask == 0U) {
      sqlite3ReleaseTempRange(pParse, r1, nFarg);
    }
  }
  return (target);
  case 134: 
  case 20: 
  if (op == 134) {
    nCol = ((pExpr->x.pSelect)->pEList)->nExpr;
    if (nCol != 1) {
      sqlite3SubselectError(pParse, nCol, 1);
    } else {
      tmp___15 = sqlite3CodeSubselect(pParse, pExpr);
      return (tmp___15);
    }
  } else {
    tmp___15 = sqlite3CodeSubselect(pParse, pExpr);
    return (tmp___15);
  }
  break;
  case 173: 
  if ((pExpr->pLeft)->iTable == 0) {
    (pExpr->pLeft)->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);
  }
  if (pExpr->iTable != 0) {
    n___0 = sqlite3ExprVectorSize(pExpr->pLeft);
    if (pExpr->iTable != n___0) {
      sqlite3ErrorMsg(pParse, "%d columns assigned %d values", pExpr->iTable, n___0);
    }
  }
  return ((pExpr->pLeft)->iTable + (int )pExpr->iColumn);
  case 49: 
  tmp___16 = sqlite3VdbeMakeLabel(pParse);
  destIfFalse = tmp___16;
  tmp___17 = sqlite3VdbeMakeLabel(pParse);
  destIfNull = tmp___17;
  sqlite3VdbeAddOp2(v, 73, 0, target);
  sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
  sqlite3VdbeAddOp2(v, 70, 1, target);
  sqlite3VdbeResolveLabel(v, destIfFalse);
  sqlite3VdbeAddOp2(v, 83, target, 0);
  sqlite3VdbeResolveLabel(v, destIfNull);
  return (target);
  case 48: 
  exprCodeBetween(pParse, pExpr, target, (void (*)(Parse * , Expr * , int  , int  ))0,
                  0);
  return (target);
  case 169: 
  case 109: 
  case 176: 
  pExpr = pExpr->pLeft;
  goto expr_code_doover;
  case 77: 
  pTab = pExpr->y.pTab;
  p1 = (pExpr->iTable * ((int )pTab->nCol + 1) + 1) + (int )pExpr->iColumn;
  sqlite3VdbeAddOp2(v, 149, p1, target);
  if ((int )pExpr->iColumn >= 0) {
    if ((int )(pTab->aCol + pExpr->iColumn)->affinity == 69) {
      sqlite3VdbeAddOp1(v, 84, target);
    }
  }
  break;
  case 172: 
  sqlite3ErrorMsg(pParse, "row value misused");
  break;
  case 174: 
  okConstFactor = pParse->okConstFactor;
  addrINR = sqlite3VdbeAddOp1(v, 21, pExpr->iTable);
  pParse->okConstFactor = (u8 )0;
  inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
  pParse->okConstFactor = okConstFactor;
  sqlite3VdbeJumpHere(v, addrINR);
  sqlite3VdbeChangeP3(v, addrINR, inReg);
  break;
  default: 
  pTest = (Expr *)0;
  pDel = (Expr *)0;
  db___0 = pParse->db;
  pEList = pExpr->x.pList;
  aListelem = pEList->a;
  nExpr = pEList->nExpr;
  endLabel = sqlite3VdbeMakeLabel(pParse);
  pX = pExpr->pLeft;
  if ((unsigned long )pX != (unsigned long )((Expr *)0)) {
    pDel = sqlite3ExprDup(db___0, pX, 0);
    if (db___0->mallocFailed) {
      sqlite3ExprDelete(db___0, pDel);
      break;
    }
    tmp___18 = exprCodeVector(pParse, pDel, & regFree1);
    exprToRegister(pDel, tmp___18);
    memset((void *)(& opCompare), 0, sizeof(opCompare));
    opCompare.op = (u8 )53;
    opCompare.pLeft = pDel;
    pTest = & opCompare;
    regFree1 = 0;
  }
  i___0 = 0;
  while (i___0 < nExpr - 1) {
    if (pX) {
      opCompare.pRight = (aListelem + i___0)->pExpr;
    } else {
      pTest = (aListelem + i___0)->pExpr;
    }
    nextCase = sqlite3VdbeMakeLabel(pParse);
    sqlite3ExprIfFalse(pParse, pTest, nextCase, 16);
    sqlite3ExprCode(pParse, (aListelem + (i___0 + 1))->pExpr, target);
    sqlite3VdbeGoto(v, endLabel);
    sqlite3VdbeResolveLabel(v, nextCase);
    i___0 += 2;
  }
  if ((nExpr & 1) != 0) {
    sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);
  } else {
    sqlite3VdbeAddOp2(v, 73, 0, target);
  }
  sqlite3ExprDelete(db___0, pDel);
  sqlite3VdbeResolveLabel(v, endLabel);
  break;
  case 71: 
  if (! pParse->pTriggerTab) {
    sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program");
    return (0);
  }
  if ((int )pExpr->affExpr == 2) {
    sqlite3MayAbort(pParse);
  }
  if ((int )pExpr->affExpr == 4) {
    sqlite3VdbeAddOp4(v, 69, 0, 4, 0, (char const   *)pExpr->u.zToken, 0);
  } else {
    sqlite3HaltConstraint(pParse, 19 | (7 << 8), (int )pExpr->affExpr, pExpr->u.zToken,
                          (i8 )0, (u8 )0);
  }
  break;
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return (inReg);
}
}
static int sqlite3ExprCodeAtInit(Parse *pParse , Expr *pExpr , int regDest ) 
{ 
  ExprList *p ;
  struct ExprList_item *pItem ;
  int i ;
  int tmp ;
  struct ExprList_item *pItem___0 ;

  {
  p = pParse->pConstExpr;
  if (regDest < 0) {
    if (p) {
      pItem = p->a;
      i = p->nExpr;
      while (i > 0) {
        if (pItem->reusable) {
          tmp = sqlite3ExprCompare((Parse *)0, pItem->pExpr, pExpr, -1);
          if (tmp == 0) {
            return (pItem->u.iConstExprReg);
          }
        }
        pItem ++;
        i --;
      }
    }
  }
  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
  p = sqlite3ExprListAppend(pParse, p, pExpr);
  if (p) {
    pItem___0 = & p->a[p->nExpr - 1];
    pItem___0->reusable = (unsigned int )(regDest < 0);
    if (regDest < 0) {
      (pParse->nMem) ++;
      regDest = pParse->nMem;
    }
    pItem___0->u.iConstExprReg = regDest;
  }
  pParse->pConstExpr = p;
  return (regDest);
}
}
static int sqlite3ExprCodeTemp(Parse *pParse , Expr *pExpr , int *pReg ) 
{ 
  int r2 ;
  int r1 ;
  int tmp ;
  int tmp___0 ;

  {
  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
  if (pParse->okConstFactor) {
    if ((int )pExpr->op != 171) {
      tmp___0 = sqlite3ExprIsConstantNotJoin(pExpr);
      if (tmp___0) {
        *pReg = 0;
        r2 = sqlite3ExprCodeAtInit(pParse, pExpr, -1);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    tmp = sqlite3GetTempReg(pParse);
    r1 = tmp;
    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
    if (r2 == r1) {
      *pReg = r1;
    } else {
      sqlite3ReleaseTempReg(pParse, r1);
      *pReg = 0;
    }
  }
  return (r2);
}
}
static void sqlite3ExprCode(Parse *pParse , Expr *pExpr , int target ) 
{ 
  int inReg ;

  {
  if (pExpr) {
    if ((int )pExpr->op == 171) {
      sqlite3VdbeAddOp2(pParse->pVdbe, 78, pExpr->iTable, target);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
    if (inReg != target) {
      if (pParse->pVdbe) {
        sqlite3VdbeAddOp2(pParse->pVdbe, 79, inReg, target);
      }
    }
  }
  return;
}
}
static void sqlite3ExprCodeCopy(Parse *pParse , Expr *pExpr , int target ) 
{ 
  sqlite3 *db ;

  {
  db = pParse->db;
  pExpr = sqlite3ExprDup(db, pExpr, 0);
  if (! db->mallocFailed) {
    sqlite3ExprCode(pParse, pExpr, target);
  }
  sqlite3ExprDelete(db, pExpr);
  return;
}
}
static void sqlite3ExprCodeFactorable(Parse *pParse , Expr *pExpr , int target ) 
{ 
  int tmp ;

  {
  if (pParse->okConstFactor) {
    tmp = sqlite3ExprIsConstantNotJoin(pExpr);
    if (tmp) {
      sqlite3ExprCodeAtInit(pParse, pExpr, target);
    } else {
      sqlite3ExprCode(pParse, pExpr, target);
    }
  } else {
    sqlite3ExprCode(pParse, pExpr, target);
  }
  return;
}
}
static void sqlite3ExprCodeAndCache(Parse *pParse , Expr *pExpr , int target ) 
{ 
  Vdbe *v ;
  int iMem ;

  {
  v = pParse->pVdbe;
  sqlite3ExprCode(pParse, pExpr, target);
  (pParse->nMem) ++;
  iMem = pParse->nMem;
  sqlite3VdbeAddOp2(v, 78, target, iMem);
  exprToRegister(pExpr, iMem);
  return;
}
}
static int sqlite3ExprCodeExprList(Parse *pParse , ExprList *pList , int target ,
                                   int srcReg , u8 flags___0 ) 
{ 
  struct ExprList_item *pItem ;
  int i ;
  int j ;
  int n ;
  u8 copyOp ;
  int tmp ;
  Vdbe *v ;
  Expr *pExpr ;
  int inReg ;
  int tmp___0 ;
  VdbeOp *pOp ;
  int tmp___1 ;

  {
  if ((int )flags___0 & 1) {
    tmp = 78;
  } else {
    tmp = 79;
  }
  copyOp = (u8 )tmp;
  v = pParse->pVdbe;
  n = pList->nExpr;
  if (! pParse->okConstFactor) {
    flags___0 = (u8 )((int )flags___0 & -3);
  }
  pItem = pList->a;
  i = 0;
  while (i < n) {
    pExpr = pItem->pExpr;
    if (((int )flags___0 & 4) != 0) {
      j = (int )pItem->u.x.iOrderByCol;
      if (j > 0) {
        if ((int )flags___0 & 8) {
          i --;
          n --;
        } else {
          sqlite3VdbeAddOp2(v, (int )copyOp, (j + srcReg) - 1, target + i);
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (((int )flags___0 & 2) != 0) {
      tmp___1 = sqlite3ExprIsConstantNotJoin(pExpr);
      if (tmp___1) {
        sqlite3ExprCodeAtInit(pParse, pExpr, target + i);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___0 = sqlite3ExprCodeTarget(pParse, pExpr, target + i);
      inReg = tmp___0;
      if (inReg != target + i) {
        if ((int )copyOp == 78) {
          pOp = sqlite3VdbeGetOp(v, -1);
          if ((int )pOp->opcode == 78) {
            if ((pOp->p1 + pOp->p3) + 1 == inReg) {
              if ((pOp->p2 + pOp->p3) + 1 == target + i) {
                (pOp->p3) ++;
              } else {
                sqlite3VdbeAddOp2(v, (int )copyOp, inReg, target + i);
              }
            } else {
              sqlite3VdbeAddOp2(v, (int )copyOp, inReg, target + i);
            }
          } else {
            sqlite3VdbeAddOp2(v, (int )copyOp, inReg, target + i);
          }
        } else {
          sqlite3VdbeAddOp2(v, (int )copyOp, inReg, target + i);
        }
      }
    }
    i ++;
    pItem ++;
  }
  return (n);
}
}
static void exprCodeBetween(Parse *pParse , Expr *pExpr , int dest , void (*xJump)(Parse * ,
                                                                                   Expr * ,
                                                                                   int  ,
                                                                                   int  ) ,
                            int jumpIfNull ) 
{ 
  Expr exprAnd ;
  Expr compLeft ;
  Expr compRight ;
  int regFree1 ;
  Expr *pDel ;
  sqlite3 *db ;
  int tmp ;

  {
  regFree1 = 0;
  pDel = (Expr *)0;
  db = pParse->db;
  memset((void *)(& compLeft), 0, sizeof(Expr ));
  memset((void *)(& compRight), 0, sizeof(Expr ));
  memset((void *)(& exprAnd), 0, sizeof(Expr ));
  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);
  if ((int )db->mallocFailed == 0) {
    exprAnd.op = (u8 )44;
    exprAnd.pLeft = & compLeft;
    exprAnd.pRight = & compRight;
    compLeft.op = (u8 )57;
    compLeft.pLeft = pDel;
    compLeft.pRight = (pExpr->x.pList)->a[0].pExpr;
    compRight.op = (u8 )55;
    compRight.pLeft = pDel;
    compRight.pRight = (pExpr->x.pList)->a[1].pExpr;
    tmp = exprCodeVector(pParse, pDel, & regFree1);
    exprToRegister(pDel, tmp);
    if (xJump) {
      (*xJump)(pParse, & exprAnd, dest, jumpIfNull);
    } else {
      pDel->flags |= 1U;
      sqlite3ExprCodeTarget(pParse, & exprAnd, dest);
    }
    sqlite3ReleaseTempReg(pParse, regFree1);
  }
  sqlite3ExprDelete(db, pDel);
  return;
}
}
static void sqlite3ExprIfTrue(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull ) 
{ 
  Vdbe *v ;
  int op ;
  int regFree1 ;
  int regFree2 ;
  int r1 ;
  int r2 ;
  Expr *pAlt ;
  Expr *tmp ;
  int d2 ;
  int tmp___0 ;
  int isNot ;
  int isTrue ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int destIfFalse ;
  int tmp___4 ;
  int destIfNull ;
  int tmp___5 ;

  {
  v = pParse->pVdbe;
  op = 0;
  regFree1 = 0;
  regFree2 = 0;
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return;
  }
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return;
  }
  op = (int )pExpr->op;
  switch (op) {
  case 43: 
  case 44: 
  tmp = sqlite3ExprSimplifiedAndOr(pExpr);
  pAlt = tmp;
  if ((unsigned long )pAlt != (unsigned long )pExpr) {
    sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);
  } else
  if (op == 44) {
    tmp___0 = sqlite3VdbeMakeLabel(pParse);
    d2 = tmp___0;
    sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);
    sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
    sqlite3VdbeResolveLabel(v, d2);
  } else {
    sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
    sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
  }
  break;
  case 19: 
  sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
  break;
  case 170: 
  isNot = (int )pExpr->op2 == 166;
  isTrue = sqlite3ExprTruthValue((Expr const   *)pExpr->pRight);
  if (isTrue ^ isNot) {
    if (isNot) {
      tmp___1 = 16;
    } else {
      tmp___1 = 0;
    }
    sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, tmp___1);
  } else {
    if (isNot) {
      tmp___2 = 16;
    } else {
      tmp___2 = 0;
    }
    sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, tmp___2);
  }
  break;
  case 166: 
  case 45: ;
  if (op == 45) {
    op = 53;
  } else {
    op = 52;
  }
  jumpIfNull = 128;
  case 53: 
  case 52: 
  case 57: 
  case 54: 
  case 55: 
  case 56: 
  tmp___3 = sqlite3ExprIsVector(pExpr->pLeft);
  if (tmp___3) {
    goto default_expr;
  }
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, & regFree2);
  codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull);
  break;
  case 51: 
  case 50: 
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  sqlite3VdbeAddOp2(v, op, r1, dest);
  break;
  case 48: 
  exprCodeBetween(pParse, pExpr, dest, & sqlite3ExprIfTrue, jumpIfNull);
  break;
  case 49: 
  tmp___4 = sqlite3VdbeMakeLabel(pParse);
  destIfFalse = tmp___4;
  if (jumpIfNull) {
    tmp___5 = dest;
  } else {
    tmp___5 = destIfFalse;
  }
  destIfNull = tmp___5;
  sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
  sqlite3VdbeGoto(v, dest);
  sqlite3VdbeResolveLabel(v, destIfFalse);
  break;
  default_expr: 
  default: 
  if ((pExpr->flags & 268435457U) == 268435456U) {
    sqlite3VdbeGoto(v, dest);
  } else
  if (! ((pExpr->flags & 536870913U) == 536870912U)) {
    r1 = sqlite3ExprCodeTemp(pParse, pExpr, & regFree1);
    sqlite3VdbeAddOp3(v, 18, r1, dest, jumpIfNull != 0);
  }
  break;
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return;
}
}
static void sqlite3ExprIfFalse(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull ) 
{ 
  Vdbe *v ;
  int op ;
  int regFree1 ;
  int regFree2 ;
  int r1 ;
  int r2 ;
  Expr *pAlt ;
  Expr *tmp ;
  int d2 ;
  int tmp___0 ;
  int isNot ;
  int isTrue ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int destIfNull ;
  int tmp___4 ;

  {
  v = pParse->pVdbe;
  op = 0;
  regFree1 = 0;
  regFree2 = 0;
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return;
  }
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return;
  }
  op = (int )pExpr->op ^ 1;
  switch ((int )pExpr->op) {
  case 43: 
  case 44: 
  tmp = sqlite3ExprSimplifiedAndOr(pExpr);
  pAlt = tmp;
  if ((unsigned long )pAlt != (unsigned long )pExpr) {
    sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);
  } else
  if ((int )pExpr->op == 44) {
    sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
    sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
  } else {
    tmp___0 = sqlite3VdbeMakeLabel(pParse);
    d2 = tmp___0;
    sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);
    sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
    sqlite3VdbeResolveLabel(v, d2);
  }
  break;
  case 19: 
  sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
  break;
  case 170: 
  isNot = (int )pExpr->op2 == 166;
  isTrue = sqlite3ExprTruthValue((Expr const   *)pExpr->pRight);
  if (isTrue ^ isNot) {
    if (isNot) {
      tmp___1 = 0;
    } else {
      tmp___1 = 16;
    }
    sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, tmp___1);
  } else {
    if (isNot) {
      tmp___2 = 0;
    } else {
      tmp___2 = 16;
    }
    sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, tmp___2);
  }
  break;
  case 166: 
  case 45: ;
  if ((int )pExpr->op == 45) {
    op = 52;
  } else {
    op = 53;
  }
  jumpIfNull = 128;
  case 53: 
  case 52: 
  case 57: 
  case 54: 
  case 55: 
  case 56: 
  tmp___3 = sqlite3ExprIsVector(pExpr->pLeft);
  if (tmp___3) {
    goto default_expr;
  }
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, & regFree2);
  codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull);
  break;
  case 51: 
  case 50: 
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, & regFree1);
  sqlite3VdbeAddOp2(v, op, r1, dest);
  break;
  case 48: 
  exprCodeBetween(pParse, pExpr, dest, & sqlite3ExprIfFalse, jumpIfNull);
  break;
  case 49: 
  if (jumpIfNull) {
    sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
  } else {
    tmp___4 = sqlite3VdbeMakeLabel(pParse);
    destIfNull = tmp___4;
    sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
    sqlite3VdbeResolveLabel(v, destIfNull);
  }
  break;
  default_expr: 
  default: 
  if ((pExpr->flags & 536870913U) == 536870912U) {
    sqlite3VdbeGoto(v, dest);
  } else
  if (! ((pExpr->flags & 268435457U) == 268435456U)) {
    r1 = sqlite3ExprCodeTemp(pParse, pExpr, & regFree1);
    sqlite3VdbeAddOp3(v, 20, r1, dest, jumpIfNull != 0);
  }
  break;
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return;
}
}
static void sqlite3ExprIfFalseDup(Parse *pParse , Expr *pExpr , int dest , int jumpIfNull ) 
{ 
  sqlite3 *db ;
  Expr *pCopy ;
  Expr *tmp ;

  {
  db = pParse->db;
  tmp = sqlite3ExprDup(db, pExpr, 0);
  pCopy = tmp;
  if ((int )db->mallocFailed == 0) {
    sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);
  }
  sqlite3ExprDelete(db, pCopy);
  return;
}
}
static int exprCompareVariable(Parse *pParse , Expr *pVar , Expr *pExpr ) 
{ 
  int res ;
  int iVar ;
  sqlite3_value *pL ;
  sqlite3_value *pR ;
  int tmp ;
  int tmp___0 ;

  {
  res = 0;
  pR = (sqlite3_value *)0;
  sqlite3ValueFromExpr(pParse->db, pExpr, (u8 )1, (u8 )65, & pR);
  if (pR) {
    iVar = (int )pVar->iColumn;
    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);
    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, (u8 )65);
    if (pL) {
      tmp = sqlite3_value_type(pL);
      if (tmp == 3) {
        sqlite3_value_text(pL);
      }
      tmp___0 = sqlite3MemCompare((Mem const   *)pL, (Mem const   *)pR, (CollSeq const   *)0);
      res = 0 == tmp___0;
    }
    sqlite3ValueFree(pR);
    sqlite3ValueFree(pL);
  }
  return (res);
}
}
static int sqlite3ExprCompare(Parse *pParse , Expr *pA , Expr *pB , int iTab ) 
{ 
  u32 combinedFlags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  if ((unsigned long )pA == (unsigned long )((Expr *)0)) {
    goto _L;
  } else
  if ((unsigned long )pB == (unsigned long )((Expr *)0)) {
    _L: /* CIL Label */ 
    if ((unsigned long )pB == (unsigned long )pA) {
      tmp = 0;
    } else {
      tmp = 2;
    }
    return (tmp);
  }
  if (pParse) {
    if ((int )pA->op == 151) {
      tmp___0 = exprCompareVariable(pParse, pA, pB);
      if (tmp___0) {
        return (0);
      }
    }
  }
  combinedFlags = pA->flags | pB->flags;
  if (combinedFlags & 1024U) {
    if (((pA->flags & pB->flags) & 1024U) != 0U) {
      if (pA->u.iValue == pB->u.iValue) {
        return (0);
      }
    }
    return (2);
  }
  if ((int )pA->op != (int )pB->op) {
    goto _L___0;
  } else
  if ((int )pA->op == 71) {
    _L___0: /* CIL Label */ 
    if ((int )pA->op == 109) {
      tmp___1 = sqlite3ExprCompare(pParse, pA->pLeft, pB, iTab);
      if (tmp___1 < 2) {
        return (1);
      }
    }
    if ((int )pB->op == 109) {
      tmp___2 = sqlite3ExprCompare(pParse, pA, pB->pLeft, iTab);
      if (tmp___2 < 2) {
        return (1);
      }
    }
    return (2);
  }
  if ((int )pA->op != 162) {
    if ((int )pA->op != 164) {
      if (pA->u.zToken) {
        if ((int )pA->op == 167) {
          goto _L___1;
        } else
        if ((int )pA->op == 163) {
          _L___1: /* CIL Label */ 
          tmp___3 = sqlite3StrICmp((char const   *)pA->u.zToken, (char const   *)pB->u.zToken);
          if (tmp___3 != 0) {
            return (2);
          }
          if (((pA->flags & 16777216U) != 0U) != ((pB->flags & 16777216U) != 0U)) {
            return (2);
          }
          if ((pA->flags & 16777216U) != 0U) {
            tmp___4 = sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1);
            if (tmp___4 != 0) {
              return (2);
            }
          }
        } else
        if ((int )pA->op == 117) {
          return (0);
        } else
        if ((int )pA->op == 109) {
          tmp___5 = sqlite3_stricmp((char const   *)pA->u.zToken, (char const   *)pB->u.zToken);
          if (tmp___5 != 0) {
            return (2);
          }
        } else
        if ((unsigned long )pB->u.zToken != (unsigned long )((char *)0)) {
          tmp___6 = strcmp((char const   *)pA->u.zToken, (char const   *)pB->u.zToken);
          if (tmp___6 != 0) {
            return (2);
          }
        }
      }
    }
  }
  if ((pA->flags & 2U) != (pB->flags & 2U)) {
    return (2);
  }
  if ((combinedFlags & 16384U) == 0U) {
    if (combinedFlags & 2048U) {
      return (2);
    }
    if ((combinedFlags & 8U) == 0U) {
      tmp___7 = sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab);
      if (tmp___7) {
        return (2);
      }
    }
    tmp___8 = sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab);
    if (tmp___8) {
      return (2);
    }
    tmp___9 = sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab);
    if (tmp___9) {
      return (2);
    }
    if ((int )pA->op != 113) {
      if ((int )pA->op != 165) {
        if ((combinedFlags & 8192U) == 0U) {
          if ((int )pA->iColumn != (int )pB->iColumn) {
            return (2);
          }
          if ((int )pA->op2 != (int )pB->op2) {
            return (2);
          }
          if ((int )pA->op != 49) {
            if (pA->iTable != pB->iTable) {
              if (pA->iTable != iTab) {
                return (2);
              } else
              if (pB->iTable >= 0) {
                return (2);
              }
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static int sqlite3ExprListCompare(ExprList *pA , ExprList *pB , int iTab ) 
{ 
  int i ;
  Expr *pExprA ;
  Expr *pExprB ;
  int tmp ;

  {
  if ((unsigned long )pA == (unsigned long )((ExprList *)0)) {
    if ((unsigned long )pB == (unsigned long )((ExprList *)0)) {
      return (0);
    }
  }
  if ((unsigned long )pA == (unsigned long )((ExprList *)0)) {
    return (1);
  } else
  if ((unsigned long )pB == (unsigned long )((ExprList *)0)) {
    return (1);
  }
  if (pA->nExpr != pB->nExpr) {
    return (1);
  }
  i = 0;
  while (i < pA->nExpr) {
    pExprA = pA->a[i].pExpr;
    pExprB = pB->a[i].pExpr;
    if ((int )pA->a[i].sortFlags != (int )pB->a[i].sortFlags) {
      return (1);
    }
    tmp = sqlite3ExprCompare((Parse *)0, pExprA, pExprB, iTab);
    if (tmp) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static int sqlite3ExprCompareSkip(Expr *pA , Expr *pB , int iTab ) 
{ 
  Expr *tmp ;
  Expr *tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3ExprSkipCollateAndLikely(pB);
  tmp___0 = sqlite3ExprSkipCollateAndLikely(pA);
  tmp___1 = sqlite3ExprCompare((Parse *)0, tmp___0, tmp, iTab);
  return (tmp___1);
}
}
static int exprImpliesNotNull(Parse *pParse , Expr *p , Expr *pNN , int iTab , int seenNot ) 
{ 
  int tmp ;
  int tmp___0 ;
  ExprList *pList ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tmp = sqlite3ExprCompare(pParse, p, pNN, iTab);
  if (tmp == 0) {
    return ((int )pNN->op != 117);
  }
  switch ((int )p->op) {
  case 49: 
  if (seenNot) {
    if ((p->flags & 2048U) != 0U) {
      return (0);
    }
  }
  tmp___0 = exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
  return (tmp___0);
  case 48: 
  pList = p->x.pList;
  if (seenNot) {
    return (0);
  }
  tmp___1 = exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1);
  if (tmp___1) {
    return (1);
  } else {
    tmp___2 = exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1);
    if (tmp___2) {
      return (1);
    }
  }
  tmp___3 = exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
  return (tmp___3);
  case 108: 
  case 102: 
  case 101: 
  case 100: 
  case 104: 
  case 103: 
  case 57: 
  case 54: 
  case 55: 
  case 56: 
  case 52: 
  case 53: 
  seenNot = 1;
  case 106: 
  case 99: 
  case 107: 
  case 105: 
  tmp___4 = exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot);
  if (tmp___4) {
    return (1);
  }
  case 168: 
  case 169: 
  case 109: 
  case 176: 
  tmp___5 = exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);
  return (tmp___5);
  case 170: 
  if (seenNot) {
    return (0);
  }
  if ((int )p->op2 != 45) {
    return (0);
  }
  tmp___6 = exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
  return (tmp___6);
  case 19: 
  case 110: 
  tmp___7 = exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
  return (tmp___7);
  }
  return (0);
}
}
static int sqlite3ExprImpliesExpr(Parse *pParse , Expr *pE1 , Expr *pE2 , int iTab ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = sqlite3ExprCompare(pParse, pE1, pE2, iTab);
  if (tmp == 0) {
    return (1);
  }
  if ((int )pE2->op == 43) {
    tmp___0 = sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab);
    if (tmp___0) {
      return (1);
    } else {
      tmp___1 = sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab);
      if (tmp___1) {
        return (1);
      }
    }
  }
  if ((int )pE2->op == 51) {
    tmp___2 = exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0);
    if (tmp___2) {
      return (1);
    }
  }
  return (0);
}
}
static int impliesNotNullRow(Walker *pWalker , Expr *pExpr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((pExpr->flags & 1U) != 0U) {
    return (1);
  }
  switch ((int )pExpr->op) {
  case 167: 
  case 49: 
  case 152: 
  case 43: 
  case 45: 
  case 51: 
  case 50: 
  case 166: ;
  return (1);
  case 162: 
  if (pWalker->u.iCur == pExpr->iTable) {
    pWalker->eCode = (u8 )1;
    return (2);
  }
  return (1);
  case 44: 
  tmp = sqlite3ExprImpliesNonNullRow(pExpr->pLeft, pWalker->u.iCur);
  if (tmp) {
    tmp___0 = sqlite3ExprImpliesNonNullRow(pExpr->pRight, pWalker->u.iCur);
    if (tmp___0) {
      pWalker->eCode = (u8 )1;
    }
  }
  return (1);
  case 48: 
  sqlite3WalkExpr(pWalker, pExpr->pLeft);
  return (1);
  case 57: 
  case 54: 
  case 55: 
  case 56: 
  case 52: 
  case 53: ;
  if ((int )(pExpr->pLeft)->op == 162) {
    if (((pExpr->pLeft)->y.pTab)->nModuleArg) {
      return (1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )(pExpr->pRight)->op == 162) {
    if (((pExpr->pRight)->y.pTab)->nModuleArg) {
      return (1);
    }
  }
  default: 
  return (0);
  }
}
}
static int sqlite3ExprImpliesNonNullRow(Expr *p , int iTab ) 
{ 
  Walker w ;
  int tmp ;

  {
  p = sqlite3ExprSkipCollateAndLikely(p);
  while (p) {
    if ((int )p->op == 51) {
      p = p->pLeft;
    } else
    if ((int )p->op == 44) {
      tmp = sqlite3ExprImpliesNonNullRow(p->pLeft, iTab);
      if (tmp) {
        return (1);
      }
      p = p->pRight;
    } else {
      break;
    }
  }
  w.xExprCallback = & impliesNotNullRow;
  w.xSelectCallback = (int (*)(Walker * , Select * ))0;
  w.xSelectCallback2 = (void (*)(Walker * , Select * ))0;
  w.eCode = (u8 )0;
  w.u.iCur = iTab;
  sqlite3WalkExpr(& w, p);
  return ((int )w.eCode);
}
}
static int exprIdxCover(Walker *pWalker , Expr *pExpr ) 
{ 
  i16 tmp ;

  {
  if ((int )pExpr->op == 162) {
    if (pExpr->iTable == (pWalker->u.pIdxCover)->iCur) {
      tmp = sqlite3ColumnOfIndex((pWalker->u.pIdxCover)->pIdx, pExpr->iColumn);
      if ((int )tmp < 0) {
        pWalker->eCode = (u8 )1;
        return (2);
      }
    }
  }
  return (0);
}
}
static int sqlite3ExprCoveredByIndex(Expr *pExpr , int iCur , Index *pIdx ) 
{ 
  Walker w ;
  struct IdxCover xcov ;

  {
  memset((void *)(& w), 0, sizeof(w));
  xcov.iCur = iCur;
  xcov.pIdx = pIdx;
  w.xExprCallback = & exprIdxCover;
  w.u.pIdxCover = & xcov;
  sqlite3WalkExpr(& w, pExpr);
  return (! w.eCode);
}
}
static int exprSrcCount(Walker *pWalker , Expr *pExpr ) 
{ 
  int i ;
  struct SrcCount *p ;
  SrcList *pSrc ;
  int nSrc ;
  int tmp ;

  {
  if ((int )pExpr->op == 162) {
    goto _L;
  } else
  if ((int )pExpr->op == 164) {
    _L: /* CIL Label */ 
    p = pWalker->u.pSrcCount;
    pSrc = p->pSrc;
    if (pSrc) {
      tmp = pSrc->nSrc;
    } else {
      tmp = 0;
    }
    nSrc = tmp;
    i = 0;
    while (i < nSrc) {
      if (pExpr->iTable == pSrc->a[i].iCursor) {
        break;
      }
      i ++;
    }
    if (i < nSrc) {
      (p->nThis) ++;
    } else
    if (nSrc == 0) {
      (p->nOther) ++;
    } else
    if (pExpr->iTable < pSrc->a[0].iCursor) {
      (p->nOther) ++;
    }
  }
  return (0);
}
}
static int sqlite3FunctionUsesThisSrc(Expr *pExpr , SrcList *pSrcList ) 
{ 
  Walker w ;
  struct SrcCount cnt ;
  int tmp ;

  {
  memset((void *)(& w), 0, sizeof(w));
  w.xExprCallback = & exprSrcCount;
  w.xSelectCallback = & sqlite3SelectWalkNoop;
  w.u.pSrcCount = & cnt;
  cnt.pSrc = pSrcList;
  cnt.nThis = 0;
  cnt.nOther = 0;
  sqlite3WalkExprList(& w, pExpr->x.pList);
  if (cnt.nThis > 0) {
    tmp = 1;
  } else
  if (cnt.nOther == 0) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int addAggInfoColumn(sqlite3 *db , AggInfo *pInfo ) 
{ 
  int i ;
  void *tmp ;

  {
  tmp = sqlite3ArrayAllocate(db, (void *)pInfo->aCol, (int )sizeof(*(pInfo->aCol + 0)),
                             & pInfo->nColumn, & i);
  pInfo->aCol = (struct AggInfo_col *)tmp;
  return (i);
}
}
static int addAggInfoFunc(sqlite3 *db , AggInfo *pInfo ) 
{ 
  int i ;
  void *tmp ;

  {
  tmp = sqlite3ArrayAllocate(db, (void *)pInfo->aFunc, (int )sizeof(*(pInfo->aFunc + 0)),
                             & pInfo->nFunc, & i);
  pInfo->aFunc = (struct AggInfo_func *)tmp;
  return (i);
}
}
static int analyzeAggregate(Walker *pWalker , Expr *pExpr ) 
{ 
  int i ;
  NameContext *pNC ;
  Parse *pParse ;
  SrcList *pSrcList ;
  AggInfo *pAggInfo ;
  struct SrcList_item *pItem ;
  struct AggInfo_col *pCol ;
  int k ;
  int j ;
  int n ;
  ExprList *pGB ;
  struct ExprList_item *pTerm ;
  Expr *pE ;
  int tmp ;
  struct AggInfo_func *pItem___0 ;
  int tmp___0 ;
  u8 enc ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pNC = pWalker->u.pNC;
  pParse = pNC->pParse;
  pSrcList = pNC->pSrcList;
  pAggInfo = pNC->uNC.pAggInfo;
  switch ((int )pExpr->op) {
  case 162: 
  case 164: 
  if ((unsigned long )pSrcList != (unsigned long )((SrcList *)0)) {
    pItem = pSrcList->a;
    i = 0;
    while (i < pSrcList->nSrc) {
      if (pExpr->iTable == pItem->iCursor) {
        pCol = pAggInfo->aCol;
        k = 0;
        while (k < pAggInfo->nColumn) {
          if (pCol->iTable == pExpr->iTable) {
            if (pCol->iColumn == (int )pExpr->iColumn) {
              break;
            }
          }
          k ++;
          pCol ++;
        }
        if (k >= pAggInfo->nColumn) {
          k = addAggInfoColumn(pParse->db, pAggInfo);
          if (k >= 0) {
            pCol = pAggInfo->aCol + k;
            pCol->pTab = pExpr->y.pTab;
            pCol->iTable = pExpr->iTable;
            pCol->iColumn = (int )pExpr->iColumn;
            (pParse->nMem) ++;
            pCol->iMem = pParse->nMem;
            pCol->iSorterColumn = -1;
            pCol->pExpr = pExpr;
            if (pAggInfo->pGroupBy) {
              pGB = pAggInfo->pGroupBy;
              pTerm = pGB->a;
              n = pGB->nExpr;
              j = 0;
              while (j < n) {
                pE = pTerm->pExpr;
                if ((int )pE->op == 162) {
                  if (pE->iTable == pExpr->iTable) {
                    if ((int )pE->iColumn == (int )pExpr->iColumn) {
                      pCol->iSorterColumn = j;
                      break;
                    }
                  }
                }
                j ++;
                pTerm ++;
              }
            }
            if (pCol->iSorterColumn < 0) {
              tmp = pAggInfo->nSortingColumn;
              (pAggInfo->nSortingColumn) ++;
              pCol->iSorterColumn = tmp;
            }
          }
        }
        pExpr->pAggInfo = pAggInfo;
        pExpr->op = (u8 )164;
        pExpr->iAgg = (i16 )k;
        break;
      }
      i ++;
      pItem ++;
    }
  }
  return (1);
  case 163: 
  if ((pNC->ncFlags & 8) == 0) {
    if (pWalker->walkerDepth == (int )pExpr->op2) {
      pItem___0 = pAggInfo->aFunc;
      i = 0;
      while (i < pAggInfo->nFunc) {
        tmp___0 = sqlite3ExprCompare((Parse *)0, pItem___0->pExpr, pExpr, -1);
        if (tmp___0 == 0) {
          break;
        }
        i ++;
        pItem___0 ++;
      }
      if (i >= pAggInfo->nFunc) {
        enc = (pParse->db)->enc;
        i = addAggInfoFunc(pParse->db, pAggInfo);
        if (i >= 0) {
          pItem___0 = pAggInfo->aFunc + i;
          pItem___0->pExpr = pExpr;
          (pParse->nMem) ++;
          pItem___0->iMem = pParse->nMem;
          if (pExpr->x.pList) {
            tmp___1 = (pExpr->x.pList)->nExpr;
          } else {
            tmp___1 = 0;
          }
          pItem___0->pFunc = sqlite3FindFunction(pParse->db, (char const   *)pExpr->u.zToken,
                                                 tmp___1, enc, (u8 )0);
          if (pExpr->flags & 2U) {
            tmp___2 = pParse->nTab;
            (pParse->nTab) ++;
            pItem___0->iDistinct = tmp___2;
          } else {
            pItem___0->iDistinct = -1;
          }
        }
      }
      pExpr->iAgg = (i16 )i;
      pExpr->pAggInfo = pAggInfo;
      return (1);
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  }
  return (0);
}
}
static int analyzeAggregatesInSelect(Walker *pWalker , Select *pSelect ) 
{ 


  {
  (pWalker->walkerDepth) ++;
  return (0);
}
}
static void analyzeAggregatesInSelectEnd(Walker *pWalker , Select *pSelect ) 
{ 


  {
  (pWalker->walkerDepth) --;
  return;
}
}
static void sqlite3ExprAnalyzeAggregates(NameContext *pNC , Expr *pExpr ) 
{ 
  Walker w ;

  {
  w.xExprCallback = & analyzeAggregate;
  w.xSelectCallback = & analyzeAggregatesInSelect;
  w.xSelectCallback2 = & analyzeAggregatesInSelectEnd;
  w.walkerDepth = 0;
  w.u.pNC = pNC;
  w.pParse = (Parse *)0;
  sqlite3WalkExpr(& w, pExpr);
  return;
}
}
static void sqlite3ExprAnalyzeAggList(NameContext *pNC , ExprList *pList ) 
{ 
  struct ExprList_item *pItem ;
  int i ;

  {
  if (pList) {
    pItem = pList->a;
    i = 0;
    while (i < pList->nExpr) {
      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
      i ++;
      pItem ++;
    }
  }
  return;
}
}
static int sqlite3GetTempReg(Parse *pParse ) 
{ 


  {
  if ((int )pParse->nTempReg == 0) {
    (pParse->nMem) ++;
    return (pParse->nMem);
  }
  pParse->nTempReg = (u8 )((int )pParse->nTempReg - 1);
  return (pParse->aTempReg[pParse->nTempReg]);
}
}
static void sqlite3ReleaseTempReg(Parse *pParse , int iReg ) 
{ 
  u8 tmp ;

  {
  if (iReg) {
    if ((int )pParse->nTempReg < (int )(sizeof(pParse->aTempReg) / sizeof(pParse->aTempReg[0]))) {
      tmp = pParse->nTempReg;
      pParse->nTempReg = (u8 )((int )pParse->nTempReg + 1);
      pParse->aTempReg[tmp] = iReg;
    }
  }
  return;
}
}
static int sqlite3GetTempRange(Parse *pParse , int nReg ) 
{ 
  int i ;
  int n ;
  int tmp ;

  {
  if (nReg == 1) {
    tmp = sqlite3GetTempReg(pParse);
    return (tmp);
  }
  i = pParse->iRangeReg;
  n = pParse->nRangeReg;
  if (nReg <= n) {
    pParse->iRangeReg += nReg;
    pParse->nRangeReg -= nReg;
  } else {
    i = pParse->nMem + 1;
    pParse->nMem += nReg;
  }
  return (i);
}
}
static void sqlite3ReleaseTempRange(Parse *pParse , int iReg , int nReg ) 
{ 


  {
  if (nReg == 1) {
    sqlite3ReleaseTempReg(pParse, iReg);
    return;
  }
  if (nReg > pParse->nRangeReg) {
    pParse->nRangeReg = nReg;
    pParse->iRangeReg = iReg;
  }
  return;
}
}
static void sqlite3ClearTempRegCache(Parse *pParse ) 
{ 


  {
  pParse->nTempReg = (u8 )0;
  pParse->nRangeReg = 0;
  return;
}
}
static int isAlterableTable(Parse *pParse , Table *pTab ) 
{ 
  int tmp ;

  {
  tmp = sqlite3_strnicmp((char const   *)pTab->zName, "sqlite_", 7);
  if (0 == tmp) {
    sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);
    return (1);
  } else
  if (pTab->tabFlags & 1024U) {
    if ((pParse->db)->flags & 268435456ULL) {
      if ((pParse->db)->nVdbeExec == 0) {
        sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);
        return (1);
      }
    }
  }
  return (0);
}
}
static void renameTestSchema(Parse *pParse , char const   *zDb , int bTemp ) 
{ 


  {
  sqlite3NestedParse(pParse, "SELECT 1 FROM \"%w\".%s WHERE name NOT LIKE \'sqliteX_%%\' ESCAPE \'X\' AND sql NOT LIKE \'create virtual%%\' AND sqlite_rename_test(%Q, sql, type, name, %d)=NULL ",
                     zDb, "sqlite_master", zDb, bTemp);
  if (bTemp == 0) {
    sqlite3NestedParse(pParse, "SELECT 1 FROM temp.%s WHERE name NOT LIKE \'sqliteX_%%\' ESCAPE \'X\' AND sql NOT LIKE \'create virtual%%\' AND sqlite_rename_test(%Q, sql, type, name, 1)=NULL ",
                       "sqlite_master", zDb);
  }
  return;
}
}
static void renameReloadSchema(Parse *pParse , int iDb ) 
{ 
  Vdbe *v ;

  {
  v = pParse->pVdbe;
  if (v) {
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, (char *)0);
    if (iDb != 1) {
      sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, (char *)0);
    }
  }
  return;
}
}
static void sqlite3AlterRenameTable(Parse *pParse , SrcList *pSrc , Token *pName ) 
{ 
  int iDb ;
  char *zDb ;
  Table *pTab ;
  char *zName ;
  sqlite3 *db ;
  int nTabName ;
  char const   *zTabName ;
  Vdbe *v ;
  VTable *pVTab ;
  u32 savedDbFlags ;
  Table *tmp ;
  Index *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  Table *tmp___5 ;
  int i ;

  {
  zName = (char *)0;
  db = pParse->db;
  pVTab = (VTable *)0;
  savedDbFlags = db->mDbFlags;
  if (db->mallocFailed) {
    goto exit_rename_table;
  }
  pTab = sqlite3LocateTableItem(pParse, (u32 )0, & pSrc->a[0]);
  if (! pTab) {
    goto exit_rename_table;
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  zDb = (db->aDb + iDb)->zDbSName;
  db->mDbFlags |= 2U;
  zName = sqlite3NameFromToken(db, pName);
  if (! zName) {
    goto exit_rename_table;
  }
  tmp = sqlite3FindTable(db, (char const   *)zName, (char const   *)zDb);
  if (tmp) {
    sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s",
                    zName);
    goto exit_rename_table;
  } else {
    tmp___0 = sqlite3FindIndex(db, (char const   *)zName, (char const   *)zDb);
    if (tmp___0) {
      sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s",
                      zName);
      goto exit_rename_table;
    }
  }
  tmp___1 = isAlterableTable(pParse, pTab);
  if (0 != tmp___1) {
    goto exit_rename_table;
  }
  tmp___2 = sqlite3CheckObjectName(pParse, (char const   *)zName, "table", (char const   *)zName);
  if (0 != tmp___2) {
    goto exit_rename_table;
  }
  if (pTab->pSelect) {
    sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
    goto exit_rename_table;
  }
  tmp___3 = sqlite3AuthCheck(pParse, 26, (char const   *)zDb, (char const   *)pTab->zName,
                             (char const   *)0);
  if (tmp___3) {
    goto exit_rename_table;
  }
  tmp___4 = sqlite3ViewGetColumnNames(pParse, pTab);
  if (tmp___4) {
    goto exit_rename_table;
  }
  if (pTab->nModuleArg) {
    pVTab = sqlite3GetVTable(db, pTab);
    if ((unsigned long )((pVTab->pVtab)->pModule)->xRename == (unsigned long )((int (* const  )(sqlite3_vtab *pVtab ,
                                                                                                char const   *zNew ))0)) {
      pVTab = (VTable *)0;
    }
  }
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    goto exit_rename_table;
  }
  sqlite3MayAbort(pParse);
  zTabName = (char const   *)pTab->zName;
  nTabName = sqlite3Utf8CharLen(zTabName, -1);
  sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!=\'index\' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE \'sqliteX_%%\' ESCAPE \'X\'",
                     zDb, "sqlite_master", zDb, zTabName, zName, iDb == 1, zTabName);
  sqlite3NestedParse(pParse, "UPDATE %Q.%s SET tbl_name = %Q, name = CASE WHEN type=\'table\' THEN %Q WHEN name LIKE \'sqliteX_autoindex%%\' ESCAPE \'X\'      AND type=\'index\' THEN \'sqlite_autoindex_\' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type=\'table\' OR type=\'index\' OR type=\'trigger\');",
                     zDb, "sqlite_master", zName, zName, zName, nTabName, zTabName);
  tmp___5 = sqlite3FindTable(db, "sqlite_sequence", (char const   *)zDb);
  if (tmp___5) {
    sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
                       zDb, zName, pTab->zName);
  }
  if (iDb != 1) {
    sqlite3NestedParse(pParse, "UPDATE sqlite_temp_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND           sqlite_rename_test(%Q, sql, type, name, 1) THEN %Q ELSE tbl_name END WHERE type IN (\'view\', \'trigger\')",
                       zDb, zTabName, zName, zTabName, zDb, zName);
  }
  if (pVTab) {
    (pParse->nMem) ++;
    i = pParse->nMem;
    sqlite3VdbeLoadString(v, i, (char const   *)zName);
    sqlite3VdbeAddOp4(v, 165, i, 0, 0, (char const   *)pVTab, -12);
  }
  renameReloadSchema(pParse, iDb);
  renameTestSchema(pParse, (char const   *)zDb, iDb == 1);
  exit_rename_table: 
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, (void *)zName);
  db->mDbFlags = savedDbFlags;
  return;
}
}
static void sqlite3AlterFinishAddColumn(Parse *pParse , Token *pColDef ) 
{ 
  Table *pNew ;
  Table *pTab ;
  int iDb ;
  char const   *zDb ;
  char const   *zTab ;
  char *zCol ;
  Column *pCol ;
  Expr *pDflt ;
  sqlite3 *db ;
  Vdbe *v ;
  int r1 ;
  int tmp ;
  sqlite3_value *pVal ;
  int rc ;
  char *zEnd ;
  u32 savedDbFlags ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  db = pParse->db;
  if (pParse->nErr) {
    return;
  } else
  if (db->mallocFailed) {
    return;
  }
  pNew = pParse->pNewTable;
  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);
  zDb = (char const   *)(db->aDb + iDb)->zDbSName;
  zTab = (char const   *)(pNew->zName + 16);
  pCol = pNew->aCol + ((int )pNew->nCol - 1);
  pDflt = pCol->pDflt;
  pTab = sqlite3FindTable(db, zTab, zDb);
  tmp = sqlite3AuthCheck(pParse, 26, zDb, (char const   *)pTab->zName, (char const   *)0);
  if (tmp) {
    return;
  }
  if (pDflt) {
    if ((int )(pDflt->pLeft)->op == 117) {
      pDflt = (Expr *)0;
    }
  }
  if ((int )pCol->colFlags & 1) {
    sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
    return;
  }
  if (pNew->pIndex) {
    sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
    return;
  }
  if (db->flags & 16384ULL) {
    if (pNew->pFKey) {
      if (pDflt) {
        sqlite3ErrorMsg(pParse, "Cannot add a REFERENCES column with non-NULL default value");
        return;
      }
    }
  }
  if (pCol->notNull) {
    if (! pDflt) {
      sqlite3ErrorMsg(pParse, "Cannot add a NOT NULL column with default value NULL");
      return;
    }
  }
  if (pDflt) {
    pVal = (sqlite3_value *)0;
    rc = sqlite3ValueFromExpr(db, pDflt, (u8 )1, (u8 )65, & pVal);
    if (rc != 0) {
      return;
    }
    if (! pVal) {
      sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default");
      return;
    }
    sqlite3ValueFree(pVal);
  }
  zCol = sqlite3DbStrNDup(db, (char const   *)((char *)pColDef->z), (u64 )pColDef->n);
  if (zCol) {
    zEnd = zCol + (pColDef->n - 1U);
    savedDbFlags = db->mDbFlags;
    while (1) {
      if ((unsigned long )zEnd > (unsigned long )zCol) {
        if (! ((int )*zEnd == 59)) {
          if (! ((int const   )sqlite3CtypeMap[(unsigned char )*zEnd] & 1)) {
            break;
          }
        }
      } else {
        break;
      }
      tmp___0 = zEnd;
      zEnd --;
      *tmp___0 = (char )'\000';
    }
    db->mDbFlags |= 2U;
    sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET sql = substr(sql,1,%d) || \', \' || %Q || substr(sql,%d) WHERE type = \'table\' AND name = %Q",
                       zDb, "sqlite_master", pNew->addColOffset, zCol, pNew->addColOffset + 1,
                       zTab);
    sqlite3DbFree(db, (void *)zCol);
    db->mDbFlags = savedDbFlags;
  }
  v = sqlite3GetVdbe(pParse);
  if (v) {
    r1 = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp3(v, 94, iDb, r1, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    sqlite3VdbeAddOp2(v, 83, r1, -2);
    tmp___1 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 47, r1, tmp___1 + 2);
    sqlite3VdbeAddOp3(v, 95, iDb, 2, 3);
    sqlite3ReleaseTempReg(pParse, r1);
  }
  renameReloadSchema(pParse, iDb);
  return;
}
}
static void sqlite3AlterBeginAddColumn(Parse *pParse , SrcList *pSrc ) 
{ 
  Table *pNew ;
  Table *pTab ;
  int iDb ;
  int i ;
  int nAlloc ;
  sqlite3 *db ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Column *pCol ;

  {
  db = pParse->db;
  if (db->mallocFailed) {
    goto exit_begin_add_column;
  }
  pTab = sqlite3LocateTableItem(pParse, (u32 )0, & pSrc->a[0]);
  if (! pTab) {
    goto exit_begin_add_column;
  }
  if (pTab->nModuleArg) {
    sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
    goto exit_begin_add_column;
  }
  if (pTab->pSelect) {
    sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
    goto exit_begin_add_column;
  }
  tmp = isAlterableTable(pParse, pTab);
  if (0 != tmp) {
    goto exit_begin_add_column;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  tmp___0 = sqlite3DbMallocZero(db, (u64 )sizeof(Table ));
  pNew = (Table *)tmp___0;
  if (! pNew) {
    goto exit_begin_add_column;
  }
  pParse->pNewTable = pNew;
  pNew->nTabRef = (u32 )1;
  pNew->nCol = pTab->nCol;
  nAlloc = (((int )pNew->nCol - 1) / 8) * 8 + 8;
  tmp___1 = sqlite3DbMallocZero(db, (u64 )(sizeof(Column ) * (unsigned long )nAlloc));
  pNew->aCol = (Column *)tmp___1;
  pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);
  if (! pNew->aCol) {
    goto exit_begin_add_column;
  } else
  if (! pNew->zName) {
    goto exit_begin_add_column;
  }
  memcpy((void * __restrict  )pNew->aCol, (void const   * __restrict  )pTab->aCol,
         sizeof(Column ) * (unsigned long )pNew->nCol);
  i = 0;
  while (i < (int )pNew->nCol) {
    pCol = pNew->aCol + i;
    pCol->zName = sqlite3DbStrDup(db, (char const   *)pCol->zName);
    pCol->zColl = (char *)0;
    pCol->pDflt = (Expr *)0;
    i ++;
  }
  pNew->pSchema = (db->aDb + iDb)->pSchema;
  pNew->addColOffset = pTab->addColOffset;
  pNew->nTabRef = (u32 )1;
  exit_begin_add_column: 
  sqlite3SrcListDelete(db, pSrc);
  return;
}
}
static int isRealTable(Parse *pParse , Table *pTab ) 
{ 
  char const   *zType ;

  {
  zType = (char const   *)0;
  if (pTab->pSelect) {
    zType = "view";
  }
  if (pTab->nModuleArg) {
    zType = "virtual table";
  }
  if (zType) {
    sqlite3ErrorMsg(pParse, "cannot rename columns of %s \"%s\"", zType, pTab->zName);
    return (1);
  }
  return (0);
}
}
static void sqlite3AlterRenameColumn(Parse *pParse , SrcList *pSrc , Token *pOld ,
                                     Token *pNew ) 
{ 
  sqlite3 *db ;
  Table *pTab ;
  int iCol ;
  char *zOld ;
  char *zNew ;
  char const   *zDb ;
  int iSchema ;
  int bQuote ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  db = pParse->db;
  zOld = (char *)0;
  zNew = (char *)0;
  pTab = sqlite3LocateTableItem(pParse, (u32 )0, & pSrc->a[0]);
  if (! pTab) {
    goto exit_rename_column;
  }
  tmp = isAlterableTable(pParse, pTab);
  if (0 != tmp) {
    goto exit_rename_column;
  }
  tmp___0 = isRealTable(pParse, pTab);
  if (0 != tmp___0) {
    goto exit_rename_column;
  }
  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);
  zDb = (char const   *)(db->aDb + iSchema)->zDbSName;
  tmp___1 = sqlite3AuthCheck(pParse, 26, zDb, (char const   *)pTab->zName, (char const   *)0);
  if (tmp___1) {
    goto exit_rename_column;
  }
  zOld = sqlite3NameFromToken(db, pOld);
  if (! zOld) {
    goto exit_rename_column;
  }
  iCol = 0;
  while (iCol < (int )pTab->nCol) {
    tmp___2 = sqlite3StrICmp((char const   *)(pTab->aCol + iCol)->zName, (char const   *)zOld);
    if (0 == tmp___2) {
      break;
    }
    iCol ++;
  }
  if (iCol == (int )pTab->nCol) {
    sqlite3ErrorMsg(pParse, "no such column: \"%s\"", zOld);
    goto exit_rename_column;
  }
  sqlite3MayAbort(pParse);
  zNew = sqlite3NameFromToken(db, pNew);
  if (! zNew) {
    goto exit_rename_column;
  }
  bQuote = (int )((int const   )sqlite3CtypeMap[(unsigned char )*(pNew->z + 0)] & 128);
  sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE \'sqliteX_%%\' ESCAPE \'X\'  AND (type != \'index\' OR tbl_name = %Q) AND sql NOT LIKE \'create virtual%%\'",
                     zDb, "sqlite_master", zDb, pTab->zName, iCol, zNew, bQuote, iSchema == 1,
                     pTab->zName);
  sqlite3NestedParse(pParse, "UPDATE temp.%s SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN (\'trigger\', \'view\')",
                     "sqlite_master", zDb, pTab->zName, iCol, zNew, bQuote);
  renameReloadSchema(pParse, iSchema);
  renameTestSchema(pParse, zDb, iSchema == 1);
  exit_rename_column: 
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, (void *)zOld);
  sqlite3DbFree(db, (void *)zNew);
  return;
}
}
static void *sqlite3RenameTokenMap(Parse *pParse , void *pPtr , Token *pToken ) 
{ 
  RenameToken *pNew ;
  void *tmp ;

  {
  tmp = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(RenameToken ));
  pNew = (RenameToken *)tmp;
  if (pNew) {
    pNew->p = pPtr;
    pNew->t = *pToken;
    pNew->pNext = pParse->pRename;
    pParse->pRename = pNew;
  }
  return (pPtr);
}
}
static void sqlite3RenameTokenRemap(Parse *pParse , void *pTo , void *pFrom ) 
{ 
  RenameToken *p ;

  {
  p = pParse->pRename;
  while (p) {
    if ((unsigned long )p->p == (unsigned long )pFrom) {
      p->p = pTo;
      break;
    }
    p = p->pNext;
  }
  return;
}
}
static int renameUnmapExprCb(Walker *pWalker , Expr *pExpr ) 
{ 
  Parse *pParse ;

  {
  pParse = pWalker->pParse;
  sqlite3RenameTokenRemap(pParse, (void *)0, (void *)pExpr);
  return (0);
}
}
static int renameUnmapSelectCb(Walker *pWalker , Select *p ) 
{ 
  Parse *pParse ;
  int i ;
  ExprList *pList ;
  SrcList *pSrc ;

  {
  pParse = pWalker->pParse;
  if (p->pEList) {
    pList = p->pEList;
    i = 0;
    while (i < pList->nExpr) {
      if (pList->a[i].zName) {
        sqlite3RenameTokenRemap(pParse, (void *)0, (void *)pList->a[i].zName);
      }
      i ++;
    }
  }
  if (p->pSrc) {
    pSrc = p->pSrc;
    i = 0;
    while (i < pSrc->nSrc) {
      sqlite3RenameTokenRemap(pParse, (void *)0, (void *)pSrc->a[i].zName);
      i ++;
    }
  }
  return (0);
}
}
static void sqlite3RenameExprUnmap(Parse *pParse , Expr *pExpr ) 
{ 
  Walker sWalker ;

  {
  memset((void *)(& sWalker), 0, sizeof(Walker ));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = & renameUnmapExprCb;
  sWalker.xSelectCallback = & renameUnmapSelectCb;
  sqlite3WalkExpr(& sWalker, pExpr);
  return;
}
}
static void sqlite3RenameExprlistUnmap(Parse *pParse , ExprList *pEList ) 
{ 
  int i ;
  Walker sWalker ;

  {
  if (pEList) {
    memset((void *)(& sWalker), 0, sizeof(Walker ));
    sWalker.pParse = pParse;
    sWalker.xExprCallback = & renameUnmapExprCb;
    sqlite3WalkExprList(& sWalker, pEList);
    i = 0;
    while (i < pEList->nExpr) {
      sqlite3RenameTokenRemap(pParse, (void *)0, (void *)pEList->a[i].zName);
      i ++;
    }
  }
  return;
}
}
static void renameTokenFree(sqlite3 *db , RenameToken *pToken ) 
{ 
  RenameToken *pNext ;
  RenameToken *p ;

  {
  p = pToken;
  while (p) {
    pNext = p->pNext;
    sqlite3DbFree(db, (void *)p);
    p = pNext;
  }
  return;
}
}
static void renameTokenFind(Parse *pParse , struct RenameCtx *pCtx , void *pPtr ) 
{ 
  RenameToken **pp ;
  RenameToken *pToken ;

  {
  pp = & pParse->pRename;
  while (*pp) {
    if ((unsigned long )(*pp)->p == (unsigned long )pPtr) {
      pToken = *pp;
      *pp = pToken->pNext;
      pToken->pNext = pCtx->pList;
      pCtx->pList = pToken;
      (pCtx->nList) ++;
      break;
    }
    pp = & (*pp)->pNext;
  }
  return;
}
}
static void renameWalkWith(Walker *pWalker , Select *pSelect ) 
{ 
  int i ;
  Select *p ;
  NameContext sNC ;

  {
  if (pSelect->pWith) {
    i = 0;
    while (i < (pSelect->pWith)->nCte) {
      p = (pSelect->pWith)->a[i].pSelect;
      memset((void *)(& sNC), 0, sizeof(sNC));
      sNC.pParse = pWalker->pParse;
      sqlite3SelectPrep(sNC.pParse, p, & sNC);
      sqlite3WalkSelect(pWalker, p);
      i ++;
    }
  }
  return;
}
}
static int renameColumnSelectCb(Walker *pWalker , Select *p ) 
{ 


  {
  renameWalkWith(pWalker, p);
  return (0);
}
}
static int renameColumnExprCb(Walker *pWalker , Expr *pExpr ) 
{ 
  RenameCtx *p ;

  {
  p = pWalker->u.pRename;
  if ((int )pExpr->op == 77) {
    if ((int )pExpr->iColumn == p->iCol) {
      if ((unsigned long )(pWalker->pParse)->pTriggerTab == (unsigned long )p->pTab) {
        renameTokenFind(pWalker->pParse, p, (void *)pExpr);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((int )pExpr->op == 162) {
    if ((int )pExpr->iColumn == p->iCol) {
      if ((unsigned long )p->pTab == (unsigned long )pExpr->y.pTab) {
        renameTokenFind(pWalker->pParse, p, (void *)pExpr);
      }
    }
  }
  return (0);
}
}
static RenameToken *renameColumnTokenNext(RenameCtx *pCtx ) 
{ 
  RenameToken *pBest ;
  RenameToken *pToken ;
  RenameToken **pp ;

  {
  pBest = pCtx->pList;
  pToken = pBest->pNext;
  while (pToken) {
    if ((unsigned long )pToken->t.z > (unsigned long )pBest->t.z) {
      pBest = pToken;
    }
    pToken = pToken->pNext;
  }
  pp = & pCtx->pList;
  while ((unsigned long )*pp != (unsigned long )pBest) {
    pp = & (*pp)->pNext;
  }
  *pp = pBest->pNext;
  return (pBest);
}
}
static void renameColumnParseError(sqlite3_context *pCtx , int bPost , sqlite3_value *pType ,
                                   sqlite3_value *pObject , Parse *pParse ) 
{ 
  char const   *zT ;
  unsigned char const   *tmp ;
  char const   *zN ;
  unsigned char const   *tmp___0 ;
  char *zErr ;
  char const   *tmp___1 ;

  {
  tmp = sqlite3_value_text(pType);
  zT = (char const   *)tmp;
  tmp___0 = sqlite3_value_text(pObject);
  zN = (char const   *)tmp___0;
  if (bPost) {
    tmp___1 = " after rename";
  } else {
    tmp___1 = "";
  }
  zErr = sqlite3_mprintf("error in %s %s%s: %s", zT, zN, tmp___1, pParse->zErrMsg);
  sqlite3_result_error(pCtx, (char const   *)zErr, -1);
  sqlite3_free((void *)zErr);
  return;
}
}
static void renameColumnElistNames(Parse *pParse , RenameCtx *pCtx , ExprList *pEList ,
                                   char const   *zOld ) 
{ 
  int i ;
  char *zName ;
  int tmp ;

  {
  if (pEList) {
    i = 0;
    while (i < pEList->nExpr) {
      zName = pEList->a[i].zName;
      tmp = sqlite3_stricmp((char const   *)zName, zOld);
      if (0 == tmp) {
        renameTokenFind(pParse, pCtx, (void *)zName);
      }
      i ++;
    }
  }
  return;
}
}
static void renameColumnIdlistNames(Parse *pParse , RenameCtx *pCtx , IdList *pIdList ,
                                    char const   *zOld ) 
{ 
  int i ;
  char *zName ;
  int tmp ;

  {
  if (pIdList) {
    i = 0;
    while (i < pIdList->nId) {
      zName = (pIdList->a + i)->zName;
      tmp = sqlite3_stricmp((char const   *)zName, zOld);
      if (0 == tmp) {
        renameTokenFind(pParse, pCtx, (void *)zName);
      }
      i ++;
    }
  }
  return;
}
}
static int renameParseSql(Parse *p , char const   *zDb , int bTable , sqlite3 *db ,
                          char const   *zSql , int bTemp ) 
{ 
  int rc ;
  char *zErr ;
  int tmp ;

  {
  zErr = (char *)0;
  if (bTemp) {
    db->init.iDb = (u8 )1;
  } else {
    tmp = sqlite3FindDbName(db, zDb);
    db->init.iDb = (u8 )tmp;
  }
  memset((void *)p, 0, sizeof(Parse ));
  if (bTable) {
    p->eParseMode = (u8 )3;
  } else {
    p->eParseMode = (u8 )2;
  }
  p->db = db;
  p->nQueryLoop = (u32 )1;
  rc = sqlite3RunParser(p, zSql, & zErr);
  p->zErrMsg = zErr;
  if (db->mallocFailed) {
    rc = 7;
  }
  if (rc == 0) {
    if ((unsigned long )p->pNewTable == (unsigned long )((Table *)0)) {
      if ((unsigned long )p->pNewIndex == (unsigned long )((Index *)0)) {
        if ((unsigned long )p->pNewTrigger == (unsigned long )((Trigger *)0)) {
          rc = sqlite3CorruptError(104155);
        }
      }
    }
  }
  db->init.iDb = (u8 )0;
  return (rc);
}
}
static int renameEditSql(sqlite3_context *pCtx , RenameCtx *pRename , char const   *zSql ,
                         char const   *zNew , int bQuote ) 
{ 
  int nNew ;
  int tmp ;
  int nSql ;
  int tmp___0 ;
  sqlite3 *db ;
  sqlite3 *tmp___1 ;
  int rc ;
  char *zQuot ;
  char *zOut ;
  int nQuot ;
  void *tmp___2 ;
  int nOut ;
  int iOff ;
  RenameToken *pBest ;
  RenameToken *tmp___3 ;
  u32 nReplace ;
  char const   *zReplace ;
  int tmp___4 ;

  {
  tmp = sqlite3Strlen30(zNew);
  nNew = tmp;
  tmp___0 = sqlite3Strlen30(zSql);
  nSql = tmp___0;
  tmp___1 = sqlite3_context_db_handle(pCtx);
  db = tmp___1;
  rc = 0;
  zQuot = sqlite3MPrintf(db, "\"%w\"", zNew);
  if ((unsigned long )zQuot == (unsigned long )((char *)0)) {
    return (7);
  } else {
    nQuot = sqlite3Strlen30((char const   *)zQuot);
  }
  if (bQuote) {
    zNew = (char const   *)zQuot;
    nNew = nQuot;
  }
  tmp___2 = sqlite3DbMallocZero(db, (u64 )((nSql + pRename->nList * nQuot) + 1));
  zOut = (char *)tmp___2;
  if (zOut) {
    nOut = nSql;
    memcpy((void * __restrict  )zOut, (void const   * __restrict  )zSql, (size_t )nSql);
    while (pRename->pList) {
      tmp___3 = renameColumnTokenNext(pRename);
      pBest = tmp___3;
      tmp___4 = sqlite3IsIdChar((u8 )*(pBest->t.z));
      if (tmp___4) {
        nReplace = (u32 )nNew;
        zReplace = zNew;
      } else {
        nReplace = (u32 )nQuot;
        zReplace = (char const   *)zQuot;
      }
      iOff = (int )(pBest->t.z - zSql);
      if (pBest->t.n != nReplace) {
        memmove((void *)(zOut + ((u32 )iOff + nReplace)), (void const   *)(zOut + ((unsigned int )iOff + pBest->t.n)),
                (size_t )((unsigned int )nOut - ((unsigned int )iOff + pBest->t.n)));
        nOut = (int )((u32 )nOut + (nReplace - pBest->t.n));
        *(zOut + nOut) = (char )'\000';
      }
      memcpy((void * __restrict  )(zOut + iOff), (void const   * __restrict  )zReplace,
             (size_t )nReplace);
      sqlite3DbFree(db, (void *)pBest);
    }
    sqlite3_result_text(pCtx, (char const   *)zOut, -1, (void (*)(void * ))-1);
    sqlite3DbFree(db, (void *)zOut);
  } else {
    rc = 7;
  }
  sqlite3_free((void *)zQuot);
  return (rc);
}
}
static int renameResolveTrigger(Parse *pParse , char const   *zDb ) 
{ 
  sqlite3 *db ;
  Trigger *pNew ;
  TriggerStep *pStep ;
  NameContext sNC ;
  int rc ;
  int tmp ;
  Table *pTarget ;
  Table *tmp___0 ;
  SrcList sSrc ;
  Upsert *pUpsert ;
  ExprList *pUpsertSet ;

  {
  db = pParse->db;
  pNew = pParse->pNewTrigger;
  rc = 0;
  memset((void *)(& sNC), 0, sizeof(sNC));
  sNC.pParse = pParse;
  tmp = sqlite3SchemaToIndex(db, pNew->pTabSchema);
  pParse->pTriggerTab = sqlite3FindTable(db, (char const   *)pNew->table, (char const   *)(db->aDb + tmp)->zDbSName);
  pParse->eTriggerOp = pNew->op;
  if (pParse->pTriggerTab) {
    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);
  }
  if (rc == 0) {
    if (pNew->pWhen) {
      rc = sqlite3ResolveExprNames(& sNC, pNew->pWhen);
    }
  }
  pStep = pNew->step_list;
  while (1) {
    if (rc == 0) {
      if (! pStep) {
        break;
      }
    } else {
      break;
    }
    if (pStep->pSelect) {
      sqlite3SelectPrep(pParse, pStep->pSelect, & sNC);
      if (pParse->nErr) {
        rc = pParse->rc;
      }
    }
    if (rc == 0) {
      if (pStep->zTarget) {
        tmp___0 = sqlite3LocateTable(pParse, (u32 )0, (char const   *)pStep->zTarget,
                                     zDb);
        pTarget = tmp___0;
        if ((unsigned long )pTarget == (unsigned long )((Table *)0)) {
          rc = 1;
        } else {
          rc = sqlite3ViewGetColumnNames(pParse, pTarget);
          if (0 == rc) {
            memset((void *)(& sSrc), 0, sizeof(sSrc));
            sSrc.nSrc = 1;
            sSrc.a[0].zName = pStep->zTarget;
            sSrc.a[0].pTab = pTarget;
            sNC.pSrcList = & sSrc;
            if (pStep->pWhere) {
              rc = sqlite3ResolveExprNames(& sNC, pStep->pWhere);
            }
            if (rc == 0) {
              rc = sqlite3ResolveExprListNames(& sNC, pStep->pExprList);
            }
            if (pStep->pUpsert) {
              pUpsert = pStep->pUpsert;
              pUpsert->pUpsertSrc = & sSrc;
              sNC.uNC.pUpsert = pUpsert;
              sNC.ncFlags = 512;
              rc = sqlite3ResolveExprListNames(& sNC, pUpsert->pUpsertTarget);
              if (rc == 0) {
                pUpsertSet = pUpsert->pUpsertSet;
                rc = sqlite3ResolveExprListNames(& sNC, pUpsertSet);
              }
              if (rc == 0) {
                rc = sqlite3ResolveExprNames(& sNC, pUpsert->pUpsertWhere);
              }
              if (rc == 0) {
                rc = sqlite3ResolveExprNames(& sNC, pUpsert->pUpsertTargetWhere);
              }
              sNC.ncFlags = 0;
            }
            sNC.pSrcList = (SrcList *)0;
          }
        }
      }
    }
    pStep = pStep->pNext;
  }
  return (rc);
}
}
static void renameWalkTrigger(Walker *pWalker , Trigger *pTrigger ) 
{ 
  TriggerStep *pStep ;
  Upsert *pUpsert ;

  {
  sqlite3WalkExpr(pWalker, pTrigger->pWhen);
  pStep = pTrigger->step_list;
  while (pStep) {
    sqlite3WalkSelect(pWalker, pStep->pSelect);
    sqlite3WalkExpr(pWalker, pStep->pWhere);
    sqlite3WalkExprList(pWalker, pStep->pExprList);
    if (pStep->pUpsert) {
      pUpsert = pStep->pUpsert;
      sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);
      sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);
      sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);
      sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);
    }
    pStep = pStep->pNext;
  }
  return;
}
}
static void renameParseCleanup(Parse *pParse ) 
{ 
  sqlite3 *db ;
  Index *pIdx ;

  {
  db = pParse->db;
  if (pParse->pVdbe) {
    sqlite3VdbeFinalize(pParse->pVdbe);
  }
  sqlite3DeleteTable(db, pParse->pNewTable);
  while (1) {
    pIdx = pParse->pNewIndex;
    if (! ((unsigned long )pIdx != (unsigned long )((Index *)0))) {
      break;
    }
    pParse->pNewIndex = pIdx->pNext;
    sqlite3FreeIndex(db, pIdx);
  }
  sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  sqlite3DbFree(db, (void *)pParse->zErrMsg);
  renameTokenFree(db, pParse->pRename);
  sqlite3ParserReset(pParse);
  return;
}
}
static void renameColumnFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  RenameCtx sCtx ;
  char const   *zSql ;
  unsigned char const   *tmp___0 ;
  char const   *zDb ;
  unsigned char const   *tmp___1 ;
  char const   *zTable ;
  unsigned char const   *tmp___2 ;
  int iCol ;
  int tmp___3 ;
  char const   *zNew ;
  unsigned char const   *tmp___4 ;
  int bQuote ;
  int tmp___5 ;
  int bTemp ;
  int tmp___6 ;
  char const   *zOld ;
  int rc ;
  Parse sParse ;
  Walker sWalker ;
  Index *pIdx ;
  int i ;
  Table *pTab ;
  int (*xAuth)(void * , int  , char const   * , char const   * , char const   * ,
               char const   * ) ;
  Select *pSelect ;
  int bFKOnly ;
  int tmp___7 ;
  FKey *pFKey ;
  int tmp___8 ;
  int tmp___9 ;
  TriggerStep *pStep ;
  char const   *tmp___10 ;
  Table *pTarget ;
  Table *tmp___11 ;
  ExprList *pUpsertSet ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zSql = (char const   *)tmp___0;
  tmp___1 = sqlite3_value_text(*(argv + 3));
  zDb = (char const   *)tmp___1;
  tmp___2 = sqlite3_value_text(*(argv + 4));
  zTable = (char const   *)tmp___2;
  tmp___3 = sqlite3_value_int(*(argv + 5));
  iCol = tmp___3;
  tmp___4 = sqlite3_value_text(*(argv + 6));
  zNew = (char const   *)tmp___4;
  tmp___5 = sqlite3_value_int(*(argv + 7));
  bQuote = tmp___5;
  tmp___6 = sqlite3_value_int(*(argv + 8));
  bTemp = tmp___6;
  xAuth = db->xAuth;
  if ((unsigned long )zSql == (unsigned long )((char const   *)0)) {
    return;
  }
  if ((unsigned long )zTable == (unsigned long )((char const   *)0)) {
    return;
  }
  if ((unsigned long )zNew == (unsigned long )((char const   *)0)) {
    return;
  }
  if (iCol < 0) {
    return;
  }
  sqlite3BtreeEnterAll(db);
  pTab = sqlite3FindTable(db, zTable, zDb);
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return;
  } else
  if (iCol >= (int )pTab->nCol) {
    return;
  }
  zOld = (char const   *)(pTab->aCol + iCol)->zName;
  memset((void *)(& sCtx), 0, sizeof(sCtx));
  if (iCol == (int )pTab->iPKey) {
    sCtx.iCol = -1;
  } else {
    sCtx.iCol = iCol;
  }
  db->xAuth = (int (*)(void * , int  , char const   * , char const   * , char const   * ,
                       char const   * ))0;
  rc = renameParseSql(& sParse, zDb, 0, db, zSql, bTemp);
  memset((void *)(& sWalker), 0, sizeof(Walker ));
  sWalker.pParse = & sParse;
  sWalker.xExprCallback = & renameColumnExprCb;
  sWalker.xSelectCallback = & renameColumnSelectCb;
  sWalker.u.pRename = & sCtx;
  sCtx.pTab = pTab;
  if (rc != 0) {
    goto renameColumnFunc_done;
  }
  if (sParse.pNewTable) {
    pSelect = (sParse.pNewTable)->pSelect;
    if (pSelect) {
      sParse.rc = 0;
      sqlite3SelectPrep(& sParse, (sParse.pNewTable)->pSelect, (NameContext *)0);
      if (db->mallocFailed) {
        rc = 7;
      } else {
        rc = sParse.rc;
      }
      if (rc == 0) {
        sqlite3WalkSelect(& sWalker, pSelect);
      }
      if (rc != 0) {
        goto renameColumnFunc_done;
      }
    } else {
      tmp___7 = sqlite3_stricmp(zTable, (char const   *)(sParse.pNewTable)->zName);
      bFKOnly = tmp___7;
      sCtx.pTab = sParse.pNewTable;
      if (bFKOnly == 0) {
        renameTokenFind(& sParse, & sCtx, (void *)((sParse.pNewTable)->aCol + iCol)->zName);
        if (sCtx.iCol < 0) {
          renameTokenFind(& sParse, & sCtx, (void *)(& (sParse.pNewTable)->iPKey));
        }
        sqlite3WalkExprList(& sWalker, (sParse.pNewTable)->pCheck);
        pIdx = (sParse.pNewTable)->pIndex;
        while (pIdx) {
          sqlite3WalkExprList(& sWalker, pIdx->aColExpr);
          pIdx = pIdx->pNext;
        }
        pIdx = sParse.pNewIndex;
        while (pIdx) {
          sqlite3WalkExprList(& sWalker, pIdx->aColExpr);
          pIdx = pIdx->pNext;
        }
      }
      pFKey = (sParse.pNewTable)->pFKey;
      while (pFKey) {
        i = 0;
        while (i < pFKey->nCol) {
          if (bFKOnly == 0) {
            if (pFKey->aCol[i].iFrom == iCol) {
              renameTokenFind(& sParse, & sCtx, (void *)(& pFKey->aCol[i]));
            }
          }
          tmp___8 = sqlite3_stricmp((char const   *)pFKey->zTo, zTable);
          if (0 == tmp___8) {
            tmp___9 = sqlite3_stricmp((char const   *)pFKey->aCol[i].zCol, zOld);
            if (0 == tmp___9) {
              renameTokenFind(& sParse, & sCtx, (void *)pFKey->aCol[i].zCol);
            }
          }
          i ++;
        }
        pFKey = pFKey->pNextFrom;
      }
    }
  } else
  if (sParse.pNewIndex) {
    sqlite3WalkExprList(& sWalker, (sParse.pNewIndex)->aColExpr);
    sqlite3WalkExpr(& sWalker, (sParse.pNewIndex)->pPartIdxWhere);
  } else {
    if (bTemp) {
      tmp___10 = (char const   *)0;
    } else {
      tmp___10 = zDb;
    }
    rc = renameResolveTrigger(& sParse, tmp___10);
    if (rc != 0) {
      goto renameColumnFunc_done;
    }
    pStep = (sParse.pNewTrigger)->step_list;
    while (pStep) {
      if (pStep->zTarget) {
        tmp___11 = sqlite3LocateTable(& sParse, (u32 )0, (char const   *)pStep->zTarget,
                                      zDb);
        pTarget = tmp___11;
        if ((unsigned long )pTarget == (unsigned long )pTab) {
          if (pStep->pUpsert) {
            pUpsertSet = (pStep->pUpsert)->pUpsertSet;
            renameColumnElistNames(& sParse, & sCtx, pUpsertSet, zOld);
          }
          renameColumnIdlistNames(& sParse, & sCtx, pStep->pIdList, zOld);
          renameColumnElistNames(& sParse, & sCtx, pStep->pExprList, zOld);
        }
      }
      pStep = pStep->pNext;
    }
    if ((unsigned long )sParse.pTriggerTab == (unsigned long )pTab) {
      renameColumnIdlistNames(& sParse, & sCtx, (sParse.pNewTrigger)->pColumns, zOld);
    }
    renameWalkTrigger(& sWalker, sParse.pNewTrigger);
  }
  rc = renameEditSql(context, & sCtx, zSql, zNew, bQuote);
  renameColumnFunc_done: 
  if (rc != 0) {
    if (sParse.zErrMsg) {
      renameColumnParseError(context, 0, *(argv + 1), *(argv + 2), & sParse);
    } else {
      sqlite3_result_error_code(context, rc);
    }
  }
  renameParseCleanup(& sParse);
  renameTokenFree(db, sCtx.pList);
  db->xAuth = xAuth;
  return;
}
}
static int renameTableExprCb(Walker *pWalker , Expr *pExpr ) 
{ 
  RenameCtx *p ;

  {
  p = pWalker->u.pRename;
  if ((int )pExpr->op == 162) {
    if ((unsigned long )p->pTab == (unsigned long )pExpr->y.pTab) {
      renameTokenFind(pWalker->pParse, p, (void *)(& pExpr->y.pTab));
    }
  }
  return (0);
}
}
static int renameTableSelectCb(Walker *pWalker , Select *pSelect ) 
{ 
  int i ;
  RenameCtx *p ;
  SrcList *pSrc ;
  struct SrcList_item *pItem ;

  {
  p = pWalker->u.pRename;
  pSrc = pSelect->pSrc;
  if ((unsigned long )pSrc == (unsigned long )((SrcList *)0)) {
    return (2);
  }
  i = 0;
  while (i < pSrc->nSrc) {
    pItem = & pSrc->a[i];
    if ((unsigned long )pItem->pTab == (unsigned long )p->pTab) {
      renameTokenFind(pWalker->pParse, p, (void *)pItem->zName);
    }
    i ++;
  }
  renameWalkWith(pWalker, pSelect);
  return (0);
}
}
static void renameTableFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  char const   *zDb ;
  unsigned char const   *tmp___0 ;
  char const   *zInput ;
  unsigned char const   *tmp___1 ;
  char const   *zOld ;
  unsigned char const   *tmp___2 ;
  char const   *zNew ;
  unsigned char const   *tmp___3 ;
  int bTemp ;
  int tmp___4 ;
  Parse sParse ;
  int rc ;
  int bQuote ;
  RenameCtx sCtx ;
  Walker sWalker ;
  int (*xAuth)(void * , int  , char const   * , char const   * , char const   * ,
               char const   * ) ;
  int isLegacy ;
  Table *pTab ;
  NameContext sNC ;
  FKey *pFKey ;
  int tmp___5 ;
  int tmp___6 ;
  Trigger *pTrigger ;
  TriggerStep *pStep ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zDb = (char const   *)tmp___0;
  tmp___1 = sqlite3_value_text(*(argv + 3));
  zInput = (char const   *)tmp___1;
  tmp___2 = sqlite3_value_text(*(argv + 4));
  zOld = (char const   *)tmp___2;
  tmp___3 = sqlite3_value_text(*(argv + 5));
  zNew = (char const   *)tmp___3;
  tmp___4 = sqlite3_value_int(*(argv + 6));
  bTemp = tmp___4;
  if (zInput) {
    if (zOld) {
      if (zNew) {
        bQuote = 1;
        xAuth = db->xAuth;
        db->xAuth = (int (*)(void * , int  , char const   * , char const   * , char const   * ,
                             char const   * ))0;
        sqlite3BtreeEnterAll(db);
        memset((void *)(& sCtx), 0, sizeof(RenameCtx ));
        sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
        memset((void *)(& sWalker), 0, sizeof(Walker ));
        sWalker.pParse = & sParse;
        sWalker.xExprCallback = & renameTableExprCb;
        sWalker.xSelectCallback = & renameTableSelectCb;
        sWalker.u.pRename = & sCtx;
        rc = renameParseSql(& sParse, zDb, 1, db, zInput, bTemp);
        if (rc == 0) {
          isLegacy = (int )(db->flags & 67108864ULL);
          if (sParse.pNewTable) {
            pTab = sParse.pNewTable;
            if (pTab->pSelect) {
              if (isLegacy == 0) {
                memset((void *)(& sNC), 0, sizeof(sNC));
                sNC.pParse = & sParse;
                sqlite3SelectPrep(& sParse, pTab->pSelect, & sNC);
                if (sParse.nErr) {
                  rc = sParse.rc;
                }
                sqlite3WalkSelect(& sWalker, pTab->pSelect);
              }
            } else {
              if (isLegacy == 0) {
                goto _L;
              } else
              if (db->flags & 16384ULL) {
                _L: /* CIL Label */ 
                pFKey = pTab->pFKey;
                while (pFKey) {
                  tmp___5 = sqlite3_stricmp((char const   *)pFKey->zTo, zOld);
                  if (tmp___5 == 0) {
                    renameTokenFind(& sParse, & sCtx, (void *)pFKey->zTo);
                  }
                  pFKey = pFKey->pNextFrom;
                }
              }
              tmp___6 = sqlite3_stricmp(zOld, (char const   *)pTab->zName);
              if (tmp___6 == 0) {
                sCtx.pTab = pTab;
                if (isLegacy == 0) {
                  sqlite3WalkExprList(& sWalker, pTab->pCheck);
                }
                renameTokenFind(& sParse, & sCtx, (void *)pTab->zName);
              }
            }
          } else
          if (sParse.pNewIndex) {
            renameTokenFind(& sParse, & sCtx, (void *)(sParse.pNewIndex)->zName);
            if (isLegacy == 0) {
              sqlite3WalkExpr(& sWalker, (sParse.pNewIndex)->pPartIdxWhere);
            }
          } else {
            pTrigger = sParse.pNewTrigger;
            tmp___7 = sqlite3_stricmp((char const   *)(sParse.pNewTrigger)->table,
                                      zOld);
            if (0 == tmp___7) {
              if ((unsigned long )(sCtx.pTab)->pSchema == (unsigned long )pTrigger->pTabSchema) {
                renameTokenFind(& sParse, & sCtx, (void *)(sParse.pNewTrigger)->table);
              }
            }
            if (isLegacy == 0) {
              if (bTemp) {
                tmp___8 = (char const   *)0;
              } else {
                tmp___8 = zDb;
              }
              rc = renameResolveTrigger(& sParse, tmp___8);
              if (rc == 0) {
                renameWalkTrigger(& sWalker, pTrigger);
                pStep = pTrigger->step_list;
                while (pStep) {
                  if (pStep->zTarget) {
                    tmp___9 = sqlite3_stricmp((char const   *)pStep->zTarget, zOld);
                    if (0 == tmp___9) {
                      renameTokenFind(& sParse, & sCtx, (void *)pStep->zTarget);
                    }
                  }
                  pStep = pStep->pNext;
                }
              }
            }
          }
        }
        if (rc == 0) {
          rc = renameEditSql(context, & sCtx, zInput, zNew, bQuote);
        }
        if (rc != 0) {
          if (sParse.zErrMsg) {
            renameColumnParseError(context, 0, *(argv + 1), *(argv + 2), & sParse);
          } else {
            sqlite3_result_error_code(context, rc);
          }
        }
        renameParseCleanup(& sParse);
        renameTokenFree(db, sCtx.pList);
        db->xAuth = xAuth;
      }
    }
  }
  return;
}
}
static void renameTableTest(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  char const   *zDb ;
  unsigned char const   *tmp___0 ;
  char const   *zInput ;
  unsigned char const   *tmp___1 ;
  int bTemp ;
  int tmp___2 ;
  int isLegacy ;
  int (*xAuth)(void * , int  , char const   * , char const   * , char const   * ,
               char const   * ) ;
  int rc ;
  Parse sParse ;
  NameContext sNC ;
  char const   *tmp___3 ;
  int i1 ;
  int tmp___4 ;
  int i2 ;
  int tmp___5 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zDb = (char const   *)tmp___0;
  tmp___1 = sqlite3_value_text(*(argv + 1));
  zInput = (char const   *)tmp___1;
  tmp___2 = sqlite3_value_int(*(argv + 4));
  bTemp = tmp___2;
  isLegacy = (int )(db->flags & 67108864ULL);
  xAuth = db->xAuth;
  db->xAuth = (int (*)(void * , int  , char const   * , char const   * , char const   * ,
                       char const   * ))0;
  if (zDb) {
    if (zInput) {
      rc = renameParseSql(& sParse, zDb, 1, db, zInput, bTemp);
      if (rc == 0) {
        if (isLegacy == 0) {
          if (sParse.pNewTable) {
            if ((sParse.pNewTable)->pSelect) {
              memset((void *)(& sNC), 0, sizeof(sNC));
              sNC.pParse = & sParse;
              sqlite3SelectPrep(& sParse, (sParse.pNewTable)->pSelect, & sNC);
              if (sParse.nErr) {
                rc = sParse.rc;
              }
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (sParse.pNewTrigger) {
          if (isLegacy == 0) {
            if (bTemp) {
              tmp___3 = (char const   *)0;
            } else {
              tmp___3 = zDb;
            }
            rc = renameResolveTrigger(& sParse, tmp___3);
          }
          if (rc == 0) {
            tmp___4 = sqlite3SchemaToIndex(db, (sParse.pNewTrigger)->pTabSchema);
            i1 = tmp___4;
            tmp___5 = sqlite3FindDbName(db, zDb);
            i2 = tmp___5;
            if (i1 == i2) {
              sqlite3_result_int(context, 1);
            }
          }
        }
      }
      if (rc != 0) {
        renameColumnParseError(context, 1, *(argv + 2), *(argv + 3), & sParse);
      }
      renameParseCleanup(& sParse);
    }
  }
  db->xAuth = xAuth;
  return;
}
}
static FuncDef aAlterTableFuncs[3]  = {      {(i8 )9, (u32 )264193, (void *)0, (FuncDef *)0, & renameColumnFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_rename_column", {(FuncDef *)0}}, 
        {(i8 )7, (u32 )264193, (void *)0, (FuncDef *)0, & renameTableFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_rename_table", {(FuncDef *)0}}, 
        {(i8 )5, (u32 )264193, (void *)0, (FuncDef *)0, & renameTableTest, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_rename_test", {(FuncDef *)0}}};
static void sqlite3AlterFunctions(void) 
{ 


  {
  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, (int )(sizeof(aAlterTableFuncs) / sizeof(aAlterTableFuncs[0])));
  return;
}
}
static void openStatTable(Parse *pParse , int iDb , int iStatCur , char const   *zWhere ,
                          char const   *zWhereType ) ;
static struct __anonstruct_aTable_527861670  const  aTable[3]  = {      {"sqlite_stat1", "tbl,idx,stat"}, 
        {"sqlite_stat4", (char const   *)0}, 
        {"sqlite_stat3", (char const   *)0}};
static void openStatTable(Parse *pParse , int iDb , int iStatCur , char const   *zWhere ,
                          char const   *zWhereType ) 
{ 
  int i ;
  sqlite3 *db ;
  Db *pDb ;
  Vdbe *v ;
  Vdbe *tmp ;
  int aRoot[(int )(sizeof(aTable) / sizeof(aTable[0]))] ;
  u8 aCreateTbl[(int )(sizeof(aTable) / sizeof(aTable[0]))] ;
  char const   *zTab ;
  Table *pStat ;

  {
  db = pParse->db;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return;
  }
  pDb = db->aDb + iDb;
  i = 0;
  while (i < (int )(sizeof(aTable) / sizeof(aTable[0]))) {
    zTab = (char const   *)aTable[i].zName;
    pStat = sqlite3FindTable(db, zTab, (char const   *)pDb->zDbSName);
    if ((unsigned long )pStat == (unsigned long )((Table *)0)) {
      if (aTable[i].zCols) {
        sqlite3NestedParse(pParse, "CREATE TABLE %Q.%s(%s)", pDb->zDbSName, zTab,
                           aTable[i].zCols);
        aRoot[i] = pParse->regRoot;
        aCreateTbl[i] = (u8 )16;
      }
    } else {
      aRoot[i] = pStat->tnum;
      aCreateTbl[i] = (u8 )0;
      sqlite3TableLock(pParse, iDb, aRoot[i], (u8 )1, zTab);
      if (zWhere) {
        sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", pDb->zDbSName,
                           zTab, zWhereType, zWhere);
      } else {
        sqlite3VdbeAddOp2(v, 137, aRoot[i], iDb);
      }
    }
    i ++;
  }
  i = 0;
  while (aTable[i].zCols) {
    sqlite3VdbeAddOp4Int(v, 98, iStatCur + i, aRoot[i], iDb, 3);
    sqlite3VdbeChangeP5(v, (u16 )aCreateTbl[i]);
    i ++;
  }
  return;
}
}
static void stat4Destructor(void *pOld ) 
{ 
  Stat4Accum *p ;

  {
  p = (Stat4Accum *)pOld;
  sqlite3DbFree(p->db, (void *)p);
  return;
}
}
static void statInit(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  Stat4Accum *p ;
  int nCol ;
  int nKeyCol ;
  int nColUp ;
  int n ;
  sqlite3 *db ;
  void *tmp ;

  {
  nCol = sqlite3_value_int(*(argv + 0));
  if (sizeof(tRowcnt ) < 8UL) {
    nColUp = (nCol + 1) & -2;
  } else {
    nColUp = nCol;
  }
  nKeyCol = sqlite3_value_int(*(argv + 1));
  n = (int )((sizeof(*p) + sizeof(tRowcnt ) * (unsigned long )nColUp) + sizeof(tRowcnt ) * (unsigned long )nColUp);
  db = sqlite3_context_db_handle(context);
  tmp = sqlite3DbMallocZero(db, (u64 )n);
  p = (Stat4Accum *)tmp;
  if ((unsigned long )p == (unsigned long )((Stat4Accum *)0)) {
    sqlite3_result_error_nomem(context);
    return;
  }
  p->db = db;
  p->nRow = (tRowcnt )0;
  p->nCol = nCol;
  p->nKeyCol = nKeyCol;
  p->current.anDLt = (tRowcnt *)(p + 1);
  p->current.anEq = p->current.anDLt + nColUp;
  sqlite3_result_blob(context, (void const   *)p, (int )sizeof(*p), & stat4Destructor);
  return;
}
}
static struct FuncDef  const  statInitFuncdef  = 
     {(i8 )2, (u32 )1, (void *)0, (FuncDef *)0, & statInit, (void (*)(sqlite3_context * ))0,
    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
    "stat_init", {(FuncDef *)0}};
static void samplePushPrevious(Stat4Accum *p , int iChng ) 
{ 


  {
  return;
}
}
static void statPush(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int i ;
  Stat4Accum *p ;
  void const   *tmp ;
  int iChng ;
  int tmp___0 ;

  {
  tmp = sqlite3_value_blob(*(argv + 0));
  p = (Stat4Accum *)tmp;
  tmp___0 = sqlite3_value_int(*(argv + 1));
  iChng = tmp___0;
  if (p->nRow == 0U) {
    i = 0;
    while (i < p->nCol) {
      *(p->current.anEq + i) = (tRowcnt )1;
      i ++;
    }
  } else {
    samplePushPrevious(p, iChng);
    i = 0;
    while (i < iChng) {
      (*(p->current.anEq + i)) ++;
      i ++;
    }
    i = iChng;
    while (i < p->nCol) {
      (*(p->current.anDLt + i)) ++;
      *(p->current.anEq + i) = (tRowcnt )1;
      i ++;
    }
  }
  (p->nRow) ++;
  return;
}
}
static struct FuncDef  const  statPushFuncdef  = 
     {(i8 )2, (u32 )1, (void *)0, (FuncDef *)0, & statPush, (void (*)(sqlite3_context * ))0,
    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
    "stat_push", {(FuncDef *)0}};
static void statGet(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  Stat4Accum *p ;
  void const   *tmp ;
  char *z ;
  int i ;
  char *zRet ;
  void *tmp___0 ;
  int tmp___1 ;
  u64 nDistinct ;
  u64 iVal ;
  int tmp___2 ;

  {
  tmp = sqlite3_value_blob(*(argv + 0));
  p = (Stat4Accum *)tmp;
  tmp___0 = sqlite3MallocZero((u64 )((p->nKeyCol + 1) * 25));
  zRet = (char *)tmp___0;
  if ((unsigned long )zRet == (unsigned long )((char *)0)) {
    sqlite3_result_error_nomem(context);
    return;
  }
  sqlite3_snprintf(24, zRet, "%llu", (u64 )p->nRow);
  tmp___1 = sqlite3Strlen30((char const   *)zRet);
  z = zRet + tmp___1;
  i = 0;
  while (i < p->nKeyCol) {
    nDistinct = (u64 )(*(p->current.anDLt + i) + 1U);
    iVal = (((u64 )p->nRow + nDistinct) - 1ULL) / nDistinct;
    sqlite3_snprintf(24, z, " %llu", iVal);
    tmp___2 = sqlite3Strlen30((char const   *)z);
    z += tmp___2;
    i ++;
  }
  sqlite3_result_text(context, (char const   *)zRet, -1, & sqlite3_free);
  return;
}
}
static struct FuncDef  const  statGetFuncdef  = 
     {(i8 )1, (u32 )1, (void *)0, (FuncDef *)0, & statGet, (void (*)(sqlite3_context * ))0,
    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
    "stat_get", {(FuncDef *)0}};
static void callStatGet(Vdbe *v , int regStat4 , int iParam , int regOut ) 
{ 


  {
  sqlite3VdbeAddOp4(v, 63, 0, regStat4, regOut, (char const   *)((char *)(& statGetFuncdef)),
                    -8);
  sqlite3VdbeChangeP5(v, (u16 )1);
  return;
}
}
static void analyzeOneTable(Parse *pParse , Table *pTab , Index *pOnlyIdx , int iStatCur ,
                            int iMem , int iTab ) 
{ 
  sqlite3 *db ;
  Index *pIdx ;
  int iIdxCur ;
  int iTabCur ;
  Vdbe *v ;
  int i ;
  int jZeroRows ;
  int iDb ;
  u8 needTableCnt ;
  int regNewRowid ;
  int tmp ;
  int regStat4 ;
  int tmp___0 ;
  int regChng ;
  int tmp___1 ;
  int regTemp ;
  int tmp___2 ;
  int regTabname ;
  int tmp___3 ;
  int regIdxname ;
  int tmp___4 ;
  int regStat1 ;
  int tmp___5 ;
  int regPrev ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int nCol ;
  int addrRewind ;
  int addrNextRow ;
  char const   *zIdxName ;
  int nColTest ;
  int endDistinctTest ;
  int tmp___10 ;
  int *aGotoChng ;
  void *tmp___11 ;
  char *pColl ;
  CollSeq *tmp___12 ;

  {
  db = pParse->db;
  jZeroRows = -1;
  needTableCnt = (u8 )1;
  tmp = iMem;
  iMem ++;
  regNewRowid = tmp;
  tmp___0 = iMem;
  iMem ++;
  regStat4 = tmp___0;
  tmp___1 = iMem;
  iMem ++;
  regChng = tmp___1;
  tmp___2 = iMem;
  iMem ++;
  regTemp = tmp___2;
  tmp___3 = iMem;
  iMem ++;
  regTabname = tmp___3;
  tmp___4 = iMem;
  iMem ++;
  regIdxname = tmp___4;
  tmp___5 = iMem;
  iMem ++;
  regStat1 = tmp___5;
  regPrev = iMem;
  if (pParse->nMem > iMem) {
    pParse->nMem = pParse->nMem;
  } else {
    pParse->nMem = iMem;
  }
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return;
  } else
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return;
  }
  if (pTab->tnum == 0) {
    return;
  }
  tmp___6 = sqlite3_strlike("sqlite\\_%", (char const   *)pTab->zName, (unsigned int )'\\');
  if (tmp___6 == 0) {
    return;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  tmp___7 = sqlite3AuthCheck(pParse, 28, (char const   *)pTab->zName, (char const   *)0,
                             (char const   *)(db->aDb + iDb)->zDbSName);
  if (tmp___7) {
    return;
  }
  sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )0, (char const   *)pTab->zName);
  tmp___8 = iTab;
  iTab ++;
  iTabCur = tmp___8;
  tmp___9 = iTab;
  iTab ++;
  iIdxCur = tmp___9;
  if (pParse->nTab > iTab) {
    pParse->nTab = pParse->nTab;
  } else {
    pParse->nTab = iTab;
  }
  sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 97);
  sqlite3VdbeLoadString(v, regTabname, (char const   *)pTab->zName);
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (pOnlyIdx) {
      if ((unsigned long )pOnlyIdx != (unsigned long )pIdx) {
        goto __Cont;
      }
    }
    if ((unsigned long )pIdx->pPartIdxWhere == (unsigned long )((Expr *)0)) {
      needTableCnt = (u8 )0;
    }
    if (! ((pTab->tabFlags & 32U) == 0U)) {
      if (pIdx->idxType == 2U) {
        nCol = (int )pIdx->nKeyCol;
        zIdxName = (char const   *)pTab->zName;
        nColTest = nCol - 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      nCol = (int )pIdx->nColumn;
      zIdxName = (char const   *)pIdx->zName;
      if (pIdx->uniqNotNull) {
        nColTest = (int )pIdx->nKeyCol - 1;
      } else {
        nColTest = nCol - 1;
      }
    }
    sqlite3VdbeLoadString(v, regIdxname, zIdxName);
    if (pParse->nMem > regPrev + nColTest) {
      pParse->nMem = pParse->nMem;
    } else {
      pParse->nMem = regPrev + nColTest;
    }
    sqlite3VdbeAddOp3(v, 97, iIdxCur, pIdx->tnum, iDb);
    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
    sqlite3VdbeAddOp2(v, 70, nCol, regStat4 + 1);
    sqlite3VdbeAddOp2(v, 70, (int )pIdx->nKeyCol, regStat4 + 2);
    sqlite3VdbeAddOp4(v, 63, 0, regStat4 + 1, regStat4, (char const   *)((char *)(& statInitFuncdef)),
                      -8);
    sqlite3VdbeChangeP5(v, (u16 )2);
    addrRewind = sqlite3VdbeAddOp1(v, 36, iIdxCur);
    sqlite3VdbeAddOp2(v, 70, 0, regChng);
    addrNextRow = sqlite3VdbeCurrentAddr(v);
    if (nColTest > 0) {
      tmp___10 = sqlite3VdbeMakeLabel(pParse);
      endDistinctTest = tmp___10;
      tmp___11 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(int ) * (unsigned long )nColTest));
      aGotoChng = (int *)tmp___11;
      if ((unsigned long )aGotoChng == (unsigned long )((int *)0)) {
        goto __Cont;
      }
      sqlite3VdbeAddOp0(v, 11);
      addrNextRow = sqlite3VdbeCurrentAddr(v);
      if (nColTest == 1) {
        if ((int )pIdx->nKeyCol == 1) {
          if ((int )pIdx->onError != 0) {
            sqlite3VdbeAddOp2(v, 51, regPrev, endDistinctTest);
          }
        }
      }
      i = 0;
      while (i < nColTest) {
        tmp___12 = sqlite3LocateCollSeq(pParse, *(pIdx->azColl + i));
        pColl = (char *)tmp___12;
        sqlite3VdbeAddOp2(v, 70, i, regChng);
        sqlite3VdbeAddOp3(v, 90, iIdxCur, i, regTemp);
        *(aGotoChng + i) = sqlite3VdbeAddOp4(v, 52, regTemp, 0, regPrev + i, (char const   *)pColl,
                                             -2);
        sqlite3VdbeChangeP5(v, (u16 )128);
        i ++;
      }
      sqlite3VdbeAddOp2(v, 70, nColTest, regChng);
      sqlite3VdbeGoto(v, endDistinctTest);
      sqlite3VdbeJumpHere(v, addrNextRow - 1);
      i = 0;
      while (i < nColTest) {
        sqlite3VdbeJumpHere(v, *(aGotoChng + i));
        sqlite3VdbeAddOp3(v, 90, iIdxCur, i, regPrev + i);
        i ++;
      }
      sqlite3VdbeResolveLabel(v, endDistinctTest);
      sqlite3DbFree(db, (void *)aGotoChng);
    }
    sqlite3VdbeAddOp4(v, 63, 1, regStat4, regTemp, (char const   *)((char *)(& statPushFuncdef)),
                      -8);
    sqlite3VdbeChangeP5(v, (u16 )2);
    sqlite3VdbeAddOp2(v, 5, iIdxCur, addrNextRow);
    callStatGet(v, regStat4, 0, regStat1);
    sqlite3VdbeAddOp4(v, 92, regTabname, 3, regTemp, "BBB", 0);
    sqlite3VdbeAddOp2(v, 121, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 122, iStatCur, regTemp, regNewRowid);
    sqlite3VdbeChangeP5(v, (u16 )8);
    sqlite3VdbeJumpHere(v, addrRewind);
    __Cont: /* CIL Label */ 
    pIdx = pIdx->pNext;
  }
  if ((unsigned long )pOnlyIdx == (unsigned long )((Index *)0)) {
    if (needTableCnt) {
      sqlite3VdbeAddOp2(v, 93, iTabCur, regStat1);
      jZeroRows = sqlite3VdbeAddOp1(v, 20, regStat1);
      sqlite3VdbeAddOp2(v, 73, 0, regIdxname);
      sqlite3VdbeAddOp4(v, 92, regTabname, 3, regTemp, "BBB", 0);
      sqlite3VdbeAddOp2(v, 121, iStatCur, regNewRowid);
      sqlite3VdbeAddOp3(v, 122, iStatCur, regTemp, regNewRowid);
      sqlite3VdbeChangeP5(v, (u16 )8);
      sqlite3VdbeJumpHere(v, jZeroRows);
    }
  }
  return;
}
}
static void loadAnalysis(Parse *pParse , int iDb ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if (v) {
    sqlite3VdbeAddOp1(v, 142, iDb);
  }
  return;
}
}
static void analyzeDatabase(Parse *pParse , int iDb ) 
{ 
  sqlite3 *db ;
  Schema *pSchema ;
  HashElem *k ;
  int iStatCur ;
  int iMem ;
  int iTab ;
  Table *pTab ;

  {
  db = pParse->db;
  pSchema = (db->aDb + iDb)->pSchema;
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 3;
  openStatTable(pParse, iDb, iStatCur, (char const   *)0, (char const   *)0);
  iMem = pParse->nMem + 1;
  iTab = pParse->nTab;
  k = pSchema->tblHash.first;
  while (k) {
    pTab = (Table *)k->data;
    analyzeOneTable(pParse, pTab, (Index *)0, iStatCur, iMem, iTab);
    k = k->next;
  }
  loadAnalysis(pParse, iDb);
  return;
}
}
static void analyzeTable(Parse *pParse , Table *pTab , Index *pOnlyIdx ) 
{ 
  int iDb ;
  int iStatCur ;

  {
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 3;
  if (pOnlyIdx) {
    openStatTable(pParse, iDb, iStatCur, (char const   *)pOnlyIdx->zName, "idx");
  } else {
    openStatTable(pParse, iDb, iStatCur, (char const   *)pTab->zName, "tbl");
  }
  analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur, pParse->nMem + 1, pParse->nTab);
  loadAnalysis(pParse, iDb);
  return;
}
}
static void sqlite3Analyze(Parse *pParse , Token *pName1 , Token *pName2 ) 
{ 
  sqlite3 *db ;
  int iDb ;
  int i ;
  char *z ;
  char *zDb ;
  Table *pTab ;
  Index *pIdx ;
  Token *pTableName ;
  Vdbe *v ;
  int tmp ;

  {
  db = pParse->db;
  tmp = sqlite3ReadSchema(pParse);
  if (0 != tmp) {
    return;
  }
  if ((unsigned long )pName1 == (unsigned long )((Token *)0)) {
    i = 0;
    while (i < db->nDb) {
      if (i == 1) {
        goto __Cont;
      }
      analyzeDatabase(pParse, i);
      __Cont: /* CIL Label */ 
      i ++;
    }
  } else
  if (pName2->n == 0U) {
    iDb = sqlite3FindDb(db, pName1);
    if (iDb >= 0) {
      analyzeDatabase(pParse, iDb);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, & pTableName);
    if (iDb >= 0) {
      if (pName2->n) {
        zDb = (db->aDb + iDb)->zDbSName;
      } else {
        zDb = (char *)0;
      }
      z = sqlite3NameFromToken(db, pTableName);
      if (z) {
        pIdx = sqlite3FindIndex(db, (char const   *)z, (char const   *)zDb);
        if ((unsigned long )pIdx != (unsigned long )((Index *)0)) {
          analyzeTable(pParse, pIdx->pTable, pIdx);
        } else {
          pTab = sqlite3LocateTable(pParse, (u32 )0, (char const   *)z, (char const   *)zDb);
          if ((unsigned long )pTab != (unsigned long )((Table *)0)) {
            analyzeTable(pParse, pTab, (Index *)0);
          }
        }
        sqlite3DbFree(db, (void *)z);
      }
    }
  }
  if ((int )db->nSqlExec == 0) {
    v = sqlite3GetVdbe(pParse);
    if ((unsigned long )v != (unsigned long )((Vdbe *)0)) {
      sqlite3VdbeAddOp0(v, 158);
    }
  }
  return;
}
}
static void decodeIntArray(char *zIntArray , int nOut , tRowcnt *aOut , LogEst *aLog ,
                           Index *pIndex ) 
{ 
  char *z ;
  int c ;
  int i ;
  tRowcnt v ;
  int sz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  z = zIntArray;
  i = 0;
  while (1) {
    if (*z) {
      if (! (i < nOut)) {
        break;
      }
    } else {
      break;
    }
    v = (tRowcnt )0;
    while (1) {
      c = (int )*(z + 0);
      if (c >= 48) {
        if (! (c <= 57)) {
          break;
        }
      } else {
        break;
      }
      v = (v * 10U + (tRowcnt )c) - 48U;
      z ++;
    }
    *(aLog + i) = sqlite3LogEst((u64 )v);
    if ((int )*z == 32) {
      z ++;
    }
    i ++;
  }
  pIndex->bUnordered = 0U;
  pIndex->noSkipScan = 0U;
  while (*(z + 0)) {
    tmp___2 = sqlite3_strglob("unordered*", (char const   *)z);
    if (tmp___2 == 0) {
      pIndex->bUnordered = 1U;
    } else {
      tmp___1 = sqlite3_strglob("sz=[0-9]*", (char const   *)z);
      if (tmp___1 == 0) {
        tmp = sqlite3Atoi((char const   *)(z + 3));
        sz = tmp;
        if (sz < 2) {
          sz = 2;
        }
        pIndex->szIdxRow = sqlite3LogEst((u64 )sz);
      } else {
        tmp___0 = sqlite3_strglob("noskipscan*", (char const   *)z);
        if (tmp___0 == 0) {
          pIndex->noSkipScan = 1U;
        }
      }
    }
    while (1) {
      if ((int )*(z + 0) != 0) {
        if (! ((int )*(z + 0) != 32)) {
          break;
        }
      } else {
        break;
      }
      z ++;
    }
    while ((int )*(z + 0) == 32) {
      z ++;
    }
  }
  return;
}
}
static int analysisLoader(void *pData , int argc , char **argv , char **NotUsed ) 
{ 
  analysisInfo *pInfo ;
  Index *pIndex ;
  Table *pTable ;
  char const   *z ;
  int tmp ;
  tRowcnt *aiRowEst ;
  int nCol ;
  Index fakeIdx ;

  {
  pInfo = (analysisInfo *)pData;
  if ((unsigned long )argv == (unsigned long )((char **)0)) {
    return (0);
  } else
  if ((unsigned long )*(argv + 0) == (unsigned long )((char *)0)) {
    return (0);
  } else
  if ((unsigned long )*(argv + 2) == (unsigned long )((char *)0)) {
    return (0);
  }
  pTable = sqlite3FindTable(pInfo->db, (char const   *)*(argv + 0), pInfo->zDatabase);
  if ((unsigned long )pTable == (unsigned long )((Table *)0)) {
    return (0);
  }
  if ((unsigned long )*(argv + 1) == (unsigned long )((char *)0)) {
    pIndex = (Index *)0;
  } else {
    tmp = sqlite3_stricmp((char const   *)*(argv + 0), (char const   *)*(argv + 1));
    if (tmp == 0) {
      pIndex = sqlite3PrimaryKeyIndex(pTable);
    } else {
      pIndex = sqlite3FindIndex(pInfo->db, (char const   *)*(argv + 1), pInfo->zDatabase);
    }
  }
  z = (char const   *)*(argv + 2);
  if (pIndex) {
    aiRowEst = (tRowcnt *)0;
    nCol = (int )pIndex->nKeyCol + 1;
    pIndex->bUnordered = 0U;
    decodeIntArray((char *)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);
    pIndex->hasStat1 = 1U;
    if ((unsigned long )pIndex->pPartIdxWhere == (unsigned long )((Expr *)0)) {
      pTable->nRowLogEst = *(pIndex->aiRowLogEst + 0);
      pTable->tabFlags |= 16U;
    }
  } else {
    fakeIdx.szIdxRow = pTable->szTabRow;
    decodeIntArray((char *)z, 1, (tRowcnt *)0, & pTable->nRowLogEst, & fakeIdx);
    pTable->szTabRow = fakeIdx.szIdxRow;
    pTable->tabFlags |= 16U;
  }
  return (0);
}
}
static void sqlite3DeleteIndexSamples(sqlite3 *db , Index *pIdx ) 
{ 


  {
  return;
}
}
static int sqlite3AnalysisLoad(sqlite3 *db , int iDb ) 
{ 
  analysisInfo sInfo ;
  HashElem *i ;
  char *zSql ;
  int rc ;
  Schema *pSchema ;
  Table *pTab ;
  Index *pIdx ;
  Table *tmp ;
  Index *pIdx___0 ;

  {
  rc = 0;
  pSchema = (db->aDb + iDb)->pSchema;
  i = pSchema->tblHash.first;
  while (i) {
    pTab = (Table *)i->data;
    pTab->tabFlags &= 4294967279U;
    i = i->next;
  }
  i = pSchema->idxHash.first;
  while (i) {
    pIdx = (Index *)i->data;
    pIdx->hasStat1 = 0U;
    i = i->next;
  }
  sInfo.db = db;
  sInfo.zDatabase = (char const   *)(db->aDb + iDb)->zDbSName;
  tmp = sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase);
  if ((unsigned long )tmp != (unsigned long )((Table *)0)) {
    zSql = sqlite3MPrintf(db, "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
    if ((unsigned long )zSql == (unsigned long )((char *)0)) {
      rc = 7;
    } else {
      rc = sqlite3_exec(db, (char const   *)zSql, & analysisLoader, (void *)(& sInfo),
                        (char **)0);
      sqlite3DbFree(db, (void *)zSql);
    }
  }
  i = pSchema->idxHash.first;
  while (i) {
    pIdx___0 = (Index *)i->data;
    if (! pIdx___0->hasStat1) {
      sqlite3DefaultRowEst(pIdx___0);
    }
    i = i->next;
  }
  if (rc == 7) {
    sqlite3OomFault(db);
  }
  return (rc);
}
}
static int resolveAttachExpr(NameContext *pName , Expr *pExpr ) 
{ 
  int rc ;

  {
  rc = 0;
  if (pExpr) {
    if ((int )pExpr->op != 59) {
      rc = sqlite3ResolveExprNames(pName, pExpr);
    } else {
      pExpr->op = (u8 )113;
    }
  }
  return (rc);
}
}
static void attachFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  int i ;
  int rc ;
  sqlite3 *db ;
  sqlite3 *tmp ;
  char const   *zName ;
  char const   *zFile ;
  char *zPath ;
  char *zErr ;
  unsigned int flags___0 ;
  Db *aNew ;
  Db *pNew ;
  char *zErrDyn ;
  sqlite3_vfs *pVfs ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  char *z ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  Pager *pPager ;
  int tmp___5 ;
  int iDb ;

  {
  rc = 0;
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  zPath = (char *)0;
  zErr = (char *)0;
  zErrDyn = (char *)0;
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zFile = (char const   *)tmp___0;
  tmp___1 = sqlite3_value_text(*(argv + 1));
  zName = (char const   *)tmp___1;
  if ((unsigned long )zFile == (unsigned long )((char const   *)0)) {
    zFile = "";
  }
  if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
    zName = "";
  }
  if (db->nDb >= db->aLimit[7] + 2) {
    zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", db->aLimit[7]);
    goto attach_error;
  }
  i = 0;
  while (i < db->nDb) {
    z = (db->aDb + i)->zDbSName;
    tmp___2 = sqlite3StrICmp((char const   *)z, zName);
    if (tmp___2 == 0) {
      zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
      goto attach_error;
    }
    i ++;
  }
  if ((unsigned long )db->aDb == (unsigned long )(db->aDbStatic)) {
    tmp___3 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(*(db->aDb + 0)) * 3UL));
    aNew = (Db *)tmp___3;
    if ((unsigned long )aNew == (unsigned long )((Db *)0)) {
      return;
    }
    memcpy((void * __restrict  )aNew, (void const   * __restrict  )db->aDb, sizeof(*(db->aDb + 0)) * 2UL);
  } else {
    tmp___4 = sqlite3DbRealloc(db, (void *)db->aDb, (u64 )(sizeof(*(db->aDb + 0)) * (unsigned long )(db->nDb + 1)));
    aNew = (Db *)tmp___4;
    if ((unsigned long )aNew == (unsigned long )((Db *)0)) {
      return;
    }
  }
  db->aDb = aNew;
  pNew = db->aDb + db->nDb;
  memset((void *)pNew, 0, sizeof(*pNew));
  flags___0 = db->openFlags;
  rc = sqlite3ParseUri((db->pVfs)->zName, zFile, & flags___0, & pVfs, & zPath, & zErr);
  if (rc != 0) {
    if (rc == 7) {
      sqlite3OomFault(db);
    }
    sqlite3_result_error(context, (char const   *)zErr, -1);
    sqlite3_free((void *)zErr);
    return;
  }
  flags___0 |= 256U;
  rc = sqlite3BtreeOpen(pVfs, (char const   *)zPath, db, & pNew->pBt, 0, (int )flags___0);
  (db->nDb) ++;
  pNew->zDbSName = sqlite3DbStrDup(db, zName);
  db->noSharedCache = (u8 )0;
  if (rc == 19) {
    rc = 1;
    zErrDyn = sqlite3MPrintf(db, "database is already attached");
  } else
  if (rc == 0) {
    pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);
    if (! pNew->pSchema) {
      rc = 7;
    } else
    if ((pNew->pSchema)->file_format) {
      if ((int )(pNew->pSchema)->enc != (int )db->enc) {
        zErrDyn = sqlite3MPrintf(db, "attached databases must use the same text encoding as main database");
        rc = 1;
      }
    }
    sqlite3BtreeEnter(pNew->pBt);
    pPager = sqlite3BtreePager(pNew->pBt);
    sqlite3PagerLockingMode(pPager, (int )db->dfltLockMode);
    tmp___5 = sqlite3BtreeSecureDelete((db->aDb + 0)->pBt, -1);
    sqlite3BtreeSecureDelete(pNew->pBt, tmp___5);
    sqlite3BtreeSetPagerFlags(pNew->pBt, (unsigned int )(3ULL | (db->flags & 56ULL)));
  }
  pNew->safety_level = (u8 )3;
  if (rc == 0) {
    if ((unsigned long )pNew->zDbSName == (unsigned long )((char *)0)) {
      rc = 7;
    }
  }
  sqlite3_free((void *)zPath);
  if (rc == 0) {
    sqlite3BtreeEnterAll(db);
    db->init.iDb = (u8 )0;
    db->mDbFlags &= 4294967279U;
    rc = sqlite3Init(db, & zErrDyn);
  }
  if (rc) {
    iDb = db->nDb - 1;
    if ((db->aDb + iDb)->pBt) {
      sqlite3BtreeClose((db->aDb + iDb)->pBt);
      (db->aDb + iDb)->pBt = (Btree *)0;
      (db->aDb + iDb)->pSchema = (Schema *)0;
    }
    sqlite3ResetAllSchemasOfConnection(db);
    db->nDb = iDb;
    if (rc == 7) {
      sqlite3OomFault(db);
      sqlite3DbFree(db, (void *)zErrDyn);
      zErrDyn = sqlite3MPrintf(db, "out of memory");
    } else
    if (rc == (10 | (12 << 8))) {
      sqlite3OomFault(db);
      sqlite3DbFree(db, (void *)zErrDyn);
      zErrDyn = sqlite3MPrintf(db, "out of memory");
    } else
    if ((unsigned long )zErrDyn == (unsigned long )((char *)0)) {
      zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
    }
    goto attach_error;
  }
  return;
  attach_error: 
  if (zErrDyn) {
    sqlite3_result_error(context, (char const   *)zErrDyn, -1);
    sqlite3DbFree(db, (void *)zErrDyn);
  }
  if (rc) {
    sqlite3_result_error_code(context, rc);
  }
  return;
}
}
static void detachFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  char const   *zName ;
  unsigned char const   *tmp ;
  sqlite3 *db ;
  sqlite3 *tmp___0 ;
  int i ;
  Db *pDb ;
  HashElem *pEntry ;
  char zErr[128] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Trigger *pTrig ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  zName = (char const   *)tmp;
  tmp___0 = sqlite3_context_db_handle(context);
  db = tmp___0;
  pDb = (Db *)0;
  if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
    zName = "";
  }
  i = 0;
  while (i < db->nDb) {
    pDb = db->aDb + i;
    if ((unsigned long )pDb->pBt == (unsigned long )((Btree *)0)) {
      goto __Cont;
    }
    tmp___1 = sqlite3StrICmp((char const   *)pDb->zDbSName, zName);
    if (tmp___1 == 0) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (i >= db->nDb) {
    sqlite3_snprintf((int )sizeof(zErr), zErr, "no such database: %s", zName);
    goto detach_error;
  }
  if (i < 2) {
    sqlite3_snprintf((int )sizeof(zErr), zErr, "cannot detach database %s", zName);
    goto detach_error;
  }
  tmp___2 = sqlite3BtreeIsInReadTrans(pDb->pBt);
  if (tmp___2) {
    sqlite3_snprintf((int )sizeof(zErr), zErr, "database %s is locked", zName);
    goto detach_error;
  } else {
    tmp___3 = sqlite3BtreeIsInBackup(pDb->pBt);
    if (tmp___3) {
      sqlite3_snprintf((int )sizeof(zErr), zErr, "database %s is locked", zName);
      goto detach_error;
    }
  }
  pEntry = ((db->aDb + 1)->pSchema)->trigHash.first;
  while (pEntry) {
    pTrig = (Trigger *)pEntry->data;
    if ((unsigned long )pTrig->pTabSchema == (unsigned long )pDb->pSchema) {
      pTrig->pTabSchema = pTrig->pSchema;
    }
    pEntry = pEntry->next;
  }
  sqlite3BtreeClose(pDb->pBt);
  pDb->pBt = (Btree *)0;
  pDb->pSchema = (Schema *)0;
  sqlite3CollapseDatabaseArray(db);
  return;
  detach_error: 
  sqlite3_result_error(context, (char const   *)(zErr), -1);
  return;
}
}
static void codeAttach(Parse *pParse , int type , FuncDef const   *pFunc , Expr *pAuthArg ,
                       Expr *pFilename , Expr *pDbname , Expr *pKey ) 
{ 
  int rc ;
  NameContext sName ;
  Vdbe *v ;
  sqlite3 *db ;
  int regArgs ;
  char *zAuthArg ;

  {
  db = pParse->db;
  if (pParse->nErr) {
    goto attach_end;
  }
  memset((void *)(& sName), 0, sizeof(NameContext ));
  sName.pParse = pParse;
  rc = resolveAttachExpr(& sName, pFilename);
  if (0 != rc) {
    goto attach_end;
  } else {
    rc = resolveAttachExpr(& sName, pDbname);
    if (0 != rc) {
      goto attach_end;
    } else {
      rc = resolveAttachExpr(& sName, pKey);
      if (0 != rc) {
        goto attach_end;
      }
    }
  }
  if (pAuthArg) {
    if ((int )pAuthArg->op == 113) {
      zAuthArg = pAuthArg->u.zToken;
    } else {
      zAuthArg = (char *)0;
    }
    rc = sqlite3AuthCheck(pParse, type, (char const   *)zAuthArg, (char const   *)0,
                          (char const   *)0);
    if (rc != 0) {
      goto attach_end;
    }
  }
  v = sqlite3GetVdbe(pParse);
  regArgs = sqlite3GetTempRange(pParse, 4);
  sqlite3ExprCode(pParse, pFilename, regArgs);
  sqlite3ExprCode(pParse, pDbname, regArgs + 1);
  sqlite3ExprCode(pParse, pKey, regArgs + 2);
  if (v) {
    sqlite3VdbeAddOp4(v, 63, 0, (regArgs + 3) - (int )pFunc->nArg, regArgs + 3, (char const   *)((char *)pFunc),
                      -8);
    sqlite3VdbeChangeP5(v, (u16 )((u8 )pFunc->nArg));
    sqlite3VdbeAddOp1(v, 158, type == 24);
  }
  attach_end: 
  sqlite3ExprDelete(db, pFilename);
  sqlite3ExprDelete(db, pDbname);
  sqlite3ExprDelete(db, pKey);
  return;
}
}
static struct FuncDef  const  detach_func  = 
     {(i8 )1, (u32 )1, (void *)0, (FuncDef *)0, & detachFunc, (void (*)(sqlite3_context * ))0,
    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
    "sqlite_detach", {(FuncDef *)0}};
static void sqlite3Detach(Parse *pParse , Expr *pDbname ) 
{ 


  {
  codeAttach(pParse, 25, & detach_func, pDbname, (Expr *)0, (Expr *)0, pDbname);
  return;
}
}
static struct FuncDef  const  attach_func  = 
     {(i8 )3, (u32 )1, (void *)0, (FuncDef *)0, & attachFunc, (void (*)(sqlite3_context * ))0,
    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
    "sqlite_attach", {(FuncDef *)0}};
static void sqlite3Attach(Parse *pParse , Expr *p , Expr *pDbname , Expr *pKey ) 
{ 


  {
  codeAttach(pParse, 24, & attach_func, p, p, pDbname, pKey);
  return;
}
}
static void sqlite3FixInit(DbFixer *pFix , Parse *pParse , int iDb , char const   *zType ,
                           Token const   *pName ) 
{ 
  sqlite3 *db ;

  {
  db = pParse->db;
  pFix->pParse = pParse;
  pFix->zDb = (char const   *)(db->aDb + iDb)->zDbSName;
  pFix->pSchema = (db->aDb + iDb)->pSchema;
  pFix->zType = zType;
  pFix->pName = pName;
  pFix->bVarOnly = iDb == 1;
  return;
}
}
static int sqlite3FixSrcList(DbFixer *pFix , SrcList *pList ) 
{ 
  int i ;
  char const   *zDb ;
  struct SrcList_item *pItem ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )pList == (unsigned long )((SrcList *)0)) {
    return (0);
  }
  zDb = pFix->zDb;
  i = 0;
  pItem = pList->a;
  while (i < pList->nSrc) {
    if (pFix->bVarOnly == 0) {
      if (pItem->zDatabase) {
        tmp = sqlite3StrICmp((char const   *)pItem->zDatabase, zDb);
        if (tmp) {
          sqlite3ErrorMsg(pFix->pParse, "%s %T cannot reference objects in database %s",
                          pFix->zType, pFix->pName, pItem->zDatabase);
          return (1);
        }
      }
      sqlite3DbFree((pFix->pParse)->db, (void *)pItem->zDatabase);
      pItem->zDatabase = (char *)0;
      pItem->pSchema = pFix->pSchema;
    }
    tmp___0 = sqlite3FixSelect(pFix, pItem->pSelect);
    if (tmp___0) {
      return (1);
    }
    tmp___1 = sqlite3FixExpr(pFix, pItem->pOn);
    if (tmp___1) {
      return (1);
    }
    if (pItem->fg.isTabFunc) {
      tmp___2 = sqlite3FixExprList(pFix, pItem->u1.pFuncArg);
      if (tmp___2) {
        return (1);
      }
    }
    i ++;
    pItem ++;
  }
  return (0);
}
}
static int sqlite3FixSelect(DbFixer *pFix , Select *pSelect ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int i ;
  int tmp___6 ;

  {
  while (pSelect) {
    tmp = sqlite3FixExprList(pFix, pSelect->pEList);
    if (tmp) {
      return (1);
    }
    tmp___0 = sqlite3FixSrcList(pFix, pSelect->pSrc);
    if (tmp___0) {
      return (1);
    }
    tmp___1 = sqlite3FixExpr(pFix, pSelect->pWhere);
    if (tmp___1) {
      return (1);
    }
    tmp___2 = sqlite3FixExprList(pFix, pSelect->pGroupBy);
    if (tmp___2) {
      return (1);
    }
    tmp___3 = sqlite3FixExpr(pFix, pSelect->pHaving);
    if (tmp___3) {
      return (1);
    }
    tmp___4 = sqlite3FixExprList(pFix, pSelect->pOrderBy);
    if (tmp___4) {
      return (1);
    }
    tmp___5 = sqlite3FixExpr(pFix, pSelect->pLimit);
    if (tmp___5) {
      return (1);
    }
    if (pSelect->pWith) {
      i = 0;
      while (i < (pSelect->pWith)->nCte) {
        tmp___6 = sqlite3FixSelect(pFix, (pSelect->pWith)->a[i].pSelect);
        if (tmp___6) {
          return (1);
        }
        i ++;
      }
    }
    pSelect = pSelect->pPrior;
  }
  return (0);
}
}
static int sqlite3FixExpr(DbFixer *pFix , Expr *pExpr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (pExpr) {
    pExpr->flags |= 1073741824U;
    if ((int )pExpr->op == 151) {
      if (((pFix->pParse)->db)->init.busy) {
        pExpr->op = (u8 )117;
      } else {
        sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
        return (1);
      }
    }
    if ((pExpr->flags & 8404992U) != 0U) {
      break;
    }
    if ((pExpr->flags & 2048U) != 0U) {
      tmp = sqlite3FixSelect(pFix, pExpr->x.pSelect);
      if (tmp) {
        return (1);
      }
    } else {
      tmp___0 = sqlite3FixExprList(pFix, pExpr->x.pList);
      if (tmp___0) {
        return (1);
      }
    }
    tmp___1 = sqlite3FixExpr(pFix, pExpr->pRight);
    if (tmp___1) {
      return (1);
    }
    pExpr = pExpr->pLeft;
  }
  return (0);
}
}
static int sqlite3FixExprList(DbFixer *pFix , ExprList *pList ) 
{ 
  int i ;
  struct ExprList_item *pItem ;
  int tmp ;

  {
  if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
    return (0);
  }
  i = 0;
  pItem = pList->a;
  while (i < pList->nExpr) {
    tmp = sqlite3FixExpr(pFix, pItem->pExpr);
    if (tmp) {
      return (1);
    }
    i ++;
    pItem ++;
  }
  return (0);
}
}
static int sqlite3FixTriggerStep(DbFixer *pFix , TriggerStep *pStep ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Upsert *pUp ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  while (pStep) {
    tmp = sqlite3FixSelect(pFix, pStep->pSelect);
    if (tmp) {
      return (1);
    }
    tmp___0 = sqlite3FixExpr(pFix, pStep->pWhere);
    if (tmp___0) {
      return (1);
    }
    tmp___1 = sqlite3FixExprList(pFix, pStep->pExprList);
    if (tmp___1) {
      return (1);
    }
    if (pStep->pUpsert) {
      pUp = pStep->pUpsert;
      tmp___2 = sqlite3FixExprList(pFix, pUp->pUpsertTarget);
      if (tmp___2) {
        return (1);
      } else {
        tmp___3 = sqlite3FixExpr(pFix, pUp->pUpsertTargetWhere);
        if (tmp___3) {
          return (1);
        } else {
          tmp___4 = sqlite3FixExprList(pFix, pUp->pUpsertSet);
          if (tmp___4) {
            return (1);
          } else {
            tmp___5 = sqlite3FixExpr(pFix, pUp->pUpsertWhere);
            if (tmp___5) {
              return (1);
            }
          }
        }
      }
    }
    pStep = pStep->pNext;
  }
  return (0);
}
}
int sqlite3_set_authorizer(sqlite3 *db , int (*xAuth)(void * , int  , char const   * ,
                                                      char const   * , char const   * ,
                                                      char const   * ) , void *pArg ) 
{ 


  {
  db->xAuth = xAuth;
  db->pAuthArg = pArg;
  if (db->xAuth) {
    sqlite3ExpirePreparedStatements(db, 1);
  }
  return (0);
}
}
static void sqliteAuthBadReturnCode(Parse *pParse ) 
{ 


  {
  sqlite3ErrorMsg(pParse, "authorizer malfunction");
  pParse->rc = 1;
  return;
}
}
static int sqlite3AuthReadCol(Parse *pParse , char const   *zTab , char const   *zCol ,
                              int iDb ) 
{ 
  sqlite3 *db ;
  char *zDb ;
  int rc ;
  char *z ;
  char *tmp ;

  {
  db = pParse->db;
  zDb = (db->aDb + iDb)->zDbSName;
  if (db->init.busy) {
    return (0);
  }
  rc = (*(db->xAuth))(db->pAuthArg, 20, zTab, zCol, (char const   *)zDb, pParse->zAuthContext);
  if (rc == 1) {
    tmp = sqlite3_mprintf("%s.%s", zTab, zCol);
    z = tmp;
    if (db->nDb > 2) {
      z = sqlite3_mprintf("%s.%z", zDb, z);
    } else
    if (iDb != 0) {
      z = sqlite3_mprintf("%s.%z", zDb, z);
    }
    sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);
    pParse->rc = 23;
  } else
  if (rc != 2) {
    if (rc != 0) {
      sqliteAuthBadReturnCode(pParse);
    }
  }
  return (rc);
}
}
static void sqlite3AuthRead(Parse *pParse , Expr *pExpr , Schema *pSchema , SrcList *pTabList ) 
{ 
  sqlite3 *db ;
  Table *pTab ;
  char const   *zCol ;
  int iSrc ;
  int iDb ;
  int iCol ;
  int tmp ;

  {
  db = pParse->db;
  pTab = (Table *)0;
  if ((unsigned long )db->xAuth == (unsigned long )((int (*)(void * , int  , char const   * ,
                                                             char const   * , char const   * ,
                                                             char const   * ))0)) {
    return;
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pSchema);
  if (iDb < 0) {
    return;
  }
  if ((int )pExpr->op == 77) {
    pTab = pParse->pTriggerTab;
  } else {
    iSrc = 0;
    while (iSrc < pTabList->nSrc) {
      if (pExpr->iTable == pTabList->a[iSrc].iCursor) {
        pTab = pTabList->a[iSrc].pTab;
        break;
      }
      iSrc ++;
    }
  }
  iCol = (int )pExpr->iColumn;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return;
  }
  if (iCol >= 0) {
    zCol = (char const   *)(pTab->aCol + iCol)->zName;
  } else
  if ((int )pTab->iPKey >= 0) {
    zCol = (char const   *)(pTab->aCol + pTab->iPKey)->zName;
  } else {
    zCol = "ROWID";
  }
  tmp = sqlite3AuthReadCol(pParse, (char const   *)pTab->zName, zCol, iDb);
  if (2 == tmp) {
    pExpr->op = (u8 )117;
  }
  return;
}
}
static int sqlite3AuthCheck(Parse *pParse , int code , char const   *zArg1 , char const   *zArg2 ,
                            char const   *zArg3 ) 
{ 
  sqlite3 *db ;
  int rc ;

  {
  db = pParse->db;
  if (db->init.busy) {
    return (0);
  } else
  if ((int )pParse->eParseMode != 0) {
    return (0);
  }
  if ((unsigned long )db->xAuth == (unsigned long )((int (*)(void * , int  , char const   * ,
                                                             char const   * , char const   * ,
                                                             char const   * ))0)) {
    return (0);
  }
  rc = (*(db->xAuth))(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext);
  if (rc == 1) {
    sqlite3ErrorMsg(pParse, "not authorized");
    pParse->rc = 23;
  } else
  if (rc != 0) {
    if (rc != 2) {
      rc = 1;
      sqliteAuthBadReturnCode(pParse);
    }
  }
  return (rc);
}
}
static void sqlite3AuthContextPush(Parse *pParse , AuthContext *pContext , char const   *zContext ) 
{ 


  {
  pContext->pParse = pParse;
  pContext->zAuthContext = pParse->zAuthContext;
  pParse->zAuthContext = zContext;
  return;
}
}
static void sqlite3AuthContextPop(AuthContext *pContext ) 
{ 


  {
  if (pContext->pParse) {
    (pContext->pParse)->zAuthContext = pContext->zAuthContext;
    pContext->pParse = (Parse *)0;
  }
  return;
}
}
static void sqlite3TableLock(Parse *pParse , int iDb , int iTab , u8 isWriteLock ,
                             char const   *zName ) 
{ 
  Parse *pToplevel ;
  Parse *tmp ;
  int i ;
  int nBytes ;
  TableLock *p ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pToplevel = tmp;
  if (iDb == 1) {
    return;
  }
  tmp___0 = sqlite3BtreeSharable(((pParse->db)->aDb + iDb)->pBt);
  if (! tmp___0) {
    return;
  }
  i = 0;
  while (i < pToplevel->nTableLock) {
    p = pToplevel->aTableLock + i;
    if (p->iDb == iDb) {
      if (p->iTab == iTab) {
        if (p->isWriteLock) {
          tmp___1 = 1;
        } else
        if (isWriteLock) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
        p->isWriteLock = (u8 )tmp___1;
        return;
      }
    }
    i ++;
  }
  nBytes = (int )(sizeof(TableLock ) * (unsigned long )(pToplevel->nTableLock + 1));
  tmp___2 = sqlite3DbReallocOrFree(pToplevel->db, (void *)pToplevel->aTableLock, (u64 )nBytes);
  pToplevel->aTableLock = (TableLock *)tmp___2;
  if (pToplevel->aTableLock) {
    tmp___3 = pToplevel->nTableLock;
    (pToplevel->nTableLock) ++;
    p = pToplevel->aTableLock + tmp___3;
    p->iDb = iDb;
    p->iTab = iTab;
    p->isWriteLock = isWriteLock;
    p->zLockName = zName;
  } else {
    pToplevel->nTableLock = 0;
    sqlite3OomFault(pToplevel->db);
  }
  return;
}
}
static void codeTableLocks(Parse *pParse ) 
{ 
  int i ;
  Vdbe *pVdbe ;
  TableLock *p ;
  int p1 ;

  {
  pVdbe = sqlite3GetVdbe(pParse);
  i = 0;
  while (i < pParse->nTableLock) {
    p = pParse->aTableLock + i;
    p1 = p->iDb;
    sqlite3VdbeAddOp4(pVdbe, 159, p1, p->iTab, (int )p->isWriteLock, p->zLockName,
                      -1);
    i ++;
  }
  return;
}
}
static void sqlite3FinishCoding(Parse *pParse ) 
{ 
  sqlite3 *db ;
  Vdbe *v ;
  int iDb ;
  int i ;
  Schema *pSchema ;
  char *vtab ;
  VTable *tmp ;
  ExprList *pEL ;

  {
  db = pParse->db;
  if (pParse->nested) {
    return;
  }
  if (db->mallocFailed) {
    goto _L;
  } else
  if (pParse->nErr) {
    _L: /* CIL Label */ 
    if (pParse->rc == 0) {
      pParse->rc = 1;
    }
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if (v) {
    sqlite3VdbeAddOp0(v, 69);
    if ((int )db->mallocFailed == 0) {
      if (pParse->cookieMask != 0U) {
        goto _L___0;
      } else
      if (pParse->pConstExpr) {
        _L___0: /* CIL Label */ 
        sqlite3VdbeJumpHere(v, 0);
        iDb = 0;
        while (iDb < db->nDb) {
          if (((pParse->cookieMask & (1U << iDb)) != 0U) == 0) {
            goto __Cont;
          }
          sqlite3VdbeUsesBtree(v, iDb);
          pSchema = (db->aDb + iDb)->pSchema;
          sqlite3VdbeAddOp4Int(v, 2, iDb, (pParse->writeMask & (1U << iDb)) != 0U,
                               pSchema->schema_cookie, pSchema->iGeneration);
          if ((int )db->init.busy == 0) {
            sqlite3VdbeChangeP5(v, (u16 )1);
          }
          __Cont: /* CIL Label */ 
          iDb ++;
        }
        i = 0;
        while (i < pParse->nVtabLock) {
          tmp = sqlite3GetVTable(db, *(pParse->apVtabLock + i));
          vtab = (char *)tmp;
          sqlite3VdbeAddOp4(v, 160, 0, 0, 0, (char const   *)vtab, -12);
          i ++;
        }
        pParse->nVtabLock = 0;
        codeTableLocks(pParse);
        sqlite3AutoincrementBegin(pParse);
        if (pParse->pConstExpr) {
          pEL = pParse->pConstExpr;
          pParse->okConstFactor = (u8 )0;
          i = 0;
          while (i < pEL->nExpr) {
            sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);
            i ++;
          }
        }
        sqlite3VdbeGoto(v, 1);
      }
    }
  }
  if (v) {
    if (pParse->nErr == 0) {
      if (! db->mallocFailed) {
        sqlite3VdbeMakeReady(v, pParse);
        pParse->rc = 101;
      } else {
        pParse->rc = 1;
      }
    } else {
      pParse->rc = 1;
    }
  } else {
    pParse->rc = 1;
  }
  return;
}
}
static void sqlite3NestedParse(Parse *pParse , char const   *zFormat  , ...) 
{ 
  va_list ap ;
  char *zSql ;
  char *zErrMsg ;
  sqlite3 *db ;
  char saveBuf[sizeof(Parse ) - (unsigned long )(& ((Parse *)0)->sLastToken)] ;

  {
  zErrMsg = (char *)0;
  db = pParse->db;
  if (pParse->nErr) {
    return;
  }
  __builtin_va_start(ap, zFormat);
  zSql = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  if ((unsigned long )zSql == (unsigned long )((char *)0)) {
    if (! db->mallocFailed) {
      pParse->rc = 18;
    }
    (pParse->nErr) ++;
    return;
  }
  pParse->nested = (u8 )((int )pParse->nested + 1);
  memcpy((void * __restrict  )(saveBuf), (void const   * __restrict  )((char *)pParse + (unsigned long )(& ((Parse *)0)->sLastToken)),
         sizeof(Parse ) - (unsigned long )(& ((Parse *)0)->sLastToken));
  memset((void *)((char *)pParse + (unsigned long )(& ((Parse *)0)->sLastToken)),
         0, sizeof(Parse ) - (unsigned long )(& ((Parse *)0)->sLastToken));
  sqlite3RunParser(pParse, (char const   *)zSql, & zErrMsg);
  sqlite3DbFree(db, (void *)zErrMsg);
  sqlite3DbFree(db, (void *)zSql);
  memcpy((void * __restrict  )((char *)pParse + (unsigned long )(& ((Parse *)0)->sLastToken)),
         (void const   * __restrict  )(saveBuf), sizeof(Parse ) - (unsigned long )(& ((Parse *)0)->sLastToken));
  pParse->nested = (u8 )((int )pParse->nested - 1);
  return;
}
}
static Table *sqlite3FindTable(sqlite3 *db , char const   *zName , char const   *zDatabase ) 
{ 
  Table *p ;
  int i ;
  int j ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  p = (Table *)0;
  while (1) {
    i = 0;
    while (i < db->nDb) {
      if (i < 2) {
        tmp = i ^ 1;
      } else {
        tmp = i;
      }
      j = tmp;
      if ((unsigned long )zDatabase == (unsigned long )((char const   *)0)) {
        goto _L;
      } else {
        tmp___1 = sqlite3StrICmp(zDatabase, (char const   *)(db->aDb + j)->zDbSName);
        if (tmp___1 == 0) {
          _L: /* CIL Label */ 
          tmp___0 = sqlite3HashFind((Hash const   *)(& ((db->aDb + j)->pSchema)->tblHash),
                                    zName);
          p = (Table *)tmp___0;
          if (p) {
            return (p);
          }
        }
      }
      i ++;
    }
    tmp___2 = sqlite3StrICmp(zName, "sqlite_master");
    if (tmp___2 != 0) {
      break;
    }
    tmp___3 = sqlite3_stricmp(zDatabase, (char const   *)(db->aDb + 1)->zDbSName);
    if (tmp___3 != 0) {
      break;
    }
    zName = "sqlite_temp_master";
  }
  return ((Table *)0);
}
}
static Table *sqlite3LocateTable(Parse *pParse , u32 flags___0 , char const   *zName ,
                                 char const   *zDbase ) 
{ 
  Table *p ;
  sqlite3 *db ;
  int tmp ;
  Module *pMod ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *zMsg ;
  char const   *tmp___3 ;

  {
  db = pParse->db;
  if ((db->mDbFlags & 16U) == 0U) {
    tmp = sqlite3ReadSchema(pParse);
    if (0 != tmp) {
      return ((Table *)0);
    }
  }
  p = sqlite3FindTable(db, zName, zDbase);
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    if ((int )pParse->disableVtab == 0) {
      tmp___0 = sqlite3HashFind((Hash const   *)(& db->aModule), zName);
      pMod = (Module *)tmp___0;
      if ((unsigned long )pMod == (unsigned long )((Module *)0)) {
        tmp___1 = sqlite3_strnicmp(zName, "pragma_", 7);
        if (tmp___1 == 0) {
          pMod = sqlite3PragmaVtabRegister(db, zName);
        }
      }
      if (pMod) {
        tmp___2 = sqlite3VtabEponymousTableInit(pParse, pMod);
        if (tmp___2) {
          return (pMod->pEpoTab);
        }
      }
    }
    if (flags___0 & 2U) {
      return ((Table *)0);
    }
    pParse->checkSchema = (u8 )1;
  } else
  if (p->nModuleArg) {
    if (pParse->disableVtab) {
      p = (Table *)0;
    }
  }
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    if (flags___0 & 1U) {
      tmp___3 = "no such view";
    } else {
      tmp___3 = "no such table";
    }
    zMsg = tmp___3;
    if (zDbase) {
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
    } else {
      sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
    }
  }
  return (p);
}
}
static Table *sqlite3LocateTableItem(Parse *pParse , u32 flags___0 , struct SrcList_item *p ) 
{ 
  char const   *zDb ;
  int iDb ;
  int tmp ;
  Table *tmp___0 ;

  {
  if (p->pSchema) {
    tmp = sqlite3SchemaToIndex(pParse->db, p->pSchema);
    iDb = tmp;
    zDb = (char const   *)((pParse->db)->aDb + iDb)->zDbSName;
  } else {
    zDb = (char const   *)p->zDatabase;
  }
  tmp___0 = sqlite3LocateTable(pParse, flags___0, (char const   *)p->zName, zDb);
  return (tmp___0);
}
}
static Index *sqlite3FindIndex(sqlite3 *db , char const   *zName , char const   *zDb ) 
{ 
  Index *p ;
  int i ;
  int j ;
  int tmp ;
  Schema *pSchema ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  p = (Index *)0;
  i = 0;
  while (i < db->nDb) {
    if (i < 2) {
      tmp = i ^ 1;
    } else {
      tmp = i;
    }
    j = tmp;
    pSchema = (db->aDb + j)->pSchema;
    if (zDb) {
      tmp___0 = sqlite3StrICmp(zDb, (char const   *)(db->aDb + j)->zDbSName);
      if (tmp___0) {
        goto __Cont;
      }
    }
    tmp___1 = sqlite3HashFind((Hash const   *)(& pSchema->idxHash), zName);
    p = (Index *)tmp___1;
    if (p) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (p);
}
}
static void sqlite3FreeIndex(sqlite3 *db , Index *p ) 
{ 


  {
  sqlite3DeleteIndexSamples(db, p);
  sqlite3ExprDelete(db, p->pPartIdxWhere);
  sqlite3ExprListDelete(db, p->aColExpr);
  sqlite3DbFree(db, (void *)p->zColAff);
  if (p->isResized) {
    sqlite3DbFree(db, (void *)p->azColl);
  }
  sqlite3DbFree(db, (void *)p);
  return;
}
}
static void sqlite3UnlinkAndDeleteIndex(sqlite3 *db , int iDb , char const   *zIdxName ) 
{ 
  Index *pIndex ;
  Hash *pHash ;
  void *tmp ;
  Index *p ;

  {
  pHash = & ((db->aDb + iDb)->pSchema)->idxHash;
  tmp = sqlite3HashInsert(pHash, zIdxName, (void *)0);
  pIndex = (Index *)tmp;
  if (pIndex) {
    if ((unsigned long )(pIndex->pTable)->pIndex == (unsigned long )pIndex) {
      (pIndex->pTable)->pIndex = pIndex->pNext;
    } else {
      p = (pIndex->pTable)->pIndex;
      while (1) {
        if (p) {
          if (! ((unsigned long )p->pNext != (unsigned long )pIndex)) {
            break;
          }
        } else {
          break;
        }
        p = p->pNext;
      }
      if (p) {
        if ((unsigned long )p->pNext == (unsigned long )pIndex) {
          p->pNext = pIndex->pNext;
        }
      }
    }
    sqlite3FreeIndex(db, pIndex);
  }
  db->mDbFlags |= 1U;
  return;
}
}
static void sqlite3CollapseDatabaseArray(sqlite3 *db ) 
{ 
  int i ;
  int j ;
  struct Db *pDb ;

  {
  j = 2;
  i = j;
  while (i < db->nDb) {
    pDb = db->aDb + i;
    if ((unsigned long )pDb->pBt == (unsigned long )((Btree *)0)) {
      sqlite3DbFree(db, (void *)pDb->zDbSName);
      pDb->zDbSName = (char *)0;
      goto __Cont;
    }
    if (j < i) {
      *(db->aDb + j) = *(db->aDb + i);
    }
    j ++;
    __Cont: /* CIL Label */ 
    i ++;
  }
  db->nDb = j;
  if (db->nDb <= 2) {
    if ((unsigned long )db->aDb != (unsigned long )(db->aDbStatic)) {
      memcpy((void * __restrict  )(db->aDbStatic), (void const   * __restrict  )db->aDb,
             2UL * sizeof(*(db->aDb + 0)));
      sqlite3DbFree(db, (void *)db->aDb);
      db->aDb = db->aDbStatic;
    }
  }
  return;
}
}
static void sqlite3ResetOneSchema(sqlite3 *db , int iDb ) 
{ 
  int i ;

  {
  if (iDb >= 0) {
    ((db->aDb + iDb)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + iDb)->pSchema)->schemaFlags | 8);
    ((db->aDb + 1)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + 1)->pSchema)->schemaFlags | 8);
    db->mDbFlags &= 4294967279U;
  }
  if (db->nSchemaLock == 0U) {
    i = 0;
    while (i < db->nDb) {
      if (((int )((db->aDb + i)->pSchema)->schemaFlags & 8) == 8) {
        sqlite3SchemaClear((void *)(db->aDb + i)->pSchema);
      }
      i ++;
    }
  }
  return;
}
}
static void sqlite3ResetAllSchemasOfConnection(sqlite3 *db ) 
{ 
  int i ;
  Db *pDb ;

  {
  sqlite3BtreeEnterAll(db);
  i = 0;
  while (i < db->nDb) {
    pDb = db->aDb + i;
    if (pDb->pSchema) {
      if (db->nSchemaLock == 0U) {
        sqlite3SchemaClear((void *)pDb->pSchema);
      } else {
        ((db->aDb + i)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + i)->pSchema)->schemaFlags | 8);
      }
    }
    i ++;
  }
  db->mDbFlags &= 4294967278U;
  sqlite3VtabUnlockList(db);
  if (db->nSchemaLock == 0U) {
    sqlite3CollapseDatabaseArray(db);
  }
  return;
}
}
static void sqlite3CommitInternalChanges(sqlite3 *db ) 
{ 


  {
  db->mDbFlags &= 4294967294U;
  return;
}
}
static void sqlite3DeleteColumnNames(sqlite3 *db , Table *pTable ) 
{ 
  int i ;
  Column *pCol ;

  {
  pCol = pTable->aCol;
  if ((unsigned long )pCol != (unsigned long )((Column *)0)) {
    i = 0;
    while (i < (int )pTable->nCol) {
      sqlite3DbFree(db, (void *)pCol->zName);
      sqlite3ExprDelete(db, pCol->pDflt);
      sqlite3DbFree(db, (void *)pCol->zColl);
      i ++;
      pCol ++;
    }
    sqlite3DbFree(db, (void *)pTable->aCol);
  }
  return;
}
}
static void ( __attribute__((__noinline__)) deleteTable)(sqlite3 *db , Table *pTable ) 
{ 
  Index *pIndex ;
  Index *pNext ;
  char *zName ;

  {
  pIndex = pTable->pIndex;
  while (pIndex) {
    pNext = pIndex->pNext;
    if ((unsigned long )db == (unsigned long )((sqlite3 *)0)) {
      goto _L;
    } else
    if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
      _L: /* CIL Label */ 
      if (! pTable->nModuleArg) {
        zName = pIndex->zName;
        sqlite3HashInsert(& (pIndex->pSchema)->idxHash, (char const   *)zName, (void *)0);
      }
    }
    sqlite3FreeIndex(db, pIndex);
    pIndex = pNext;
  }
  sqlite3FkDelete(db, pTable);
  sqlite3DeleteColumnNames(db, pTable);
  sqlite3DbFree(db, (void *)pTable->zName);
  sqlite3DbFree(db, (void *)pTable->zColAff);
  sqlite3SelectDelete(db, pTable->pSelect);
  sqlite3ExprListDelete(db, pTable->pCheck);
  sqlite3VtabClear(db, pTable);
  sqlite3DbFree(db, (void *)pTable);
  return;
}
}
static void sqlite3DeleteTable(sqlite3 *db , Table *pTable ) 
{ 


  {
  if (! pTable) {
    return;
  }
  if (! db) {
    goto _L;
  } else
  if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
    _L: /* CIL Label */ 
    (pTable->nTabRef) --;
    if (pTable->nTabRef > 0U) {
      return;
    }
  }
  deleteTable(db, pTable);
  return;
}
}
static void sqlite3UnlinkAndDeleteTable(sqlite3 *db , int iDb , char const   *zTabName ) 
{ 
  Table *p ;
  Db *pDb ;
  void *tmp ;

  {
  pDb = db->aDb + iDb;
  tmp = sqlite3HashInsert(& (pDb->pSchema)->tblHash, zTabName, (void *)0);
  p = (Table *)tmp;
  sqlite3DeleteTable(db, p);
  db->mDbFlags |= 1U;
  return;
}
}
static char *sqlite3NameFromToken(sqlite3 *db , Token *pName ) 
{ 
  char *zName ;

  {
  if (pName) {
    zName = sqlite3DbStrNDup(db, (char const   *)((char *)pName->z), (u64 )pName->n);
    sqlite3Dequote(zName);
  } else {
    zName = (char *)0;
  }
  return (zName);
}
}
static void sqlite3OpenMasterTable(Parse *p , int iDb ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;

  {
  tmp = sqlite3GetVdbe(p);
  v = tmp;
  sqlite3TableLock(p, iDb, 1, (u8 )1, "sqlite_master");
  sqlite3VdbeAddOp4Int(v, 98, 0, 1, iDb, 5);
  if (p->nTab == 0) {
    p->nTab = 1;
  }
  return;
}
}
static int sqlite3FindDbName(sqlite3 *db , char const   *zName ) 
{ 
  int i ;
  Db *pDb ;
  int tmp ;
  int tmp___0 ;

  {
  i = -1;
  if (zName) {
    i = db->nDb - 1;
    pDb = db->aDb + i;
    while (i >= 0) {
      tmp = sqlite3_stricmp((char const   *)pDb->zDbSName, zName);
      if (0 == tmp) {
        break;
      }
      if (i == 0) {
        tmp___0 = sqlite3_stricmp("main", zName);
        if (0 == tmp___0) {
          break;
        }
      }
      i --;
      pDb --;
    }
  }
  return (i);
}
}
static int sqlite3FindDb(sqlite3 *db , Token *pName ) 
{ 
  int i ;
  char *zName ;

  {
  zName = sqlite3NameFromToken(db, pName);
  i = sqlite3FindDbName(db, (char const   *)zName);
  sqlite3DbFree(db, (void *)zName);
  return (i);
}
}
static int sqlite3TwoPartName(Parse *pParse , Token *pName1 , Token *pName2 , Token **pUnqual ) 
{ 
  int iDb ;
  sqlite3 *db ;

  {
  db = pParse->db;
  if (pName2->n > 0U) {
    if (db->init.busy) {
      sqlite3ErrorMsg(pParse, "corrupt database");
      return (-1);
    }
    *pUnqual = pName2;
    iDb = sqlite3FindDb(db, pName1);
    if (iDb < 0) {
      sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
      return (-1);
    }
  } else {
    iDb = (int )db->init.iDb;
    *pUnqual = pName1;
  }
  return (iDb);
}
}
static int sqlite3WritableSchema(sqlite3 *db ) 
{ 


  {
  return ((db->flags & 268435457ULL) == 1ULL);
}
}
static int sqlite3CheckObjectName(Parse *pParse , char const   *zName , char const   *zType ,
                                  char const   *zTblName ) 
{ 
  sqlite3 *db ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  db = pParse->db;
  tmp = sqlite3WritableSchema(db);
  if (tmp) {
    return (0);
  } else
  if (db->init.imposterTable) {
    return (0);
  }
  if (db->init.busy) {
    tmp___0 = sqlite3_stricmp(zType, (char const   *)*(db->init.azInit + 0));
    if (tmp___0) {
      goto _L;
    } else {
      tmp___1 = sqlite3_stricmp(zName, (char const   *)*(db->init.azInit + 1));
      if (tmp___1) {
        goto _L;
      } else {
        tmp___2 = sqlite3_stricmp(zTblName, (char const   *)*(db->init.azInit + 2));
        if (tmp___2) {
          _L: /* CIL Label */ 
          if (sqlite3Config.bExtraSchemaChecks) {
            sqlite3ErrorMsg(pParse, "");
            return (1);
          }
        }
      }
    }
  } else
  if ((int )pParse->nested == 0) {
    tmp___3 = sqlite3_strnicmp(zName, "sqlite_", 7);
    if (0 == tmp___3) {
      sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
      return (1);
    }
  }
  return (0);
}
}
static Index *sqlite3PrimaryKeyIndex(Table *pTab ) 
{ 
  Index *p ;

  {
  p = pTab->pIndex;
  while (1) {
    if (p) {
      if (! (! (p->idxType == 2U))) {
        break;
      }
    } else {
      break;
    }
    p = p->pNext;
  }
  return (p);
}
}
static i16 sqlite3ColumnOfIndex(Index *pIdx , i16 iCol ) 
{ 
  int i ;

  {
  i = 0;
  while (i < (int )pIdx->nColumn) {
    if ((int )iCol == (int )*(pIdx->aiColumn + i)) {
      return ((i16 )i);
    }
    i ++;
  }
  return ((i16 )-1);
}
}
static u8 const   aCode[4]  = {      (u8 const   )2,      (u8 const   )4,      (u8 const   )8,      (u8 const   )6};
static char const   nullRow[6]  = {      (char const   )6,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0};
static void sqlite3StartTable(Parse *pParse , Token *pName1 , Token *pName2 , int isTemp ,
                              int isView , int isVirtual , int noErr ) 
{ 
  Table *pTable ;
  char *zName ;
  sqlite3 *db ;
  Vdbe *v ;
  int iDb ;
  Token *pName ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *zDb ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *zDb___0 ;
  int tmp___5 ;
  Index *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int addr1 ;
  int fileFormat ;
  int reg1 ;
  int reg2 ;
  int reg3 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  zName = (char *)0;
  db = pParse->db;
  if (db->init.busy) {
    if (db->init.newTnum == 1) {
      iDb = (int )db->init.iDb;
      if (iDb == 1) {
        tmp = "sqlite_temp_master";
      } else {
        tmp = "sqlite_master";
      }
      zName = sqlite3DbStrDup(db, tmp);
      pName = pName1;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, & pName);
    if (iDb < 0) {
      return;
    }
    if (isTemp) {
      if (pName2->n > 0U) {
        if (iDb != 1) {
          sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
          return;
        }
      }
    }
    if (isTemp) {
      iDb = 1;
    }
    zName = sqlite3NameFromToken(db, pName);
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameTokenMap(pParse, (void *)zName, pName);
    }
  }
  pParse->sNameToken = *pName;
  if ((unsigned long )zName == (unsigned long )((char *)0)) {
    return;
  }
  if (isView) {
    tmp___0 = "view";
  } else {
    tmp___0 = "table";
  }
  tmp___1 = sqlite3CheckObjectName(pParse, (char const   *)zName, tmp___0, (char const   *)zName);
  if (tmp___1) {
    goto begin_table_error;
  }
  if ((int )db->init.iDb == 1) {
    isTemp = 1;
  }
  zDb = (db->aDb + iDb)->zDbSName;
  if (isTemp == 1) {
    tmp___2 = "sqlite_temp_master";
  } else {
    tmp___2 = "sqlite_master";
  }
  tmp___3 = sqlite3AuthCheck(pParse, 18, tmp___2, (char const   *)0, (char const   *)zDb);
  if (tmp___3) {
    goto begin_table_error;
  }
  if (! isVirtual) {
    tmp___4 = sqlite3AuthCheck(pParse, (int )aCode[isTemp + 2 * isView], (char const   *)zName,
                               (char const   *)0, (char const   *)zDb);
    if (tmp___4) {
      goto begin_table_error;
    }
  }
  if (! ((int )pParse->eParseMode != 0)) {
    zDb___0 = (db->aDb + iDb)->zDbSName;
    tmp___5 = sqlite3ReadSchema(pParse);
    if (0 != tmp___5) {
      goto begin_table_error;
    }
    pTable = sqlite3FindTable(db, (char const   *)zName, (char const   *)zDb___0);
    if (pTable) {
      if (! noErr) {
        sqlite3ErrorMsg(pParse, "table %T already exists", pName);
      } else {
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto begin_table_error;
    }
    tmp___6 = sqlite3FindIndex(db, (char const   *)zName, (char const   *)zDb___0);
    if ((unsigned long )tmp___6 != (unsigned long )((Index *)0)) {
      sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
      goto begin_table_error;
    }
  }
  tmp___7 = sqlite3DbMallocZero(db, (u64 )sizeof(Table ));
  pTable = (Table *)tmp___7;
  if ((unsigned long )pTable == (unsigned long )((Table *)0)) {
    pParse->rc = 7;
    (pParse->nErr) ++;
    goto begin_table_error;
  }
  pTable->zName = zName;
  pTable->iPKey = (i16 )-1;
  pTable->pSchema = (db->aDb + iDb)->pSchema;
  pTable->nTabRef = (u32 )1;
  pTable->nRowLogEst = (LogEst )200;
  pParse->pNewTable = pTable;
  if (! pParse->nested) {
    tmp___8 = strcmp((char const   *)zName, "sqlite_sequence");
    if (tmp___8 == 0) {
      (pTable->pSchema)->pSeqTab = pTable;
    }
  }
  if (! db->init.busy) {
    v = sqlite3GetVdbe(pParse);
    if ((unsigned long )v != (unsigned long )((Vdbe *)0)) {
      sqlite3BeginWriteOperation(pParse, 1, iDb);
      if (isVirtual) {
        sqlite3VdbeAddOp0(v, 160);
      }
      (pParse->nMem) ++;
      tmp___9 = pParse->nMem;
      pParse->regRowid = tmp___9;
      reg1 = tmp___9;
      (pParse->nMem) ++;
      tmp___10 = pParse->nMem;
      pParse->regRoot = tmp___10;
      reg2 = tmp___10;
      (pParse->nMem) ++;
      reg3 = pParse->nMem;
      sqlite3VdbeAddOp3(v, 94, iDb, reg3, 2);
      sqlite3VdbeUsesBtree(v, iDb);
      addr1 = sqlite3VdbeAddOp1(v, 18, reg3);
      if ((db->flags & 2ULL) != 0ULL) {
        fileFormat = 1;
      } else {
        fileFormat = 4;
      }
      sqlite3VdbeAddOp3(v, 95, iDb, 2, fileFormat);
      sqlite3VdbeAddOp3(v, 95, iDb, 5, (int )db->enc);
      sqlite3VdbeJumpHere(v, addr1);
      if (isView) {
        sqlite3VdbeAddOp2(v, 70, 0, reg2);
      } else
      if (isVirtual) {
        sqlite3VdbeAddOp2(v, 70, 0, reg2);
      } else {
        pParse->addrCrTab = sqlite3VdbeAddOp3(v, 139, iDb, reg2, 1);
      }
      sqlite3OpenMasterTable(pParse, iDb);
      sqlite3VdbeAddOp2(v, 121, 0, reg1);
      sqlite3VdbeAddOp4(v, 75, 6, reg3, 0, nullRow, -1);
      sqlite3VdbeAddOp3(v, 122, 0, reg3, reg1);
      sqlite3VdbeChangeP5(v, (u16 )8);
      sqlite3VdbeAddOp0(v, 117);
    }
  }
  return;
  begin_table_error: 
  sqlite3DbFree(db, (void *)zName);
  return;
}
}
static void sqlite3AddColumn(Parse *pParse , Token *pName , Token *pType ) 
{ 
  Table *p ;
  int i ;
  char *z ;
  char *zType ;
  Column *pCol ;
  sqlite3 *db ;
  void *tmp ;
  int tmp___0 ;
  Column *aNew ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  db = pParse->db;
  p = pParse->pNewTable;
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    return;
  }
  if ((int )p->nCol + 1 > db->aLimit[2]) {
    sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);
    return;
  }
  tmp = sqlite3DbMallocRaw(db, (u64 )((pName->n + pType->n) + 2U));
  z = (char *)tmp;
  if ((unsigned long )z == (unsigned long )((char *)0)) {
    return;
  }
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameTokenMap(pParse, (void *)z, pName);
  }
  memcpy((void * __restrict  )z, (void const   * __restrict  )pName->z, (size_t )pName->n);
  *(z + pName->n) = (char)0;
  sqlite3Dequote(z);
  i = 0;
  while (i < (int )p->nCol) {
    tmp___0 = sqlite3_stricmp((char const   *)z, (char const   *)(p->aCol + i)->zName);
    if (tmp___0 == 0) {
      sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
      sqlite3DbFree(db, (void *)z);
      return;
    }
    i ++;
  }
  if (((int )p->nCol & 7) == 0) {
    tmp___1 = sqlite3DbRealloc(db, (void *)p->aCol, (u64 )((unsigned long )((int )p->nCol + 8) * sizeof(*(p->aCol + 0))));
    aNew = (Column *)tmp___1;
    if ((unsigned long )aNew == (unsigned long )((Column *)0)) {
      sqlite3DbFree(db, (void *)z);
      return;
    }
    p->aCol = aNew;
  }
  pCol = p->aCol + p->nCol;
  memset((void *)pCol, 0, sizeof(*(p->aCol + 0)));
  pCol->zName = z;
  if (pType->n == 0U) {
    pCol->affinity = (char)65;
    pCol->szEst = (u8 )1;
  } else {
    tmp___2 = sqlite3Strlen30((char const   *)z);
    zType = (z + tmp___2) + 1;
    memcpy((void * __restrict  )zType, (void const   * __restrict  )pType->z, (size_t )pType->n);
    *(zType + pType->n) = (char)0;
    sqlite3Dequote(zType);
    pCol->affinity = sqlite3AffinityType((char const   *)zType, pCol);
    pCol->colFlags = (u8 )((int )pCol->colFlags | 4);
  }
  p->nCol = (i16 )((int )p->nCol + 1);
  pParse->constraintName.n = 0U;
  return;
}
}
static void sqlite3AddNotNull(Parse *pParse , int onError ) 
{ 
  Table *p ;
  Column *pCol ;
  Index *pIdx ;

  {
  p = pParse->pNewTable;
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    return;
  } else
  if ((int )p->nCol < 1) {
    return;
  }
  pCol = p->aCol + ((int )p->nCol - 1);
  pCol->notNull = (u8 )onError;
  p->tabFlags |= 512U;
  if ((int )pCol->colFlags & 8) {
    pIdx = p->pIndex;
    while (pIdx) {
      if ((int )*(pIdx->aiColumn + 0) == (int )p->nCol - 1) {
        pIdx->uniqNotNull = 1U;
      }
      pIdx = pIdx->pNext;
    }
  }
  return;
}
}
static char sqlite3AffinityType(char const   *zIn , Column *pCol ) 
{ 
  u32 h ;
  char aff ;
  char const   *zChar ;
  int v ;

  {
  h = (u32 )0;
  aff = (char)67;
  zChar = (char const   *)0;
  while (*(zIn + 0)) {
    h = (h << 8) + (u32 )sqlite3UpperToLower[(int const   )*zIn & 255];
    zIn ++;
    if (h == (u32 )((((99 << 24) + (104 << 16)) + (97 << 8)) + 114)) {
      aff = (char)66;
      zChar = zIn;
    } else
    if (h == (u32 )((((99 << 24) + (108 << 16)) + (111 << 8)) + 98)) {
      aff = (char)66;
    } else
    if (h == (u32 )((((116 << 24) + (101 << 16)) + (120 << 8)) + 116)) {
      aff = (char)66;
    } else
    if (h == (u32 )((((98 << 24) + (108 << 16)) + (111 << 8)) + 98)) {
      if ((int )aff == 67) {
        goto _L___3;
      } else
      if ((int )aff == 69) {
        _L___3: /* CIL Label */ 
        aff = (char)65;
        if ((int const   )*(zIn + 0) == 40) {
          zChar = zIn;
        }
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (h == (u32 )((((114 << 24) + (101 << 16)) + (97 << 8)) + 108)) {
      if ((int )aff == 67) {
        aff = (char)69;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (h == (u32 )((((102 << 24) + (108 << 16)) + (111 << 8)) + 97)) {
      if ((int )aff == 67) {
        aff = (char)69;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (h == (u32 )((((100 << 24) + (111 << 16)) + (117 << 8)) + 98)) {
      if ((int )aff == 67) {
        aff = (char)69;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((h & 16777215U) == (unsigned int )(((105 << 16) + (110 << 8)) + 116)) {
      aff = (char)68;
      break;
    }
  }
  if (pCol) {
    v = 0;
    if ((int )aff < 67) {
      if (zChar) {
        while (*(zChar + 0)) {
          if ((int const   )sqlite3CtypeMap[(unsigned char )*(zChar + 0)] & 4) {
            sqlite3GetInt32(zChar, & v);
            break;
          }
          zChar ++;
        }
      } else {
        v = 16;
      }
    }
    v = v / 4 + 1;
    if (v > 255) {
      v = 255;
    }
    pCol->szEst = (u8 )v;
  }
  return (aff);
}
}
static void sqlite3AddDefaultValue(Parse *pParse , Expr *pExpr , char const   *zStart ,
                                   char const   *zEnd ) 
{ 
  Table *p ;
  Column *pCol ;
  sqlite3 *db ;
  Expr x___0 ;
  int tmp ;

  {
  db = pParse->db;
  p = pParse->pNewTable;
  if ((unsigned long )p != (unsigned long )((Table *)0)) {
    pCol = p->aCol + ((int )p->nCol - 1);
    tmp = sqlite3ExprIsConstantOrFunction(pExpr, db->init.busy);
    if (tmp) {
      sqlite3ExprDelete(db, pCol->pDflt);
      memset((void *)(& x___0), 0, sizeof(x___0));
      x___0.op = (u8 )176;
      x___0.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
      x___0.pLeft = pExpr;
      x___0.flags = (u32 )4096;
      pCol->pDflt = sqlite3ExprDup(db, & x___0, 1);
      sqlite3DbFree(db, (void *)x___0.u.zToken);
    } else {
      sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", pCol->zName);
    }
  }
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameExprUnmap(pParse, pExpr);
  }
  sqlite3ExprDelete(db, pExpr);
  return;
}
}
static void sqlite3StringToId(Expr *p ) 
{ 


  {
  if ((int )p->op == 113) {
    p->op = (u8 )59;
  } else
  if ((int )p->op == 109) {
    if ((int )(p->pLeft)->op == 113) {
      (p->pLeft)->op = (u8 )59;
    }
  }
  return;
}
}
static void sqlite3AddPrimaryKey(Parse *pParse , ExprList *pList , int onError , int autoInc___0 ,
                                 int sortOrder ) 
{ 
  Table *pTab ;
  Column *pCol ;
  int iCol ;
  int i ;
  int nTerm ;
  Expr *pCExpr ;
  Expr *tmp ;
  char const   *zCName ;
  int tmp___0 ;
  Expr *pCExpr___0 ;
  Expr *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  pTab = pParse->pNewTable;
  pCol = (Column *)0;
  iCol = -1;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    goto primary_key_exit;
  }
  if (pTab->tabFlags & 4U) {
    sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", pTab->zName);
    goto primary_key_exit;
  }
  pTab->tabFlags |= 4U;
  if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
    iCol = (int )pTab->nCol - 1;
    pCol = pTab->aCol + iCol;
    pCol->colFlags = (u8 )((int )pCol->colFlags | 1);
    nTerm = 1;
  } else {
    nTerm = pList->nExpr;
    i = 0;
    while (i < nTerm) {
      tmp = sqlite3ExprSkipCollate(pList->a[i].pExpr);
      pCExpr = tmp;
      sqlite3StringToId(pCExpr);
      if ((int )pCExpr->op == 59) {
        zCName = (char const   *)pCExpr->u.zToken;
        iCol = 0;
        while (iCol < (int )pTab->nCol) {
          tmp___0 = sqlite3StrICmp(zCName, (char const   *)(pTab->aCol + iCol)->zName);
          if (tmp___0 == 0) {
            pCol = pTab->aCol + iCol;
            pCol->colFlags = (u8 )((int )pCol->colFlags | 1);
            break;
          }
          iCol ++;
        }
      }
      i ++;
    }
  }
  if (nTerm == 1) {
    if (pCol) {
      tmp___2 = sqlite3ColumnType(pCol, (char *)"");
      tmp___3 = sqlite3StrICmp((char const   *)tmp___2, "INTEGER");
      if (tmp___3 == 0) {
        if (sortOrder != 1) {
          if ((int )pParse->eParseMode >= 2) {
            if (pList) {
              tmp___1 = sqlite3ExprSkipCollate(pList->a[0].pExpr);
              pCExpr___0 = tmp___1;
              sqlite3RenameTokenRemap(pParse, (void *)(& pTab->iPKey), (void *)pCExpr___0);
            }
          }
          pTab->iPKey = (i16 )iCol;
          pTab->keyConf = (u8 )onError;
          pTab->tabFlags |= (unsigned int )(autoInc___0 * 8);
          if (pList) {
            pParse->iPkSortOrder = pList->a[0].sortFlags;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (autoInc___0) {
    sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY");
  } else {
    sqlite3CreateIndex(pParse, (Token *)0, (Token *)0, (SrcList *)0, pList, onError,
                       (Token *)0, (Expr *)0, sortOrder, 0, (u8 )2);
    pList = (ExprList *)0;
  }
  primary_key_exit: 
  sqlite3ExprListDelete(pParse->db, pList);
  return;
}
}
static void sqlite3AddCheckConstraint(Parse *pParse , Expr *pCheckExpr ) 
{ 
  Table *pTab ;
  sqlite3 *db ;
  int tmp ;

  {
  pTab = pParse->pNewTable;
  db = pParse->db;
  if (pTab) {
    if (! ((int )pParse->eParseMode == 1)) {
      tmp = sqlite3BtreeIsReadonly((db->aDb + db->init.iDb)->pBt);
      if (tmp) {
        sqlite3ExprDelete(pParse->db, pCheckExpr);
      } else {
        pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);
        if (pParse->constraintName.n) {
          sqlite3ExprListSetName(pParse, pTab->pCheck, & pParse->constraintName, 1);
        }
      }
    } else {
      sqlite3ExprDelete(pParse->db, pCheckExpr);
    }
  } else {
    sqlite3ExprDelete(pParse->db, pCheckExpr);
  }
  return;
}
}
static void sqlite3AddCollateType(Parse *pParse , Token *pToken ) 
{ 
  Table *p ;
  int i ;
  char *zColl ;
  sqlite3 *db ;
  Index *pIdx ;
  CollSeq *tmp ;

  {
  p = pParse->pNewTable;
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    return;
  }
  i = (int )p->nCol - 1;
  db = pParse->db;
  zColl = sqlite3NameFromToken(db, pToken);
  if (! zColl) {
    return;
  }
  tmp = sqlite3LocateCollSeq(pParse, (char const   *)zColl);
  if (tmp) {
    sqlite3DbFree(db, (void *)(p->aCol + i)->zColl);
    (p->aCol + i)->zColl = zColl;
    pIdx = p->pIndex;
    while (pIdx) {
      if ((int )*(pIdx->aiColumn + 0) == i) {
        *(pIdx->azColl + 0) = (char const   *)(p->aCol + i)->zColl;
      }
      pIdx = pIdx->pNext;
    }
  } else {
    sqlite3DbFree(db, (void *)zColl);
  }
  return;
}
}
static CollSeq *sqlite3LocateCollSeq(Parse *pParse , char const   *zName ) 
{ 
  sqlite3 *db ;
  u8 enc ;
  u8 initbusy ;
  CollSeq *pColl ;

  {
  db = pParse->db;
  enc = db->enc;
  initbusy = db->init.busy;
  pColl = sqlite3FindCollSeq(db, enc, zName, (int )initbusy);
  if (! initbusy) {
    if (! pColl) {
      pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName);
    } else
    if (! pColl->xCmp) {
      pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName);
    }
  }
  return (pColl);
}
}
static void sqlite3ChangeCookie(Parse *pParse , int iDb ) 
{ 
  sqlite3 *db ;
  Vdbe *v ;

  {
  db = pParse->db;
  v = pParse->pVdbe;
  sqlite3VdbeAddOp3(v, 95, iDb, 1, (int )(1U + (unsigned int )((db->aDb + iDb)->pSchema)->schema_cookie));
  return;
}
}
static int identLength(char const   *z ) 
{ 
  int n ;

  {
  n = 0;
  while (*z) {
    if ((int const   )*z == 34) {
      n ++;
    }
    n ++;
    z ++;
  }
  return (n + 2);
}
}
static void identPut(char *z , int *pIdx , char *zSignedIdent ) 
{ 
  unsigned char *zIdent ;
  int i ;
  int j ;
  int needQuote ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  zIdent = (unsigned char *)zSignedIdent;
  i = *pIdx;
  j = 0;
  while (*(zIdent + j)) {
    if (! ((int const   )sqlite3CtypeMap[*(zIdent + j)] & 6)) {
      if ((int )*(zIdent + j) != 95) {
        break;
      }
    }
    j ++;
  }
  if ((int const   )sqlite3CtypeMap[*(zIdent + 0)] & 4) {
    tmp___0 = 1;
  } else {
    tmp = sqlite3KeywordCode((unsigned char const   *)zIdent, j);
    if (tmp != 59) {
      tmp___0 = 1;
    } else
    if ((int )*(zIdent + j) != 0) {
      tmp___0 = 1;
    } else
    if (j == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  needQuote = tmp___0;
  if (needQuote) {
    tmp___1 = i;
    i ++;
    *(z + tmp___1) = (char )'\"';
  }
  j = 0;
  while (*(zIdent + j)) {
    tmp___2 = i;
    i ++;
    *(z + tmp___2) = (char )*(zIdent + j);
    if ((int )*(zIdent + j) == 34) {
      tmp___3 = i;
      i ++;
      *(z + tmp___3) = (char )'\"';
    }
    j ++;
  }
  if (needQuote) {
    tmp___4 = i;
    i ++;
    *(z + tmp___4) = (char )'\"';
  }
  *(z + i) = (char)0;
  *pIdx = i;
  return;
}
}
static char *createTableStmt(sqlite3 *db , Table *p ) ;
static char const   * const  azType___0[5]  = {      (char const   * const  )"",      (char const   * const  )" TEXT",      (char const   * const  )" NUM",      (char const   * const  )" INT", 
        (char const   * const  )" REAL"};
static char *createTableStmt(sqlite3 *db , Table *p ) 
{ 
  int i ;
  int k ;
  int n ;
  char *zStmt ;
  char *zSep ;
  char *zSep2 ;
  char *zEnd ;
  Column *pCol ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int len ;
  char const   *zType ;
  int tmp___3 ;

  {
  n = 0;
  pCol = p->aCol;
  i = 0;
  while (i < (int )p->nCol) {
    tmp = identLength((char const   *)pCol->zName);
    n += tmp + 5;
    i ++;
    pCol ++;
  }
  tmp___0 = identLength((char const   *)p->zName);
  n += tmp___0;
  if (n < 50) {
    zSep = (char *)"";
    zSep2 = (char *)",";
    zEnd = (char *)")";
  } else {
    zSep = (char *)"\n  ";
    zSep2 = (char *)",\n  ";
    zEnd = (char *)"\n)";
  }
  n += 35 + 6 * (int )p->nCol;
  tmp___1 = sqlite3DbMallocRaw((sqlite3 *)0, (u64 )n);
  zStmt = (char *)tmp___1;
  if ((unsigned long )zStmt == (unsigned long )((char *)0)) {
    sqlite3OomFault(db);
    return ((char *)0);
  }
  sqlite3_snprintf(n, zStmt, "CREATE TABLE ");
  k = sqlite3Strlen30((char const   *)zStmt);
  identPut(zStmt, & k, p->zName);
  tmp___2 = k;
  k ++;
  *(zStmt + tmp___2) = (char )'(';
  pCol = p->aCol;
  i = 0;
  while (i < (int )p->nCol) {
    sqlite3_snprintf(n - k, zStmt + k, (char const   *)zSep);
    tmp___3 = sqlite3Strlen30((char const   *)(zStmt + k));
    k += tmp___3;
    zSep = zSep2;
    identPut(zStmt, & k, pCol->zName);
    zType = (char const   *)azType___0[(int )pCol->affinity - 65];
    len = sqlite3Strlen30(zType);
    memcpy((void * __restrict  )(zStmt + k), (void const   * __restrict  )zType, (size_t )len);
    k += len;
    i ++;
    pCol ++;
  }
  sqlite3_snprintf(n - k, zStmt + k, "%s", zEnd);
  return (zStmt);
}
}
static int resizeIndexObject(sqlite3 *db , Index *pIdx , int N ) 
{ 
  char *zExtra ;
  int nByte ;
  void *tmp ;

  {
  if ((int )pIdx->nColumn >= N) {
    return (0);
  }
  nByte = (int )(((sizeof(char *) + sizeof(i16 )) + 1UL) * (unsigned long )N);
  tmp = sqlite3DbMallocZero(db, (u64 )nByte);
  zExtra = (char *)tmp;
  if ((unsigned long )zExtra == (unsigned long )((char *)0)) {
    return (7);
  }
  memcpy((void * __restrict  )zExtra, (void const   * __restrict  )pIdx->azColl, sizeof(char *) * (unsigned long )pIdx->nColumn);
  pIdx->azColl = (char const   **)zExtra;
  zExtra += sizeof(char *) * (unsigned long )N;
  memcpy((void * __restrict  )zExtra, (void const   * __restrict  )pIdx->aiColumn,
         sizeof(i16 ) * (unsigned long )pIdx->nColumn);
  pIdx->aiColumn = (i16 *)zExtra;
  zExtra += sizeof(i16 ) * (unsigned long )N;
  memcpy((void * __restrict  )zExtra, (void const   * __restrict  )pIdx->aSortOrder,
         (size_t )pIdx->nColumn);
  pIdx->aSortOrder = (u8 *)zExtra;
  pIdx->nColumn = (u16 )N;
  pIdx->isResized = 1U;
  return (0);
}
}
static void estimateTableWidth(Table *pTab ) 
{ 
  unsigned int wTable ;
  Column const   *pTabCol ;
  int i ;

  {
  wTable = 0U;
  i = (int )pTab->nCol;
  pTabCol = (Column const   *)pTab->aCol;
  while (i > 0) {
    wTable += (unsigned int )pTabCol->szEst;
    i --;
    pTabCol ++;
  }
  if ((int )pTab->iPKey < 0) {
    wTable ++;
  }
  pTab->szTabRow = sqlite3LogEst((u64 )(wTable * 4U));
  return;
}
}
static void estimateIndexWidth(Index *pIdx ) 
{ 
  unsigned int wIndex ;
  int i ;
  Column const   *aCol ;
  i16 x___0 ;
  int tmp ;

  {
  wIndex = 0U;
  aCol = (Column const   *)(pIdx->pTable)->aCol;
  i = 0;
  while (i < (int )pIdx->nColumn) {
    x___0 = *(pIdx->aiColumn + i);
    if ((int )x___0 < 0) {
      tmp = 1;
    } else {
      tmp = (int )(aCol + *(pIdx->aiColumn + i))->szEst;
    }
    wIndex += (unsigned int )tmp;
    i ++;
  }
  pIdx->szIdxRow = sqlite3LogEst((u64 )(wIndex * 4U));
  return;
}
}
static int hasColumn(i16 const   *aiCol , int nCol , int x___0 ) 
{ 
  i16 const   *tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp___0 = nCol;
    nCol --;
    if (! (tmp___0 > 0)) {
      break;
    }
    tmp = aiCol;
    aiCol ++;
    if (x___0 == (int )*tmp) {
      return (1);
    }
  }
  return (0);
}
}
static int isDupColumn(Index *pIdx , int nKey , Index *pPk , int iCol ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
  j = (int )*(pPk->aiColumn + iCol);
  i = 0;
  while (i < nKey) {
    if ((int )*(pIdx->aiColumn + i) == j) {
      tmp = sqlite3StrICmp(*(pIdx->azColl + i), *(pPk->azColl + iCol));
      if (tmp == 0) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static void recomputeColumnsNotIndexed(Index *pIdx ) 
{ 
  Bitmask m ;
  int j ;
  int x___0 ;

  {
  m = (Bitmask )0;
  j = (int )pIdx->nColumn - 1;
  while (j >= 0) {
    x___0 = (int )*(pIdx->aiColumn + j);
    if (x___0 >= 0) {
      if (x___0 < (int )(sizeof(Bitmask ) * 8UL) - 1) {
        m |= 1ULL << x___0;
      }
    }
    j --;
  }
  pIdx->colNotIdxed = ~ m;
  return;
}
}
static void convertToWithoutRowidTable(Parse *pParse , Table *pTab ) 
{ 
  Index *pIdx ;
  Index *pPk ;
  int nPk ;
  int nExtra ;
  int i ;
  int j ;
  sqlite3 *db ;
  Vdbe *v ;
  ExprList *pList ;
  Token ipkToken ;
  Expr *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  db = pParse->db;
  v = pParse->pVdbe;
  if (! db->init.imposterTable) {
    i = 0;
    while (i < (int )pTab->nCol) {
      if (((int )(pTab->aCol + i)->colFlags & 1) != 0) {
        (pTab->aCol + i)->notNull = (u8 )2;
      }
      i ++;
    }
  }
  if (pParse->addrCrTab) {
    sqlite3VdbeChangeP3(v, pParse->addrCrTab, 2);
  }
  if ((int )pTab->iPKey >= 0) {
    sqlite3TokenInit(& ipkToken, (pTab->aCol + pTab->iPKey)->zName);
    tmp = sqlite3ExprAlloc(db, 59, (Token const   *)(& ipkToken), 0);
    pList = sqlite3ExprListAppend(pParse, (ExprList *)0, tmp);
    if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
      return;
    }
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameTokenRemap(pParse, (void *)pList->a[0].pExpr, (void *)(& pTab->iPKey));
    }
    pList->a[0].sortFlags = pParse->iPkSortOrder;
    pTab->iPKey = (i16 )-1;
    sqlite3CreateIndex(pParse, (Token *)0, (Token *)0, (SrcList *)0, pList, (int )pTab->keyConf,
                       (Token *)0, (Expr *)0, 0, 0, (u8 )2);
    if (db->mallocFailed) {
      return;
    } else
    if (pParse->nErr) {
      return;
    }
    pPk = sqlite3PrimaryKeyIndex(pTab);
  } else {
    pPk = sqlite3PrimaryKeyIndex(pTab);
    j = 1;
    i = j;
    while (i < (int )pPk->nKeyCol) {
      tmp___1 = isDupColumn(pPk, j, pPk, i);
      if (tmp___1) {
        pPk->nColumn = (u16 )((int )pPk->nColumn - 1);
      } else {
        *(pPk->azColl + j) = *(pPk->azColl + i);
        *(pPk->aSortOrder + j) = *(pPk->aSortOrder + i);
        tmp___0 = j;
        j ++;
        *(pPk->aiColumn + tmp___0) = *(pPk->aiColumn + i);
      }
      i ++;
    }
    pPk->nKeyCol = (u16 )j;
  }
  pPk->isCovering = 1U;
  if (! db->init.imposterTable) {
    pPk->uniqNotNull = 1U;
  }
  tmp___2 = pPk->nKeyCol;
  pPk->nColumn = tmp___2;
  nPk = (int )tmp___2;
  if (v) {
    if (pPk->tnum > 0) {
      sqlite3VdbeChangeOpcode(v, pPk->tnum, (u8 )11);
    }
  }
  pPk->tnum = pTab->tnum;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (pIdx->idxType == 2U) {
      goto __Cont;
    }
    n = 0;
    i = n;
    while (i < nPk) {
      tmp___3 = isDupColumn(pIdx, (int )pIdx->nKeyCol, pPk, i);
      if (! tmp___3) {
        n ++;
      }
      i ++;
    }
    if (n == 0) {
      pIdx->nColumn = pIdx->nKeyCol;
      goto __Cont;
    }
    tmp___4 = resizeIndexObject(db, pIdx, (int )pIdx->nKeyCol + n);
    if (tmp___4) {
      return;
    }
    i = 0;
    j = (int )pIdx->nKeyCol;
    while (i < nPk) {
      tmp___5 = isDupColumn(pIdx, (int )pIdx->nKeyCol, pPk, i);
      if (! tmp___5) {
        *(pIdx->aiColumn + j) = *(pPk->aiColumn + i);
        *(pIdx->azColl + j) = *(pPk->azColl + i);
        if (*(pPk->aSortOrder + i)) {
          pIdx->bAscKeyBug = 1U;
        }
        j ++;
      }
      i ++;
    }
    __Cont: /* CIL Label */ 
    pIdx = pIdx->pNext;
  }
  nExtra = 0;
  i = 0;
  while (i < (int )pTab->nCol) {
    tmp___6 = hasColumn((i16 const   *)pPk->aiColumn, nPk, i);
    if (! tmp___6) {
      nExtra ++;
    }
    i ++;
  }
  tmp___7 = resizeIndexObject(db, pPk, nPk + nExtra);
  if (tmp___7) {
    return;
  }
  i = 0;
  j = nPk;
  while (i < (int )pTab->nCol) {
    tmp___8 = hasColumn((i16 const   *)pPk->aiColumn, j, i);
    if (! tmp___8) {
      *(pPk->aiColumn + j) = (i16 )i;
      *(pPk->azColl + j) = sqlite3StrBINARY;
      j ++;
    }
    i ++;
  }
  recomputeColumnsNotIndexed(pPk);
  return;
}
}
static int isShadowTableName(sqlite3 *db , char *zName ) 
{ 
  char *zTail ;
  Table *pTab ;
  Module *pMod ;
  void *tmp ;
  int tmp___0 ;

  {
  zTail = strrchr((char const   *)zName, '_');
  if ((unsigned long )zTail == (unsigned long )((char *)0)) {
    return (0);
  }
  *zTail = (char)0;
  pTab = sqlite3FindTable(db, (char const   *)zName, (char const   *)0);
  *zTail = (char )'_';
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return (0);
  }
  if (! pTab->nModuleArg) {
    return (0);
  }
  tmp = sqlite3HashFind((Hash const   *)(& db->aModule), (char const   *)*(pTab->azModuleArg + 0));
  pMod = (Module *)tmp;
  if ((unsigned long )pMod == (unsigned long )((Module *)0)) {
    return (0);
  }
  if ((pMod->pModule)->iVersion < 3) {
    return (0);
  }
  if ((unsigned long )(pMod->pModule)->xShadowName == (unsigned long )((int (* const  )(char const   * ))0)) {
    return (0);
  }
  tmp___0 = (*((pMod->pModule)->xShadowName))((char const   *)(zTail + 1));
  return (tmp___0);
}
}
static void sqlite3EndTable(Parse *pParse , Token *pCons , Token *pEnd , u8 tabOpts ,
                            Select *pSelect ) 
{ 
  Table *p ;
  sqlite3 *db ;
  int iDb ;
  Index *pIdx ;
  int tmp ;
  int n ;
  Vdbe *v ;
  char *zType ;
  char *zType2 ;
  char *zStmt ;
  SelectDest dest ;
  int regYield ;
  int addrTop ;
  int regRec ;
  int regRowid ;
  int addrInsLoop ;
  Table *pSelTab ;
  int tmp___0 ;
  Token *pEnd2 ;
  Token *tmp___1 ;
  Db *pDb ;
  char *tmp___2 ;
  Table *pOld ;
  Schema *pSchema ;
  void *tmp___3 ;
  char const   *zName ;
  int nName ;
  int tmp___4 ;

  {
  db = pParse->db;
  if ((unsigned long )pEnd == (unsigned long )((Token *)0)) {
    if ((unsigned long )pSelect == (unsigned long )((Select *)0)) {
      return;
    }
  }
  p = pParse->pNewTable;
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    return;
  }
  if ((unsigned long )pSelect == (unsigned long )((Select *)0)) {
    tmp = isShadowTableName(db, p->zName);
    if (tmp) {
      p->tabFlags |= 1024U;
    }
  }
  if (db->init.busy) {
    if (pSelect) {
      sqlite3ErrorMsg(pParse, "");
      return;
    }
    p->tnum = db->init.newTnum;
    if (p->tnum == 1) {
      p->tabFlags |= 1U;
    }
  }
  if ((int )tabOpts & 32) {
    if (p->tabFlags & 8U) {
      sqlite3ErrorMsg(pParse, "AUTOINCREMENT not allowed on WITHOUT ROWID tables");
      return;
    }
    if ((p->tabFlags & 4U) == 0U) {
      sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p->zName);
    } else {
      p->tabFlags |= 96U;
      convertToWithoutRowidTable(pParse, p);
    }
  }
  iDb = sqlite3SchemaToIndex(db, p->pSchema);
  if (p->pCheck) {
    sqlite3ResolveSelfReference(pParse, p, 4, (Expr *)0, p->pCheck);
  }
  estimateTableWidth(p);
  pIdx = p->pIndex;
  while (pIdx) {
    estimateIndexWidth(pIdx);
    pIdx = pIdx->pNext;
  }
  if (! db->init.busy) {
    v = sqlite3GetVdbe(pParse);
    if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
      return;
    }
    sqlite3VdbeAddOp1(v, 117, 0);
    if ((unsigned long )p->pSelect == (unsigned long )((Select *)0)) {
      zType = (char *)"table";
      zType2 = (char *)"TABLE";
    } else {
      zType = (char *)"view";
      zType2 = (char *)"VIEW";
    }
    if (pSelect) {
      (pParse->nMem) ++;
      regYield = pParse->nMem;
      (pParse->nMem) ++;
      regRec = pParse->nMem;
      (pParse->nMem) ++;
      regRowid = pParse->nMem;
      sqlite3MayAbort(pParse);
      sqlite3VdbeAddOp3(v, 98, 1, pParse->regRoot, iDb);
      sqlite3VdbeChangeP5(v, (u16 )16);
      pParse->nTab = 2;
      tmp___0 = sqlite3VdbeCurrentAddr(v);
      addrTop = tmp___0 + 1;
      sqlite3VdbeAddOp3(v, 13, regYield, 0, addrTop);
      if (pParse->nErr) {
        return;
      }
      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, (char)65);
      if ((unsigned long )pSelTab == (unsigned long )((Table *)0)) {
        return;
      }
      p->nCol = pSelTab->nCol;
      p->aCol = pSelTab->aCol;
      pSelTab->nCol = (i16 )0;
      pSelTab->aCol = (Column *)0;
      sqlite3DeleteTable(db, pSelTab);
      sqlite3SelectDestInit(& dest, 13, regYield);
      sqlite3Select(pParse, pSelect, & dest);
      if (pParse->nErr) {
        return;
      }
      sqlite3VdbeEndCoroutine(v, regYield);
      sqlite3VdbeJumpHere(v, addrTop - 1);
      addrInsLoop = sqlite3VdbeAddOp1(v, 14, dest.iSDParm);
      sqlite3VdbeAddOp3(v, 92, dest.iSdst, dest.nSdst, regRec);
      sqlite3TableAffinity(v, p, 0);
      sqlite3VdbeAddOp2(v, 121, 1, regRowid);
      sqlite3VdbeAddOp3(v, 122, 1, regRec, regRowid);
      sqlite3VdbeGoto(v, addrInsLoop);
      sqlite3VdbeJumpHere(v, addrInsLoop);
      sqlite3VdbeAddOp1(v, 117, 1);
    }
    if (pSelect) {
      zStmt = createTableStmt(db, p);
    } else {
      if (tabOpts) {
        tmp___1 = & pParse->sLastToken;
      } else {
        tmp___1 = pEnd;
      }
      pEnd2 = tmp___1;
      n = (int )(pEnd2->z - pParse->sNameToken.z);
      if ((int const   )*(pEnd2->z + 0) != 59) {
        n = (int )((unsigned int )n + pEnd2->n);
      }
      zStmt = sqlite3MPrintf(db, "CREATE %s %.*s", zType2, n, pParse->sNameToken.z);
    }
    sqlite3NestedParse(pParse, "UPDATE %Q.%s SET type=\'%s\', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q WHERE rowid=#%d",
                       (db->aDb + iDb)->zDbSName, "sqlite_master", zType, p->zName,
                       p->zName, pParse->regRoot, zStmt, pParse->regRowid);
    sqlite3DbFree(db, (void *)zStmt);
    sqlite3ChangeCookie(pParse, iDb);
    if ((p->tabFlags & 8U) != 0U) {
      pDb = db->aDb + iDb;
      if ((unsigned long )(pDb->pSchema)->pSeqTab == (unsigned long )((Table *)0)) {
        sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", pDb->zDbSName);
      }
    }
    tmp___2 = sqlite3MPrintf(db, "tbl_name=\'%q\' AND type!=\'trigger\'", p->zName);
    sqlite3VdbeAddParseSchemaOp(v, iDb, tmp___2);
  }
  if (db->init.busy) {
    pSchema = p->pSchema;
    tmp___3 = sqlite3HashInsert(& pSchema->tblHash, (char const   *)p->zName, (void *)p);
    pOld = (Table *)tmp___3;
    if (pOld) {
      sqlite3OomFault(db);
      return;
    }
    pParse->pNewTable = (Table *)0;
    db->mDbFlags |= 1U;
    if (! p->pSelect) {
      zName = pParse->sNameToken.z;
      if ((unsigned long )pCons->z == (unsigned long )((char const   *)0)) {
        pCons = pEnd;
      }
      nName = (int )(pCons->z - zName);
      tmp___4 = sqlite3Utf8CharLen(zName, nName);
      p->addColOffset = 13 + tmp___4;
    }
  }
  return;
}
}
static void sqlite3CreateView(Parse *pParse , Token *pBegin , Token *pName1 , Token *pName2 ,
                              ExprList *pCNames , Select *pSelect , int isTemp , int noErr ) 
{ 
  Table *p ;
  int n ;
  char const   *z ;
  Token sEnd ;
  DbFixer sFix ;
  Token *pName ;
  int iDb ;
  sqlite3 *db ;
  int tmp ;

  {
  pName = (Token *)0;
  db = pParse->db;
  if ((int )pParse->nVar > 0) {
    sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
    goto create_view_fail;
  }
  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
  p = pParse->pNewTable;
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    goto create_view_fail;
  } else
  if (pParse->nErr) {
    goto create_view_fail;
  }
  sqlite3TwoPartName(pParse, pName1, pName2, & pName);
  iDb = sqlite3SchemaToIndex(db, p->pSchema);
  sqlite3FixInit(& sFix, pParse, iDb, "view", (Token const   *)pName);
  tmp = sqlite3FixSelect(& sFix, pSelect);
  if (tmp) {
    goto create_view_fail;
  }
  if ((int )pParse->eParseMode >= 2) {
    p->pSelect = pSelect;
    pSelect = (Select *)0;
  } else {
    p->pSelect = sqlite3SelectDup(db, pSelect, 1);
  }
  p->pCheck = sqlite3ExprListDup(db, pCNames, 1);
  if (db->mallocFailed) {
    goto create_view_fail;
  }
  sEnd = pParse->sLastToken;
  if ((int const   )*(sEnd.z + 0) != 59) {
    sEnd.z += sEnd.n;
  }
  sEnd.n = 0U;
  n = (int )(sEnd.z - pBegin->z);
  z = pBegin->z;
  while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + (n - 1))] & 1) {
    n --;
  }
  sEnd.z = z + (n - 1);
  sEnd.n = 1U;
  sqlite3EndTable(pParse, (Token *)0, & sEnd, (u8 )0, (Select *)0);
  create_view_fail: 
  sqlite3SelectDelete(db, pSelect);
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameExprlistUnmap(pParse, pCNames);
  }
  sqlite3ExprListDelete(db, pCNames);
  return;
}
}
static int sqlite3ViewGetColumnNames(Parse *pParse , Table *pTable ) 
{ 
  Table *pSelTab ;
  Select *pSel ;
  int nErr ;
  int n ;
  sqlite3 *db ;
  int rc ;
  int (*xAuth)(void * , int  , char const   * , char const   * , char const   * ,
               char const   * ) ;
  u8 eParseMode ;

  {
  nErr = 0;
  db = pParse->db;
  (db->nSchemaLock) ++;
  rc = sqlite3VtabCallConnect(pParse, pTable);
  (db->nSchemaLock) --;
  if (rc) {
    return (1);
  }
  if (pTable->nModuleArg) {
    return (0);
  }
  if ((int )pTable->nCol > 0) {
    return (0);
  }
  if ((int )pTable->nCol < 0) {
    sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);
    return (1);
  }
  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);
  if (pSel) {
    eParseMode = pParse->eParseMode;
    pParse->eParseMode = (u8 )0;
    n = pParse->nTab;
    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
    pTable->nCol = (i16 )-1;
    (db->lookaside.bDisable) ++;
    xAuth = db->xAuth;
    db->xAuth = (int (*)(void * , int  , char const   * , char const   * , char const   * ,
                         char const   * ))0;
    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, (char)64);
    db->xAuth = xAuth;
    pParse->nTab = n;
    if (pTable->pCheck) {
      sqlite3ColumnsFromExprList(pParse, pTable->pCheck, & pTable->nCol, & pTable->aCol);
      if ((int )db->mallocFailed == 0) {
        if (pParse->nErr == 0) {
          if ((int )pTable->nCol == (pSel->pEList)->nExpr) {
            sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel, (char)64);
          }
        }
      }
    } else
    if (pSelTab) {
      pTable->nCol = pSelTab->nCol;
      pTable->aCol = pSelTab->aCol;
      pSelTab->nCol = (i16 )0;
      pSelTab->aCol = (Column *)0;
    } else {
      pTable->nCol = (i16 )0;
      nErr ++;
    }
    sqlite3DeleteTable(db, pSelTab);
    sqlite3SelectDelete(db, pSel);
    (db->lookaside.bDisable) --;
    pParse->eParseMode = eParseMode;
  } else {
    nErr ++;
  }
  (pTable->pSchema)->schemaFlags = (u16 )((int )(pTable->pSchema)->schemaFlags | 2);
  if (db->mallocFailed) {
    sqlite3DeleteColumnNames(db, pTable);
    pTable->aCol = (Column *)0;
    pTable->nCol = (i16 )0;
  }
  return (nErr);
}
}
static void sqliteViewResetAll(sqlite3 *db , int idx ) 
{ 
  HashElem *i ;
  Table *pTab ;

  {
  if (! (((int )((db->aDb + idx)->pSchema)->schemaFlags & 2) == 2)) {
    return;
  }
  i = ((db->aDb + idx)->pSchema)->tblHash.first;
  while (i) {
    pTab = (Table *)i->data;
    if (pTab->pSelect) {
      sqlite3DeleteColumnNames(db, pTab);
      pTab->aCol = (Column *)0;
      pTab->nCol = (i16 )0;
    }
    i = i->next;
  }
  ((db->aDb + idx)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + idx)->pSchema)->schemaFlags & -3);
  return;
}
}
static void sqlite3RootPageMoved(sqlite3 *db , int iDb , int iFrom , int iTo ) 
{ 
  HashElem *pElem ;
  Hash *pHash ;
  Db *pDb ;
  Table *pTab ;
  Index *pIdx ;

  {
  pDb = db->aDb + iDb;
  pHash = & (pDb->pSchema)->tblHash;
  pElem = pHash->first;
  while (pElem) {
    pTab = (Table *)pElem->data;
    if (pTab->tnum == iFrom) {
      pTab->tnum = iTo;
    }
    pElem = pElem->next;
  }
  pHash = & (pDb->pSchema)->idxHash;
  pElem = pHash->first;
  while (pElem) {
    pIdx = (Index *)pElem->data;
    if (pIdx->tnum == iFrom) {
      pIdx->tnum = iTo;
    }
    pElem = pElem->next;
  }
  return;
}
}
static void destroyRootPage(Parse *pParse , int iTable , int iDb ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  int r1 ;
  int tmp___0 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  tmp___0 = sqlite3GetTempReg(pParse);
  r1 = tmp___0;
  if (iTable < 2) {
    sqlite3ErrorMsg(pParse, "corrupt schema");
  }
  sqlite3VdbeAddOp3(v, 136, iTable, r1, iDb);
  sqlite3MayAbort(pParse);
  sqlite3NestedParse(pParse, "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d",
                     ((pParse->db)->aDb + iDb)->zDbSName, "sqlite_master", iTable,
                     r1, r1);
  sqlite3ReleaseTempReg(pParse, r1);
  return;
}
}
static void destroyTable(Parse *pParse , Table *pTab ) 
{ 
  int iTab ;
  int iDestroyed ;
  Index *pIdx ;
  int iLargest ;
  int iIdx ;
  int iDb ;
  int tmp ;

  {
  iTab = pTab->tnum;
  iDestroyed = 0;
  while (1) {
    iLargest = 0;
    if (iDestroyed == 0) {
      iLargest = iTab;
    } else
    if (iTab < iDestroyed) {
      iLargest = iTab;
    }
    pIdx = pTab->pIndex;
    while (pIdx) {
      iIdx = pIdx->tnum;
      if (iDestroyed == 0) {
        goto _L;
      } else
      if (iIdx < iDestroyed) {
        _L: /* CIL Label */ 
        if (iIdx > iLargest) {
          iLargest = iIdx;
        }
      }
      pIdx = pIdx->pNext;
    }
    if (iLargest == 0) {
      return;
    } else {
      tmp = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
      iDb = tmp;
      destroyRootPage(pParse, iLargest, iDb);
      iDestroyed = iLargest;
    }
  }
}
}
static void sqlite3ClearStatTables(Parse *pParse , int iDb , char const   *zType ,
                                   char const   *zName ) 
{ 
  int i ;
  char const   *zDbName ;
  char zTab[24] ;
  Table *tmp ;

  {
  zDbName = (char const   *)((pParse->db)->aDb + iDb)->zDbSName;
  i = 1;
  while (i <= 4) {
    sqlite3_snprintf((int )sizeof(zTab), zTab, "sqlite_stat%d", i);
    tmp = sqlite3FindTable(pParse->db, (char const   *)(zTab), zDbName);
    if (tmp) {
      sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", zDbName, zTab, zType,
                         zName);
    }
    i ++;
  }
  return;
}
}
static void sqlite3CodeDropTable(Parse *pParse , Table *pTab , int iDb , int isView ) 
{ 
  Vdbe *v ;
  sqlite3 *db ;
  Trigger *pTrigger ;
  Db *pDb ;

  {
  db = pParse->db;
  pDb = db->aDb + iDb;
  v = sqlite3GetVdbe(pParse);
  sqlite3BeginWriteOperation(pParse, 1, iDb);
  if (pTab->nModuleArg) {
    sqlite3VdbeAddOp0(v, 160);
  }
  pTrigger = sqlite3TriggerList(pParse, pTab);
  while (pTrigger) {
    sqlite3DropTriggerPtr(pParse, pTrigger);
    pTrigger = pTrigger->pNext;
  }
  if (pTab->tabFlags & 8U) {
    sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_sequence WHERE name=%Q", pDb->zDbSName,
                       pTab->zName);
  }
  sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!=\'trigger\'",
                     pDb->zDbSName, "sqlite_master", pTab->zName);
  if (! isView) {
    if (! pTab->nModuleArg) {
      destroyTable(pParse, pTab);
    }
  }
  if (pTab->nModuleArg) {
    sqlite3VdbeAddOp4(v, 162, iDb, 0, 0, (char const   *)pTab->zName, 0);
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 143, iDb, 0, 0, (char const   *)pTab->zName, 0);
  sqlite3ChangeCookie(pParse, iDb);
  sqliteViewResetAll(db, iDb);
  return;
}
}
static void sqlite3DropTable(Parse *pParse , SrcList *pName , int isView , int noErr ) 
{ 
  Table *pTab ;
  Vdbe *v ;
  sqlite3 *db ;
  int iDb ;
  int tmp ;
  int tmp___0 ;
  int code ;
  char const   *zTab ;
  char const   *tmp___1 ;
  char const   *zDb ;
  char const   *zArg2 ;
  int tmp___2 ;
  VTable *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  db = pParse->db;
  if (db->mallocFailed) {
    goto exit_drop_table;
  }
  tmp = sqlite3ReadSchema(pParse);
  if (tmp) {
    goto exit_drop_table;
  }
  if (noErr) {
    db->suppressErr = (u8 )((int )db->suppressErr + 1);
  }
  pTab = sqlite3LocateTableItem(pParse, (u32 )isView, & pName->a[0]);
  if (noErr) {
    db->suppressErr = (u8 )((int )db->suppressErr - 1);
  }
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    if (noErr) {
      sqlite3CodeVerifyNamedSchema(pParse, (char const   *)pName->a[0].zDatabase);
    }
    goto exit_drop_table;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  if (pTab->nModuleArg) {
    tmp___0 = sqlite3ViewGetColumnNames(pParse, pTab);
    if (tmp___0) {
      goto exit_drop_table;
    }
  }
  if (iDb == 1) {
    tmp___1 = "sqlite_temp_master";
  } else {
    tmp___1 = "sqlite_master";
  }
  zTab = tmp___1;
  zDb = (char const   *)(db->aDb + iDb)->zDbSName;
  zArg2 = (char const   *)0;
  tmp___2 = sqlite3AuthCheck(pParse, 9, zTab, (char const   *)0, zDb);
  if (tmp___2) {
    goto exit_drop_table;
  }
  if (isView) {
    if (iDb == 1) {
      code = 15;
    } else {
      code = 17;
    }
  } else
  if (pTab->nModuleArg) {
    code = 30;
    tmp___3 = sqlite3GetVTable(db, pTab);
    zArg2 = (tmp___3->pMod)->zName;
  } else
  if (iDb == 1) {
    code = 13;
  } else {
    code = 11;
  }
  tmp___4 = sqlite3AuthCheck(pParse, code, (char const   *)pTab->zName, zArg2, zDb);
  if (tmp___4) {
    goto exit_drop_table;
  }
  tmp___5 = sqlite3AuthCheck(pParse, 9, (char const   *)pTab->zName, (char const   *)0,
                             zDb);
  if (tmp___5) {
    goto exit_drop_table;
  }
  tmp___6 = sqlite3_strnicmp((char const   *)pTab->zName, "sqlite_", 7);
  if (tmp___6 == 0) {
    tmp___7 = sqlite3_strnicmp((char const   *)(pTab->zName + 7), "stat", 4);
    if (tmp___7 != 0) {
      tmp___8 = sqlite3_strnicmp((char const   *)(pTab->zName + 7), "parameters",
                                 10);
      if (tmp___8 != 0) {
        sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
        goto exit_drop_table;
      }
    }
  }
  if (isView) {
    if ((unsigned long )pTab->pSelect == (unsigned long )((Select *)0)) {
      sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);
      goto exit_drop_table;
    }
  }
  if (! isView) {
    if (pTab->pSelect) {
      sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);
      goto exit_drop_table;
    }
  }
  v = sqlite3GetVdbe(pParse);
  if (v) {
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    if (! isView) {
      sqlite3ClearStatTables(pParse, iDb, "tbl", (char const   *)pTab->zName);
      sqlite3FkDropTable(pParse, pName, pTab);
    }
    sqlite3CodeDropTable(pParse, pTab, iDb, isView);
  }
  exit_drop_table: 
  sqlite3SrcListDelete(db, pName);
  return;
}
}
static void sqlite3CreateForeignKey(Parse *pParse , ExprList *pFromCol , Token *pTo ,
                                    ExprList *pToCol , int flags___0 ) 
{ 
  sqlite3 *db ;
  FKey *pFKey ;
  FKey *pNextTo ;
  Table *p ;
  int nByte ;
  int i ;
  int nCol ;
  char *z ;
  int iCol ;
  int tmp ;
  void *tmp___0 ;
  int j ;
  int tmp___1 ;
  int n ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  db = pParse->db;
  pFKey = (FKey *)0;
  p = pParse->pNewTable;
  if ((unsigned long )p == (unsigned long )((Table *)0)) {
    goto fk_end;
  } else
  if ((int )pParse->eParseMode == 1) {
    goto fk_end;
  }
  if ((unsigned long )pFromCol == (unsigned long )((ExprList *)0)) {
    iCol = (int )p->nCol - 1;
    if (iCol < 0) {
      goto fk_end;
    }
    if (pToCol) {
      if (pToCol->nExpr != 1) {
        sqlite3ErrorMsg(pParse, "foreign key on %s should reference only one column of table %T",
                        (p->aCol + iCol)->zName, pTo);
        goto fk_end;
      }
    }
    nCol = 1;
  } else
  if (pToCol) {
    if (pToCol->nExpr != pFromCol->nExpr) {
      sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of columns in the referenced table");
      goto fk_end;
    } else {
      nCol = pFromCol->nExpr;
    }
  } else {
    nCol = pFromCol->nExpr;
  }
  nByte = (int )(((sizeof(*pFKey) + (unsigned long )(nCol - 1) * sizeof(pFKey->aCol[0])) + (unsigned long )pTo->n) + 1UL);
  if (pToCol) {
    i = 0;
    while (i < pToCol->nExpr) {
      tmp = sqlite3Strlen30((char const   *)pToCol->a[i].zName);
      nByte += tmp + 1;
      i ++;
    }
  }
  tmp___0 = sqlite3DbMallocZero(db, (u64 )nByte);
  pFKey = (FKey *)tmp___0;
  if ((unsigned long )pFKey == (unsigned long )((FKey *)0)) {
    goto fk_end;
  }
  pFKey->pFrom = p;
  pFKey->pNextFrom = p->pFKey;
  z = (char *)(& pFKey->aCol[nCol]);
  pFKey->zTo = z;
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameTokenMap(pParse, (void *)z, pTo);
  }
  memcpy((void * __restrict  )z, (void const   * __restrict  )pTo->z, (size_t )pTo->n);
  *(z + pTo->n) = (char)0;
  sqlite3Dequote(z);
  z += pTo->n + 1U;
  pFKey->nCol = nCol;
  if ((unsigned long )pFromCol == (unsigned long )((ExprList *)0)) {
    pFKey->aCol[0].iFrom = (int )p->nCol - 1;
  } else {
    i = 0;
    while (i < nCol) {
      j = 0;
      while (j < (int )p->nCol) {
        tmp___1 = sqlite3StrICmp((char const   *)(p->aCol + j)->zName, (char const   *)pFromCol->a[i].zName);
        if (tmp___1 == 0) {
          pFKey->aCol[i].iFrom = j;
          break;
        }
        j ++;
      }
      if (j >= (int )p->nCol) {
        sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition",
                        pFromCol->a[i].zName);
        goto fk_end;
      }
      if ((int )pParse->eParseMode >= 2) {
        sqlite3RenameTokenRemap(pParse, (void *)(& pFKey->aCol[i]), (void *)pFromCol->a[i].zName);
      }
      i ++;
    }
  }
  if (pToCol) {
    i = 0;
    while (i < nCol) {
      tmp___2 = sqlite3Strlen30((char const   *)pToCol->a[i].zName);
      n = tmp___2;
      pFKey->aCol[i].zCol = z;
      if ((int )pParse->eParseMode >= 2) {
        sqlite3RenameTokenRemap(pParse, (void *)z, (void *)pToCol->a[i].zName);
      }
      memcpy((void * __restrict  )z, (void const   * __restrict  )pToCol->a[i].zName,
             (size_t )n);
      *(z + n) = (char)0;
      z += n + 1;
      i ++;
    }
  }
  pFKey->isDeferred = (u8 )0;
  pFKey->aAction[0] = (u8 )(flags___0 & 255);
  pFKey->aAction[1] = (u8 )((flags___0 >> 8) & 255);
  tmp___3 = sqlite3HashInsert(& (p->pSchema)->fkeyHash, (char const   *)pFKey->zTo,
                              (void *)pFKey);
  pNextTo = (FKey *)tmp___3;
  if ((unsigned long )pNextTo == (unsigned long )pFKey) {
    sqlite3OomFault(db);
    goto fk_end;
  }
  if (pNextTo) {
    pFKey->pNextTo = pNextTo;
    pNextTo->pPrevTo = pFKey;
  }
  p->pFKey = pFKey;
  pFKey = (FKey *)0;
  fk_end: 
  sqlite3DbFree(db, (void *)pFKey);
  sqlite3ExprListDelete(db, pFromCol);
  sqlite3ExprListDelete(db, pToCol);
  return;
}
}
static void sqlite3DeferForeignKey(Parse *pParse , int isDeferred ) 
{ 
  Table *pTab ;
  FKey *pFKey ;

  {
  pTab = pParse->pNewTable;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return;
  } else {
    pFKey = pTab->pFKey;
    if ((unsigned long )pFKey == (unsigned long )((FKey *)0)) {
      return;
    }
  }
  pFKey->isDeferred = (u8 )isDeferred;
  return;
}
}
static void sqlite3RefillIndex(Parse *pParse , Index *pIndex , int memRootPage ) 
{ 
  Table *pTab ;
  int iTab ;
  int tmp ;
  int iIdx ;
  int tmp___0 ;
  int iSorter ;
  int addr1 ;
  int addr2 ;
  int tnum ;
  int iPartIdxLabel ;
  Vdbe *v ;
  KeyInfo *pKey ;
  int regRecord ;
  sqlite3 *db ;
  int iDb ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  KeyInfo *tmp___4 ;
  int tmp___5 ;
  int j2 ;
  int tmp___6 ;

  {
  pTab = pIndex->pTable;
  tmp = pParse->nTab;
  (pParse->nTab) ++;
  iTab = tmp;
  tmp___0 = pParse->nTab;
  (pParse->nTab) ++;
  iIdx = tmp___0;
  db = pParse->db;
  tmp___1 = sqlite3SchemaToIndex(db, pIndex->pSchema);
  iDb = tmp___1;
  tmp___2 = sqlite3AuthCheck(pParse, 27, (char const   *)pIndex->zName, (char const   *)0,
                             (char const   *)(db->aDb + iDb)->zDbSName);
  if (tmp___2) {
    return;
  }
  sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )1, (char const   *)pTab->zName);
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return;
  }
  if (memRootPage >= 0) {
    tnum = memRootPage;
  } else {
    tnum = pIndex->tnum;
  }
  pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);
  tmp___3 = pParse->nTab;
  (pParse->nTab) ++;
  iSorter = tmp___3;
  tmp___4 = sqlite3KeyInfoRef(pKey);
  sqlite3VdbeAddOp4(v, 114, iSorter, 0, (int )pIndex->nKeyCol, (char const   *)((char *)tmp___4),
                    -9);
  sqlite3OpenTable(pParse, iTab, iDb, pTab, 97);
  addr1 = sqlite3VdbeAddOp2(v, 36, iTab, 0);
  regRecord = sqlite3GetTempReg(pParse);
  sqlite3MultiWrite(pParse);
  sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 0, & iPartIdxLabel, (Index *)0,
                          0);
  sqlite3VdbeAddOp2(v, 131, iSorter, regRecord);
  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
  sqlite3VdbeAddOp2(v, 5, iTab, addr1 + 1);
  sqlite3VdbeJumpHere(v, addr1);
  if (memRootPage < 0) {
    sqlite3VdbeAddOp2(v, 137, tnum, iDb);
  }
  sqlite3VdbeAddOp4(v, 98, iIdx, tnum, iDb, (char const   *)((char *)pKey), -9);
  if (memRootPage >= 0) {
    tmp___5 = 16;
  } else {
    tmp___5 = 0;
  }
  sqlite3VdbeChangeP5(v, (u16 )(1 | tmp___5));
  addr1 = sqlite3VdbeAddOp2(v, 34, iSorter, 0);
  if ((int )pIndex->onError != 0) {
    tmp___6 = sqlite3VdbeGoto(v, 1);
    j2 = tmp___6;
    addr2 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp4Int(v, 125, iSorter, j2, regRecord, (int )pIndex->nKeyCol);
    sqlite3UniqueConstraint(pParse, 2, pIndex);
    sqlite3VdbeJumpHere(v, j2);
  } else {
    sqlite3MayAbort(pParse);
    addr2 = sqlite3VdbeCurrentAddr(v);
  }
  sqlite3VdbeAddOp3(v, 126, iSorter, regRecord, iIdx);
  if (! pIndex->bAscKeyBug) {
    sqlite3VdbeAddOp1(v, 130, iIdx);
  }
  sqlite3VdbeAddOp2(v, 132, iIdx, regRecord);
  sqlite3VdbeChangeP5(v, (u16 )16);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeAddOp2(v, 3, iSorter, addr2);
  sqlite3VdbeJumpHere(v, addr1);
  sqlite3VdbeAddOp1(v, 117, iTab);
  sqlite3VdbeAddOp1(v, 117, iIdx);
  sqlite3VdbeAddOp1(v, 117, iSorter);
  return;
}
}
static Index *sqlite3AllocateIndexObject(sqlite3 *db , i16 nCol , int nExtra , char **ppExtra ) 
{ 
  Index *p ;
  int nByte ;
  void *tmp ;
  char *pExtra ;

  {
  nByte = (int )((((sizeof(Index ) + 7UL) & 0xfffffffffffffff8UL) + ((sizeof(char *) * (unsigned long )nCol + 7UL) & 0xfffffffffffffff8UL)) + ((((sizeof(LogEst ) * (unsigned long )((int )nCol + 1) + sizeof(i16 ) * (unsigned long )nCol) + sizeof(u8 ) * (unsigned long )nCol) + 7UL) & 0xfffffffffffffff8UL));
  tmp = sqlite3DbMallocZero(db, (u64 )(nByte + nExtra));
  p = (Index *)tmp;
  if (p) {
    pExtra = (char *)p + ((sizeof(Index ) + 7UL) & 0xfffffffffffffff8UL);
    p->azColl = (char const   **)pExtra;
    pExtra += (sizeof(char *) * (unsigned long )nCol + 7UL) & 0xfffffffffffffff8UL;
    p->aiRowLogEst = (LogEst *)pExtra;
    pExtra += sizeof(LogEst ) * (unsigned long )((int )nCol + 1);
    p->aiColumn = (i16 *)pExtra;
    pExtra += sizeof(i16 ) * (unsigned long )nCol;
    p->aSortOrder = (u8 *)pExtra;
    p->nColumn = (u16 )nCol;
    p->nKeyCol = (u16 )((int )nCol - 1);
    *ppExtra = (char *)p + nByte;
  }
  return (p);
}
}
static int sqlite3HasExplicitNulls(Parse *pParse , ExprList *pList ) 
{ 
  int i ;
  u8 sf ;
  char const   *tmp ;

  {
  if (pList) {
    i = 0;
    while (i < pList->nExpr) {
      if (pList->a[i].bNulls) {
        sf = pList->a[i].sortFlags;
        if ((int )sf == 0) {
          tmp = "FIRST";
        } else
        if ((int )sf == 3) {
          tmp = "FIRST";
        } else {
          tmp = "LAST";
        }
        sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s", tmp);
        return (1);
      }
      i ++;
    }
  }
  return (0);
}
}
static void sqlite3CreateIndex(Parse *pParse , Token *pName1 , Token *pName2 , SrcList *pTblName ,
                               ExprList *pList , int onError , Token *pStart , Expr *pPIWhere ,
                               int sortOrder , int ifNotExist , u8 idxType ) 
{ 
  Table *pTab ;
  Index *pIndex ;
  char *zName ;
  int nName ;
  int i ;
  int j ;
  DbFixer sFix ;
  int sortOrderMask ;
  sqlite3 *db ;
  Db *pDb ;
  int iDb ;
  Token *pName ;
  struct ExprList_item *pListItem ;
  int nExtra ;
  int nExtraCol ;
  char *zExtra ;
  Index *pPk ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Table *tmp___3 ;
  Index *tmp___4 ;
  int n ;
  Index *pLoop ;
  char const   *zDb ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Token prevCol ;
  Column *pCol ;
  Expr *tmp___8 ;
  Expr *pExpr ;
  int tmp___9 ;
  Expr *pCExpr ;
  int requestedSortOrder ;
  char const   *zColl ;
  int nColl ;
  int tmp___10 ;
  CollSeq *tmp___11 ;
  int x___0 ;
  int tmp___12 ;
  i16 tmp___13 ;
  Index *pIdx ;
  int k ;
  char const   *z1 ;
  char const   *z2 ;
  int tmp___14 ;
  Index *p ;
  int tmp___15 ;
  void *tmp___16 ;
  Vdbe *v ;
  char *zStmt ;
  int iMem ;
  int n___0 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  Index *pOther ;

  {
  pTab = (Table *)0;
  pIndex = (Index *)0;
  zName = (char *)0;
  db = pParse->db;
  pName = (Token *)0;
  nExtra = 0;
  zExtra = (char *)0;
  pPk = (Index *)0;
  if (db->mallocFailed) {
    goto exit_create_index;
  } else
  if (pParse->nErr > 0) {
    goto exit_create_index;
  }
  if ((int )pParse->eParseMode == 1) {
    if ((int )idxType != 2) {
      goto exit_create_index;
    }
  }
  tmp = sqlite3ReadSchema(pParse);
  if (0 != tmp) {
    goto exit_create_index;
  }
  tmp___0 = sqlite3HasExplicitNulls(pParse, pList);
  if (tmp___0) {
    goto exit_create_index;
  }
  if ((unsigned long )pTblName != (unsigned long )((SrcList *)0)) {
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, & pName);
    if (iDb < 0) {
      goto exit_create_index;
    }
    if (! db->init.busy) {
      pTab = sqlite3SrcListLookup(pParse, pTblName);
      if (pName2->n == 0U) {
        if (pTab) {
          if ((unsigned long )pTab->pSchema == (unsigned long )(db->aDb + 1)->pSchema) {
            iDb = 1;
          }
        }
      }
    }
    sqlite3FixInit(& sFix, pParse, iDb, "index", (Token const   *)pName);
    sqlite3FixSrcList(& sFix, pTblName);
    pTab = sqlite3LocateTableItem(pParse, (u32 )0, & pTblName->a[0]);
    if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
      goto exit_create_index;
    }
    if (iDb == 1) {
      if ((unsigned long )(db->aDb + iDb)->pSchema != (unsigned long )pTab->pSchema) {
        sqlite3ErrorMsg(pParse, "cannot create a TEMP index on non-TEMP table \"%s\"",
                        pTab->zName);
        goto exit_create_index;
      }
    }
    if (! ((pTab->tabFlags & 32U) == 0U)) {
      pPk = sqlite3PrimaryKeyIndex(pTab);
    }
  } else {
    pTab = pParse->pNewTable;
    if (! pTab) {
      goto exit_create_index;
    }
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  }
  pDb = db->aDb + iDb;
  tmp___1 = sqlite3_strnicmp((char const   *)pTab->zName, "sqlite_", 7);
  if (tmp___1 == 0) {
    if ((int )db->init.busy == 0) {
      if ((unsigned long )pTblName != (unsigned long )((SrcList *)0)) {
        sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);
        goto exit_create_index;
      }
    }
  }
  if (pTab->pSelect) {
    sqlite3ErrorMsg(pParse, "views may not be indexed");
    goto exit_create_index;
  }
  if (pTab->nModuleArg) {
    sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
    goto exit_create_index;
  }
  if (pName) {
    zName = sqlite3NameFromToken(db, pName);
    if ((unsigned long )zName == (unsigned long )((char *)0)) {
      goto exit_create_index;
    }
    tmp___2 = sqlite3CheckObjectName(pParse, (char const   *)zName, "index", (char const   *)pTab->zName);
    if (0 != tmp___2) {
      goto exit_create_index;
    }
    if (! ((int )pParse->eParseMode >= 2)) {
      if (! db->init.busy) {
        tmp___3 = sqlite3FindTable(db, (char const   *)zName, (char const   *)0);
        if ((unsigned long )tmp___3 != (unsigned long )((Table *)0)) {
          sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
          goto exit_create_index;
        }
      }
      tmp___4 = sqlite3FindIndex(db, (char const   *)zName, (char const   *)pDb->zDbSName);
      if ((unsigned long )tmp___4 != (unsigned long )((Index *)0)) {
        if (! ifNotExist) {
          sqlite3ErrorMsg(pParse, "index %s already exists", zName);
        } else {
          sqlite3CodeVerifySchema(pParse, iDb);
        }
        goto exit_create_index;
      }
    }
  } else {
    pLoop = pTab->pIndex;
    n = 1;
    while (pLoop) {
      pLoop = pLoop->pNext;
      n ++;
    }
    zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);
    if ((unsigned long )zName == (unsigned long )((char *)0)) {
      goto exit_create_index;
    }
    if ((int )pParse->eParseMode != 0) {
      *(zName + 7) = (char )((int )*(zName + 7) + 1);
    }
  }
  if (! ((int )pParse->eParseMode >= 2)) {
    zDb = (char const   *)pDb->zDbSName;
    if (iDb == 1) {
      tmp___5 = "sqlite_temp_master";
    } else {
      tmp___5 = "sqlite_master";
    }
    tmp___6 = sqlite3AuthCheck(pParse, 18, tmp___5, (char const   *)0, zDb);
    if (tmp___6) {
      goto exit_create_index;
    }
    i = 1;
    if (iDb == 1) {
      i = 3;
    }
    tmp___7 = sqlite3AuthCheck(pParse, i, (char const   *)zName, (char const   *)pTab->zName,
                               zDb);
    if (tmp___7) {
      goto exit_create_index;
    }
  }
  if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
    pCol = pTab->aCol + ((int )pTab->nCol - 1);
    pCol->colFlags = (u8 )((int )pCol->colFlags | 8);
    sqlite3TokenInit(& prevCol, pCol->zName);
    tmp___8 = sqlite3ExprAlloc(db, 59, (Token const   *)(& prevCol), 0);
    pList = sqlite3ExprListAppend(pParse, (ExprList *)0, tmp___8);
    if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
      goto exit_create_index;
    }
    sqlite3ExprListSetSortOrder(pList, sortOrder, -1);
  } else {
    sqlite3ExprListCheckLength(pParse, pList, "index");
    if (pParse->nErr) {
      goto exit_create_index;
    }
  }
  i = 0;
  while (i < pList->nExpr) {
    pExpr = pList->a[i].pExpr;
    if ((int )pExpr->op == 109) {
      tmp___9 = sqlite3Strlen30((char const   *)pExpr->u.zToken);
      nExtra += 1 + tmp___9;
    }
    i ++;
  }
  nName = sqlite3Strlen30((char const   *)zName);
  if (pPk) {
    nExtraCol = (int )pPk->nKeyCol;
  } else {
    nExtraCol = 1;
  }
  pIndex = sqlite3AllocateIndexObject(db, (i16 )(pList->nExpr + nExtraCol), (nName + nExtra) + 1,
                                      & zExtra);
  if (db->mallocFailed) {
    goto exit_create_index;
  }
  pIndex->zName = zExtra;
  zExtra += nName + 1;
  memcpy((void * __restrict  )pIndex->zName, (void const   * __restrict  )zName, (size_t )(nName + 1));
  pIndex->pTable = pTab;
  pIndex->onError = (u8 )onError;
  pIndex->uniqNotNull = (unsigned int )(onError != 0);
  pIndex->idxType = (unsigned int )idxType;
  pIndex->pSchema = (db->aDb + iDb)->pSchema;
  pIndex->nKeyCol = (u16 )pList->nExpr;
  if (pPIWhere) {
    sqlite3ResolveSelfReference(pParse, pTab, 2, pPIWhere, (ExprList *)0);
    pIndex->pPartIdxWhere = pPIWhere;
    pPIWhere = (Expr *)0;
  }
  if ((int )(pDb->pSchema)->file_format >= 4) {
    sortOrderMask = -1;
  } else {
    sortOrderMask = 0;
  }
  pListItem = pList->a;
  if ((int )pParse->eParseMode >= 2) {
    pIndex->aColExpr = pList;
    pList = (ExprList *)0;
  }
  i = 0;
  while (i < (int )pIndex->nKeyCol) {
    sqlite3StringToId(pListItem->pExpr);
    sqlite3ResolveSelfReference(pParse, pTab, 32, pListItem->pExpr, (ExprList *)0);
    if (pParse->nErr) {
      goto exit_create_index;
    }
    pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
    if ((int )pCExpr->op != 162) {
      if ((unsigned long )pTab == (unsigned long )pParse->pNewTable) {
        sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and UNIQUE constraints");
        goto exit_create_index;
      }
      if ((unsigned long )pIndex->aColExpr == (unsigned long )((ExprList *)0)) {
        pIndex->aColExpr = pList;
        pList = (ExprList *)0;
      }
      j = -2;
      *(pIndex->aiColumn + i) = (i16 )-2;
      pIndex->uniqNotNull = 0U;
    } else {
      j = (int )pCExpr->iColumn;
      if (j < 0) {
        j = (int )pTab->iPKey;
      } else
      if ((int )(pTab->aCol + j)->notNull == 0) {
        pIndex->uniqNotNull = 0U;
      }
      *(pIndex->aiColumn + i) = (i16 )j;
    }
    zColl = (char const   *)0;
    if ((int )(pListItem->pExpr)->op == 109) {
      zColl = (char const   *)(pListItem->pExpr)->u.zToken;
      tmp___10 = sqlite3Strlen30(zColl);
      nColl = tmp___10 + 1;
      memcpy((void * __restrict  )zExtra, (void const   * __restrict  )zColl, (size_t )nColl);
      zColl = (char const   *)zExtra;
      zExtra += nColl;
      nExtra -= nColl;
    } else
    if (j >= 0) {
      zColl = (char const   *)(pTab->aCol + j)->zColl;
    }
    if (! zColl) {
      zColl = sqlite3StrBINARY;
    }
    if (! db->init.busy) {
      tmp___11 = sqlite3LocateCollSeq(pParse, zColl);
      if (! tmp___11) {
        goto exit_create_index;
      }
    }
    *(pIndex->azColl + i) = zColl;
    requestedSortOrder = (int )pListItem->sortFlags & sortOrderMask;
    *(pIndex->aSortOrder + i) = (u8 )requestedSortOrder;
    i ++;
    pListItem ++;
  }
  if (pPk) {
    j = 0;
    while (j < (int )pPk->nKeyCol) {
      x___0 = (int )*(pPk->aiColumn + j);
      tmp___12 = isDupColumn(pIndex, (int )pIndex->nKeyCol, pPk, j);
      if (tmp___12) {
        pIndex->nColumn = (u16 )((int )pIndex->nColumn - 1);
      } else {
        *(pIndex->aiColumn + i) = (i16 )x___0;
        *(pIndex->azColl + i) = *(pPk->azColl + j);
        *(pIndex->aSortOrder + i) = *(pPk->aSortOrder + j);
        i ++;
      }
      j ++;
    }
  } else {
    *(pIndex->aiColumn + i) = (i16 )-1;
    *(pIndex->azColl + i) = sqlite3StrBINARY;
  }
  sqlite3DefaultRowEst(pIndex);
  if ((unsigned long )pParse->pNewTable == (unsigned long )((Table *)0)) {
    estimateIndexWidth(pIndex);
  }
  recomputeColumnsNotIndexed(pIndex);
  if ((unsigned long )pTblName != (unsigned long )((SrcList *)0)) {
    if ((int )pIndex->nColumn >= (int )pTab->nCol) {
      pIndex->isCovering = 1U;
      j = 0;
      while (j < (int )pTab->nCol) {
        if (j == (int )pTab->iPKey) {
          goto __Cont;
        }
        tmp___13 = sqlite3ColumnOfIndex(pIndex, (i16 )j);
        if ((int )tmp___13 >= 0) {
          goto __Cont;
        }
        pIndex->isCovering = 0U;
        break;
        __Cont: /* CIL Label */ 
        j ++;
      }
    }
  }
  if ((unsigned long )pTab == (unsigned long )pParse->pNewTable) {
    pIdx = pTab->pIndex;
    while (pIdx) {
      if ((int )pIdx->nKeyCol != (int )pIndex->nKeyCol) {
        goto __Cont___0;
      }
      k = 0;
      while (k < (int )pIdx->nKeyCol) {
        if ((int )*(pIdx->aiColumn + k) != (int )*(pIndex->aiColumn + k)) {
          break;
        }
        z1 = *(pIdx->azColl + k);
        z2 = *(pIndex->azColl + k);
        tmp___14 = sqlite3StrICmp(z1, z2);
        if (tmp___14) {
          break;
        }
        k ++;
      }
      if (k == (int )pIdx->nKeyCol) {
        if ((int )pIdx->onError != (int )pIndex->onError) {
          if (! ((int )pIdx->onError == 11)) {
            if (! ((int )pIndex->onError == 11)) {
              sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified",
                              0);
            }
          }
          if ((int )pIdx->onError == 11) {
            pIdx->onError = pIndex->onError;
          }
        }
        if ((int )idxType == 2) {
          pIdx->idxType = (unsigned int )idxType;
        }
        if ((int )pParse->eParseMode >= 2) {
          pIndex->pNext = pParse->pNewIndex;
          pParse->pNewIndex = pIndex;
          pIndex = (Index *)0;
        }
        goto exit_create_index;
      }
      __Cont___0: /* CIL Label */ 
      pIdx = pIdx->pNext;
    }
  }
  if (! ((int )pParse->eParseMode >= 2)) {
    if (db->init.busy) {
      if ((unsigned long )pTblName != (unsigned long )((SrcList *)0)) {
        pIndex->tnum = db->init.newTnum;
        tmp___15 = sqlite3IndexHasDuplicateRootPage(pIndex);
        if (tmp___15) {
          sqlite3ErrorMsg(pParse, "invalid rootpage");
          pParse->rc = sqlite3CorruptError(111273);
          goto exit_create_index;
        }
      }
      tmp___16 = sqlite3HashInsert(& (pIndex->pSchema)->idxHash, (char const   *)pIndex->zName,
                                   (void *)pIndex);
      p = (Index *)tmp___16;
      if (p) {
        sqlite3OomFault(db);
        goto exit_create_index;
      }
      db->mDbFlags |= 1U;
    } else
    if ((pTab->tabFlags & 32U) == 0U) {
      goto _L;
    } else
    if ((unsigned long )pTblName != (unsigned long )((SrcList *)0)) {
      _L: /* CIL Label */ 
      (pParse->nMem) ++;
      iMem = pParse->nMem;
      v = sqlite3GetVdbe(pParse);
      if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
        goto exit_create_index;
      }
      sqlite3BeginWriteOperation(pParse, 1, iDb);
      pIndex->tnum = sqlite3VdbeAddOp0(v, 170);
      sqlite3VdbeAddOp3(v, 139, iDb, iMem, 2);
      if (pStart) {
        n___0 = (int )((unsigned int )((int )(pParse->sLastToken.z - pName->z)) + pParse->sLastToken.n);
        if ((int const   )*(pName->z + (n___0 - 1)) == 59) {
          n___0 --;
        }
        if (onError == 0) {
          tmp___17 = "";
        } else {
          tmp___17 = " UNIQUE";
        }
        zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s", tmp___17, n___0, pName->z);
      } else {
        zStmt = (char *)0;
      }
      sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES(\'index\',%Q,%Q,#%d,%Q);",
                         (db->aDb + iDb)->zDbSName, "sqlite_master", pIndex->zName,
                         pTab->zName, iMem, zStmt);
      sqlite3DbFree(db, (void *)zStmt);
      if (pTblName) {
        sqlite3RefillIndex(pParse, pIndex, iMem);
        sqlite3ChangeCookie(pParse, iDb);
        tmp___18 = sqlite3MPrintf(db, "name=\'%q\' AND type=\'index\'", pIndex->zName);
        sqlite3VdbeAddParseSchemaOp(v, iDb, tmp___18);
        sqlite3VdbeAddOp2(v, 158, 0, 1);
      }
      sqlite3VdbeJumpHere(v, pIndex->tnum);
    }
  }
  if (db->init.busy) {
    goto _L___0;
  } else
  if ((unsigned long )pTblName == (unsigned long )((SrcList *)0)) {
    _L___0: /* CIL Label */ 
    if (onError != 5) {
      pIndex->pNext = pTab->pIndex;
      pTab->pIndex = pIndex;
    } else
    if ((unsigned long )pTab->pIndex == (unsigned long )((Index *)0)) {
      pIndex->pNext = pTab->pIndex;
      pTab->pIndex = pIndex;
    } else
    if ((int )(pTab->pIndex)->onError == 5) {
      pIndex->pNext = pTab->pIndex;
      pTab->pIndex = pIndex;
    } else {
      pOther = pTab->pIndex;
      while (1) {
        if (pOther->pNext) {
          if (! ((int )(pOther->pNext)->onError != 5)) {
            break;
          }
        } else {
          break;
        }
        pOther = pOther->pNext;
      }
      pIndex->pNext = pOther->pNext;
      pOther->pNext = pIndex;
    }
    pIndex = (Index *)0;
  } else
  if ((int )pParse->eParseMode >= 2) {
    pParse->pNewIndex = pIndex;
    pIndex = (Index *)0;
  }
  exit_create_index: 
  if (pIndex) {
    sqlite3FreeIndex(db, pIndex);
  }
  sqlite3ExprDelete(db, pPIWhere);
  sqlite3ExprListDelete(db, pList);
  sqlite3SrcListDelete(db, pTblName);
  sqlite3DbFree(db, (void *)zName);
  return;
}
}
static void sqlite3DefaultRowEst(Index *pIdx ) 
{ 
  LogEst aVal[5] ;
  LogEst *a___0 ;
  int nCopy ;
  int tmp ;
  int i ;

  {
  aVal[0] = (LogEst )33;
  aVal[1] = (LogEst )32;
  aVal[2] = (LogEst )30;
  aVal[3] = (LogEst )28;
  aVal[4] = (LogEst )26;
  a___0 = pIdx->aiRowLogEst;
  if ((int )(sizeof(aVal) / sizeof(aVal[0])) < (int )pIdx->nKeyCol) {
    tmp = (int )(sizeof(aVal) / sizeof(aVal[0]));
  } else {
    tmp = (int )pIdx->nKeyCol;
  }
  nCopy = tmp;
  *(a___0 + 0) = (pIdx->pTable)->nRowLogEst;
  if ((unsigned long )pIdx->pPartIdxWhere != (unsigned long )((Expr *)0)) {
    *(a___0 + 0) = (LogEst )((int )*(a___0 + 0) - 10);
  }
  if ((int )*(a___0 + 0) < 33) {
    *(a___0 + 0) = (LogEst )33;
  }
  memcpy((void * __restrict  )(a___0 + 1), (void const   * __restrict  )(aVal), (unsigned long )nCopy * sizeof(LogEst ));
  i = nCopy + 1;
  while (i <= (int )pIdx->nKeyCol) {
    *(a___0 + i) = (LogEst )23;
    i ++;
  }
  if ((int )pIdx->onError != 0) {
    *(a___0 + pIdx->nKeyCol) = (LogEst )0;
  }
  return;
}
}
static void sqlite3DropIndex(Parse *pParse , SrcList *pName , int ifExists ) 
{ 
  Index *pIndex ;
  Vdbe *v ;
  sqlite3 *db ;
  int iDb ;
  int tmp ;
  int code ;
  Table *pTab ;
  char const   *zDb ;
  char const   *zTab ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  db = pParse->db;
  if (db->mallocFailed) {
    goto exit_drop_index;
  }
  tmp = sqlite3ReadSchema(pParse);
  if (0 != tmp) {
    goto exit_drop_index;
  }
  pIndex = sqlite3FindIndex(db, (char const   *)pName->a[0].zName, (char const   *)pName->a[0].zDatabase);
  if ((unsigned long )pIndex == (unsigned long )((Index *)0)) {
    if (! ifExists) {
      sqlite3ErrorMsg(pParse, "no such index: %S", pName, 0);
    } else {
      sqlite3CodeVerifyNamedSchema(pParse, (char const   *)pName->a[0].zDatabase);
    }
    pParse->checkSchema = (u8 )1;
    goto exit_drop_index;
  }
  if (pIndex->idxType != 0U) {
    sqlite3ErrorMsg(pParse, "index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped",
                    0);
    goto exit_drop_index;
  }
  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);
  code = 10;
  pTab = pIndex->pTable;
  zDb = (char const   *)(db->aDb + iDb)->zDbSName;
  if (iDb == 1) {
    tmp___0 = "sqlite_temp_master";
  } else {
    tmp___0 = "sqlite_master";
  }
  zTab = tmp___0;
  tmp___1 = sqlite3AuthCheck(pParse, 9, zTab, (char const   *)0, zDb);
  if (tmp___1) {
    goto exit_drop_index;
  }
  if (iDb) {
    code = 12;
  }
  tmp___2 = sqlite3AuthCheck(pParse, code, (char const   *)pIndex->zName, (char const   *)pTab->zName,
                             zDb);
  if (tmp___2) {
    goto exit_drop_index;
  }
  v = sqlite3GetVdbe(pParse);
  if (v) {
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE name=%Q AND type=\'index\'",
                       (db->aDb + iDb)->zDbSName, "sqlite_master", pIndex->zName);
    sqlite3ClearStatTables(pParse, iDb, "idx", (char const   *)pIndex->zName);
    sqlite3ChangeCookie(pParse, iDb);
    destroyRootPage(pParse, pIndex->tnum, iDb);
    sqlite3VdbeAddOp4(v, 144, iDb, 0, 0, (char const   *)pIndex->zName, 0);
  }
  exit_drop_index: 
  sqlite3SrcListDelete(db, pName);
  return;
}
}
static void *sqlite3ArrayAllocate(sqlite3 *db , void *pArray , int szEntry , int *pnEntry ,
                                  int *pIdx ) 
{ 
  char *z ;
  sqlite_int64 n ;
  int tmp ;
  sqlite_int64 sz ;
  sqlite_int64 tmp___0 ;
  void *pNew ;
  void *tmp___1 ;

  {
  tmp = *pnEntry;
  *pIdx = tmp;
  n = (sqlite_int64 )tmp;
  if ((n & (n - 1LL)) == 0LL) {
    if (n == 0LL) {
      tmp___0 = (sqlite_int64 )1;
    } else {
      tmp___0 = 2LL * n;
    }
    sz = tmp___0;
    tmp___1 = sqlite3DbRealloc(db, pArray, (u64 )(sz * (sqlite_int64 )szEntry));
    pNew = tmp___1;
    if ((unsigned long )pNew == (unsigned long )((void *)0)) {
      *pIdx = -1;
      return (pArray);
    }
    pArray = pNew;
  }
  z = (char *)pArray;
  memset((void *)(z + n * (sqlite_int64 )szEntry), 0, (size_t )szEntry);
  (*pnEntry) ++;
  return (pArray);
}
}
static IdList *sqlite3IdListAppend(Parse *pParse , IdList *pList , Token *pToken ) 
{ 
  sqlite3 *db ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  db = pParse->db;
  if ((unsigned long )pList == (unsigned long )((IdList *)0)) {
    tmp = sqlite3DbMallocZero(db, (u64 )sizeof(IdList ));
    pList = (IdList *)tmp;
    if ((unsigned long )pList == (unsigned long )((IdList *)0)) {
      return ((IdList *)0);
    }
  }
  tmp___0 = sqlite3ArrayAllocate(db, (void *)pList->a, (int )sizeof(*(pList->a + 0)),
                                 & pList->nId, & i);
  pList->a = (struct IdList_item *)tmp___0;
  if (i < 0) {
    sqlite3IdListDelete(db, pList);
    return ((IdList *)0);
  }
  (pList->a + i)->zName = sqlite3NameFromToken(db, pToken);
  if ((int )pParse->eParseMode >= 2) {
    if ((pList->a + i)->zName) {
      sqlite3RenameTokenMap(pParse, (void *)(pList->a + i)->zName, pToken);
    }
  }
  return (pList);
}
}
static void sqlite3IdListDelete(sqlite3 *db , IdList *pList ) 
{ 
  int i ;

  {
  if ((unsigned long )pList == (unsigned long )((IdList *)0)) {
    return;
  }
  i = 0;
  while (i < pList->nId) {
    sqlite3DbFree(db, (void *)(pList->a + i)->zName);
    i ++;
  }
  sqlite3DbFree(db, (void *)pList->a);
  sqlite3DbFreeNN(db, (void *)pList);
  return;
}
}
static int sqlite3IdListIndex(IdList *pList , char const   *zName ) 
{ 
  int i ;
  int tmp ;

  {
  if ((unsigned long )pList == (unsigned long )((IdList *)0)) {
    return (-1);
  }
  i = 0;
  while (i < pList->nId) {
    tmp = sqlite3StrICmp((char const   *)(pList->a + i)->zName, zName);
    if (tmp == 0) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
static SrcList *sqlite3SrcListEnlarge(Parse *pParse , SrcList *pSrc , int nExtra ,
                                      int iStart ) 
{ 
  int i ;
  SrcList *pNew ;
  sqlite_int64 nAlloc ;
  sqlite3 *db ;
  void *tmp ;

  {
  if ((u32 )pSrc->nSrc + (u32 )nExtra > pSrc->nAlloc) {
    nAlloc = 2LL * (sqlite_int64 )pSrc->nSrc + (sqlite_int64 )nExtra;
    db = pParse->db;
    if (pSrc->nSrc + nExtra >= 200) {
      sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d", 200);
      return ((SrcList *)0);
    }
    if (nAlloc > 200LL) {
      nAlloc = (sqlite_int64 )200;
    }
    tmp = sqlite3DbRealloc(db, (void *)pSrc, (unsigned long long )sizeof(*pSrc) + (unsigned long long )(nAlloc - 1LL) * (unsigned long long )sizeof(pSrc->a[0]));
    pNew = (SrcList *)tmp;
    if ((unsigned long )pNew == (unsigned long )((SrcList *)0)) {
      return ((SrcList *)0);
    }
    pSrc = pNew;
    pSrc->nAlloc = (u32 )nAlloc;
  }
  i = pSrc->nSrc - 1;
  while (i >= iStart) {
    pSrc->a[i + nExtra] = pSrc->a[i];
    i --;
  }
  pSrc->nSrc += nExtra;
  memset((void *)(& pSrc->a[iStart]), 0, sizeof(pSrc->a[0]) * (unsigned long )nExtra);
  i = iStart;
  while (i < iStart + nExtra) {
    pSrc->a[i].iCursor = -1;
    i ++;
  }
  return (pSrc);
}
}
static SrcList *sqlite3SrcListAppend(Parse *pParse , SrcList *pList , Token *pTable ,
                                     Token *pDatabase ) 
{ 
  struct SrcList_item *pItem ;
  sqlite3 *db ;
  void *tmp ;
  SrcList *pNew ;
  SrcList *tmp___0 ;

  {
  db = pParse->db;
  if ((unsigned long )pList == (unsigned long )((SrcList *)0)) {
    tmp = sqlite3DbMallocRawNN(pParse->db, (u64 )sizeof(SrcList ));
    pList = (SrcList *)tmp;
    if ((unsigned long )pList == (unsigned long )((SrcList *)0)) {
      return ((SrcList *)0);
    }
    pList->nAlloc = (u32 )1;
    pList->nSrc = 1;
    memset((void *)(& pList->a[0]), 0, sizeof(pList->a[0]));
    pList->a[0].iCursor = -1;
  } else {
    tmp___0 = sqlite3SrcListEnlarge(pParse, pList, 1, pList->nSrc);
    pNew = tmp___0;
    if ((unsigned long )pNew == (unsigned long )((SrcList *)0)) {
      sqlite3SrcListDelete(db, pList);
      return ((SrcList *)0);
    } else {
      pList = pNew;
    }
  }
  pItem = & pList->a[pList->nSrc - 1];
  if (pDatabase) {
    if ((unsigned long )pDatabase->z == (unsigned long )((char const   *)0)) {
      pDatabase = (Token *)0;
    }
  }
  if (pDatabase) {
    pItem->zName = sqlite3NameFromToken(db, pDatabase);
    pItem->zDatabase = sqlite3NameFromToken(db, pTable);
  } else {
    pItem->zName = sqlite3NameFromToken(db, pTable);
    pItem->zDatabase = (char *)0;
  }
  return (pList);
}
}
static void sqlite3SrcListAssignCursors(Parse *pParse , SrcList *pList ) 
{ 
  int i ;
  struct SrcList_item *pItem ;
  int tmp ;

  {
  if (pList) {
    i = 0;
    pItem = pList->a;
    while (i < pList->nSrc) {
      if (pItem->iCursor >= 0) {
        break;
      }
      tmp = pParse->nTab;
      (pParse->nTab) ++;
      pItem->iCursor = tmp;
      if (pItem->pSelect) {
        sqlite3SrcListAssignCursors(pParse, (pItem->pSelect)->pSrc);
      }
      i ++;
      pItem ++;
    }
  }
  return;
}
}
static void sqlite3SrcListDelete(sqlite3 *db , SrcList *pList ) 
{ 
  int i ;
  struct SrcList_item *pItem ;

  {
  if ((unsigned long )pList == (unsigned long )((SrcList *)0)) {
    return;
  }
  pItem = pList->a;
  i = 0;
  while (i < pList->nSrc) {
    sqlite3DbFree(db, (void *)pItem->zDatabase);
    sqlite3DbFree(db, (void *)pItem->zName);
    sqlite3DbFree(db, (void *)pItem->zAlias);
    if (pItem->fg.isIndexedBy) {
      sqlite3DbFree(db, (void *)pItem->u1.zIndexedBy);
    }
    if (pItem->fg.isTabFunc) {
      sqlite3ExprListDelete(db, pItem->u1.pFuncArg);
    }
    sqlite3DeleteTable(db, pItem->pTab);
    sqlite3SelectDelete(db, pItem->pSelect);
    sqlite3ExprDelete(db, pItem->pOn);
    sqlite3IdListDelete(db, pItem->pUsing);
    i ++;
    pItem ++;
  }
  sqlite3DbFreeNN(db, (void *)pList);
  return;
}
}
static SrcList *sqlite3SrcListAppendFromTerm(Parse *pParse , SrcList *p , Token *pTable ,
                                             Token *pDatabase , Token *pAlias , Select *pSubquery ,
                                             Expr *pOn , IdList *pUsing ) 
{ 
  struct SrcList_item *pItem ;
  sqlite3 *db ;
  char const   *tmp ;
  Token *pToken ;
  Token *tmp___0 ;

  {
  db = pParse->db;
  if (! p) {
    if (pOn) {
      goto _L;
    } else
    if (pUsing) {
      _L: /* CIL Label */ 
      if (pOn) {
        tmp = "ON";
      } else {
        tmp = "USING";
      }
      sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s", tmp);
      goto append_from_error;
    }
  }
  p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);
  if ((unsigned long )p == (unsigned long )((SrcList *)0)) {
    goto append_from_error;
  }
  pItem = & p->a[p->nSrc - 1];
  if ((int )pParse->eParseMode >= 2) {
    if (pItem->zName) {
      if (pDatabase) {
        if (pDatabase->z) {
          tmp___0 = pDatabase;
        } else {
          tmp___0 = pTable;
        }
      } else {
        tmp___0 = pTable;
      }
      pToken = tmp___0;
      sqlite3RenameTokenMap(pParse, (void *)pItem->zName, pToken);
    }
  }
  if (pAlias->n) {
    pItem->zAlias = sqlite3NameFromToken(db, pAlias);
  }
  pItem->pSelect = pSubquery;
  pItem->pOn = pOn;
  pItem->pUsing = pUsing;
  return (p);
  append_from_error: 
  sqlite3ExprDelete(db, pOn);
  sqlite3IdListDelete(db, pUsing);
  sqlite3SelectDelete(db, pSubquery);
  return ((SrcList *)0);
}
}
static void sqlite3SrcListIndexedBy(Parse *pParse , SrcList *p , Token *pIndexedBy ) 
{ 
  struct SrcList_item *pItem ;

  {
  if (p) {
    if (pIndexedBy->n > 0U) {
      pItem = & p->a[p->nSrc - 1];
      if (pIndexedBy->n == 1U) {
        if (! pIndexedBy->z) {
          pItem->fg.notIndexed = 1U;
        } else {
          pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
          pItem->fg.isIndexedBy = 1U;
        }
      } else {
        pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
        pItem->fg.isIndexedBy = 1U;
      }
    }
  }
  return;
}
}
static void sqlite3SrcListFuncArgs(Parse *pParse , SrcList *p , ExprList *pList ) 
{ 
  struct SrcList_item *pItem ;

  {
  if (p) {
    pItem = & p->a[p->nSrc - 1];
    pItem->u1.pFuncArg = pList;
    pItem->fg.isTabFunc = 1U;
  } else {
    sqlite3ExprListDelete(pParse->db, pList);
  }
  return;
}
}
static void sqlite3SrcListShiftJoinType(SrcList *p ) 
{ 
  int i ;

  {
  if (p) {
    i = p->nSrc - 1;
    while (i > 0) {
      p->a[i].fg.jointype = p->a[i - 1].fg.jointype;
      i --;
    }
    p->a[0].fg.jointype = (u8 )0;
  }
  return;
}
}
static void sqlite3BeginTransaction(Parse *pParse , int type ) 
{ 
  sqlite3 *db ;
  Vdbe *v ;
  int i ;
  int tmp ;

  {
  db = pParse->db;
  tmp = sqlite3AuthCheck(pParse, 22, "BEGIN", (char const   *)0, (char const   *)0);
  if (tmp) {
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if (! v) {
    return;
  }
  if (type != 7) {
    i = 0;
    while (i < db->nDb) {
      sqlite3VdbeAddOp2(v, 2, i, (type == 9) + 1);
      sqlite3VdbeUsesBtree(v, i);
      i ++;
    }
  }
  sqlite3VdbeAddOp0(v, 1);
  return;
}
}
static void sqlite3EndTransaction(Parse *pParse , int eType ) 
{ 
  Vdbe *v ;
  int isRollback ;
  char const   *tmp ;
  int tmp___0 ;

  {
  isRollback = eType == 12;
  if (isRollback) {
    tmp = "ROLLBACK";
  } else {
    tmp = "COMMIT";
  }
  tmp___0 = sqlite3AuthCheck(pParse, 22, tmp, (char const   *)0, (char const   *)0);
  if (tmp___0) {
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if (v) {
    sqlite3VdbeAddOp2(v, 1, 1, isRollback);
  }
  return;
}
}
static char const   * const  az[3]  = {      (char const   * const  )"BEGIN",      (char const   * const  )"RELEASE",      (char const   * const  )"ROLLBACK"};
static void sqlite3Savepoint(Parse *pParse , int op , Token *pName ) 
{ 
  char *zName ;
  char *tmp ;
  Vdbe *v ;
  Vdbe *tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3NameFromToken(pParse->db, pName);
  zName = tmp;
  if (zName) {
    tmp___0 = sqlite3GetVdbe(pParse);
    v = tmp___0;
    if (! v) {
      sqlite3DbFree(pParse->db, (void *)zName);
      return;
    } else {
      tmp___1 = sqlite3AuthCheck(pParse, 32, (char const   *)az[op], (char const   *)zName,
                                 (char const   *)0);
      if (tmp___1) {
        sqlite3DbFree(pParse->db, (void *)zName);
        return;
      }
    }
    sqlite3VdbeAddOp4(v, 0, op, 0, 0, (char const   *)zName, -7);
  }
  return;
}
}
static int const   flags  =    (int const   )542;
static int sqlite3OpenTempDatabase(Parse *pParse ) 
{ 
  sqlite3 *db ;
  int rc ;
  Btree *pBt ;
  int tmp ;

  {
  db = pParse->db;
  if ((unsigned long )(db->aDb + 1)->pBt == (unsigned long )((Btree *)0)) {
    if (! pParse->explain) {
      rc = sqlite3BtreeOpen(db->pVfs, (char const   *)0, db, & pBt, 0, (int )flags);
      if (rc != 0) {
        sqlite3ErrorMsg(pParse, "unable to open a temporary database file for storing temporary tables");
        pParse->rc = rc;
        return (1);
      }
      (db->aDb + 1)->pBt = pBt;
      tmp = sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0);
      if (7 == tmp) {
        sqlite3OomFault(db);
        return (1);
      }
    }
  }
  return (0);
}
}
static void sqlite3CodeVerifySchema(Parse *pParse , int iDb ) 
{ 
  Parse *pToplevel ;
  Parse *tmp ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pToplevel = tmp;
  if (((pToplevel->cookieMask & (1U << iDb)) != 0U) == 0) {
    pToplevel->cookieMask |= 1U << iDb;
    if (iDb == 1) {
      sqlite3OpenTempDatabase(pToplevel);
    }
  }
  return;
}
}
static void sqlite3CodeVerifyNamedSchema(Parse *pParse , char const   *zDb ) 
{ 
  sqlite3 *db ;
  int i ;
  Db *pDb ;
  int tmp ;

  {
  db = pParse->db;
  i = 0;
  while (i < db->nDb) {
    pDb = db->aDb + i;
    if (pDb->pBt) {
      if (! zDb) {
        sqlite3CodeVerifySchema(pParse, i);
      } else {
        tmp = sqlite3StrICmp(zDb, (char const   *)pDb->zDbSName);
        if (0 == tmp) {
          sqlite3CodeVerifySchema(pParse, i);
        }
      }
    }
    i ++;
  }
  return;
}
}
static void sqlite3BeginWriteOperation(Parse *pParse , int setStatement , int iDb ) 
{ 
  Parse *pToplevel ;
  Parse *tmp ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pToplevel = tmp;
  sqlite3CodeVerifySchema(pParse, iDb);
  pToplevel->writeMask |= 1U << iDb;
  pToplevel->isMultiWrite = (u8 )((int )pToplevel->isMultiWrite | setStatement);
  return;
}
}
static void sqlite3MultiWrite(Parse *pParse ) 
{ 
  Parse *pToplevel ;
  Parse *tmp ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pToplevel = tmp;
  pToplevel->isMultiWrite = (u8 )1;
  return;
}
}
static void sqlite3MayAbort(Parse *pParse ) 
{ 
  Parse *pToplevel ;
  Parse *tmp ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pToplevel = tmp;
  pToplevel->mayAbort = (u8 )1;
  return;
}
}
static void sqlite3HaltConstraint(Parse *pParse , int errCode , int onError , char *p4 ,
                                  i8 p4type , u8 p5Errmsg ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if (onError == 2) {
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 69, errCode, onError, 0, (char const   *)p4, (int )p4type);
  sqlite3VdbeChangeP5(v, (u16 )p5Errmsg);
  return;
}
}
static void sqlite3UniqueConstraint(Parse *pParse , int onError , Index *pIdx ) 
{ 
  char *zErr ;
  int j ;
  StrAccum errMsg ;
  Table *pTab ;
  char *zCol ;
  int tmp ;

  {
  pTab = pIdx->pTable;
  sqlite3StrAccumInit(& errMsg, pParse->db, (char *)0, 0, (pParse->db)->aLimit[0]);
  if (pIdx->aColExpr) {
    sqlite3_str_appendf(& errMsg, "index \'%q\'", pIdx->zName);
  } else {
    j = 0;
    while (j < (int )pIdx->nKeyCol) {
      zCol = (pTab->aCol + *(pIdx->aiColumn + j))->zName;
      if (j) {
        sqlite3_str_append(& errMsg, ", ", 2);
      }
      sqlite3_str_appendall(& errMsg, (char const   *)pTab->zName);
      sqlite3_str_append(& errMsg, ".", 1);
      sqlite3_str_appendall(& errMsg, (char const   *)zCol);
      j ++;
    }
  }
  zErr = sqlite3StrAccumFinish(& errMsg);
  if (pIdx->idxType == 2U) {
    tmp = 19 | (6 << 8);
  } else {
    tmp = 19 | (8 << 8);
  }
  sqlite3HaltConstraint(pParse, tmp, onError, zErr, (i8 )-7, (u8 )2);
  return;
}
}
static void sqlite3RowidConstraint(Parse *pParse , int onError , Table *pTab ) 
{ 
  char *zMsg ;
  int rc ;

  {
  if ((int )pTab->iPKey >= 0) {
    zMsg = sqlite3MPrintf(pParse->db, "%s.%s", pTab->zName, (pTab->aCol + pTab->iPKey)->zName);
    rc = 19 | (6 << 8);
  } else {
    zMsg = sqlite3MPrintf(pParse->db, "%s.rowid", pTab->zName);
    rc = 19 | (10 << 8);
  }
  sqlite3HaltConstraint(pParse, rc, onError, zMsg, (i8 )-7, (u8 )2);
  return;
}
}
static int collationMatch(char const   *zColl , Index *pIndex ) 
{ 
  int i ;
  char const   *z ;
  int tmp ;

  {
  i = 0;
  while (i < (int )pIndex->nColumn) {
    z = *(pIndex->azColl + i);
    if ((int )*(pIndex->aiColumn + i) >= 0) {
      tmp = sqlite3StrICmp(z, zColl);
      if (0 == tmp) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static void reindexTable(Parse *pParse , Table *pTab , char const   *zColl ) 
{ 
  Index *pIndex ;
  int iDb ;
  int tmp ;
  int tmp___0 ;

  {
  if (! pTab->nModuleArg) {
    pIndex = pTab->pIndex;
    while (pIndex) {
      if ((unsigned long )zColl == (unsigned long )((char const   *)0)) {
        tmp = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        iDb = tmp;
        sqlite3BeginWriteOperation(pParse, 0, iDb);
        sqlite3RefillIndex(pParse, pIndex, -1);
      } else {
        tmp___0 = collationMatch(zColl, pIndex);
        if (tmp___0) {
          tmp = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
          iDb = tmp;
          sqlite3BeginWriteOperation(pParse, 0, iDb);
          sqlite3RefillIndex(pParse, pIndex, -1);
        }
      }
      pIndex = pIndex->pNext;
    }
  }
  return;
}
}
static void reindexDatabases(Parse *pParse , char const   *zColl ) 
{ 
  Db *pDb ;
  int iDb ;
  sqlite3 *db ;
  HashElem *k ;
  Table *pTab ;

  {
  db = pParse->db;
  iDb = 0;
  pDb = db->aDb;
  while (iDb < db->nDb) {
    k = (pDb->pSchema)->tblHash.first;
    while (k) {
      pTab = (Table *)k->data;
      reindexTable(pParse, pTab, zColl);
      k = k->next;
    }
    iDb ++;
    pDb ++;
  }
  return;
}
}
static void sqlite3Reindex(Parse *pParse , Token *pName1 , Token *pName2 ) 
{ 
  CollSeq *pColl ;
  char *z ;
  char const   *zDb ;
  Table *pTab ;
  Index *pIndex ;
  int iDb ;
  sqlite3 *db ;
  Token *pObjName ;
  int tmp ;
  char *zColl ;

  {
  db = pParse->db;
  tmp = sqlite3ReadSchema(pParse);
  if (0 != tmp) {
    return;
  }
  if ((unsigned long )pName1 == (unsigned long )((Token *)0)) {
    reindexDatabases(pParse, (char const   *)0);
    return;
  } else
  if ((unsigned long )pName2 == (unsigned long )((Token *)0)) {
    goto _L;
  } else
  if ((unsigned long )pName2->z == (unsigned long )((char const   *)0)) {
    _L: /* CIL Label */ 
    zColl = sqlite3NameFromToken(pParse->db, pName1);
    if (! zColl) {
      return;
    }
    pColl = sqlite3FindCollSeq(db, db->enc, (char const   *)zColl, 0);
    if (pColl) {
      reindexDatabases(pParse, (char const   *)zColl);
      sqlite3DbFree(db, (void *)zColl);
      return;
    }
    sqlite3DbFree(db, (void *)zColl);
  }
  iDb = sqlite3TwoPartName(pParse, pName1, pName2, & pObjName);
  if (iDb < 0) {
    return;
  }
  z = sqlite3NameFromToken(db, pObjName);
  if ((unsigned long )z == (unsigned long )((char *)0)) {
    return;
  }
  zDb = (char const   *)(db->aDb + iDb)->zDbSName;
  pTab = sqlite3FindTable(db, (char const   *)z, zDb);
  if (pTab) {
    reindexTable(pParse, pTab, (char const   *)0);
    sqlite3DbFree(db, (void *)z);
    return;
  }
  pIndex = sqlite3FindIndex(db, (char const   *)z, zDb);
  sqlite3DbFree(db, (void *)z);
  if (pIndex) {
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3RefillIndex(pParse, pIndex, -1);
    return;
  }
  sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
  return;
}
}
static KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse , Index *pIdx ) 
{ 
  int i ;
  int nCol ;
  int nKey ;
  KeyInfo *pKey ;
  char const   *zColl ;
  CollSeq *tmp ;

  {
  nCol = (int )pIdx->nColumn;
  nKey = (int )pIdx->nKeyCol;
  if (pParse->nErr) {
    return ((KeyInfo *)0);
  }
  if (pIdx->uniqNotNull) {
    pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol - nKey);
  } else {
    pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);
  }
  if (pKey) {
    i = 0;
    while (i < nCol) {
      zColl = *(pIdx->azColl + i);
      if ((unsigned long )zColl == (unsigned long )(sqlite3StrBINARY)) {
        pKey->aColl[i] = (CollSeq *)0;
      } else {
        tmp = sqlite3LocateCollSeq(pParse, zColl);
        pKey->aColl[i] = tmp;
      }
      *(pKey->aSortFlags + i) = *(pIdx->aSortOrder + i);
      i ++;
    }
    if (pParse->nErr) {
      if (pIdx->bNoQuery == 0U) {
        pIdx->bNoQuery = 1U;
        pParse->rc = 1 | (2 << 8);
      }
      sqlite3KeyInfoUnref(pKey);
      pKey = (KeyInfo *)0;
    }
  }
  return (pKey);
}
}
static With *sqlite3WithAdd(Parse *pParse , With *pWith , Token *pName , ExprList *pArglist ,
                            Select *pQuery ) 
{ 
  sqlite3 *db ;
  With *pNew ;
  char *zName ;
  int i ;
  int tmp ;
  sqlite_int64 nByte ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  db = pParse->db;
  zName = sqlite3NameFromToken(pParse->db, pName);
  if (zName) {
    if (pWith) {
      i = 0;
      while (i < pWith->nCte) {
        tmp = sqlite3StrICmp((char const   *)zName, (char const   *)pWith->a[i].zName);
        if (tmp == 0) {
          sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
        }
        i ++;
      }
    }
  }
  if (pWith) {
    nByte = (sqlite_int64 )(sizeof(*pWith) + sizeof(pWith->a[1]) * (unsigned long )pWith->nCte);
    tmp___0 = sqlite3DbRealloc(db, (void *)pWith, (u64 )nByte);
    pNew = (With *)tmp___0;
  } else {
    tmp___1 = sqlite3DbMallocZero(db, (u64 )sizeof(*pWith));
    pNew = (With *)tmp___1;
  }
  if (db->mallocFailed) {
    sqlite3ExprListDelete(db, pArglist);
    sqlite3SelectDelete(db, pQuery);
    sqlite3DbFree(db, (void *)zName);
    pNew = pWith;
  } else {
    pNew->a[pNew->nCte].pSelect = pQuery;
    pNew->a[pNew->nCte].pCols = pArglist;
    pNew->a[pNew->nCte].zName = zName;
    pNew->a[pNew->nCte].zCteErr = (char const   *)0;
    (pNew->nCte) ++;
  }
  return (pNew);
}
}
static void sqlite3WithDelete(sqlite3 *db , With *pWith ) 
{ 
  int i ;
  struct Cte *pCte ;

  {
  if (pWith) {
    i = 0;
    while (i < pWith->nCte) {
      pCte = & pWith->a[i];
      sqlite3ExprListDelete(db, pCte->pCols);
      sqlite3SelectDelete(db, pCte->pSelect);
      sqlite3DbFree(db, (void *)pCte->zName);
      i ++;
    }
    sqlite3DbFree(db, (void *)pWith);
  }
  return;
}
}
static void callCollNeeded(sqlite3 *db , int enc , char const   *zName ) 
{ 
  char *zExternal ;
  char *tmp ;
  char const   *zExternal___0 ;
  sqlite3_value *pTmp ;
  sqlite3_value *tmp___0 ;
  void const   *tmp___1 ;

  {
  if (db->xCollNeeded) {
    tmp = sqlite3DbStrDup(db, zName);
    zExternal = tmp;
    if (! zExternal) {
      return;
    }
    (*(db->xCollNeeded))(db->pCollNeededArg, db, enc, (char const   *)zExternal);
    sqlite3DbFree(db, (void *)zExternal);
  }
  if (db->xCollNeeded16) {
    tmp___0 = sqlite3ValueNew(db);
    pTmp = tmp___0;
    sqlite3ValueSetStr(pTmp, -1, (void const   *)zName, (u8 )1, (void (*)(void * ))0);
    tmp___1 = sqlite3ValueText(pTmp, (u8 )2);
    zExternal___0 = (char const   *)tmp___1;
    if (zExternal___0) {
      (*(db->xCollNeeded16))(db->pCollNeededArg, db, (int )db->enc, (void const   *)zExternal___0);
    }
    sqlite3ValueFree(pTmp);
  }
  return;
}
}
static int synthCollSeq(sqlite3 *db , CollSeq *pColl ) ;
static u8 const   aEnc[3]  = {      (u8 const   )3,      (u8 const   )2,      (u8 const   )1};
static int synthCollSeq(sqlite3 *db , CollSeq *pColl ) 
{ 
  CollSeq *pColl2 ;
  char *z ;
  int i ;

  {
  z = pColl->zName;
  i = 0;
  while (i < 3) {
    pColl2 = sqlite3FindCollSeq(db, (u8 )aEnc[i], (char const   *)z, 0);
    if ((unsigned long )pColl2->xCmp != (unsigned long )((int (*)(void * , int  ,
                                                                  void const   * ,
                                                                  int  , void const   * ))0)) {
      memcpy((void * __restrict  )pColl, (void const   * __restrict  )pColl2, sizeof(CollSeq ));
      pColl->xDel = (void (*)(void * ))0;
      return (0);
    }
    i ++;
  }
  return (1);
}
}
static CollSeq *sqlite3GetCollSeq(Parse *pParse , u8 enc , CollSeq *pColl , char const   *zName ) 
{ 
  CollSeq *p ;
  sqlite3 *db ;
  int tmp ;

  {
  db = pParse->db;
  p = pColl;
  if (! p) {
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if (! p) {
    callCollNeeded(db, (int )enc, zName);
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  } else
  if (! p->xCmp) {
    callCollNeeded(db, (int )enc, zName);
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if (p) {
    if (! p->xCmp) {
      tmp = synthCollSeq(db, p);
      if (tmp) {
        p = (CollSeq *)0;
      }
    }
  }
  if ((unsigned long )p == (unsigned long )((CollSeq *)0)) {
    sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
    pParse->rc = 1 | (1 << 8);
  }
  return (p);
}
}
static int sqlite3CheckCollSeq(Parse *pParse , CollSeq *pColl ) 
{ 
  char const   *zName ;
  sqlite3 *db ;
  CollSeq *p ;
  CollSeq *tmp ;

  {
  if (pColl) {
    if ((unsigned long )pColl->xCmp == (unsigned long )((int (*)(void * , int  , void const   * ,
                                                                 int  , void const   * ))0)) {
      zName = (char const   *)pColl->zName;
      db = pParse->db;
      tmp = sqlite3GetCollSeq(pParse, db->enc, pColl, zName);
      p = tmp;
      if (! p) {
        return (1);
      }
    }
  }
  return (0);
}
}
static CollSeq *findCollSeqEntry(sqlite3 *db , char const   *zName , int create ) 
{ 
  CollSeq *pColl ;
  void *tmp ;
  int nName ;
  int tmp___0 ;
  void *tmp___1 ;
  CollSeq *pDel ;
  void *tmp___2 ;

  {
  tmp = sqlite3HashFind((Hash const   *)(& db->aCollSeq), zName);
  pColl = (CollSeq *)tmp;
  if ((unsigned long )((CollSeq *)0) == (unsigned long )pColl) {
    if (create) {
      tmp___0 = sqlite3Strlen30(zName);
      nName = tmp___0 + 1;
      tmp___1 = sqlite3DbMallocZero(db, (u64 )(3UL * sizeof(*pColl) + (unsigned long )nName));
      pColl = (CollSeq *)tmp___1;
      if (pColl) {
        pDel = (CollSeq *)0;
        (pColl + 0)->zName = (char *)(pColl + 3);
        (pColl + 0)->enc = (u8 )1;
        (pColl + 1)->zName = (char *)(pColl + 3);
        (pColl + 1)->enc = (u8 )2;
        (pColl + 2)->zName = (char *)(pColl + 3);
        (pColl + 2)->enc = (u8 )3;
        memcpy((void * __restrict  )(pColl + 0)->zName, (void const   * __restrict  )zName,
               (size_t )nName);
        tmp___2 = sqlite3HashInsert(& db->aCollSeq, (char const   *)(pColl + 0)->zName,
                                    (void *)pColl);
        pDel = (CollSeq *)tmp___2;
        if ((unsigned long )pDel != (unsigned long )((CollSeq *)0)) {
          sqlite3OomFault(db);
          sqlite3DbFree(db, (void *)pDel);
          pColl = (CollSeq *)0;
        }
      }
    }
  }
  return (pColl);
}
}
static CollSeq *sqlite3FindCollSeq(sqlite3 *db , u8 enc , char const   *zName , int create ) 
{ 
  CollSeq *pColl ;

  {
  if (zName) {
    pColl = findCollSeqEntry(db, zName, create);
  } else {
    pColl = db->pDfltColl;
  }
  if (pColl) {
    pColl += (int )enc - 1;
  }
  return (pColl);
}
}
static int matchQuality(FuncDef *p , int nArg , u8 enc ) 
{ 
  int match ;
  int tmp ;

  {
  if (nArg == -2) {
    if ((unsigned long )p->xSFunc == (unsigned long )((void (*)(sqlite3_context * ,
                                                                int  , sqlite3_value ** ))0)) {
      tmp = 0;
    } else {
      tmp = 6;
    }
    return (tmp);
  }
  if ((int )p->nArg != nArg) {
    if ((int )p->nArg >= 0) {
      return (0);
    }
  }
  if ((int )p->nArg == nArg) {
    match = 4;
  } else {
    match = 1;
  }
  if ((unsigned int )enc == (p->funcFlags & 3U)) {
    match += 2;
  } else
  if ((((unsigned int )enc & p->funcFlags) & 2U) != 0U) {
    match ++;
  }
  return (match);
}
}
static FuncDef *sqlite3FunctionSearch(int h , char const   *zFunc ) 
{ 
  FuncDef *p ;
  int tmp ;

  {
  p = sqlite3BuiltinFunctions.a[h];
  while (p) {
    tmp = sqlite3StrICmp(p->zName, zFunc);
    if (tmp == 0) {
      return (p);
    }
    p = p->u.pHash;
  }
  return ((FuncDef *)0);
}
}
static void sqlite3InsertBuiltinFuncs(FuncDef *aDef , int nDef ) 
{ 
  int i ;
  FuncDef *pOther ;
  char const   *zName ;
  int nName ;
  int tmp ;
  int h ;

  {
  i = 0;
  while (i < nDef) {
    zName = (aDef + i)->zName;
    tmp = sqlite3Strlen30(zName);
    nName = tmp;
    h = (int )(((int const   )*(zName + 0) + (int const   )nName) % 23);
    pOther = sqlite3FunctionSearch(h, zName);
    if (pOther) {
      (aDef + i)->pNext = pOther->pNext;
      pOther->pNext = aDef + i;
    } else {
      (aDef + i)->pNext = (FuncDef *)0;
      (aDef + i)->u.pHash = sqlite3BuiltinFunctions.a[h];
      sqlite3BuiltinFunctions.a[h] = aDef + i;
    }
    i ++;
  }
  return;
}
}
static FuncDef *sqlite3FindFunction(sqlite3 *db , char const   *zName , int nArg ,
                                    u8 enc , u8 createFlag ) 
{ 
  FuncDef *p ;
  FuncDef *pBest ;
  int bestScore ;
  int h ;
  int nName ;
  void *tmp ;
  int score ;
  int tmp___0 ;
  int score___0 ;
  int tmp___1 ;
  FuncDef *pOther ;
  u8 *z ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  pBest = (FuncDef *)0;
  bestScore = 0;
  nName = sqlite3Strlen30(zName);
  tmp = sqlite3HashFind((Hash const   *)(& db->aFunc), zName);
  p = (FuncDef *)tmp;
  while (p) {
    tmp___0 = matchQuality(p, nArg, enc);
    score = tmp___0;
    if (score > bestScore) {
      pBest = p;
      bestScore = score;
    }
    p = p->pNext;
  }
  if (! createFlag) {
    if ((unsigned long )pBest == (unsigned long )((FuncDef *)0)) {
      goto _L;
    } else
    if ((db->mDbFlags & 2U) != 0U) {
      _L: /* CIL Label */ 
      bestScore = 0;
      h = (int )(((int const   )sqlite3UpperToLower[(u8 )*(zName + 0)] + (int const   )nName) % 23);
      p = sqlite3FunctionSearch(h, zName);
      while (p) {
        tmp___1 = matchQuality(p, nArg, enc);
        score___0 = tmp___1;
        if (score___0 > bestScore) {
          pBest = p;
          bestScore = score___0;
        }
        p = p->pNext;
      }
    }
  }
  if (createFlag) {
    if (bestScore < 6) {
      tmp___3 = sqlite3DbMallocZero(db, (u64 )((sizeof(*pBest) + (unsigned long )nName) + 1UL));
      pBest = (FuncDef *)tmp___3;
      if ((unsigned long )pBest != (unsigned long )((FuncDef *)0)) {
        pBest->zName = (char const   *)(pBest + 1);
        pBest->nArg = (i8 )((u16 )nArg);
        pBest->funcFlags = (u32 )enc;
        memcpy((void * __restrict  )((char *)(pBest + 1)), (void const   * __restrict  )zName,
               (size_t )(nName + 1));
        z = (u8 *)pBest->zName;
        while (*z) {
          *z = (u8 )sqlite3UpperToLower[*z];
          z ++;
        }
        tmp___2 = sqlite3HashInsert(& db->aFunc, pBest->zName, (void *)pBest);
        pOther = (FuncDef *)tmp___2;
        if ((unsigned long )pOther == (unsigned long )pBest) {
          sqlite3DbFree(db, (void *)pBest);
          sqlite3OomFault(db);
          return ((FuncDef *)0);
        } else {
          pBest->pNext = pOther;
        }
      }
    }
  }
  if (pBest) {
    if (pBest->xSFunc) {
      return (pBest);
    } else
    if (createFlag) {
      return (pBest);
    }
  }
  return ((FuncDef *)0);
}
}
static void sqlite3SchemaClear(void *p ) 
{ 
  Hash temp1 ;
  Hash temp2 ;
  HashElem *pElem ;
  Schema *pSchema ;
  Table *pTab ;

  {
  pSchema = (Schema *)p;
  temp1 = pSchema->tblHash;
  temp2 = pSchema->trigHash;
  sqlite3HashInit(& pSchema->trigHash);
  sqlite3HashClear(& pSchema->idxHash);
  pElem = temp2.first;
  while (pElem) {
    sqlite3DeleteTrigger((sqlite3 *)0, (Trigger *)pElem->data);
    pElem = pElem->next;
  }
  sqlite3HashClear(& temp2);
  sqlite3HashInit(& pSchema->tblHash);
  pElem = temp1.first;
  while (pElem) {
    pTab = (Table *)pElem->data;
    sqlite3DeleteTable((sqlite3 *)0, pTab);
    pElem = pElem->next;
  }
  sqlite3HashClear(& temp1);
  sqlite3HashClear(& pSchema->fkeyHash);
  pSchema->pSeqTab = (Table *)0;
  if ((int )pSchema->schemaFlags & 1) {
    (pSchema->iGeneration) ++;
  }
  pSchema->schemaFlags = (u16 )((int )pSchema->schemaFlags & -10);
  return;
}
}
static Schema *sqlite3SchemaGet(sqlite3 *db , Btree *pBt ) 
{ 
  Schema *p ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (pBt) {
    tmp = sqlite3BtreeSchema(pBt, (int )sizeof(Schema ), & sqlite3SchemaClear);
    p = (Schema *)tmp;
  } else {
    tmp___0 = sqlite3DbMallocZero((sqlite3 *)0, (u64 )sizeof(Schema ));
    p = (Schema *)tmp___0;
  }
  if (! p) {
    sqlite3OomFault(db);
  } else
  if (0 == (int )p->file_format) {
    sqlite3HashInit(& p->tblHash);
    sqlite3HashInit(& p->idxHash);
    sqlite3HashInit(& p->trigHash);
    sqlite3HashInit(& p->fkeyHash);
    p->enc = (u8 )1;
  }
  return (p);
}
}
static Table *sqlite3SrcListLookup(Parse *pParse , SrcList *pSrc ) 
{ 
  struct SrcList_item *pItem ;
  Table *pTab ;
  int tmp ;

  {
  pItem = pSrc->a;
  pTab = sqlite3LocateTableItem(pParse, (u32 )0, pItem);
  sqlite3DeleteTable(pParse->db, pItem->pTab);
  pItem->pTab = pTab;
  if (pTab) {
    (pTab->nTabRef) ++;
  }
  tmp = sqlite3IndexedByLookup(pParse, pItem);
  if (tmp) {
    pTab = (Table *)0;
  }
  return (pTab);
}
}
static int tabIsReadOnly(Parse *pParse , Table *pTab ) 
{ 
  sqlite3 *db ;
  VTable *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (pTab->nModuleArg) {
    tmp = sqlite3GetVTable(pParse->db, pTab);
    return ((unsigned long )((tmp->pMod)->pModule)->xUpdate == (unsigned long )((int (* const  )(sqlite3_vtab * ,
                                                                                                 int  ,
                                                                                                 sqlite3_value ** ,
                                                                                                 sqlite_int64 * ))0));
  }
  if ((pTab->tabFlags & 1025U) == 0U) {
    return (0);
  }
  db = pParse->db;
  if ((pTab->tabFlags & 1U) != 0U) {
    tmp___0 = sqlite3WritableSchema(db);
    if (tmp___0 == 0) {
      if ((int )pParse->nested == 0) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    return (tmp___1);
  }
  if ((db->flags & 268435456ULL) != 0ULL) {
    if ((unsigned long )db->pVtabCtx == (unsigned long )((VtabCtx *)0)) {
      if (db->nVdbeExec == 0) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
static int sqlite3IsReadOnly(Parse *pParse , Table *pTab , int viewOk ) 
{ 
  int tmp ;

  {
  tmp = tabIsReadOnly(pParse, pTab);
  if (tmp) {
    sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
    return (1);
  }
  if (! viewOk) {
    if (pTab->pSelect) {
      sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", pTab->zName);
      return (1);
    }
  }
  return (0);
}
}
static void sqlite3MaterializeView(Parse *pParse , Table *pView , Expr *pWhere , ExprList *pOrderBy ,
                                   Expr *pLimit , int iCur ) 
{ 
  SelectDest dest ;
  Select *pSel ;
  SrcList *pFrom ;
  sqlite3 *db ;
  int iDb ;
  int tmp ;

  {
  db = pParse->db;
  tmp = sqlite3SchemaToIndex(db, pView->pSchema);
  iDb = tmp;
  pWhere = sqlite3ExprDup(db, pWhere, 0);
  pFrom = sqlite3SrcListAppend(pParse, (SrcList *)0, (Token *)0, (Token *)0);
  if (pFrom) {
    pFrom->a[0].zName = sqlite3DbStrDup(db, (char const   *)pView->zName);
    pFrom->a[0].zDatabase = sqlite3DbStrDup(db, (char const   *)(db->aDb + iDb)->zDbSName);
  }
  pSel = sqlite3SelectNew(pParse, (ExprList *)0, pFrom, pWhere, (ExprList *)0, (Expr *)0,
                          pOrderBy, (u32 )131072, pLimit);
  sqlite3SelectDestInit(& dest, 12, iCur);
  sqlite3Select(pParse, pSel, & dest);
  sqlite3SelectDelete(db, pSel);
  return;
}
}
static void sqlite3DeleteFrom(Parse *pParse , SrcList *pTabList , Expr *pWhere , ExprList *pOrderBy ,
                              Expr *pLimit ) 
{ 
  Vdbe *v ;
  Table *pTab ;
  int i ;
  WhereInfo *pWInfo ;
  Index *pIdx ;
  int iTabCur ;
  int iDataCur ;
  int iIdxCur ;
  int nIdx ;
  sqlite3 *db ;
  AuthContext sContext ;
  NameContext sNC ;
  int iDb ;
  int memCnt ;
  int rcauth ;
  int eOnePass ;
  int aiCurOnePass[2] ;
  u8 *aToOpen ;
  Index *pPk ;
  int iPk ;
  i16 nPk ;
  int iKey ;
  i16 nKey ;
  int iEphCur ;
  int iRowSet ;
  int addrBypass ;
  int addrLoop ;
  int addrEphOpen ;
  int bComplex ;
  int isView ;
  Trigger *pTrigger ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u16 wcf ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  char const   *tmp___11 ;
  int iAddrOnce ;
  char const   *pVTab ;
  VTable *tmp___12 ;
  int count ;

  {
  iDataCur = 0;
  iIdxCur = 0;
  memCnt = 0;
  aToOpen = (u8 *)0;
  iPk = 0;
  nPk = (i16 )1;
  iEphCur = 0;
  iRowSet = 0;
  addrBypass = 0;
  addrLoop = 0;
  addrEphOpen = 0;
  memset((void *)(& sContext), 0, sizeof(sContext));
  db = pParse->db;
  if (pParse->nErr) {
    goto delete_from_cleanup;
  } else
  if (db->mallocFailed) {
    goto delete_from_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    goto delete_from_cleanup;
  }
  pTrigger = sqlite3TriggersExist(pParse, pTab, 124, (ExprList *)0, (int *)0);
  isView = (unsigned long )pTab->pSelect != (unsigned long )((Select *)0);
  if (pTrigger) {
    tmp___0 = 1;
  } else {
    tmp = sqlite3FkRequired(pParse, pTab, (int *)0, 0);
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  bComplex = tmp___0;
  tmp___1 = sqlite3ViewGetColumnNames(pParse, pTab);
  if (tmp___1) {
    goto delete_from_cleanup;
  }
  if (pTrigger) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  tmp___3 = sqlite3IsReadOnly(pParse, pTab, tmp___2);
  if (tmp___3) {
    goto delete_from_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  rcauth = sqlite3AuthCheck(pParse, 9, (char const   *)pTab->zName, (char const   *)0,
                            (char const   *)(db->aDb + iDb)->zDbSName);
  if (rcauth == 1) {
    goto delete_from_cleanup;
  }
  tmp___5 = pParse->nTab;
  (pParse->nTab) ++;
  tmp___4 = tmp___5;
  pTabList->a[0].iCursor = tmp___4;
  iTabCur = tmp___4;
  nIdx = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    (pParse->nTab) ++;
    pIdx = pIdx->pNext;
    nIdx ++;
  }
  if (isView) {
    sqlite3AuthContextPush(pParse, & sContext, (char const   *)pTab->zName);
  }
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    goto delete_from_cleanup;
  }
  if ((int )pParse->nested == 0) {
    sqlite3VdbeCountChanges(v);
  }
  sqlite3BeginWriteOperation(pParse, bComplex, iDb);
  if (isView) {
    sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iTabCur);
    iIdxCur = iTabCur;
    iDataCur = iIdxCur;
    pOrderBy = (ExprList *)0;
    pLimit = (Expr *)0;
  }
  memset((void *)(& sNC), 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  tmp___6 = sqlite3ResolveExprNames(& sNC, pWhere);
  if (tmp___6) {
    goto delete_from_cleanup;
  }
  if ((db->flags & 128ULL) != 0ULL) {
    if (! pParse->nested) {
      if (! pParse->pTriggerTab) {
        (pParse->nMem) ++;
        memCnt = pParse->nMem;
        sqlite3VdbeAddOp2(v, 70, 0, memCnt);
      }
    }
  }
  if (rcauth == 0) {
    if ((unsigned long )pWhere == (unsigned long )((Expr *)0)) {
      if (! bComplex) {
        if (! pTab->nModuleArg) {
          sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )1, (char const   *)pTab->zName);
          if ((pTab->tabFlags & 32U) == 0U) {
            if (memCnt) {
              tmp___7 = memCnt;
            } else {
              tmp___7 = -1;
            }
            sqlite3VdbeAddOp4(v, 137, pTab->tnum, iDb, tmp___7, (char const   *)pTab->zName,
                              -1);
          }
          pIdx = pTab->pIndex;
          while (pIdx) {
            sqlite3VdbeAddOp2(v, 137, pIdx->tnum, iDb);
            pIdx = pIdx->pNext;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    wcf = (u16 )1044;
    if (sNC.ncFlags & 64) {
      bComplex = 1;
    }
    if (bComplex) {
      tmp___8 = 0;
    } else {
      tmp___8 = 8;
    }
    wcf = (u16 )((int )wcf | tmp___8);
    if ((pTab->tabFlags & 32U) == 0U) {
      pPk = (Index *)0;
      nPk = (i16 )1;
      (pParse->nMem) ++;
      iRowSet = pParse->nMem;
      sqlite3VdbeAddOp2(v, 73, 0, iRowSet);
    } else {
      pPk = sqlite3PrimaryKeyIndex(pTab);
      nPk = (i16 )pPk->nKeyCol;
      iPk = pParse->nMem + 1;
      pParse->nMem += (int )nPk;
      tmp___9 = pParse->nTab;
      (pParse->nTab) ++;
      iEphCur = tmp___9;
      addrEphOpen = sqlite3VdbeAddOp2(v, 112, iEphCur, (int )nPk);
      sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, (ExprList *)0, (ExprList *)0,
                               wcf, iTabCur + 1);
    if ((unsigned long )pWInfo == (unsigned long )((WhereInfo *)0)) {
      goto delete_from_cleanup;
    }
    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
    if (eOnePass != 1) {
      sqlite3MultiWrite(pParse);
    }
    if (memCnt) {
      sqlite3VdbeAddOp2(v, 83, memCnt, 1);
    }
    if (pPk) {
      i = 0;
      while (i < (int )nPk) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, (int )*(pPk->aiColumn + i),
                                        iPk + i);
        i ++;
      }
      iKey = iPk;
    } else {
      (pParse->nMem) ++;
      iKey = pParse->nMem;
      sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);
    }
    if (eOnePass != 0) {
      nKey = nPk;
      tmp___10 = sqlite3DbMallocRawNN(db, (u64 )(nIdx + 2));
      aToOpen = (u8 *)tmp___10;
      if ((unsigned long )aToOpen == (unsigned long )((u8 *)0)) {
        sqlite3WhereEnd(pWInfo);
        goto delete_from_cleanup;
      }
      memset((void *)aToOpen, 1, (size_t )(nIdx + 1));
      *(aToOpen + (nIdx + 1)) = (u8 )0;
      if (aiCurOnePass[0] >= 0) {
        *(aToOpen + (aiCurOnePass[0] - iTabCur)) = (u8 )0;
      }
      if (aiCurOnePass[1] >= 0) {
        *(aToOpen + (aiCurOnePass[1] - iTabCur)) = (u8 )0;
      }
      if (addrEphOpen) {
        sqlite3VdbeChangeToNoop(v, addrEphOpen);
      }
    } else
    if (pPk) {
      (pParse->nMem) ++;
      iKey = pParse->nMem;
      nKey = (i16 )0;
      tmp___11 = sqlite3IndexAffinityStr(pParse->db, pPk);
      sqlite3VdbeAddOp4(v, 92, iPk, (int )nPk, iKey, tmp___11, (int )nPk);
      sqlite3VdbeAddOp4Int(v, 132, iEphCur, iKey, iPk, (int )nPk);
    } else {
      nKey = (i16 )1;
      sqlite3VdbeAddOp2(v, 147, iRowSet, iKey);
    }
    if (eOnePass != 0) {
      addrBypass = sqlite3VdbeMakeLabel(pParse);
    } else {
      sqlite3WhereEnd(pWInfo);
    }
    if (! isView) {
      iAddrOnce = 0;
      if (eOnePass == 2) {
        iAddrOnce = sqlite3VdbeAddOp0(v, 17);
      }
      sqlite3OpenTableAndIndices(pParse, pTab, 98, (u8 )8, iTabCur, aToOpen, & iDataCur,
                                 & iIdxCur);
      if (eOnePass == 2) {
        sqlite3VdbeJumpHere(v, iAddrOnce);
      }
    }
    if (eOnePass != 0) {
      if (! pTab->nModuleArg) {
        if (*(aToOpen + (iDataCur - iTabCur))) {
          sqlite3VdbeAddOp4Int(v, 28, iDataCur, addrBypass, iKey, (int )nKey);
        }
      }
    } else
    if (pPk) {
      addrLoop = sqlite3VdbeAddOp1(v, 36, iEphCur);
      if (pTab->nModuleArg) {
        sqlite3VdbeAddOp3(v, 90, iEphCur, 0, iKey);
      } else {
        sqlite3VdbeAddOp2(v, 127, iEphCur, iKey);
      }
    } else {
      addrLoop = sqlite3VdbeAddOp3(v, 41, iRowSet, 0, iKey);
    }
    if (pTab->nModuleArg) {
      tmp___12 = sqlite3GetVTable(db, pTab);
      pVTab = (char const   *)tmp___12;
      sqlite3VtabMakeWritable(pParse, pTab);
      sqlite3MayAbort(pParse);
      if (eOnePass == 1) {
        sqlite3VdbeAddOp1(v, 117, iTabCur);
        if ((unsigned long )pParse->pToplevel == (unsigned long )((Parse *)0)) {
          pParse->isMultiWrite = (u8 )0;
        }
      }
      sqlite3VdbeAddOp4(v, 10, 0, 1, iKey, pVTab, -12);
      sqlite3VdbeChangeP5(v, (u16 )2);
    } else {
      count = (int )pParse->nested == 0;
      sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, iKey, nKey,
                               (u8 )count, (u8 )11, (u8 )eOnePass, aiCurOnePass[1]);
    }
    if (eOnePass != 0) {
      sqlite3VdbeResolveLabel(v, addrBypass);
      sqlite3WhereEnd(pWInfo);
    } else
    if (pPk) {
      sqlite3VdbeAddOp2(v, 5, iEphCur, addrLoop + 1);
      sqlite3VdbeJumpHere(v, addrLoop);
    } else {
      sqlite3VdbeGoto(v, addrLoop);
      sqlite3VdbeJumpHere(v, addrLoop);
    }
  }
  if ((int )pParse->nested == 0) {
    if ((unsigned long )pParse->pTriggerTab == (unsigned long )((Table *)0)) {
      sqlite3AutoincrementEnd(pParse);
    }
  }
  if (memCnt) {
    sqlite3VdbeAddOp2(v, 81, memCnt, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows deleted", (void (*)(void * ))0);
  }
  delete_from_cleanup: 
  sqlite3AuthContextPop(& sContext);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprDelete(db, pWhere);
  sqlite3DbFree(db, (void *)aToOpen);
  return;
}
}
static void sqlite3GenerateRowDelete(Parse *pParse , Table *pTab , Trigger *pTrigger ,
                                     int iDataCur , int iIdxCur , int iPk , i16 nPk ,
                                     u8 count , u8 onconf , u8 eMode , int iIdxNoSeek ) 
{ 
  Vdbe *v ;
  int iOld ;
  int iLabel ;
  u8 opSeek ;
  u32 mask ;
  int iCol ;
  int addrStart ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u8 p5 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  v = pParse->pVdbe;
  iOld = 0;
  iLabel = sqlite3VdbeMakeLabel(pParse);
  if ((pTab->tabFlags & 32U) == 0U) {
    opSeek = (u8 )31;
  } else {
    opSeek = (u8 )28;
  }
  if ((int )eMode == 0) {
    sqlite3VdbeAddOp4Int(v, (int )opSeek, iDataCur, iLabel, iPk, (int )nPk);
  }
  tmp___1 = sqlite3FkRequired(pParse, pTab, (int *)0, 0);
  if (tmp___1) {
    goto _L;
  } else
  if (pTrigger) {
    _L: /* CIL Label */ 
    mask = sqlite3TriggerColmask(pParse, pTrigger, (ExprList *)0, 0, 3, pTab, (int )onconf);
    tmp = sqlite3FkOldmask(pParse, pTab);
    mask |= tmp;
    iOld = pParse->nMem + 1;
    pParse->nMem += 1 + (int )pTab->nCol;
    sqlite3VdbeAddOp2(v, 78, iPk, iOld);
    iCol = 0;
    while (iCol < (int )pTab->nCol) {
      if (mask == 4294967295U) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, (iOld + iCol) + 1);
      } else
      if (iCol <= 31) {
        if ((mask & (1U << iCol)) != 0U) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, (iOld + iCol) + 1);
        }
      }
      iCol ++;
    }
    addrStart = sqlite3VdbeCurrentAddr(v);
    sqlite3CodeRowTrigger(pParse, pTrigger, 124, (ExprList *)0, 1, pTab, iOld, (int )onconf,
                          iLabel);
    tmp___0 = sqlite3VdbeCurrentAddr(v);
    if (addrStart < tmp___0) {
      sqlite3VdbeAddOp4Int(v, (int )opSeek, iDataCur, iLabel, iPk, (int )nPk);
      iIdxNoSeek = -1;
    }
    sqlite3FkCheck(pParse, pTab, iOld, 0, (int *)0, 0);
  }
  if ((unsigned long )pTab->pSelect == (unsigned long )((Select *)0)) {
    p5 = (u8 )0;
    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, (int *)0, iIdxNoSeek);
    if (count) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    sqlite3VdbeAddOp2(v, 123, iDataCur, tmp___2);
    if ((int )pParse->nested == 0) {
      sqlite3VdbeAppendP4(v, (void *)((char *)pTab), -6);
    } else {
      tmp___3 = sqlite3_stricmp((char const   *)pTab->zName, "sqlite_stat1");
      if (0 == tmp___3) {
        sqlite3VdbeAppendP4(v, (void *)((char *)pTab), -6);
      }
    }
    if ((int )eMode != 0) {
      sqlite3VdbeChangeP5(v, (u16 )4);
    }
    if (iIdxNoSeek >= 0) {
      if (iIdxNoSeek != iDataCur) {
        sqlite3VdbeAddOp1(v, 123, iIdxNoSeek);
      }
    }
    if ((int )eMode == 2) {
      p5 = (u8 )((int )p5 | 2);
    }
    sqlite3VdbeChangeP5(v, (u16 )p5);
  }
  sqlite3FkActions(pParse, pTab, (ExprList *)0, iOld, (int *)0, 0);
  sqlite3CodeRowTrigger(pParse, pTrigger, 124, (ExprList *)0, 2, pTab, iOld, (int )onconf,
                        iLabel);
  sqlite3VdbeResolveLabel(v, iLabel);
  return;
}
}
static void sqlite3GenerateRowIndexDelete(Parse *pParse , Table *pTab , int iDataCur ,
                                          int iIdxCur , int *aRegIdx , int iIdxNoSeek ) 
{ 
  int i ;
  int r1 ;
  int iPartIdxLabel ;
  Index *pIdx ;
  Index *pPrior ;
  Vdbe *v ;
  Index *pPk ;
  Index *tmp ;
  int tmp___0 ;

  {
  r1 = -1;
  pPrior = (Index *)0;
  v = pParse->pVdbe;
  if ((pTab->tabFlags & 32U) == 0U) {
    pPk = (Index *)0;
  } else {
    tmp = sqlite3PrimaryKeyIndex(pTab);
    pPk = tmp;
  }
  i = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if ((unsigned long )aRegIdx != (unsigned long )((int *)0)) {
      if (*(aRegIdx + i) == 0) {
        goto __Cont;
      }
    }
    if ((unsigned long )pIdx == (unsigned long )pPk) {
      goto __Cont;
    }
    if (iIdxCur + i == iIdxNoSeek) {
      goto __Cont;
    }
    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1, & iPartIdxLabel, pPrior,
                                 r1);
    if (pIdx->uniqNotNull) {
      tmp___0 = (int )pIdx->nKeyCol;
    } else {
      tmp___0 = (int )pIdx->nColumn;
    }
    sqlite3VdbeAddOp3(v, 133, iIdxCur + i, r1, tmp___0);
    sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
    pPrior = pIdx;
    __Cont: /* CIL Label */ 
    i ++;
    pIdx = pIdx->pNext;
  }
  return;
}
}
static int sqlite3GenerateIndexKey(Parse *pParse , Index *pIdx , int iDataCur , int regOut ,
                                   int prefixOnly , int *piPartIdxLabel , Index *pPrior ,
                                   int regPrior ) 
{ 
  Vdbe *v ;
  int j ;
  int regBase ;
  int nCol ;
  char const   *zAff___0 ;
  char const   *tmp ;

  {
  v = pParse->pVdbe;
  if (piPartIdxLabel) {
    if (pIdx->pPartIdxWhere) {
      *piPartIdxLabel = sqlite3VdbeMakeLabel(pParse);
      pParse->iSelfTab = iDataCur + 1;
      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel, 16);
      pParse->iSelfTab = 0;
    } else {
      *piPartIdxLabel = 0;
    }
  }
  if (prefixOnly) {
    if (pIdx->uniqNotNull) {
      nCol = (int )pIdx->nKeyCol;
    } else {
      nCol = (int )pIdx->nColumn;
    }
  } else {
    nCol = (int )pIdx->nColumn;
  }
  regBase = sqlite3GetTempRange(pParse, nCol);
  if (pPrior) {
    if (regBase != regPrior) {
      pPrior = (Index *)0;
    } else
    if (pPrior->pPartIdxWhere) {
      pPrior = (Index *)0;
    }
  }
  j = 0;
  while (j < nCol) {
    if (pPrior) {
      if ((int )*(pPrior->aiColumn + j) == (int )*(pIdx->aiColumn + j)) {
        if ((int )*(pPrior->aiColumn + j) != -2) {
          goto __Cont;
        }
      }
    }
    sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase + j);
    sqlite3VdbeDeletePriorOpcode(v, (u8 )84);
    __Cont: /* CIL Label */ 
    j ++;
  }
  if (regOut) {
    sqlite3VdbeAddOp3(v, 92, regBase, nCol, regOut);
    if ((pIdx->pTable)->pSelect) {
      tmp = sqlite3IndexAffinityStr(pParse->db, pIdx);
      zAff___0 = tmp;
      sqlite3VdbeChangeP4(v, -1, zAff___0, 0);
    }
  }
  sqlite3ReleaseTempRange(pParse, regBase, nCol);
  return (regBase);
}
}
static void sqlite3ResolvePartIdxLabel(Parse *pParse , int iLabel ) 
{ 


  {
  if (iLabel) {
    sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);
  }
  return;
}
}
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context ) 
{ 
  VdbeOp *pOp ;

  {
  pOp = (context->pVdbe)->aOp + (context->iOp - 1);
  return (pOp->p4.pColl);
}
}
static void sqlite3SkipAccumulatorLoad(sqlite3_context *context ) 
{ 


  {
  context->isError = -1;
  context->skipFlag = (u8 )1;
  return;
}
}
static void minmaxFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int i ;
  int mask ;
  int iBest ;
  CollSeq *pColl ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___0 = sqlite3_user_data(context);
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    mask = 0;
  } else {
    mask = -1;
  }
  pColl = sqlite3GetFuncCollSeq(context);
  iBest = 0;
  tmp___1 = sqlite3_value_type(*(argv + 0));
  if (tmp___1 == 5) {
    return;
  }
  i = 1;
  while (i < argc) {
    tmp___2 = sqlite3_value_type(*(argv + i));
    if (tmp___2 == 5) {
      return;
    }
    tmp___3 = sqlite3MemCompare((Mem const   *)*(argv + iBest), (Mem const   *)*(argv + i),
                                (CollSeq const   *)pColl);
    if ((tmp___3 ^ mask) >= 0) {
      iBest = i;
    }
    i ++;
  }
  sqlite3_result_value(context, *(argv + iBest));
  return;
}
}
static void typeofFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) ;
static char const   *azType___1[5]  = {      "integer",      "real",      "text",      "blob", 
        "null"};
static void typeofFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  int i ;
  int tmp ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  i = tmp - 1;
  sqlite3_result_text(context, azType___1[i], -1, (void (*)(void * ))0);
  return;
}
}
static void lengthFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned char const   *z ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *z0 ;
  unsigned char c ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  switch (tmp) {
  case 2: 
  case 1: 
  case 4: 
  tmp___0 = sqlite3_value_bytes(*(argv + 0));
  sqlite3_result_int(context, tmp___0);
  break;
  case 3: 
  tmp___1 = sqlite3_value_text(*(argv + 0));
  z = tmp___1;
  if ((unsigned long )z == (unsigned long )((unsigned char const   *)0)) {
    return;
  }
  z0 = z;
  while (1) {
    c = (unsigned char )*z;
    if (! ((int )c != 0)) {
      break;
    }
    z ++;
    if ((int )c >= 192) {
      while (((int const   )*z & 192) == 128) {
        z ++;
        z0 ++;
      }
    }
  }
  sqlite3_result_int(context, (int )(z - z0));
  break;
  default: 
  sqlite3_result_null(context);
  break;
  }
  return;
}
}
static void absFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int tmp ;
  i64 iVal ;
  long long tmp___0 ;
  double rVal ;
  double tmp___1 ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  switch (tmp) {
  case 1: 
  tmp___0 = sqlite3_value_int64(*(argv + 0));
  iVal = tmp___0;
  if (iVal < 0LL) {
    if (iVal == -1LL - (4294967295LL | (2147483647LL << 32))) {
      sqlite3_result_error(context, "integer overflow", -1);
      return;
    }
    iVal = - iVal;
  }
  sqlite3_result_int64(context, iVal);
  break;
  case 5: 
  sqlite3_result_null(context);
  break;
  default: 
  tmp___1 = sqlite3_value_double(*(argv + 0));
  rVal = tmp___1;
  if (rVal < (double )0) {
    rVal = - rVal;
  }
  sqlite3_result_double(context, rVal);
  break;
  }
  return;
}
}
static void instrFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *zHaystack ;
  unsigned char const   *zNeedle ;
  int nHaystack ;
  int nNeedle ;
  int typeHaystack ;
  int typeNeedle ;
  int N ;
  int isText ;
  unsigned char firstChar ;
  sqlite3_value *pC1 ;
  sqlite3_value *pC2 ;
  void const   *tmp ;
  void const   *tmp___0 ;
  int tmp___1 ;

  {
  N = 1;
  pC1 = (sqlite3_value *)0;
  pC2 = (sqlite3_value *)0;
  typeHaystack = sqlite3_value_type(*(argv + 0));
  typeNeedle = sqlite3_value_type(*(argv + 1));
  if (typeHaystack == 5) {
    return;
  } else
  if (typeNeedle == 5) {
    return;
  }
  nHaystack = sqlite3_value_bytes(*(argv + 0));
  nNeedle = sqlite3_value_bytes(*(argv + 1));
  if (nNeedle > 0) {
    if (typeHaystack == 4) {
      if (typeNeedle == 4) {
        tmp = sqlite3_value_blob(*(argv + 0));
        zHaystack = (unsigned char const   *)tmp;
        tmp___0 = sqlite3_value_blob(*(argv + 1));
        zNeedle = (unsigned char const   *)tmp___0;
        isText = 0;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (typeHaystack != 4) {
      if (typeNeedle != 4) {
        zHaystack = sqlite3_value_text(*(argv + 0));
        zNeedle = sqlite3_value_text(*(argv + 1));
        isText = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      pC1 = sqlite3_value_dup((sqlite3_value const   *)*(argv + 0));
      zHaystack = sqlite3_value_text(pC1);
      if ((unsigned long )zHaystack == (unsigned long )((unsigned char const   *)0)) {
        goto endInstrOOM;
      }
      nHaystack = sqlite3_value_bytes(pC1);
      pC2 = sqlite3_value_dup((sqlite3_value const   *)*(argv + 1));
      zNeedle = sqlite3_value_text(pC2);
      if ((unsigned long )zNeedle == (unsigned long )((unsigned char const   *)0)) {
        goto endInstrOOM;
      }
      nNeedle = sqlite3_value_bytes(pC2);
      isText = 1;
    }
    if ((unsigned long )zNeedle == (unsigned long )((unsigned char const   *)0)) {
      goto endInstrOOM;
    } else
    if (nHaystack) {
      if ((unsigned long )zHaystack == (unsigned long )((unsigned char const   *)0)) {
        goto endInstrOOM;
      }
    }
    firstChar = (unsigned char )*(zNeedle + 0);
    while (1) {
      if (nNeedle <= nHaystack) {
        if (! ((int const   )*(zHaystack + 0) != (int const   )firstChar)) {
          tmp___1 = memcmp((void const   *)zHaystack, (void const   *)zNeedle, (size_t )nNeedle);
          if (! (tmp___1 != 0)) {
            break;
          }
        }
      } else {
        break;
      }
      N ++;
      while (1) {
        nHaystack --;
        zHaystack ++;
        if (isText) {
          if (! (((int const   )*(zHaystack + 0) & 192) == 128)) {
            break;
          }
        } else {
          break;
        }
      }
    }
    if (nNeedle > nHaystack) {
      N = 0;
    }
  }
  sqlite3_result_int(context, N);
  endInstr: 
  sqlite3_value_free(pC1);
  sqlite3_value_free(pC2);
  return;
  endInstrOOM: 
  sqlite3_result_error_nomem(context);
  goto endInstr;
}
}
static void printfFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  PrintfArguments x___0 ;
  StrAccum str ;
  char const   *zFormat ;
  int n ;
  sqlite3 *db ;
  sqlite3 *tmp ;
  char *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  if (argc >= 1) {
    tmp___1 = sqlite3_value_text(*(argv + 0));
    zFormat = (char const   *)tmp___1;
    if ((unsigned long )zFormat != (unsigned long )((char const   *)0)) {
      x___0.nArg = argc - 1;
      x___0.nUsed = 0;
      x___0.apArg = argv + 1;
      sqlite3StrAccumInit(& str, db, (char *)0, 0, db->aLimit[0]);
      str.printfFlags = (u8 )2;
      sqlite3_str_appendf(& str, zFormat, & x___0);
      n = (int )str.nChar;
      tmp___0 = sqlite3StrAccumFinish(& str);
      sqlite3_result_text(context, (char const   *)tmp___0, n, (void (*)(void * ))(& sqlite3MallocSize));
    }
  }
  return;
}
}
static void substrFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *z ;
  unsigned char const   *z2 ;
  int len ;
  int p0type ;
  i64 p1 ;
  i64 p2 ;
  int negP2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  sqlite3 *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
  negP2 = 0;
  tmp = sqlite3_value_type(*(argv + 1));
  if (tmp == 5) {
    return;
  } else
  if (argc == 3) {
    tmp___0 = sqlite3_value_type(*(argv + 2));
    if (tmp___0 == 5) {
      return;
    }
  }
  p0type = sqlite3_value_type(*(argv + 0));
  tmp___1 = sqlite3_value_int(*(argv + 1));
  p1 = (i64 )tmp___1;
  if (p0type == 4) {
    len = sqlite3_value_bytes(*(argv + 0));
    tmp___2 = sqlite3_value_blob(*(argv + 0));
    z = (unsigned char const   *)tmp___2;
    if ((unsigned long )z == (unsigned long )((unsigned char const   *)0)) {
      return;
    }
  } else {
    z = sqlite3_value_text(*(argv + 0));
    if ((unsigned long )z == (unsigned long )((unsigned char const   *)0)) {
      return;
    }
    len = 0;
    if (p1 < 0LL) {
      z2 = z;
      while (*z2) {
        tmp___3 = z2;
        z2 ++;
        if ((int const   )*tmp___3 >= 192) {
          while (((int const   )*z2 & 192) == 128) {
            z2 ++;
          }
        }
        len ++;
      }
    }
  }
  if (argc == 3) {
    tmp___4 = sqlite3_value_int(*(argv + 2));
    p2 = (i64 )tmp___4;
    if (p2 < 0LL) {
      p2 = - p2;
      negP2 = 1;
    }
  } else {
    tmp___5 = sqlite3_context_db_handle(context);
    p2 = (i64 )tmp___5->aLimit[0];
  }
  if (p1 < 0LL) {
    p1 += (i64 )len;
    if (p1 < 0LL) {
      p2 += p1;
      if (p2 < 0LL) {
        p2 = (i64 )0;
      }
      p1 = (i64 )0;
    }
  } else
  if (p1 > 0LL) {
    p1 --;
  } else
  if (p2 > 0LL) {
    p2 --;
  }
  if (negP2) {
    p1 -= p2;
    if (p1 < 0LL) {
      p2 += p1;
      p1 = (i64 )0;
    }
  }
  if (p0type != 4) {
    while (1) {
      if (*z) {
        if (! p1) {
          break;
        }
      } else {
        break;
      }
      tmp___6 = z;
      z ++;
      if ((int const   )*tmp___6 >= 192) {
        while (((int const   )*z & 192) == 128) {
          z ++;
        }
      }
      p1 --;
    }
    z2 = z;
    while (1) {
      if (*z2) {
        if (! p2) {
          break;
        }
      } else {
        break;
      }
      tmp___7 = z2;
      z2 ++;
      if ((int const   )*tmp___7 >= 192) {
        while (((int const   )*z2 & 192) == 128) {
          z2 ++;
        }
      }
      p2 --;
    }
    sqlite3_result_text64(context, (char const   *)((char *)z), (sqlite_uint64 )(z2 - z),
                          (void (*)(void * ))-1, (unsigned char)1);
  } else {
    if (p1 + p2 > (i64 )len) {
      p2 = (i64 )len - p1;
      if (p2 < 0LL) {
        p2 = (i64 )0;
      }
    }
    sqlite3_result_blob64(context, (void const   *)((char *)(z + p1)), (u64 )p2, (void (*)(void * ))-1);
  }
  return;
}
}
static void roundFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int n ;
  double r ;
  char *zBuf ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;

  {
  n = 0;
  if (argc == 2) {
    tmp = sqlite3_value_type(*(argv + 1));
    if (5 == tmp) {
      return;
    }
    n = sqlite3_value_int(*(argv + 1));
    if (n > 30) {
      n = 30;
    }
    if (n < 0) {
      n = 0;
    }
  }
  tmp___0 = sqlite3_value_type(*(argv + 0));
  if (tmp___0 == 5) {
    return;
  }
  r = sqlite3_value_double(*(argv + 0));
  if (! (r < - 4503599627370496.0)) {
    if (! (r > 4503599627370496.0)) {
      if (n == 0) {
        if (r < (double )0) {
          tmp___1 = - 0.5;
        } else {
          tmp___1 = 0.5;
        }
        r = (double )((sqlite_int64 )(r + tmp___1));
      } else {
        zBuf = sqlite3_mprintf("%.*f", n, r);
        if ((unsigned long )zBuf == (unsigned long )((char *)0)) {
          sqlite3_result_error_nomem(context);
          return;
        }
        tmp___2 = sqlite3Strlen30((char const   *)zBuf);
        sqlite3AtoF((char const   *)zBuf, & r, tmp___2, (u8 )1);
        sqlite3_free((void *)zBuf);
      }
    }
  }
  sqlite3_result_double(context, r);
  return;
}
}
static void *contextMalloc(sqlite3_context *context , i64 nByte ) 
{ 
  char *z ;
  sqlite3 *db ;
  sqlite3 *tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  if (nByte > (i64 )db->aLimit[0]) {
    sqlite3_result_error_toobig(context);
    z = (char *)0;
  } else {
    tmp___0 = sqlite3Malloc((u64 )nByte);
    z = (char *)tmp___0;
    if (! z) {
      sqlite3_result_error_nomem(context);
    }
  }
  return ((void *)z);
}
}
static void upperFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char *z1 ;
  char const   *z2 ;
  int i ;
  int n ;
  unsigned char const   *tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  z2 = (char const   *)((char *)tmp);
  n = sqlite3_value_bytes(*(argv + 0));
  if (z2) {
    tmp___0 = contextMalloc(context, (i64 )n + 1LL);
    z1 = (char *)tmp___0;
    if (z1) {
      i = 0;
      while (i < n) {
        *(z1 + i) = (char )((int const   )*(z2 + i) & ~ ((int const   )sqlite3CtypeMap[(unsigned char )*(z2 + i)] & 32));
        i ++;
      }
      sqlite3_result_text(context, (char const   *)z1, n, & sqlite3_free);
    }
  }
  return;
}
}
static void lowerFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char *z1 ;
  char const   *z2 ;
  int i ;
  int n ;
  unsigned char const   *tmp ;
  void *tmp___0 ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  z2 = (char const   *)((char *)tmp);
  n = sqlite3_value_bytes(*(argv + 0));
  if (z2) {
    tmp___0 = contextMalloc(context, (i64 )n + 1LL);
    z1 = (char *)tmp___0;
    if (z1) {
      i = 0;
      while (i < n) {
        *(z1 + i) = (char )sqlite3UpperToLower[(unsigned char )*(z2 + i)];
        i ++;
      }
      sqlite3_result_text(context, (char const   *)z1, n, & sqlite3_free);
    }
  }
  return;
}
}
static void randomFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  sqlite_int64 r ;

  {
  sqlite3_randomness((int )sizeof(r), (void *)(& r));
  if (r < 0LL) {
    r = - (r & (4294967295LL | (2147483647LL << 32)));
  }
  sqlite3_result_int64(context, r);
  return;
}
}
static void randomBlob(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  sqlite_int64 n ;
  unsigned char *p ;
  void *tmp ;

  {
  n = sqlite3_value_int64(*(argv + 0));
  if (n < 1LL) {
    n = (sqlite_int64 )1;
  }
  tmp = contextMalloc(context, n);
  p = (unsigned char *)tmp;
  if (p) {
    sqlite3_randomness((int )n, (void *)p);
    sqlite3_result_blob(context, (void const   *)((char *)p), (int )n, & sqlite3_free);
  }
  return;
}
}
static void last_insert_rowid(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  sqlite_int64 tmp___0 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_last_insert_rowid(db);
  sqlite3_result_int64(context, tmp___0);
  return;
}
}
static void changes(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_changes(db);
  sqlite3_result_int(context, tmp___0);
  return;
}
}
static void total_changes(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_total_changes(db);
  sqlite3_result_int(context, tmp___0);
  return;
}
}
static struct compareInfo  const  globInfo  =    {(u8 )'*', (u8 )'?', (u8 )'[', (u8 )0};
static struct compareInfo  const  likeInfoNorm  =    {(u8 )'%', (u8 )'_', (u8 )0, (u8 )1};
static struct compareInfo  const  likeInfoAlt  =    {(u8 )'%', (u8 )'_', (u8 )0, (u8 )0};
static int patternCompare(u8 const   *zPattern , u8 const   *zString , struct compareInfo  const  *pInfo ,
                          u32 matchOther ) 
{ 
  u32 c ;
  u32 c2 ;
  u32 matchOne ;
  u32 matchAll ;
  u8 noCase ;
  u8 const   *zEscaped ;
  u32 tmp ;
  u8 const   *tmp___0 ;
  u32 tmp___1 ;
  int bMatch ;
  int tmp___2 ;
  u8 const   *tmp___3 ;
  char zStop[3] ;
  int bMatch___0 ;
  size_t tmp___4 ;
  int bMatch___1 ;
  u8 const   *tmp___5 ;
  u32 tmp___6 ;
  u32 prior_c ;
  int seen ;
  int invert ;
  u8 const   *tmp___7 ;
  u32 tmp___8 ;
  u8 const   *tmp___9 ;
  u32 tmp___10 ;
  int tmp___11 ;

  {
  matchOne = (u32 )pInfo->matchOne;
  matchAll = (u32 )pInfo->matchAll;
  noCase = (u8 )pInfo->noCase;
  zEscaped = (u8 const   *)0;
  while (1) {
    if ((int const   )*(zPattern + 0) < 128) {
      tmp___9 = zPattern;
      zPattern ++;
      c = (u32 )*tmp___9;
    } else {
      tmp___10 = sqlite3Utf8Read(& zPattern);
      c = tmp___10;
    }
    if (! (c != 0U)) {
      break;
    }
    if (c == matchAll) {
      while (1) {
        if ((int const   )*(zPattern + 0) < 128) {
          tmp___0 = zPattern;
          zPattern ++;
          c = (u32 )*tmp___0;
        } else {
          tmp___1 = sqlite3Utf8Read(& zPattern);
          c = tmp___1;
        }
        if (! (c == matchAll)) {
          if (! (c == matchOne)) {
            break;
          }
        }
        if (c == matchOne) {
          tmp = sqlite3Utf8Read(& zString);
          if (tmp == 0U) {
            return (2);
          }
        }
      }
      if (c == 0U) {
        return (0);
      } else
      if (c == matchOther) {
        if ((int const   )pInfo->matchSet == 0) {
          c = sqlite3Utf8Read(& zPattern);
          if (c == 0U) {
            return (2);
          }
        } else {
          while (*zString) {
            tmp___2 = patternCompare(zPattern + -1, zString, pInfo, matchOther);
            bMatch = tmp___2;
            if (bMatch != 1) {
              return (bMatch);
            }
            tmp___3 = zString;
            zString ++;
            if ((int const   )*tmp___3 >= 192) {
              while (((int const   )*zString & 192) == 128) {
                zString ++;
              }
            }
          }
          return (2);
        }
      }
      if (c <= 128U) {
        if (noCase) {
          zStop[0] = (char )(c & (unsigned int )(~ ((int const   )sqlite3CtypeMap[(unsigned char )c] & 32)));
          zStop[1] = (char )sqlite3UpperToLower[(unsigned char )c];
          zStop[2] = (char)0;
        } else {
          zStop[0] = (char )c;
          zStop[1] = (char)0;
        }
        while (1) {
          tmp___4 = strcspn((char const   *)zString, (char const   *)(zStop));
          zString += tmp___4;
          if ((int const   )*(zString + 0) == 0) {
            break;
          }
          zString ++;
          bMatch___0 = patternCompare(zPattern, zString, pInfo, matchOther);
          if (bMatch___0 != 1) {
            return (bMatch___0);
          }
        }
      } else {
        while (1) {
          if ((int const   )*(zString + 0) < 128) {
            tmp___5 = zString;
            zString ++;
            c2 = (u32 )*tmp___5;
          } else {
            tmp___6 = sqlite3Utf8Read(& zString);
            c2 = tmp___6;
          }
          if (! (c2 != 0U)) {
            break;
          }
          if (c2 != c) {
            continue;
          }
          bMatch___1 = patternCompare(zPattern, zString, pInfo, matchOther);
          if (bMatch___1 != 1) {
            return (bMatch___1);
          }
        }
      }
      return (2);
    }
    if (c == matchOther) {
      if ((int const   )pInfo->matchSet == 0) {
        c = sqlite3Utf8Read(& zPattern);
        if (c == 0U) {
          return (1);
        }
        zEscaped = zPattern;
      } else {
        prior_c = (u32 )0;
        seen = 0;
        invert = 0;
        c = sqlite3Utf8Read(& zString);
        if (c == 0U) {
          return (1);
        }
        c2 = sqlite3Utf8Read(& zPattern);
        if (c2 == 94U) {
          invert = 1;
          c2 = sqlite3Utf8Read(& zPattern);
        }
        if (c2 == 93U) {
          if (c == 93U) {
            seen = 1;
          }
          c2 = sqlite3Utf8Read(& zPattern);
        }
        while (1) {
          if (c2) {
            if (! (c2 != 93U)) {
              break;
            }
          } else {
            break;
          }
          if (c2 == 45U) {
            if ((int const   )*(zPattern + 0) != 93) {
              if ((int const   )*(zPattern + 0) != 0) {
                if (prior_c > 0U) {
                  c2 = sqlite3Utf8Read(& zPattern);
                  if (c >= prior_c) {
                    if (c <= c2) {
                      seen = 1;
                    }
                  }
                  prior_c = (u32 )0;
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
            if (c == c2) {
              seen = 1;
            }
            prior_c = c2;
          }
          c2 = sqlite3Utf8Read(& zPattern);
        }
        if (c2 == 0U) {
          return (1);
        } else
        if ((seen ^ invert) == 0) {
          return (1);
        }
        continue;
      }
    }
    if ((int const   )*(zString + 0) < 128) {
      tmp___7 = zString;
      zString ++;
      c2 = (u32 )*tmp___7;
    } else {
      tmp___8 = sqlite3Utf8Read(& zString);
      c2 = tmp___8;
    }
    if (c == c2) {
      continue;
    }
    if (noCase) {
      if ((int const   )sqlite3UpperToLower[(unsigned char )c] == (int const   )sqlite3UpperToLower[(unsigned char )c2]) {
        if (c < 128U) {
          if (c2 < 128U) {
            continue;
          }
        }
      }
    }
    if (c == matchOne) {
      if ((unsigned long )zPattern != (unsigned long )zEscaped) {
        if (c2 != 0U) {
          continue;
        }
      }
    }
    return (1);
  }
  if ((int const   )*zString == 0) {
    tmp___11 = 0;
  } else {
    tmp___11 = 1;
  }
  return (tmp___11);
}
}
int sqlite3_strglob(char const   *zGlobPattern , char const   *zString ) 
{ 
  int tmp ;

  {
  tmp = patternCompare((u8 const   *)((u8 *)zGlobPattern), (u8 const   *)((u8 *)zString),
                       & globInfo, (u32 )'[');
  return (tmp);
}
}
int sqlite3_strlike(char const   *zPattern , char const   *zStr , unsigned int esc ) 
{ 
  int tmp ;

  {
  tmp = patternCompare((u8 const   *)((u8 *)zPattern), (u8 const   *)((u8 *)zStr),
                       & likeInfoNorm, esc);
  return (tmp);
}
}
static void likeFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *zA ;
  unsigned char const   *zB ;
  u32 escape ;
  int nPat ;
  sqlite3 *db ;
  sqlite3 *tmp ;
  struct compareInfo *pInfo ;
  void *tmp___0 ;
  unsigned char const   *zEsc ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_user_data(context);
  pInfo = (struct compareInfo *)tmp___0;
  nPat = sqlite3_value_bytes(*(argv + 0));
  if (nPat > db->aLimit[8]) {
    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
    return;
  }
  if (argc == 3) {
    tmp___1 = sqlite3_value_text(*(argv + 2));
    zEsc = tmp___1;
    if ((unsigned long )zEsc == (unsigned long )((unsigned char const   *)0)) {
      return;
    }
    tmp___2 = sqlite3Utf8CharLen((char const   *)((char *)zEsc), -1);
    if (tmp___2 != 1) {
      sqlite3_result_error(context, "ESCAPE expression must be a single character",
                           -1);
      return;
    }
    escape = sqlite3Utf8Read(& zEsc);
  } else {
    escape = (u32 )pInfo->matchSet;
  }
  zB = sqlite3_value_text(*(argv + 0));
  zA = sqlite3_value_text(*(argv + 1));
  if (zA) {
    if (zB) {
      tmp___3 = patternCompare(zB, zA, (struct compareInfo  const  *)pInfo, escape);
      sqlite3_result_int(context, tmp___3 == 0);
    }
  }
  return;
}
}
static void nullifFunc(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  CollSeq *pColl ;
  CollSeq *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3GetFuncCollSeq(context);
  pColl = tmp;
  tmp___0 = sqlite3MemCompare((Mem const   *)*(argv + 0), (Mem const   *)*(argv + 1),
                              (CollSeq const   *)pColl);
  if (tmp___0 != 0) {
    sqlite3_result_value(context, *(argv + 0));
  }
  return;
}
}
static void versionFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3_libversion();
  sqlite3_result_text(context, tmp, -1, (void (*)(void * ))0);
  return;
}
}
static void sourceidFunc(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3_sourceid();
  sqlite3_result_text(context, tmp, -1, (void (*)(void * ))0);
  return;
}
}
static void errlogFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_value_text(*(argv + 1));
  tmp___0 = sqlite3_value_int(*(argv + 0));
  sqlite3_log(tmp___0, "%s", tmp);
  return;
}
}
static void compileoptionusedFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zOptName ;
  int tmp ;
  unsigned char const   *tmp___0 ;

  {
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zOptName = (char const   *)tmp___0;
  if ((unsigned long )zOptName != (unsigned long )((char const   *)0)) {
    tmp = sqlite3_compileoption_used(zOptName);
    sqlite3_result_int(context, tmp);
  }
  return;
}
}
static void compileoptiongetFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int n ;
  char const   *tmp ;

  {
  n = sqlite3_value_int(*(argv + 0));
  tmp = sqlite3_compileoption_get(n);
  sqlite3_result_text(context, tmp, -1, (void (*)(void * ))0);
  return;
}
}
static char const   hexdigits[16]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F'};
static void quoteFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int tmp ;
  double r1 ;
  double r2 ;
  char zBuf[50] ;
  char *zText___0 ;
  char const   *zBlob ;
  void const   *tmp___0 ;
  int nBlob ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  int i___0 ;
  int j ;
  u64 n ;
  unsigned char const   *zArg ;
  unsigned char const   *tmp___3 ;
  char *z ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  switch (tmp) {
  case 2: 
  r1 = sqlite3_value_double(*(argv + 0));
  sqlite3_snprintf((int )sizeof(zBuf), zBuf, "%!.15g", r1);
  sqlite3AtoF((char const   *)(zBuf), & r2, 20, (u8 )1);
  if (r1 != r2) {
    sqlite3_snprintf((int )sizeof(zBuf), zBuf, "%!.20e", r1);
  }
  sqlite3_result_text(context, (char const   *)(zBuf), -1, (void (*)(void * ))-1);
  break;
  case 1: 
  sqlite3_result_value(context, *(argv + 0));
  break;
  case 4: 
  zText___0 = (char *)0;
  tmp___0 = sqlite3_value_blob(*(argv + 0));
  zBlob = (char const   *)tmp___0;
  tmp___1 = sqlite3_value_bytes(*(argv + 0));
  nBlob = tmp___1;
  tmp___2 = contextMalloc(context, 2LL * (i64 )nBlob + 4LL);
  zText___0 = (char *)tmp___2;
  if (zText___0) {
    i = 0;
    while (i < nBlob) {
      *(zText___0 + (i * 2 + 2)) = (char )hexdigits[((int const   )*(zBlob + i) >> 4) & 15];
      *(zText___0 + (i * 2 + 3)) = (char )hexdigits[(int const   )*(zBlob + i) & 15];
      i ++;
    }
    *(zText___0 + (nBlob * 2 + 2)) = (char )'\'';
    *(zText___0 + (nBlob * 2 + 3)) = (char )'\000';
    *(zText___0 + 0) = (char )'X';
    *(zText___0 + 1) = (char )'\'';
    sqlite3_result_text(context, (char const   *)zText___0, -1, (void (*)(void * ))-1);
    sqlite3_free((void *)zText___0);
  }
  break;
  case 3: 
  tmp___3 = sqlite3_value_text(*(argv + 0));
  zArg = tmp___3;
  if ((unsigned long )zArg == (unsigned long )((unsigned char const   *)0)) {
    return;
  }
  i___0 = 0;
  n = (u64 )0;
  while (*(zArg + i___0)) {
    if ((int const   )*(zArg + i___0) == 39) {
      n ++;
    }
    i___0 ++;
  }
  tmp___4 = contextMalloc(context, ((i64 )i___0 + (i64 )n) + 3LL);
  z = (char *)tmp___4;
  if (z) {
    *(z + 0) = (char )'\'';
    i___0 = 0;
    j = 1;
    while (*(zArg + i___0)) {
      tmp___5 = j;
      j ++;
      *(z + tmp___5) = (char )*(zArg + i___0);
      if ((int const   )*(zArg + i___0) == 39) {
        tmp___6 = j;
        j ++;
        *(z + tmp___6) = (char )'\'';
      }
      i___0 ++;
    }
    tmp___7 = j;
    j ++;
    *(z + tmp___7) = (char )'\'';
    *(z + j) = (char)0;
    sqlite3_result_text(context, (char const   *)z, j, & sqlite3_free);
  }
  break;
  default: 
  sqlite3_result_text(context, "NULL", 4, (void (*)(void * ))0);
  break;
  }
  return;
}
}
static void unicodeFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *z ;
  unsigned char const   *tmp ;
  u32 tmp___0 ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  z = tmp;
  if (z) {
    if (*(z + 0)) {
      tmp___0 = sqlite3Utf8Read(& z);
      sqlite3_result_int(context, (int )tmp___0);
    }
  }
  return;
}
}
static void charFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char *z ;
  unsigned char *zOut ;
  int i ;
  void *tmp ;
  sqlite_int64 x___0 ;
  unsigned int c ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;

  {
  tmp = sqlite3_malloc64((sqlite_uint64 )(argc * 4 + 1));
  z = (unsigned char *)tmp;
  zOut = z;
  if ((unsigned long )z == (unsigned long )((unsigned char *)0)) {
    sqlite3_result_error_nomem(context);
    return;
  }
  i = 0;
  while (i < argc) {
    x___0 = sqlite3_value_int64(*(argv + i));
    if (x___0 < 0LL) {
      x___0 = (sqlite_int64 )65533;
    } else
    if (x___0 > 1114111LL) {
      x___0 = (sqlite_int64 )65533;
    }
    c = (unsigned int )(x___0 & 2097151LL);
    if (c < 128U) {
      tmp___0 = zOut;
      zOut ++;
      *tmp___0 = (u8 )(c & 255U);
    } else
    if (c < 2048U) {
      tmp___1 = zOut;
      zOut ++;
      *tmp___1 = (unsigned char )(192 + (int )((u8 )((c >> 6) & 31U)));
      tmp___2 = zOut;
      zOut ++;
      *tmp___2 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
    } else
    if (c < 65536U) {
      tmp___3 = zOut;
      zOut ++;
      *tmp___3 = (unsigned char )(224 + (int )((u8 )((c >> 12) & 15U)));
      tmp___4 = zOut;
      zOut ++;
      *tmp___4 = (unsigned char )(128 + (int )((u8 )((c >> 6) & 63U)));
      tmp___5 = zOut;
      zOut ++;
      *tmp___5 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
    } else {
      tmp___6 = zOut;
      zOut ++;
      *tmp___6 = (unsigned char )(240 + (int )((u8 )((c >> 18) & 7U)));
      tmp___7 = zOut;
      zOut ++;
      *tmp___7 = (unsigned char )(128 + (int )((u8 )((c >> 12) & 63U)));
      tmp___8 = zOut;
      zOut ++;
      *tmp___8 = (unsigned char )(128 + (int )((u8 )((c >> 6) & 63U)));
      tmp___9 = zOut;
      zOut ++;
      *tmp___9 = (unsigned char )(128 + (int )((u8 )(c & 63U)));
    }
    i ++;
  }
  sqlite3_result_text64(context, (char const   *)((char *)z), (sqlite_uint64 )(zOut - z),
                        & sqlite3_free, (unsigned char)1);
  return;
}
}
static void hexFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int i ;
  int n ;
  unsigned char const   *pBlob ;
  char *zHex ;
  char *z ;
  void const   *tmp ;
  void *tmp___0 ;
  unsigned char c ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = sqlite3_value_blob(*(argv + 0));
  pBlob = (unsigned char const   *)tmp;
  n = sqlite3_value_bytes(*(argv + 0));
  tmp___0 = contextMalloc(context, (i64 )n * 2LL + 1LL);
  zHex = (char *)tmp___0;
  z = zHex;
  if (zHex) {
    i = 0;
    while (i < n) {
      c = (unsigned char )*pBlob;
      tmp___1 = z;
      z ++;
      *tmp___1 = (char )hexdigits[((int )c >> 4) & 15];
      tmp___2 = z;
      z ++;
      *tmp___2 = (char )hexdigits[(int )c & 15];
      i ++;
      pBlob ++;
    }
    *z = (char)0;
    sqlite3_result_text(context, (char const   *)zHex, n * 2, & sqlite3_free);
  }
  return;
}
}
static void zeroblobFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  i64 n ;
  int rc ;

  {
  n = sqlite3_value_int64(*(argv + 0));
  if (n < 0LL) {
    n = (i64 )0;
  }
  rc = sqlite3_result_zeroblob64(context, (unsigned long long )n);
  if (rc) {
    sqlite3_result_error_code(context, rc);
  }
  return;
}
}
static void replaceFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *zStr ;
  unsigned char const   *zPattern ;
  unsigned char const   *zRep ;
  unsigned char *zOut ;
  int nStr ;
  int nPattern ;
  int nRep ;
  i64 nOut ;
  int loopLimit ;
  int i ;
  int j ;
  unsigned int cntExpand ;
  sqlite3 *db ;
  sqlite3 *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u8 *zOld ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  zStr = sqlite3_value_text(*(argv + 0));
  if ((unsigned long )zStr == (unsigned long )((unsigned char const   *)0)) {
    return;
  }
  nStr = sqlite3_value_bytes(*(argv + 0));
  zPattern = sqlite3_value_text(*(argv + 1));
  if ((unsigned long )zPattern == (unsigned long )((unsigned char const   *)0)) {
    return;
  }
  if ((int const   )*(zPattern + 0) == 0) {
    sqlite3_result_value(context, *(argv + 0));
    return;
  }
  nPattern = sqlite3_value_bytes(*(argv + 1));
  zRep = sqlite3_value_text(*(argv + 2));
  if ((unsigned long )zRep == (unsigned long )((unsigned char const   *)0)) {
    return;
  }
  nRep = sqlite3_value_bytes(*(argv + 2));
  nOut = (i64 )(nStr + 1);
  tmp___0 = contextMalloc(context, nOut);
  zOut = (unsigned char *)tmp___0;
  if ((unsigned long )zOut == (unsigned long )((unsigned char *)0)) {
    return;
  }
  loopLimit = nStr - nPattern;
  cntExpand = 0U;
  j = 0;
  i = j;
  while (i <= loopLimit) {
    if ((int const   )*(zStr + i) != (int const   )*(zPattern + 0)) {
      tmp___1 = j;
      j ++;
      *(zOut + tmp___1) = (unsigned char )*(zStr + i);
    } else {
      tmp___3 = memcmp((void const   *)(zStr + i), (void const   *)zPattern, (size_t )nPattern);
      if (tmp___3) {
        tmp___1 = j;
        j ++;
        *(zOut + tmp___1) = (unsigned char )*(zStr + i);
      } else {
        if (nRep > nPattern) {
          nOut += (i64 )(nRep - nPattern);
          if (nOut - 1LL > (i64 )db->aLimit[0]) {
            sqlite3_result_error_toobig(context);
            sqlite3_free((void *)zOut);
            return;
          }
          cntExpand ++;
          if ((cntExpand & (cntExpand - 1U)) == 0U) {
            zOld = zOut;
            tmp___2 = sqlite3_realloc64((void *)zOut, (sqlite_uint64 )((i64 )((int )nOut) + ((nOut - (i64 )nStr) - 1LL)));
            zOut = (unsigned char *)tmp___2;
            if ((unsigned long )zOut == (unsigned long )((unsigned char *)0)) {
              sqlite3_result_error_nomem(context);
              sqlite3_free((void *)zOld);
              return;
            }
          }
        }
        memcpy((void * __restrict  )(zOut + j), (void const   * __restrict  )zRep,
               (size_t )nRep);
        j += nRep;
        i += nPattern - 1;
      }
    }
    i ++;
  }
  memcpy((void * __restrict  )(zOut + j), (void const   * __restrict  )(zStr + i),
         (size_t )(nStr - i));
  j += nStr - i;
  *(zOut + j) = (unsigned char)0;
  sqlite3_result_text(context, (char const   *)((char *)zOut), j, & sqlite3_free);
  return;
}
}
static void trimFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) ;
static unsigned char const   lenOne[1]  = {      (unsigned char const   )1};
static unsigned char * const  azOne[1]  = {      (unsigned char * const  )((u8 *)" ")};
static void trimFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *zIn ;
  unsigned char const   *zCharSet ;
  int nIn ;
  int flags___0 ;
  int i ;
  unsigned char *aLen___0 ;
  unsigned char **azChar ;
  int nChar ;
  int tmp ;
  unsigned char const   *z ;
  unsigned char const   *tmp___0 ;
  void *tmp___1 ;
  unsigned char const   *tmp___2 ;
  void *tmp___3 ;
  int len ;
  int tmp___4 ;
  int len___0 ;
  int tmp___5 ;

  {
  aLen___0 = (unsigned char *)0;
  azChar = (unsigned char **)0;
  tmp = sqlite3_value_type(*(argv + 0));
  if (tmp == 5) {
    return;
  }
  zIn = sqlite3_value_text(*(argv + 0));
  if ((unsigned long )zIn == (unsigned long )((unsigned char const   *)0)) {
    return;
  }
  nIn = sqlite3_value_bytes(*(argv + 0));
  if (argc == 1) {
    nChar = 1;
    aLen___0 = (u8 *)(lenOne);
    azChar = (unsigned char **)(azOne);
    zCharSet = (unsigned char const   *)0;
  } else {
    zCharSet = sqlite3_value_text(*(argv + 1));
    if ((unsigned long )zCharSet == (unsigned long )((unsigned char const   *)0)) {
      return;
    } else {
      z = zCharSet;
      nChar = 0;
      while (*z) {
        tmp___0 = z;
        z ++;
        if ((int const   )*tmp___0 >= 192) {
          while (((int const   )*z & 192) == 128) {
            z ++;
          }
        }
        nChar ++;
      }
      if (nChar > 0) {
        tmp___1 = contextMalloc(context, (i64 )((unsigned long long )((i64 )nChar) * (unsigned long long )(sizeof(char *) + 1UL)));
        azChar = (unsigned char **)tmp___1;
        if ((unsigned long )azChar == (unsigned long )((unsigned char **)0)) {
          return;
        }
        aLen___0 = (unsigned char *)(azChar + nChar);
        z = zCharSet;
        nChar = 0;
        while (*z) {
          *(azChar + nChar) = (unsigned char *)z;
          tmp___2 = z;
          z ++;
          if ((int const   )*tmp___2 >= 192) {
            while (((int const   )*z & 192) == 128) {
              z ++;
            }
          }
          *(aLen___0 + nChar) = (u8 )(z - (unsigned char const   *)*(azChar + nChar));
          nChar ++;
        }
      }
    }
  }
  if (nChar > 0) {
    tmp___3 = sqlite3_user_data(context);
    flags___0 = (int )((long )tmp___3);
    if (flags___0 & 1) {
      while (nIn > 0) {
        len = 0;
        i = 0;
        while (i < nChar) {
          len = (int )*(aLen___0 + i);
          if (len <= nIn) {
            tmp___4 = memcmp((void const   *)zIn, (void const   *)*(azChar + i), (size_t )len);
            if (tmp___4 == 0) {
              break;
            }
          }
          i ++;
        }
        if (i >= nChar) {
          break;
        }
        zIn += len;
        nIn -= len;
      }
    }
    if (flags___0 & 2) {
      while (nIn > 0) {
        len___0 = 0;
        i = 0;
        while (i < nChar) {
          len___0 = (int )*(aLen___0 + i);
          if (len___0 <= nIn) {
            tmp___5 = memcmp((void const   *)(zIn + (nIn - len___0)), (void const   *)*(azChar + i),
                             (size_t )len___0);
            if (tmp___5 == 0) {
              break;
            }
          }
          i ++;
        }
        if (i >= nChar) {
          break;
        }
        nIn -= len___0;
      }
    }
    if (zCharSet) {
      sqlite3_free((void *)azChar);
    }
  }
  sqlite3_result_text(context, (char const   *)((char *)zIn), nIn, (void (*)(void * ))-1);
  return;
}
}
static void sumStep(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  SumCtx *p ;
  int type ;
  void *tmp ;
  i64 v ;
  long long tmp___0 ;
  u8 tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;

  {
  tmp = sqlite3_aggregate_context(context, (int )sizeof(*p));
  p = (SumCtx *)tmp;
  type = sqlite3_value_numeric_type(*(argv + 0));
  if (p) {
    if (type != 5) {
      (p->cnt) ++;
      if (type == 1) {
        tmp___0 = sqlite3_value_int64(*(argv + 0));
        v = tmp___0;
        p->rSum += (double )v;
        if (((int )p->approx | (int )p->overflow) == 0) {
          tmp___2 = sqlite3AddInt64(& p->iSum, v);
          if (tmp___2) {
            tmp___1 = (u8 )1;
            p->overflow = tmp___1;
            p->approx = tmp___1;
          }
        }
      } else {
        tmp___3 = sqlite3_value_double(*(argv + 0));
        p->rSum += tmp___3;
        p->approx = (u8 )1;
      }
    }
  }
  return;
}
}
static void sumInverse(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  SumCtx *p ;
  int type ;
  void *tmp ;
  i64 v ;
  long long tmp___0 ;
  double tmp___1 ;

  {
  tmp = sqlite3_aggregate_context(context, (int )sizeof(*p));
  p = (SumCtx *)tmp;
  type = sqlite3_value_numeric_type(*(argv + 0));
  if (p) {
    if (type != 5) {
      (p->cnt) --;
      if (type == 1) {
        if ((int )p->approx == 0) {
          tmp___0 = sqlite3_value_int64(*(argv + 0));
          v = tmp___0;
          p->rSum -= (double )v;
          p->iSum -= v;
        } else {
          tmp___1 = sqlite3_value_double(*(argv + 0));
          p->rSum -= tmp___1;
        }
      } else {
        tmp___1 = sqlite3_value_double(*(argv + 0));
        p->rSum -= tmp___1;
      }
    }
  }
  return;
}
}
static void sumFinalize(sqlite3_context *context ) 
{ 
  SumCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  p = (SumCtx *)tmp;
  if (p) {
    if (p->cnt > 0LL) {
      if (p->overflow) {
        sqlite3_result_error(context, "integer overflow", -1);
      } else
      if (p->approx) {
        sqlite3_result_double(context, p->rSum);
      } else {
        sqlite3_result_int64(context, p->iSum);
      }
    }
  }
  return;
}
}
static void avgFinalize(sqlite3_context *context ) 
{ 
  SumCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  p = (SumCtx *)tmp;
  if (p) {
    if (p->cnt > 0LL) {
      sqlite3_result_double(context, p->rSum / (double )p->cnt);
    }
  }
  return;
}
}
static void totalFinalize(sqlite3_context *context ) 
{ 
  SumCtx *p ;
  void *tmp ;
  double tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  p = (SumCtx *)tmp;
  if (p) {
    tmp___0 = p->rSum;
  } else {
    tmp___0 = (double )0;
  }
  sqlite3_result_double(context, tmp___0);
  return;
}
}
static void countStep(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  CountCtx *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(context, (int )sizeof(*p));
  p = (CountCtx *)tmp;
  if (argc == 0) {
    goto _L;
  } else {
    tmp___0 = sqlite3_value_type(*(argv + 0));
    if (5 != tmp___0) {
      _L: /* CIL Label */ 
      if (p) {
        (p->n) ++;
      }
    }
  }
  return;
}
}
static void countFinalize(sqlite3_context *context ) 
{ 
  CountCtx *p ;
  void *tmp ;
  i64 tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  p = (CountCtx *)tmp;
  if (p) {
    tmp___0 = p->n;
  } else {
    tmp___0 = (i64 )0;
  }
  sqlite3_result_int64(context, tmp___0);
  return;
}
}
static void countInverse(sqlite3_context *ctx , int argc , sqlite3_value **argv ) 
{ 
  CountCtx *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(ctx, (int )sizeof(*p));
  p = (CountCtx *)tmp;
  if (argc == 0) {
    goto _L;
  } else {
    tmp___0 = sqlite3_value_type(*(argv + 0));
    if (5 != tmp___0) {
      _L: /* CIL Label */ 
      if (p) {
        (p->n) --;
      }
    }
  }
  return;
}
}
static void minmaxStep(sqlite3_context *context , int NotUsed , sqlite3_value **argv ) 
{ 
  Mem *pArg ;
  Mem *pBest ;
  void *tmp ;
  int max ;
  int cmp ;
  CollSeq *pColl ;
  CollSeq *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  pArg = *(argv + 0);
  tmp = sqlite3_aggregate_context(context, (int )sizeof(*pBest));
  pBest = (Mem *)tmp;
  if (! pBest) {
    return;
  }
  tmp___2 = sqlite3_value_type(pArg);
  if (tmp___2 == 5) {
    if (pBest->flags) {
      sqlite3SkipAccumulatorLoad(context);
    }
  } else
  if (pBest->flags) {
    tmp___0 = sqlite3GetFuncCollSeq(context);
    pColl = tmp___0;
    tmp___1 = sqlite3_user_data(context);
    max = (unsigned long )tmp___1 != (unsigned long )((void *)0);
    cmp = sqlite3MemCompare((Mem const   *)pBest, (Mem const   *)pArg, (CollSeq const   *)pColl);
    if (max) {
      if (cmp < 0) {
        sqlite3VdbeMemCopy(pBest, (Mem const   *)pArg);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (! max) {
      if (cmp > 0) {
        sqlite3VdbeMemCopy(pBest, (Mem const   *)pArg);
      } else {
        sqlite3SkipAccumulatorLoad(context);
      }
    } else {
      sqlite3SkipAccumulatorLoad(context);
    }
  } else {
    pBest->db = sqlite3_context_db_handle(context);
    sqlite3VdbeMemCopy(pBest, (Mem const   *)pArg);
  }
  return;
}
}
static void minMaxValueFinalize(sqlite3_context *context , int bValue ) 
{ 
  sqlite3_value *pRes ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  pRes = (sqlite3_value *)tmp;
  if (pRes) {
    if (pRes->flags) {
      sqlite3_result_value(context, pRes);
    }
    if (bValue == 0) {
      sqlite3VdbeMemRelease(pRes);
    }
  }
  return;
}
}
static void minMaxValue(sqlite3_context *context ) 
{ 


  {
  minMaxValueFinalize(context, 1);
  return;
}
}
static void minMaxFinalize(sqlite3_context *context ) 
{ 


  {
  minMaxValueFinalize(context, 0);
  return;
}
}
static void groupConcatStep(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zVal ;
  StrAccum *pAccum ;
  char const   *zSep ;
  int nVal ;
  int nSep ;
  int tmp ;
  void *tmp___0 ;
  sqlite3 *db ;
  sqlite3 *tmp___1 ;
  int firstTerm ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  if (tmp == 5) {
    return;
  }
  tmp___0 = sqlite3_aggregate_context(context, (int )sizeof(*pAccum));
  pAccum = (StrAccum *)tmp___0;
  if (pAccum) {
    tmp___1 = sqlite3_context_db_handle(context);
    db = tmp___1;
    firstTerm = pAccum->mxAlloc == 0U;
    pAccum->mxAlloc = (u32 )db->aLimit[0];
    if (! firstTerm) {
      if (argc == 2) {
        tmp___2 = sqlite3_value_text(*(argv + 1));
        zSep = (char const   *)((char *)tmp___2);
        nSep = sqlite3_value_bytes(*(argv + 1));
      } else {
        zSep = ",";
        nSep = 1;
      }
      if (zSep) {
        sqlite3_str_append(pAccum, zSep, nSep);
      }
    }
    tmp___3 = sqlite3_value_text(*(argv + 0));
    zVal = (char const   *)((char *)tmp___3);
    nVal = sqlite3_value_bytes(*(argv + 0));
    if (zVal) {
      sqlite3_str_append(pAccum, zVal, nVal);
    }
  }
  return;
}
}
static void groupConcatInverse(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int n ;
  StrAccum *pAccum ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  if (tmp == 5) {
    return;
  }
  tmp___0 = sqlite3_aggregate_context(context, (int )sizeof(*pAccum));
  pAccum = (StrAccum *)tmp___0;
  if (pAccum) {
    n = sqlite3_value_bytes(*(argv + 0));
    if (argc == 2) {
      tmp___1 = sqlite3_value_bytes(*(argv + 1));
      n += tmp___1;
    } else {
      n ++;
    }
    if (n >= (int )pAccum->nChar) {
      pAccum->nChar = (u32 )0;
    } else {
      pAccum->nChar -= (u32 )n;
      memmove((void *)pAccum->zText, (void const   *)(pAccum->zText + n), (size_t )pAccum->nChar);
    }
    if (pAccum->nChar == 0U) {
      pAccum->mxAlloc = (u32 )0;
    }
  }
  return;
}
}
static void groupConcatFinalize(sqlite3_context *context ) 
{ 
  StrAccum *pAccum ;
  void *tmp ;
  char *tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  pAccum = (StrAccum *)tmp;
  if (pAccum) {
    if ((int )pAccum->accError == 18) {
      sqlite3_result_error_toobig(context);
    } else
    if ((int )pAccum->accError == 7) {
      sqlite3_result_error_nomem(context);
    } else {
      tmp___0 = sqlite3StrAccumFinish(pAccum);
      sqlite3_result_text(context, (char const   *)tmp___0, -1, & sqlite3_free);
    }
  }
  return;
}
}
static void groupConcatValue(sqlite3_context *context ) 
{ 
  sqlite3_str *pAccum ;
  void *tmp ;
  char const   *zText___0 ;
  char *tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(context, 0);
  pAccum = (sqlite3_str *)tmp;
  if (pAccum) {
    if ((int )pAccum->accError == 18) {
      sqlite3_result_error_toobig(context);
    } else
    if ((int )pAccum->accError == 7) {
      sqlite3_result_error_nomem(context);
    } else {
      tmp___0 = sqlite3_str_value(pAccum);
      zText___0 = (char const   *)tmp___0;
      sqlite3_result_text(context, zText___0, -1, (void (*)(void * ))-1);
    }
  }
  return;
}
}
static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_overload_function(db, "MATCH", 2);
  rc = tmp;
  if (rc == 7) {
    sqlite3OomFault(db);
  }
  return;
}
}
static void sqlite3RegisterLikeFunctions(sqlite3 *db , int caseSensitive ) 
{ 
  struct compareInfo *pInfo ;
  int flags___0 ;
  FuncDef *tmp ;
  FuncDef *tmp___0 ;

  {
  if (caseSensitive) {
    pInfo = (struct compareInfo *)(& likeInfoAlt);
    flags___0 = 12;
  } else {
    pInfo = (struct compareInfo *)(& likeInfoNorm);
    flags___0 = 4;
  }
  sqlite3CreateFunc(db, "like", 2, 1, (void *)pInfo, & likeFunc, (void (*)(sqlite3_context * ,
                                                                           int  ,
                                                                           sqlite3_value ** ))0,
                    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0,
                    (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0, (FuncDestructor *)0);
  sqlite3CreateFunc(db, "like", 3, 1, (void *)pInfo, & likeFunc, (void (*)(sqlite3_context * ,
                                                                           int  ,
                                                                           sqlite3_value ** ))0,
                    (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0,
                    (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0, (FuncDestructor *)0);
  tmp = sqlite3FindFunction(db, "like", 2, (u8 )1, (u8 )0);
  tmp->funcFlags |= (unsigned int )flags___0;
  tmp___0 = sqlite3FindFunction(db, "like", 3, (u8 )1, (u8 )0);
  tmp___0->funcFlags |= (unsigned int )flags___0;
  return;
}
}
static int sqlite3IsLikeFunction(sqlite3 *db , Expr *pExpr , int *pIsNocase , char *aWc ) 
{ 
  FuncDef *pDef ;
  int nExpr ;
  Expr *pEscape ;
  char *zEscape ;

  {
  if ((int )pExpr->op != 167) {
    return (0);
  } else
  if (! pExpr->x.pList) {
    return (0);
  }
  nExpr = (pExpr->x.pList)->nExpr;
  pDef = sqlite3FindFunction(db, (char const   *)pExpr->u.zToken, nExpr, (u8 )1, (u8 )0);
  if ((unsigned long )pDef == (unsigned long )((FuncDef *)0)) {
    return (0);
  } else
  if ((pDef->funcFlags & 4U) == 0U) {
    return (0);
  }
  if (nExpr < 3) {
    *(aWc + 3) = (char)0;
  } else {
    pEscape = (pExpr->x.pList)->a[2].pExpr;
    if ((int )pEscape->op != 113) {
      return (0);
    }
    zEscape = pEscape->u.zToken;
    if ((int )*(zEscape + 0) == 0) {
      return (0);
    } else
    if ((int )*(zEscape + 1) != 0) {
      return (0);
    }
    *(aWc + 3) = *(zEscape + 0);
  }
  memcpy((void * __restrict  )aWc, (void const   * __restrict  )pDef->pUserData, (size_t )3);
  *pIsNocase = (pDef->funcFlags & 8U) == 0U;
  return (1);
}
}
static FuncDef aBuiltinFunc[57]  = 
  {      {(i8 )1, (u32 )8193, (void *)0, (FuncDef *)0, & compileoptionusedFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_compileoption_used", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )8193, (void *)0, (FuncDef *)0, & compileoptiongetFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_compileoption_get", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )3073, (void *)0L, (FuncDef *)0, & versionFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "unlikely", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )3073, (void *)0L, (FuncDef *)0, & versionFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "likelihood", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )3073, (void *)0L, (FuncDef *)0, & versionFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "likely", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)1L, (FuncDef *)0, & trimFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "ltrim", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)1L, (FuncDef *)0, & trimFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "ltrim", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)2L, (FuncDef *)0, & trimFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "rtrim", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)2L, (FuncDef *)0, & trimFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "rtrim", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)3L, (FuncDef *)0, & trimFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "trim", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)3L, (FuncDef *)0, & trimFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "trim", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )2081, (void *)0L, (FuncDef *)0, & minmaxFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "min", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )2081, (void *)0L, (FuncDef *)0, (void (*)(sqlite3_context * ,
                                                              int  , sqlite3_value ** ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "min", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )4129, (void *)0L, (FuncDef *)0, & minmaxStep, & minMaxFinalize,
      & minMaxValue, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0, "min",
      {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )2081, (void *)1L, (FuncDef *)0, & minmaxFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "max", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )2081, (void *)1L, (FuncDef *)0, (void (*)(sqlite3_context * ,
                                                              int  , sqlite3_value ** ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "max", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )4129, (void *)1L, (FuncDef *)0, & minmaxStep, & minMaxFinalize,
      & minMaxValue, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0, "max",
      {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2177, (void *)0L, (FuncDef *)0, & typeofFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "typeof", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2113, (void *)0L, (FuncDef *)0, & lengthFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "length", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)0L, (FuncDef *)0, & instrFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "instr", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )2049, (void *)0L, (FuncDef *)0, & printfFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "printf", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & unicodeFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "unicode", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )2049, (void *)0L, (FuncDef *)0, & charFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "char", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & absFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "abs", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & roundFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "round", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)0L, (FuncDef *)0, & roundFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "round", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & upperFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "upper", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & lowerFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "lower", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & hexFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "hex", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2561, (void *)0L, (FuncDef *)0, & versionFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "ifnull", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )1, (void *)0L, (FuncDef *)0, & randomFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "random", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )1, (void *)0L, (FuncDef *)0, & randomBlob, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "randomblob", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2081, (void *)0L, (FuncDef *)0, & nullifFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "nullif", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )8193, (void *)0, (FuncDef *)0, & versionFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_version", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )8193, (void *)0, (FuncDef *)0, & sourceidFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_source_id", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)0L, (FuncDef *)0, & errlogFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "sqlite_log", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & quoteFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "quote", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )1, (void *)0L, (FuncDef *)0, & last_insert_rowid, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "last_insert_rowid", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )1, (void *)0L, (FuncDef *)0, & changes, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "changes", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )1, (void *)0L, (FuncDef *)0, & total_changes, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "total_changes", {(FuncDef *)0}}, 
        {(i8 )3, (u32 )2049, (void *)0L, (FuncDef *)0, & replaceFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "replace", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, & zeroblobFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "zeroblob", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2049, (void *)0L, (FuncDef *)0, & substrFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "substr", {(FuncDef *)0}}, 
        {(i8 )3, (u32 )2049, (void *)0L, (FuncDef *)0, & substrFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "substr", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )1, (void *)0L, (FuncDef *)0, & sumStep, & sumFinalize, & sumFinalize,
      & sumInverse, "sum", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )1, (void *)0L, (FuncDef *)0, & sumStep, & totalFinalize, & totalFinalize,
      & sumInverse, "total", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )1, (void *)0L, (FuncDef *)0, & sumStep, & avgFinalize, & avgFinalize,
      & sumInverse, "avg", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )257, (void *)0L, (FuncDef *)0, & countStep, & countFinalize, & countFinalize,
      & countInverse, "count", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )1, (void *)0L, (FuncDef *)0, & countStep, & countFinalize, & countFinalize,
      & countInverse, "count", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )1, (void *)0L, (FuncDef *)0, & groupConcatStep, & groupConcatFinalize,
      & groupConcatValue, & groupConcatInverse, "group_concat", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )1, (void *)0L, (FuncDef *)0, & groupConcatStep, & groupConcatFinalize,
      & groupConcatValue, & groupConcatInverse, "group_concat", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2061, (void *)(& globInfo), (FuncDef *)0, & likeFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "glob", {(FuncDef *)0}}, 
        {(i8 )2, (u32 )2053, (void *)(& likeInfoNorm), (FuncDef *)0, & likeFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "like", {(FuncDef *)0}}, 
        {(i8 )3, (u32 )2053, (void *)(& likeInfoNorm), (FuncDef *)0, & likeFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "like", {(FuncDef *)0}}, 
        {(i8 )1, (u32 )2049, (void *)0L, (FuncDef *)0, (void (*)(sqlite3_context * ,
                                                              int  , sqlite3_value ** ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "coalesce", {(FuncDef *)0}}, 
        {(i8 )0, (u32 )2049, (void *)0L, (FuncDef *)0, (void (*)(sqlite3_context * ,
                                                              int  , sqlite3_value ** ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
      "coalesce", {(FuncDef *)0}}, 
        {(i8 )-1, (u32 )2561, (void *)0L, (FuncDef *)0, & versionFunc, (void (*)(sqlite3_context * ))0,
      (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
      "coalesce", {(FuncDef *)0}}};
static void sqlite3RegisterBuiltinFunctions(void) 
{ 


  {
  sqlite3AlterFunctions();
  sqlite3WindowFunctions();
  sqlite3RegisterDateTimeFunctions();
  sqlite3InsertBuiltinFuncs(aBuiltinFunc, (int )(sizeof(aBuiltinFunc) / sizeof(aBuiltinFunc[0])));
  return;
}
}
static int sqlite3FkLocateIndex(Parse *pParse , Table *pParent , FKey *pFKey , Index **ppIdx ,
                                int **paiCol ) 
{ 
  Index *pIdx ;
  int *aiCol ;
  int nCol ;
  char *zKey ;
  int tmp ;
  void *tmp___0 ;
  int i ;
  int i___0 ;
  int j ;
  i16 iCol ;
  char const   *zDfltColl ;
  char *zIdxCol ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pIdx = (Index *)0;
  aiCol = (int *)0;
  nCol = pFKey->nCol;
  zKey = pFKey->aCol[0].zCol;
  if (nCol == 1) {
    if ((int )pParent->iPKey >= 0) {
      if (! zKey) {
        return (0);
      }
      tmp = sqlite3StrICmp((char const   *)(pParent->aCol + pParent->iPKey)->zName,
                           (char const   *)zKey);
      if (! tmp) {
        return (0);
      }
    }
  } else
  if (paiCol) {
    tmp___0 = sqlite3DbMallocRawNN(pParse->db, (u64 )((unsigned long )nCol * sizeof(int )));
    aiCol = (int *)tmp___0;
    if (! aiCol) {
      return (1);
    }
    *paiCol = aiCol;
  }
  pIdx = pParent->pIndex;
  while (pIdx) {
    if ((int )pIdx->nKeyCol == nCol) {
      if ((int )pIdx->onError != 0) {
        if ((unsigned long )pIdx->pPartIdxWhere == (unsigned long )((Expr *)0)) {
          if ((unsigned long )zKey == (unsigned long )((char *)0)) {
            if (pIdx->idxType == 2U) {
              if (aiCol) {
                i = 0;
                while (i < nCol) {
                  *(aiCol + i) = pFKey->aCol[i].iFrom;
                  i ++;
                }
              }
              break;
            }
          } else {
            i___0 = 0;
            while (i___0 < nCol) {
              iCol = *(pIdx->aiColumn + i___0);
              if ((int )iCol < 0) {
                break;
              }
              zDfltColl = (char const   *)(pParent->aCol + iCol)->zColl;
              if (! zDfltColl) {
                zDfltColl = sqlite3StrBINARY;
              }
              tmp___1 = sqlite3StrICmp(*(pIdx->azColl + i___0), zDfltColl);
              if (tmp___1) {
                break;
              }
              zIdxCol = (pParent->aCol + iCol)->zName;
              j = 0;
              while (j < nCol) {
                tmp___2 = sqlite3StrICmp((char const   *)pFKey->aCol[j].zCol, (char const   *)zIdxCol);
                if (tmp___2 == 0) {
                  if (aiCol) {
                    *(aiCol + i___0) = pFKey->aCol[j].iFrom;
                  }
                  break;
                }
                j ++;
              }
              if (j == nCol) {
                break;
              }
              i___0 ++;
            }
            if (i___0 == nCol) {
              break;
            }
          }
        }
      }
    }
    pIdx = pIdx->pNext;
  }
  if (! pIdx) {
    if (! pParse->disableTriggers) {
      sqlite3ErrorMsg(pParse, "foreign key mismatch - \"%w\" referencing \"%w\"",
                      (pFKey->pFrom)->zName, pFKey->zTo);
    }
    sqlite3DbFree(pParse->db, (void *)aiCol);
    return (1);
  }
  *ppIdx = pIdx;
  return (0);
}
}
static void fkLookupParent(Parse *pParse , int iDb , Table *pTab , Index *pIdx , FKey *pFKey ,
                           int *aiCol , int regData , int nIncr , int isIgnore ) 
{ 
  int i ;
  Vdbe *v ;
  Vdbe *tmp ;
  int iCur ;
  int iOk ;
  int tmp___0 ;
  int iReg ;
  int iMustBeInt ;
  int regTemp ;
  int tmp___1 ;
  int tmp___2 ;
  int nCol ;
  int regTemp___0 ;
  int tmp___3 ;
  int regRec ;
  int tmp___4 ;
  int iJump ;
  int tmp___5 ;
  int iChild ;
  int iParent ;
  char const   *tmp___6 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  iCur = pParse->nTab - 1;
  tmp___0 = sqlite3VdbeMakeLabel(pParse);
  iOk = tmp___0;
  if (nIncr < 0) {
    sqlite3VdbeAddOp2(v, 46, (int )pFKey->isDeferred, iOk);
  }
  i = 0;
  while (i < pFKey->nCol) {
    iReg = (*(aiCol + i) + regData) + 1;
    sqlite3VdbeAddOp2(v, 50, iReg, iOk);
    i ++;
  }
  if (isIgnore == 0) {
    if ((unsigned long )pIdx == (unsigned long )((Index *)0)) {
      tmp___1 = sqlite3GetTempReg(pParse);
      regTemp = tmp___1;
      sqlite3VdbeAddOp2(v, 79, (*(aiCol + 0) + 1) + regData, regTemp);
      iMustBeInt = sqlite3VdbeAddOp2(v, 15, regTemp, 0);
      if ((unsigned long )pTab == (unsigned long )pFKey->pFrom) {
        if (nIncr == 1) {
          sqlite3VdbeAddOp3(v, 53, regData, iOk, regTemp);
          sqlite3VdbeChangeP5(v, (u16 )144);
        }
      }
      sqlite3OpenTable(pParse, iCur, iDb, pTab, 97);
      sqlite3VdbeAddOp3(v, 31, iCur, 0, regTemp);
      sqlite3VdbeGoto(v, iOk);
      tmp___2 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeJumpHere(v, tmp___2 - 2);
      sqlite3VdbeJumpHere(v, iMustBeInt);
      sqlite3ReleaseTempReg(pParse, regTemp);
    } else {
      nCol = pFKey->nCol;
      tmp___3 = sqlite3GetTempRange(pParse, nCol);
      regTemp___0 = tmp___3;
      tmp___4 = sqlite3GetTempReg(pParse);
      regRec = tmp___4;
      sqlite3VdbeAddOp3(v, 97, iCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      i = 0;
      while (i < nCol) {
        sqlite3VdbeAddOp2(v, 78, (*(aiCol + i) + 1) + regData, regTemp___0 + i);
        i ++;
      }
      if ((unsigned long )pTab == (unsigned long )pFKey->pFrom) {
        if (nIncr == 1) {
          tmp___5 = sqlite3VdbeCurrentAddr(v);
          iJump = (tmp___5 + nCol) + 1;
          i = 0;
          while (i < nCol) {
            iChild = (*(aiCol + i) + 1) + regData;
            iParent = ((int )*(pIdx->aiColumn + i) + 1) + regData;
            if ((int )*(pIdx->aiColumn + i) == (int )pTab->iPKey) {
              iParent = regData;
            }
            sqlite3VdbeAddOp3(v, 52, iChild, iJump, iParent);
            sqlite3VdbeChangeP5(v, (u16 )16);
            i ++;
          }
          sqlite3VdbeGoto(v, iOk);
        }
      }
      tmp___6 = sqlite3IndexAffinityStr(pParse->db, pIdx);
      sqlite3VdbeAddOp4(v, 92, regTemp___0, nCol, regRec, tmp___6, nCol);
      sqlite3VdbeAddOp4Int(v, 29, iCur, iOk, regRec, 0);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempRange(pParse, regTemp___0, nCol);
    }
  }
  if (! pFKey->isDeferred) {
    if (! ((pParse->db)->flags & 524288ULL)) {
      if (! pParse->pToplevel) {
        if (! pParse->isMultiWrite) {
          sqlite3HaltConstraint(pParse, 19 | (3 << 8), 2, (char *)0, (i8 )-1, (u8 )4);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    if (nIncr > 0) {
      if ((int )pFKey->isDeferred == 0) {
        sqlite3MayAbort(pParse);
      }
    }
    sqlite3VdbeAddOp2(v, 150, (int )pFKey->isDeferred, nIncr);
  }
  sqlite3VdbeResolveLabel(v, iOk);
  sqlite3VdbeAddOp1(v, 117, iCur);
  return;
}
}
static Expr *exprTableRegister(Parse *pParse , Table *pTab , int regBase , i16 iCol ) 
{ 
  Expr *pExpr ;
  Column *pCol ;
  char const   *zColl ;
  sqlite3 *db ;

  {
  db = pParse->db;
  pExpr = sqlite3Expr(db, 171, (char const   *)0);
  if (pExpr) {
    if ((int )iCol >= 0) {
      if ((int )iCol != (int )pTab->iPKey) {
        pCol = pTab->aCol + iCol;
        pExpr->iTable = (regBase + (int )iCol) + 1;
        pExpr->affExpr = pCol->affinity;
        zColl = (char const   *)pCol->zColl;
        if ((unsigned long )zColl == (unsigned long )((char const   *)0)) {
          zColl = (char const   *)(db->pDfltColl)->zName;
        }
        pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
      } else {
        pExpr->iTable = regBase;
        pExpr->affExpr = (char)68;
      }
    } else {
      pExpr->iTable = regBase;
      pExpr->affExpr = (char)68;
    }
  }
  return (pExpr);
}
}
static Expr *exprTableColumn(sqlite3 *db , Table *pTab , int iCursor , i16 iCol ) 
{ 
  Expr *pExpr ;
  Expr *tmp ;

  {
  tmp = sqlite3Expr(db, 162, (char const   *)0);
  pExpr = tmp;
  if (pExpr) {
    pExpr->y.pTab = pTab;
    pExpr->iTable = iCursor;
    pExpr->iColumn = iCol;
  }
  return (pExpr);
}
}
static void fkScanChildren(Parse *pParse , SrcList *pSrc , Table *pTab , Index *pIdx ,
                           FKey *pFKey , int *aiCol , int regData , int nIncr ) 
{ 
  sqlite3 *db ;
  int i ;
  Expr *pWhere ;
  NameContext sNameContext ;
  WhereInfo *pWInfo ;
  int iFkIfZero ;
  Vdbe *v ;
  Vdbe *tmp ;
  Expr *pLeft ;
  Expr *pRight ;
  Expr *pEq ;
  i16 iCol ;
  char const   *zCol ;
  Expr *pNe ;
  Expr *pLeft___0 ;
  Expr *pRight___0 ;
  Expr *pEq___0 ;
  Expr *pAll ;
  i16 iCol___0 ;

  {
  db = pParse->db;
  pWhere = (Expr *)0;
  iFkIfZero = 0;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if (nIncr < 0) {
    iFkIfZero = sqlite3VdbeAddOp2(v, 46, (int )pFKey->isDeferred, 0);
  }
  i = 0;
  while (i < pFKey->nCol) {
    if (pIdx) {
      iCol = *(pIdx->aiColumn + i);
    } else {
      iCol = (i16 )-1;
    }
    pLeft = exprTableRegister(pParse, pTab, regData, iCol);
    if (aiCol) {
      iCol = (i16 )*(aiCol + i);
    } else {
      iCol = (i16 )pFKey->aCol[0].iFrom;
    }
    zCol = (char const   *)((pFKey->pFrom)->aCol + iCol)->zName;
    pRight = sqlite3Expr(db, 59, zCol);
    pEq = sqlite3PExpr(pParse, 53, pLeft, pRight);
    pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
    i ++;
  }
  if ((unsigned long )pTab == (unsigned long )pFKey->pFrom) {
    if (nIncr > 0) {
      if ((pTab->tabFlags & 32U) == 0U) {
        pLeft___0 = exprTableRegister(pParse, pTab, regData, (i16 )-1);
        pRight___0 = exprTableColumn(db, pTab, pSrc->a[0].iCursor, (i16 )-1);
        pNe = sqlite3PExpr(pParse, 52, pLeft___0, pRight___0);
      } else {
        pAll = (Expr *)0;
        i = 0;
        while (i < (int )pIdx->nKeyCol) {
          iCol___0 = *(pIdx->aiColumn + i);
          pLeft___0 = exprTableRegister(pParse, pTab, regData, iCol___0);
          pRight___0 = sqlite3Expr(db, 59, (char const   *)(pTab->aCol + iCol___0)->zName);
          pEq___0 = sqlite3PExpr(pParse, 45, pLeft___0, pRight___0);
          pAll = sqlite3ExprAnd(pParse, pAll, pEq___0);
          i ++;
        }
        pNe = sqlite3PExpr(pParse, 19, pAll, (Expr *)0);
      }
      pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
    }
  }
  memset((void *)(& sNameContext), 0, sizeof(NameContext ));
  sNameContext.pSrcList = pSrc;
  sNameContext.pParse = pParse;
  sqlite3ResolveExprNames(& sNameContext, pWhere);
  if (pParse->nErr == 0) {
    pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, (ExprList *)0, (ExprList *)0,
                               (u16 )0, 0);
    sqlite3VdbeAddOp2(v, 150, (int )pFKey->isDeferred, nIncr);
    if (pWInfo) {
      sqlite3WhereEnd(pWInfo);
    }
  }
  sqlite3ExprDelete(db, pWhere);
  if (iFkIfZero) {
    sqlite3VdbeJumpHere(v, iFkIfZero);
  }
  return;
}
}
static FKey *sqlite3FkReferences(Table *pTab ) 
{ 
  void *tmp ;

  {
  tmp = sqlite3HashFind((Hash const   *)(& (pTab->pSchema)->fkeyHash), (char const   *)pTab->zName);
  return ((FKey *)tmp);
}
}
static void fkTriggerDelete(sqlite3 *dbMem , Trigger *p ) 
{ 
  TriggerStep *pStep ;

  {
  if (p) {
    pStep = p->step_list;
    sqlite3ExprDelete(dbMem, pStep->pWhere);
    sqlite3ExprListDelete(dbMem, pStep->pExprList);
    sqlite3SelectDelete(dbMem, pStep->pSelect);
    sqlite3ExprDelete(dbMem, p->pWhen);
    sqlite3DbFree(dbMem, (void *)p);
  }
  return;
}
}
static void sqlite3FkDropTable(Parse *pParse , SrcList *pName , Table *pTab ) 
{ 
  sqlite3 *db ;
  int iSkip ;
  Vdbe *v ;
  Vdbe *tmp ;
  FKey *p ;
  FKey *tmp___0 ;
  SrcList *tmp___1 ;
  int tmp___2 ;

  {
  db = pParse->db;
  if (db->flags & 16384ULL) {
    if (! pTab->nModuleArg) {
      iSkip = 0;
      tmp = sqlite3GetVdbe(pParse);
      v = tmp;
      tmp___0 = sqlite3FkReferences(pTab);
      if ((unsigned long )tmp___0 == (unsigned long )((FKey *)0)) {
        p = pTab->pFKey;
        while (p) {
          if (p->isDeferred) {
            break;
          } else
          if (db->flags & 524288ULL) {
            break;
          }
          p = p->pNextFrom;
        }
        if (! p) {
          return;
        }
        iSkip = sqlite3VdbeMakeLabel(pParse);
        sqlite3VdbeAddOp2(v, 46, 1, iSkip);
      }
      pParse->disableTriggers = (u8 )1;
      tmp___1 = sqlite3SrcListDup(db, pName, 0);
      sqlite3DeleteFrom(pParse, tmp___1, (Expr *)0, (ExprList *)0, (Expr *)0);
      pParse->disableTriggers = (u8 )0;
      if ((db->flags & 524288ULL) == 0ULL) {
        tmp___2 = sqlite3VdbeCurrentAddr(v);
        sqlite3VdbeAddOp2(v, 46, 0, tmp___2 + 2);
        sqlite3HaltConstraint(pParse, 19 | (3 << 8), 2, (char *)0, (i8 )-1, (u8 )4);
      }
      if (iSkip) {
        sqlite3VdbeResolveLabel(v, iSkip);
      }
    }
  }
  return;
}
}
static int fkChildIsModified(Table *pTab , FKey *p , int *aChange , int bChngRowid ) 
{ 
  int i ;
  int iChildKey ;

  {
  i = 0;
  while (i < p->nCol) {
    iChildKey = p->aCol[i].iFrom;
    if (*(aChange + iChildKey) >= 0) {
      return (1);
    }
    if (iChildKey == (int )pTab->iPKey) {
      if (bChngRowid) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static int fkParentIsModified(Table *pTab , FKey *p , int *aChange , int bChngRowid ) 
{ 
  int i ;
  char *zKey ;
  int iKey ;
  Column *pCol ;
  int tmp ;

  {
  i = 0;
  while (i < p->nCol) {
    zKey = p->aCol[i].zCol;
    iKey = 0;
    while (iKey < (int )pTab->nCol) {
      if (*(aChange + iKey) >= 0) {
        goto _L;
      } else
      if (iKey == (int )pTab->iPKey) {
        if (bChngRowid) {
          _L: /* CIL Label */ 
          pCol = pTab->aCol + iKey;
          if (zKey) {
            tmp = sqlite3StrICmp((char const   *)pCol->zName, (char const   *)zKey);
            if (0 == tmp) {
              return (1);
            }
          } else
          if ((int )pCol->colFlags & 1) {
            return (1);
          }
        }
      }
      iKey ++;
    }
    i ++;
  }
  return (0);
}
}
static int isSetNullAction(Parse *pParse , FKey *pFKey ) 
{ 
  Parse *pTop ;
  Parse *tmp ;
  Trigger *p ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pTop = tmp;
  if (pTop->pTriggerPrg) {
    p = (pTop->pTriggerPrg)->pTrigger;
    if ((unsigned long )p == (unsigned long )pFKey->apTrigger[0]) {
      if ((int )pFKey->aAction[0] == 8) {
        return (1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((unsigned long )p == (unsigned long )pFKey->apTrigger[1]) {
      if ((int )pFKey->aAction[1] == 8) {
        return (1);
      }
    }
  }
  return (0);
}
}
static void sqlite3FkCheck(Parse *pParse , Table *pTab , int regOld , int regNew ,
                           int *aChange , int bChngRowid ) 
{ 
  sqlite3 *db ;
  FKey *pFKey ;
  int iDb ;
  char const   *zDb ;
  int isIgnoreErrors ;
  Table *pTo ;
  Index *pIdx ;
  int *aiFree ;
  int *aiCol ;
  int iCol ;
  int i ;
  int bIgnore ;
  int tmp ;
  int tmp___0 ;
  Vdbe *v ;
  Vdbe *tmp___1 ;
  int iJump ;
  int tmp___2 ;
  int iReg ;
  int tmp___3 ;
  int rcauth ;
  char *zCol ;
  int tmp___4 ;
  int tmp___5 ;
  Index *pIdx___0 ;
  SrcList *pSrc ;
  int *aiCol___0 ;
  int tmp___6 ;
  int tmp___7 ;
  struct SrcList_item *pItem ;
  int tmp___8 ;
  int eAction ;

  {
  db = pParse->db;
  isIgnoreErrors = (int )pParse->disableTriggers;
  if ((db->flags & 16384ULL) == 0ULL) {
    return;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  zDb = (char const   *)(db->aDb + iDb)->zDbSName;
  pFKey = pTab->pFKey;
  while (pFKey) {
    pIdx = (Index *)0;
    aiFree = (int *)0;
    bIgnore = 0;
    if (aChange) {
      tmp = sqlite3_stricmp((char const   *)pTab->zName, (char const   *)pFKey->zTo);
      if (tmp != 0) {
        tmp___0 = fkChildIsModified(pTab, pFKey, aChange, bChngRowid);
        if (tmp___0 == 0) {
          goto __Cont;
        }
      }
    }
    if (pParse->disableTriggers) {
      pTo = sqlite3FindTable(db, (char const   *)pFKey->zTo, zDb);
    } else {
      pTo = sqlite3LocateTable(pParse, (u32 )0, (char const   *)pFKey->zTo, zDb);
    }
    if (! pTo) {
      goto _L;
    } else {
      tmp___3 = sqlite3FkLocateIndex(pParse, pTo, pFKey, & pIdx, & aiFree);
      if (tmp___3) {
        _L: /* CIL Label */ 
        if (! isIgnoreErrors) {
          return;
        } else
        if (db->mallocFailed) {
          return;
        }
        if ((unsigned long )pTo == (unsigned long )((Table *)0)) {
          tmp___1 = sqlite3GetVdbe(pParse);
          v = tmp___1;
          tmp___2 = sqlite3VdbeCurrentAddr(v);
          iJump = (tmp___2 + pFKey->nCol) + 1;
          i = 0;
          while (i < pFKey->nCol) {
            iReg = (pFKey->aCol[i].iFrom + regOld) + 1;
            sqlite3VdbeAddOp2(v, 50, iReg, iJump);
            i ++;
          }
          sqlite3VdbeAddOp2(v, 150, (int )pFKey->isDeferred, -1);
        }
        goto __Cont;
      }
    }
    if (aiFree) {
      aiCol = aiFree;
    } else {
      iCol = pFKey->aCol[0].iFrom;
      aiCol = & iCol;
    }
    i = 0;
    while (i < pFKey->nCol) {
      if (*(aiCol + i) == (int )pTab->iPKey) {
        *(aiCol + i) = -1;
      }
      if (db->xAuth) {
        if (pIdx) {
          tmp___4 = (int )*(pIdx->aiColumn + i);
        } else {
          tmp___4 = (int )pTo->iPKey;
        }
        zCol = (pTo->aCol + tmp___4)->zName;
        rcauth = sqlite3AuthReadCol(pParse, (char const   *)pTo->zName, (char const   *)zCol,
                                    iDb);
        bIgnore = rcauth == 2;
      }
      i ++;
    }
    sqlite3TableLock(pParse, iDb, pTo->tnum, (u8 )0, (char const   *)pTo->zName);
    (pParse->nTab) ++;
    if (regOld != 0) {
      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore);
    }
    if (regNew != 0) {
      tmp___5 = isSetNullAction(pParse, pFKey);
      if (! tmp___5) {
        fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, 1, bIgnore);
      }
    }
    sqlite3DbFree(db, (void *)aiFree);
    __Cont: /* CIL Label */ 
    pFKey = pFKey->pNextFrom;
  }
  pFKey = sqlite3FkReferences(pTab);
  while (pFKey) {
    pIdx___0 = (Index *)0;
    aiCol___0 = (int *)0;
    if (aChange) {
      tmp___6 = fkParentIsModified(pTab, pFKey, aChange, bChngRowid);
      if (tmp___6 == 0) {
        goto __Cont___0;
      }
    }
    if (! pFKey->isDeferred) {
      if (! (db->flags & 524288ULL)) {
        if (! pParse->pToplevel) {
          if (! pParse->isMultiWrite) {
            goto __Cont___0;
          }
        }
      }
    }
    tmp___7 = sqlite3FkLocateIndex(pParse, pTab, pFKey, & pIdx___0, & aiCol___0);
    if (tmp___7) {
      if (! isIgnoreErrors) {
        return;
      } else
      if (db->mallocFailed) {
        return;
      }
      goto __Cont___0;
    }
    pSrc = sqlite3SrcListAppend(pParse, (SrcList *)0, (Token *)0, (Token *)0);
    if (pSrc) {
      pItem = pSrc->a;
      pItem->pTab = pFKey->pFrom;
      pItem->zName = (pFKey->pFrom)->zName;
      ((pItem->pTab)->nTabRef) ++;
      tmp___8 = pParse->nTab;
      (pParse->nTab) ++;
      pItem->iCursor = tmp___8;
      if (regNew != 0) {
        fkScanChildren(pParse, pSrc, pTab, pIdx___0, pFKey, aiCol___0, regNew, -1);
      }
      if (regOld != 0) {
        eAction = (int )pFKey->aAction[(unsigned long )aChange != (unsigned long )((int *)0)];
        fkScanChildren(pParse, pSrc, pTab, pIdx___0, pFKey, aiCol___0, regOld, 1);
        if (! pFKey->isDeferred) {
          if (eAction != 10) {
            if (eAction != 8) {
              sqlite3MayAbort(pParse);
            }
          }
        }
      }
      pItem->zName = (char *)0;
      sqlite3SrcListDelete(db, pSrc);
    }
    sqlite3DbFree(db, (void *)aiCol___0);
    __Cont___0: /* CIL Label */ 
    pFKey = pFKey->pNextTo;
  }
  return;
}
}
static u32 sqlite3FkOldmask(Parse *pParse , Table *pTab ) 
{ 
  u32 mask ;
  FKey *p ;
  int i ;
  unsigned int tmp ;
  Index *pIdx ;
  unsigned int tmp___0 ;

  {
  mask = (u32 )0;
  if ((pParse->db)->flags & 16384ULL) {
    p = pTab->pFKey;
    while (p) {
      i = 0;
      while (i < p->nCol) {
        if (p->aCol[i].iFrom > 31) {
          tmp = 4294967295U;
        } else {
          tmp = 1U << p->aCol[i].iFrom;
        }
        mask |= tmp;
        i ++;
      }
      p = p->pNextFrom;
    }
    p = sqlite3FkReferences(pTab);
    while (p) {
      pIdx = (Index *)0;
      sqlite3FkLocateIndex(pParse, pTab, p, & pIdx, (int **)0);
      if (pIdx) {
        i = 0;
        while (i < (int )pIdx->nKeyCol) {
          if ((int )*(pIdx->aiColumn + i) > 31) {
            tmp___0 = 4294967295U;
          } else {
            tmp___0 = 1U << (int )*(pIdx->aiColumn + i);
          }
          mask |= tmp___0;
          i ++;
        }
      }
      p = p->pNextTo;
    }
  }
  return (mask);
}
}
static int sqlite3FkRequired(Parse *pParse , Table *pTab , int *aChange , int chngRowid ) 
{ 
  int eRet ;
  FKey *tmp ;
  int tmp___0 ;
  FKey *p ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  eRet = 0;
  if ((pParse->db)->flags & 16384ULL) {
    if (! aChange) {
      tmp = sqlite3FkReferences(pTab);
      if (tmp) {
        tmp___0 = 1;
      } else
      if (pTab->pFKey) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      eRet = tmp___0;
    } else {
      p = pTab->pFKey;
      while (p) {
        tmp___1 = sqlite3_stricmp((char const   *)pTab->zName, (char const   *)p->zTo);
        if (0 == tmp___1) {
          return (2);
        }
        tmp___2 = fkChildIsModified(pTab, p, aChange, chngRowid);
        if (tmp___2) {
          eRet = 1;
        }
        p = p->pNextFrom;
      }
      p = sqlite3FkReferences(pTab);
      while (p) {
        tmp___3 = fkParentIsModified(pTab, p, aChange, chngRowid);
        if (tmp___3) {
          if ((int )p->aAction[1] != 0) {
            return (2);
          }
          eRet = 1;
        }
        p = p->pNextTo;
      }
    }
  }
  return (eRet);
}
}
static Trigger *fkActionTrigger(Parse *pParse , Table *pTab , FKey *pFKey , ExprList *pChanges ) 
{ 
  sqlite3 *db ;
  int action ;
  Trigger *pTrigger ;
  int iAction ;
  char const   *zFrom ;
  int nFrom ;
  Index *pIdx ;
  int *aiCol ;
  TriggerStep *pStep ;
  Expr *pWhere ;
  ExprList *pList ;
  Select *pSelect ;
  int i ;
  Expr *pWhen ;
  int tmp ;
  Token tOld ;
  Token tNew ;
  Token tFromCol ;
  Token tToCol ;
  int iFromCol ;
  Expr *pEq ;
  int tmp___0 ;
  Expr *tmp___1 ;
  Expr *tmp___2 ;
  Expr *tmp___3 ;
  Expr *tmp___4 ;
  Expr *tmp___5 ;
  Expr *tmp___6 ;
  Expr *tmp___7 ;
  Expr *tmp___8 ;
  Expr *tmp___9 ;
  Expr *tmp___10 ;
  Expr *pNew ;
  Expr *tmp___11 ;
  Expr *tmp___12 ;
  Expr *pDflt ;
  Token tFrom ;
  Expr *pRaise ;
  SrcList *tmp___13 ;
  ExprList *tmp___14 ;
  void *tmp___15 ;
  TriggerStep *tmp___16 ;

  {
  db = pParse->db;
  iAction = (unsigned long )pChanges != (unsigned long )((ExprList *)0);
  action = (int )pFKey->aAction[iAction];
  if (action == 7) {
    if (db->flags & 524288ULL) {
      return ((Trigger *)0);
    }
  }
  pTrigger = pFKey->apTrigger[iAction];
  if (action != 0) {
    if (! pTrigger) {
      pIdx = (Index *)0;
      aiCol = (int *)0;
      pStep = (TriggerStep *)0;
      pWhere = (Expr *)0;
      pList = (ExprList *)0;
      pSelect = (Select *)0;
      pWhen = (Expr *)0;
      tmp = sqlite3FkLocateIndex(pParse, pTab, pFKey, & pIdx, & aiCol);
      if (tmp) {
        return ((Trigger *)0);
      }
      i = 0;
      while (i < pFKey->nCol) {
        tOld.z = "old";
        tOld.n = 3U;
        tNew.z = "new";
        tNew.n = 3U;
        if (aiCol) {
          iFromCol = *(aiCol + i);
        } else {
          iFromCol = pFKey->aCol[0].iFrom;
        }
        if (pIdx) {
          tmp___0 = (int )*(pIdx->aiColumn + i);
        } else {
          tmp___0 = (int )pTab->iPKey;
        }
        sqlite3TokenInit(& tToCol, (pTab->aCol + tmp___0)->zName);
        sqlite3TokenInit(& tFromCol, ((pFKey->pFrom)->aCol + iFromCol)->zName);
        tmp___1 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tFromCol), 0);
        tmp___2 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tToCol), 0);
        tmp___3 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tOld), 0);
        tmp___4 = sqlite3PExpr(pParse, 137, tmp___3, tmp___2);
        pEq = sqlite3PExpr(pParse, 53, tmp___4, tmp___1);
        pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
        if (pChanges) {
          tmp___5 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tToCol), 0);
          tmp___6 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tNew), 0);
          tmp___7 = sqlite3PExpr(pParse, 137, tmp___6, tmp___5);
          tmp___8 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tToCol), 0);
          tmp___9 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tOld), 0);
          tmp___10 = sqlite3PExpr(pParse, 137, tmp___9, tmp___8);
          pEq = sqlite3PExpr(pParse, 45, tmp___10, tmp___7);
          pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
        }
        if (action != 7) {
          if (action != 10) {
            goto _L;
          } else
          if (pChanges) {
            _L: /* CIL Label */ 
            if (action == 10) {
              tmp___11 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tToCol), 0);
              tmp___12 = sqlite3ExprAlloc(db, 59, (Token const   *)(& tNew), 0);
              pNew = sqlite3PExpr(pParse, 137, tmp___12, tmp___11);
            } else
            if (action == 9) {
              pDflt = ((pFKey->pFrom)->aCol + iFromCol)->pDflt;
              if (pDflt) {
                pNew = sqlite3ExprDup(db, pDflt, 0);
              } else {
                pNew = sqlite3ExprAlloc(db, 117, (Token const   *)0, 0);
              }
            } else {
              pNew = sqlite3ExprAlloc(db, 117, (Token const   *)0, 0);
            }
            pList = sqlite3ExprListAppend(pParse, pList, pNew);
            sqlite3ExprListSetName(pParse, pList, & tFromCol, 0);
          }
        }
        i ++;
      }
      sqlite3DbFree(db, (void *)aiCol);
      zFrom = (char const   *)(pFKey->pFrom)->zName;
      nFrom = sqlite3Strlen30(zFrom);
      if (action == 7) {
        tFrom.z = zFrom;
        tFrom.n = (unsigned int )nFrom;
        pRaise = sqlite3Expr(db, 71, "FOREIGN KEY constraint failed");
        if (pRaise) {
          pRaise->affExpr = (char)2;
        }
        tmp___13 = sqlite3SrcListAppend(pParse, (SrcList *)0, & tFrom, (Token *)0);
        tmp___14 = sqlite3ExprListAppend(pParse, (ExprList *)0, pRaise);
        pSelect = sqlite3SelectNew(pParse, tmp___14, tmp___13, pWhere, (ExprList *)0,
                                   (Expr *)0, (ExprList *)0, (u32 )0, (Expr *)0);
        pWhere = (Expr *)0;
      }
      (db->lookaside.bDisable) ++;
      tmp___15 = sqlite3DbMallocZero(db, (u64 )(((sizeof(Trigger ) + sizeof(TriggerStep )) + (unsigned long )nFrom) + 1UL));
      pTrigger = (Trigger *)tmp___15;
      if (pTrigger) {
        tmp___16 = (TriggerStep *)(pTrigger + 1);
        pTrigger->step_list = tmp___16;
        pStep = tmp___16;
        pStep->zTarget = (char *)(pStep + 1);
        memcpy((void * __restrict  )pStep->zTarget, (void const   * __restrict  )zFrom,
               (size_t )nFrom);
        pStep->pWhere = sqlite3ExprDup(db, pWhere, 1);
        pStep->pExprList = sqlite3ExprListDup(db, pList, 1);
        pStep->pSelect = sqlite3SelectDup(db, pSelect, 1);
        if (pWhen) {
          pWhen = sqlite3PExpr(pParse, 19, pWhen, (Expr *)0);
          pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 1);
        }
      }
      (db->lookaside.bDisable) --;
      sqlite3ExprDelete(db, pWhere);
      sqlite3ExprDelete(db, pWhen);
      sqlite3ExprListDelete(db, pList);
      sqlite3SelectDelete(db, pSelect);
      if ((int )db->mallocFailed == 1) {
        fkTriggerDelete(db, pTrigger);
        return ((Trigger *)0);
      }
      switch (action) {
      case 7: 
      pStep->op = (u8 )134;
      break;
      case 10: 
      if (! pChanges) {
        pStep->op = (u8 )124;
        break;
      }
      default: 
      pStep->op = (u8 )125;
      }
      pStep->pTrig = pTrigger;
      pTrigger->pSchema = pTab->pSchema;
      pTrigger->pTabSchema = pTab->pSchema;
      pFKey->apTrigger[iAction] = pTrigger;
      if (pChanges) {
        pTrigger->op = (u8 )125;
      } else {
        pTrigger->op = (u8 )124;
      }
    }
  }
  return (pTrigger);
}
}
static void sqlite3FkActions(Parse *pParse , Table *pTab , ExprList *pChanges , int regOld ,
                             int *aChange , int bChngRowid ) 
{ 
  FKey *pFKey ;
  Trigger *pAct ;
  Trigger *tmp ;
  int tmp___0 ;

  {
  if ((pParse->db)->flags & 16384ULL) {
    pFKey = sqlite3FkReferences(pTab);
    while (pFKey) {
      if ((unsigned long )aChange == (unsigned long )((int *)0)) {
        goto _L;
      } else {
        tmp___0 = fkParentIsModified(pTab, pFKey, aChange, bChngRowid);
        if (tmp___0) {
          _L: /* CIL Label */ 
          tmp = fkActionTrigger(pParse, pTab, pFKey, pChanges);
          pAct = tmp;
          if (pAct) {
            sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, 2, 0);
          }
        }
      }
      pFKey = pFKey->pNextTo;
    }
  }
  return;
}
}
static void sqlite3FkDelete(sqlite3 *db , Table *pTab ) 
{ 
  FKey *pFKey ;
  FKey *pNext ;
  void *p ;
  char const   *z ;
  char *tmp ;

  {
  pFKey = pTab->pFKey;
  while (pFKey) {
    if (! db) {
      goto _L;
    } else
    if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
      _L: /* CIL Label */ 
      if (pFKey->pPrevTo) {
        (pFKey->pPrevTo)->pNextTo = pFKey->pNextTo;
      } else {
        p = (void *)pFKey->pNextTo;
        if (p) {
          tmp = (pFKey->pNextTo)->zTo;
        } else {
          tmp = pFKey->zTo;
        }
        z = (char const   *)tmp;
        sqlite3HashInsert(& (pTab->pSchema)->fkeyHash, z, p);
      }
      if (pFKey->pNextTo) {
        (pFKey->pNextTo)->pPrevTo = pFKey->pPrevTo;
      }
    }
    fkTriggerDelete(db, pFKey->apTrigger[0]);
    fkTriggerDelete(db, pFKey->apTrigger[1]);
    pNext = pFKey->pNextFrom;
    sqlite3DbFree(db, (void *)pFKey);
    pFKey = pNext;
  }
  return;
}
}
static void sqlite3OpenTable(Parse *pParse , int iCur , int iDb , Table *pTab , int opcode ) 
{ 
  Vdbe *v ;
  int tmp ;
  Index *pPk ;
  Index *tmp___0 ;

  {
  v = sqlite3GetVdbe(pParse);
  if (opcode == 98) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )tmp, (char const   *)pTab->zName);
  if ((pTab->tabFlags & 32U) == 0U) {
    sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, (int )pTab->nCol);
  } else {
    tmp___0 = sqlite3PrimaryKeyIndex(pTab);
    pPk = tmp___0;
    sqlite3VdbeAddOp3(v, opcode, iCur, pPk->tnum, iDb);
    sqlite3VdbeSetP4KeyInfo(pParse, pPk);
  }
  return;
}
}
static char const   *sqlite3IndexAffinityStr(sqlite3 *db , Index *pIdx ) 
{ 
  int n ;
  Table *pTab ;
  void *tmp ;
  i16 x___0 ;
  char aff ;

  {
  if (! pIdx->zColAff) {
    pTab = pIdx->pTable;
    tmp = sqlite3DbMallocRaw((sqlite3 *)0, (u64 )((int )pIdx->nColumn + 1));
    pIdx->zColAff = (char *)tmp;
    if (! pIdx->zColAff) {
      sqlite3OomFault(db);
      return ((char const   *)0);
    }
    n = 0;
    while (n < (int )pIdx->nColumn) {
      x___0 = *(pIdx->aiColumn + n);
      if ((int )x___0 >= 0) {
        aff = (pTab->aCol + x___0)->affinity;
      } else
      if ((int )x___0 == -1) {
        aff = (char)68;
      } else {
        aff = sqlite3ExprAffinity((pIdx->aColExpr)->a[n].pExpr);
      }
      if ((int )aff < 65) {
        aff = (char)65;
      }
      if ((int )aff > 67) {
        aff = (char)67;
      }
      *(pIdx->zColAff + n) = aff;
      n ++;
    }
    *(pIdx->zColAff + n) = (char)0;
  }
  return ((char const   *)pIdx->zColAff);
}
}
static void sqlite3TableAffinity(Vdbe *v , Table *pTab , int iReg ) 
{ 
  int i ;
  char *zColAff ;
  sqlite3 *db ;
  sqlite3 *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  zColAff = pTab->zColAff;
  if ((unsigned long )zColAff == (unsigned long )((char *)0)) {
    tmp = sqlite3VdbeDb(v);
    db = tmp;
    tmp___0 = sqlite3DbMallocRaw((sqlite3 *)0, (u64 )((int )pTab->nCol + 1));
    zColAff = (char *)tmp___0;
    if (! zColAff) {
      sqlite3OomFault(db);
      return;
    }
    i = 0;
    while (i < (int )pTab->nCol) {
      *(zColAff + i) = (pTab->aCol + i)->affinity;
      i ++;
    }
    while (1) {
      tmp___1 = i;
      i --;
      *(zColAff + tmp___1) = (char)0;
      if (i >= 0) {
        if (! ((int )*(zColAff + i) <= 65)) {
          break;
        }
      } else {
        break;
      }
    }
    pTab->zColAff = zColAff;
  }
  tmp___2 = strlen((char const   *)zColAff);
  i = (int )(tmp___2 & 1073741823UL);
  if (i) {
    if (iReg) {
      sqlite3VdbeAddOp4(v, 91, iReg, i, 0, (char const   *)zColAff, i);
    } else {
      sqlite3VdbeChangeP4(v, -1, (char const   *)zColAff, i);
    }
  }
  return;
}
}
static int readsTable(Parse *p , int iDb , Table *pTab ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  int i ;
  int iEnd ;
  int tmp___0 ;
  VTable *pVTab ;
  VTable *tmp___1 ;
  VTable *tmp___2 ;
  VdbeOp *pOp ;
  VdbeOp *tmp___3 ;
  Index *pIndex ;
  int tnum ;

  {
  tmp = sqlite3GetVdbe(p);
  v = tmp;
  tmp___0 = sqlite3VdbeCurrentAddr(v);
  iEnd = tmp___0;
  if (pTab->nModuleArg) {
    tmp___1 = sqlite3GetVTable(p->db, pTab);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = (VTable *)0;
  }
  pVTab = tmp___2;
  i = 1;
  while (i < iEnd) {
    tmp___3 = sqlite3VdbeGetOp(v, i);
    pOp = tmp___3;
    if ((int )pOp->opcode == 97) {
      if (pOp->p3 == iDb) {
        tnum = pOp->p2;
        if (tnum == pTab->tnum) {
          return (1);
        }
        pIndex = pTab->pIndex;
        while (pIndex) {
          if (tnum == pIndex->tnum) {
            return (1);
          }
          pIndex = pIndex->pNext;
        }
      }
    }
    if ((int )pOp->opcode == 163) {
      if ((unsigned long )pOp->p4.pVtab == (unsigned long )pVTab) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static int autoIncBegin(Parse *pParse , int iDb , Table *pTab ) 
{ 
  int memId ;
  Parse *pToplevel ;
  Parse *tmp ;
  AutoincInfo *pInfo ;
  Table *pSeqTab ;
  void *tmp___0 ;

  {
  memId = 0;
  if ((pTab->tabFlags & 8U) != 0U) {
    if (((pParse->db)->mDbFlags & 4U) == 0U) {
      if (pParse->pToplevel) {
        tmp = pParse->pToplevel;
      } else {
        tmp = pParse;
      }
      pToplevel = tmp;
      pSeqTab = (((pParse->db)->aDb + iDb)->pSchema)->pSeqTab;
      if ((unsigned long )pSeqTab == (unsigned long )((Table *)0)) {
        (pParse->nErr) ++;
        pParse->rc = 11 | (2 << 8);
        return (0);
      } else
      if (! ((pSeqTab->tabFlags & 32U) == 0U)) {
        (pParse->nErr) ++;
        pParse->rc = 11 | (2 << 8);
        return (0);
      } else
      if (pSeqTab->nModuleArg) {
        (pParse->nErr) ++;
        pParse->rc = 11 | (2 << 8);
        return (0);
      } else
      if ((int )pSeqTab->nCol != 2) {
        (pParse->nErr) ++;
        pParse->rc = 11 | (2 << 8);
        return (0);
      }
      pInfo = pToplevel->pAinc;
      while (1) {
        if (pInfo) {
          if (! ((unsigned long )pInfo->pTab != (unsigned long )pTab)) {
            break;
          }
        } else {
          break;
        }
        pInfo = pInfo->pNext;
      }
      if ((unsigned long )pInfo == (unsigned long )((AutoincInfo *)0)) {
        tmp___0 = sqlite3DbMallocRawNN(pParse->db, (u64 )sizeof(*pInfo));
        pInfo = (AutoincInfo *)tmp___0;
        if ((unsigned long )pInfo == (unsigned long )((AutoincInfo *)0)) {
          return (0);
        }
        pInfo->pNext = pToplevel->pAinc;
        pToplevel->pAinc = pInfo;
        pInfo->pTab = pTab;
        pInfo->iDb = iDb;
        (pToplevel->nMem) ++;
        (pToplevel->nMem) ++;
        pInfo->regCtr = pToplevel->nMem;
        pToplevel->nMem += 2;
      }
      memId = pInfo->regCtr;
    }
  }
  return (memId);
}
}
static int const   iLn___0  =    (int const   )0;
static VdbeOpList const   autoInc[12]  = 
  {      {(u8 )73, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )36, (signed char)0, (signed char)10, (signed char)0}, 
        {(u8 )90, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )52, (signed char)0, (signed char)9, (signed char)0}, 
        {(u8 )128, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )90, (signed char)0, (signed char)1, (signed char)0}, 
        {(u8 )83, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )78, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )11, (signed char)0, (signed char)11, (signed char)0}, 
        {(u8 )5, (signed char)0, (signed char)2, (signed char)0}, 
        {(u8 )70, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )117, (signed char)0, (signed char)0, (signed char)0}};
static void sqlite3AutoincrementBegin(Parse *pParse ) 
{ 
  AutoincInfo *p ;
  sqlite3 *db ;
  Db *pDb ;
  int memId ;
  Vdbe *v ;
  VdbeOp *aOp___1 ;

  {
  db = pParse->db;
  v = pParse->pVdbe;
  p = pParse->pAinc;
  while (p) {
    pDb = db->aDb + p->iDb;
    memId = p->regCtr;
    sqlite3OpenTable(pParse, 0, p->iDb, (pDb->pSchema)->pSeqTab, 97);
    sqlite3VdbeLoadString(v, memId - 1, (char const   *)(p->pTab)->zName);
    aOp___1 = sqlite3VdbeAddOpList(v, (int )(sizeof(autoInc) / sizeof(autoInc[0])),
                                   autoInc, (int )iLn___0);
    if ((unsigned long )aOp___1 == (unsigned long )((VdbeOp *)0)) {
      break;
    }
    (aOp___1 + 0)->p2 = memId;
    (aOp___1 + 0)->p3 = memId + 2;
    (aOp___1 + 2)->p3 = memId;
    (aOp___1 + 3)->p1 = memId - 1;
    (aOp___1 + 3)->p3 = memId;
    (aOp___1 + 3)->p5 = (u16 )16;
    (aOp___1 + 4)->p2 = memId + 1;
    (aOp___1 + 5)->p3 = memId;
    (aOp___1 + 6)->p1 = memId;
    (aOp___1 + 7)->p2 = memId + 2;
    (aOp___1 + 7)->p1 = memId;
    (aOp___1 + 10)->p2 = memId;
    if (pParse->nTab == 0) {
      pParse->nTab = 1;
    }
    p = p->pNext;
  }
  return;
}
}
static void autoIncStep(Parse *pParse , int memId , int regRowid ) 
{ 


  {
  if (memId > 0) {
    sqlite3VdbeAddOp2(pParse->pVdbe, 151, memId, regRowid);
  }
  return;
}
}
static void ( __attribute__((__noinline__)) autoIncrementEnd)(Parse *pParse ) ;
static int const   iLn___1  =    (int const   )0;
static VdbeOpList const   autoIncEnd[5]  = {      {(u8 )51, (signed char)0, (signed char)2, (signed char)0}, 
        {(u8 )121, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )92, (signed char)0, (signed char)2, (signed char)0}, 
        {(u8 )122, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )117, (signed char)0, (signed char)0, (signed char)0}};
static void ( __attribute__((__noinline__)) autoIncrementEnd)(Parse *pParse ) 
{ 
  AutoincInfo *p ;
  Vdbe *v ;
  sqlite3 *db ;
  VdbeOp *aOp___1 ;
  Db *pDb ;
  int iRec ;
  int memId ;
  int tmp ;

  {
  v = pParse->pVdbe;
  db = pParse->db;
  p = pParse->pAinc;
  while (p) {
    pDb = db->aDb + p->iDb;
    memId = p->regCtr;
    iRec = sqlite3GetTempReg(pParse);
    tmp = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp3(v, 55, memId + 2, tmp + 7, memId);
    sqlite3OpenTable(pParse, 0, p->iDb, (pDb->pSchema)->pSeqTab, 98);
    aOp___1 = sqlite3VdbeAddOpList(v, (int )(sizeof(autoIncEnd) / sizeof(autoIncEnd[0])),
                                   autoIncEnd, (int )iLn___1);
    if ((unsigned long )aOp___1 == (unsigned long )((VdbeOp *)0)) {
      break;
    }
    (aOp___1 + 0)->p1 = memId + 1;
    (aOp___1 + 1)->p2 = memId + 1;
    (aOp___1 + 2)->p1 = memId - 1;
    (aOp___1 + 2)->p3 = iRec;
    (aOp___1 + 3)->p2 = iRec;
    (aOp___1 + 3)->p3 = memId + 1;
    (aOp___1 + 3)->p5 = (u16 )8;
    sqlite3ReleaseTempReg(pParse, iRec);
    p = p->pNext;
  }
  return;
}
}
static void sqlite3AutoincrementEnd(Parse *pParse ) 
{ 


  {
  if (pParse->pAinc) {
    autoIncrementEnd(pParse);
  }
  return;
}
}
static int xferOptimization(Parse *pParse , Table *pDest , Select *pSelect , int onError ,
                            int iDbDest ) ;
static void sqlite3Insert(Parse *pParse , SrcList *pTabList , Select *pSelect , IdList *pColumn ,
                          int onError , Upsert *pUpsert ) 
{ 
  sqlite3 *db ;
  Table *pTab ;
  int i ;
  int j ;
  Vdbe *v ;
  Index *pIdx ;
  int nColumn ;
  int nHidden ;
  int iDataCur ;
  int iIdxCur ;
  int ipkColumn ;
  int endOfLoop ;
  int srcTab ;
  int addrInsTop ;
  int addrCont ;
  SelectDest dest ;
  int iDb ;
  u8 useTempTable ;
  u8 appendFlag ;
  u8 withoutRowid ;
  u8 bIdListInOrder ;
  ExprList *pList ;
  int regFromSelect ;
  int regAutoinc ;
  int regRowCount ;
  int regIns ;
  int regRowid ;
  int regData ;
  int *aRegIdx ;
  int isView ;
  Trigger *pTrigger ;
  int tmask ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int regYield ;
  int addrTop ;
  int rc ;
  int tmp___6 ;
  int tmp___7 ;
  int regRec ;
  int regTempRowid ;
  int addrL ;
  int tmp___8 ;
  NameContext sNC ;
  int tmp___9 ;
  int tmp___10 ;
  int nIdx ;
  void *tmp___11 ;
  int tmp___12 ;
  int regCols ;
  int tmp___13 ;
  int addr1 ;
  Expr *pIpk ;
  int addr1___0 ;
  int iRegStore ;
  char const   *pVTab ;
  VTable *tmp___14 ;
  int tmp___15 ;
  int isReplace ;
  int bUseSeek ;
  FKey *tmp___16 ;
  int tmp___17 ;

  {
  nHidden = 0;
  iDataCur = 0;
  iIdxCur = 0;
  ipkColumn = -1;
  srcTab = 0;
  addrInsTop = 0;
  addrCont = 0;
  useTempTable = (u8 )0;
  appendFlag = (u8 )0;
  pList = (ExprList *)0;
  regFromSelect = 0;
  regAutoinc = 0;
  regRowCount = 0;
  aRegIdx = (int *)0;
  db = pParse->db;
  if (pParse->nErr) {
    goto insert_cleanup;
  } else
  if (db->mallocFailed) {
    goto insert_cleanup;
  }
  dest.iSDParm = 0;
  if (pSelect) {
    if ((pSelect->selFlags & 512U) != 0U) {
      if ((unsigned long )pSelect->pPrior == (unsigned long )((Select *)0)) {
        pList = pSelect->pEList;
        pSelect->pEList = (ExprList *)0;
        sqlite3SelectDelete(db, pSelect);
        pSelect = (Select *)0;
      }
    }
  }
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    goto insert_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  tmp = sqlite3AuthCheck(pParse, 18, (char const   *)pTab->zName, (char const   *)0,
                         (char const   *)(db->aDb + iDb)->zDbSName);
  if (tmp) {
    goto insert_cleanup;
  }
  withoutRowid = (u8 )(! ((pTab->tabFlags & 32U) == 0U));
  pTrigger = sqlite3TriggersExist(pParse, pTab, 123, (ExprList *)0, & tmask);
  isView = (unsigned long )pTab->pSelect != (unsigned long )((Select *)0);
  tmp___0 = sqlite3ViewGetColumnNames(pParse, pTab);
  if (tmp___0) {
    goto insert_cleanup;
  }
  tmp___1 = sqlite3IsReadOnly(pParse, pTab, tmask);
  if (tmp___1) {
    goto insert_cleanup;
  }
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    goto insert_cleanup;
  }
  if ((int )pParse->nested == 0) {
    sqlite3VdbeCountChanges(v);
  }
  if (pSelect) {
    tmp___2 = 1;
  } else
  if (pTrigger) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  sqlite3BeginWriteOperation(pParse, tmp___2, iDb);
  if ((unsigned long )pColumn == (unsigned long )((IdList *)0)) {
    tmp___3 = xferOptimization(pParse, pTab, pSelect, onError, iDb);
    if (tmp___3) {
      goto insert_end;
    }
  }
  regAutoinc = autoIncBegin(pParse, iDb, pTab);
  regIns = pParse->nMem + 1;
  regRowid = regIns;
  pParse->nMem += (int )pTab->nCol + 1;
  if (pTab->nModuleArg) {
    regRowid ++;
    (pParse->nMem) ++;
  }
  regData = regRowid + 1;
  bIdListInOrder = (u8 )((pTab->tabFlags & 128U) == 0U);
  if (pColumn) {
    i = 0;
    while (i < pColumn->nId) {
      (pColumn->a + i)->idx = -1;
      i ++;
    }
    i = 0;
    while (i < pColumn->nId) {
      j = 0;
      while (j < (int )pTab->nCol) {
        tmp___4 = sqlite3StrICmp((char const   *)(pColumn->a + i)->zName, (char const   *)(pTab->aCol + j)->zName);
        if (tmp___4 == 0) {
          (pColumn->a + i)->idx = j;
          if (i != j) {
            bIdListInOrder = (u8 )0;
          }
          if (j == (int )pTab->iPKey) {
            ipkColumn = i;
          }
          break;
        }
        j ++;
      }
      if (j >= (int )pTab->nCol) {
        tmp___5 = sqlite3IsRowid((char const   *)(pColumn->a + i)->zName);
        if (tmp___5) {
          if (! withoutRowid) {
            ipkColumn = i;
            bIdListInOrder = (u8 )0;
          } else {
            sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList, 0,
                            (pColumn->a + i)->zName);
            pParse->checkSchema = (u8 )1;
            goto insert_cleanup;
          }
        } else {
          sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList, 0,
                          (pColumn->a + i)->zName);
          pParse->checkSchema = (u8 )1;
          goto insert_cleanup;
        }
      }
      i ++;
    }
  }
  if (pSelect) {
    (pParse->nMem) ++;
    regYield = pParse->nMem;
    tmp___6 = sqlite3VdbeCurrentAddr(v);
    addrTop = tmp___6 + 1;
    sqlite3VdbeAddOp3(v, 13, regYield, 0, addrTop);
    sqlite3SelectDestInit(& dest, 13, regYield);
    if (bIdListInOrder) {
      dest.iSdst = regData;
    } else {
      dest.iSdst = 0;
    }
    dest.nSdst = (int )pTab->nCol;
    rc = sqlite3Select(pParse, pSelect, & dest);
    regFromSelect = dest.iSdst;
    if (rc) {
      goto insert_cleanup;
    } else
    if (db->mallocFailed) {
      goto insert_cleanup;
    } else
    if (pParse->nErr) {
      goto insert_cleanup;
    }
    sqlite3VdbeEndCoroutine(v, regYield);
    sqlite3VdbeJumpHere(v, addrTop - 1);
    nColumn = (pSelect->pEList)->nExpr;
    if (pTrigger) {
      useTempTable = (u8 )1;
    } else {
      tmp___7 = readsTable(pParse, iDb, pTab);
      if (tmp___7) {
        useTempTable = (u8 )1;
      }
    }
    if (useTempTable) {
      tmp___8 = pParse->nTab;
      (pParse->nTab) ++;
      srcTab = tmp___8;
      regRec = sqlite3GetTempReg(pParse);
      regTempRowid = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 112, srcTab, nColumn);
      addrL = sqlite3VdbeAddOp1(v, 14, dest.iSDParm);
      sqlite3VdbeAddOp3(v, 92, regFromSelect, nColumn, regRec);
      sqlite3VdbeAddOp2(v, 121, srcTab, regTempRowid);
      sqlite3VdbeAddOp3(v, 122, srcTab, regRec, regTempRowid);
      sqlite3VdbeGoto(v, addrL);
      sqlite3VdbeJumpHere(v, addrL);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempReg(pParse, regTempRowid);
    }
  } else {
    memset((void *)(& sNC), 0, sizeof(sNC));
    sNC.pParse = pParse;
    srcTab = -1;
    if (pList) {
      nColumn = pList->nExpr;
      tmp___9 = sqlite3ResolveExprListNames(& sNC, pList);
      if (tmp___9) {
        goto insert_cleanup;
      }
    } else {
      nColumn = 0;
    }
  }
  if ((unsigned long )pColumn == (unsigned long )((IdList *)0)) {
    if (nColumn > 0) {
      ipkColumn = (int )pTab->iPKey;
    }
  }
  i = 0;
  while (i < (int )pTab->nCol) {
    if (((int )(pTab->aCol + i)->colFlags & 2) != 0) {
      tmp___10 = 1;
    } else {
      tmp___10 = 0;
    }
    nHidden += tmp___10;
    i ++;
  }
  if ((unsigned long )pColumn == (unsigned long )((IdList *)0)) {
    if (nColumn) {
      if (nColumn != (int )pTab->nCol - nHidden) {
        sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied",
                        pTabList, 0, (int )pTab->nCol - nHidden, nColumn);
        goto insert_cleanup;
      }
    }
  }
  if ((unsigned long )pColumn != (unsigned long )((IdList *)0)) {
    if (nColumn != pColumn->nId) {
      sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
      goto insert_cleanup;
    }
  }
  if ((db->flags & 128ULL) != 0ULL) {
    if (! pParse->nested) {
      if (! pParse->pTriggerTab) {
        (pParse->nMem) ++;
        regRowCount = pParse->nMem;
        sqlite3VdbeAddOp2(v, 70, 0, regRowCount);
      }
    }
  }
  if (! isView) {
    nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 98, (u8 )0, -1, (u8 *)0, & iDataCur,
                                      & iIdxCur);
    tmp___11 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(int ) * (unsigned long )(nIdx + 2)));
    aRegIdx = (int *)tmp___11;
    if ((unsigned long )aRegIdx == (unsigned long )((int *)0)) {
      goto insert_cleanup;
    }
    i = 0;
    pIdx = pTab->pIndex;
    while (i < nIdx) {
      (pParse->nMem) ++;
      *(aRegIdx + i) = pParse->nMem;
      pParse->nMem += (int )pIdx->nColumn;
      pIdx = pIdx->pNext;
      i ++;
    }
    (pParse->nMem) ++;
    *(aRegIdx + i) = pParse->nMem;
  }
  if (pUpsert) {
    if (pTab->nModuleArg) {
      sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"", pTab->zName);
      goto insert_cleanup;
    }
    tmp___12 = sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget);
    if (tmp___12) {
      goto insert_cleanup;
    }
    pTabList->a[0].iCursor = iDataCur;
    pUpsert->pUpsertSrc = pTabList;
    pUpsert->regData = regData;
    pUpsert->iDataCur = iDataCur;
    pUpsert->iIdxCur = iIdxCur;
    if (pUpsert->pUpsertTarget) {
      sqlite3UpsertAnalyzeTarget(pParse, pTabList, pUpsert);
    }
  }
  if (useTempTable) {
    addrInsTop = sqlite3VdbeAddOp1(v, 36, srcTab);
    addrCont = sqlite3VdbeCurrentAddr(v);
  } else
  if (pSelect) {
    addrCont = sqlite3VdbeAddOp1(v, 14, dest.iSDParm);
    addrInsTop = addrCont;
  }
  endOfLoop = sqlite3VdbeMakeLabel(pParse);
  if (tmask & 1) {
    tmp___13 = sqlite3GetTempRange(pParse, (int )pTab->nCol + 1);
    regCols = tmp___13;
    if (ipkColumn < 0) {
      sqlite3VdbeAddOp2(v, 70, -1, regCols);
    } else {
      if (useTempTable) {
        sqlite3VdbeAddOp3(v, 90, srcTab, ipkColumn, regCols);
      } else {
        sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);
      }
      addr1 = sqlite3VdbeAddOp1(v, 51, regCols);
      sqlite3VdbeAddOp2(v, 70, -1, regCols);
      sqlite3VdbeJumpHere(v, addr1);
      sqlite3VdbeAddOp1(v, 15, regCols);
    }
    j = 0;
    i = j;
    while (i < (int )pTab->nCol) {
      if (pColumn) {
        j = 0;
        while (j < pColumn->nId) {
          if ((pColumn->a + j)->idx == i) {
            break;
          }
          j ++;
        }
      }
      if (! useTempTable) {
        if (! pList) {
          sqlite3ExprCode(pParse, (pTab->aCol + i)->pDflt, (regCols + i) + 1);
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (pColumn) {
        if (j >= pColumn->nId) {
          sqlite3ExprCode(pParse, (pTab->aCol + i)->pDflt, (regCols + i) + 1);
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if ((unsigned long )pColumn == (unsigned long )((IdList *)0)) {
        goto _L;
      } else
      _L: /* CIL Label */ 
      if (useTempTable) {
        sqlite3VdbeAddOp3(v, 90, srcTab, j, (regCols + i) + 1);
      } else {
        sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, (regCols + i) + 1);
      }
      if ((unsigned long )pColumn == (unsigned long )((IdList *)0)) {
        j ++;
      }
      i ++;
    }
    if (! isView) {
      sqlite3TableAffinity(v, pTab, regCols + 1);
    }
    sqlite3CodeRowTrigger(pParse, pTrigger, 123, (ExprList *)0, 1, pTab, (regCols - (int )pTab->nCol) - 1,
                          onError, endOfLoop);
    sqlite3ReleaseTempRange(pParse, regCols, (int )pTab->nCol + 1);
  }
  if (! isView) {
    if (pTab->nModuleArg) {
      sqlite3VdbeAddOp2(v, 73, 0, regIns);
    }
    if (ipkColumn >= 0) {
      if (useTempTable) {
        sqlite3VdbeAddOp3(v, 90, srcTab, ipkColumn, regRowid);
      } else
      if (pSelect) {
        sqlite3VdbeAddOp2(v, 78, regFromSelect + ipkColumn, regRowid);
      } else {
        pIpk = pList->a[ipkColumn].pExpr;
        if ((int )pIpk->op == 117) {
          if (! pTab->nModuleArg) {
            sqlite3VdbeAddOp3(v, 121, iDataCur, regRowid, regAutoinc);
            appendFlag = (u8 )1;
          } else {
            sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);
          }
        } else {
          sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);
        }
      }
      if (! appendFlag) {
        if (! pTab->nModuleArg) {
          addr1___0 = sqlite3VdbeAddOp1(v, 51, regRowid);
          sqlite3VdbeAddOp3(v, 121, iDataCur, regRowid, regAutoinc);
          sqlite3VdbeJumpHere(v, addr1___0);
        } else {
          addr1___0 = sqlite3VdbeCurrentAddr(v);
          sqlite3VdbeAddOp2(v, 50, regRowid, addr1___0 + 2);
        }
        sqlite3VdbeAddOp1(v, 15, regRowid);
      }
    } else
    if (pTab->nModuleArg) {
      sqlite3VdbeAddOp2(v, 73, 0, regRowid);
    } else
    if (withoutRowid) {
      sqlite3VdbeAddOp2(v, 73, 0, regRowid);
    } else {
      sqlite3VdbeAddOp3(v, 121, iDataCur, regRowid, regAutoinc);
      appendFlag = (u8 )1;
    }
    autoIncStep(pParse, regAutoinc, regRowid);
    nHidden = 0;
    i = 0;
    while (i < (int )pTab->nCol) {
      iRegStore = (regRowid + 1) + i;
      if (i == (int )pTab->iPKey) {
        sqlite3VdbeAddOp1(v, 74, iRegStore);
        goto __Cont;
      }
      if ((unsigned long )pColumn == (unsigned long )((IdList *)0)) {
        if (((int )(pTab->aCol + i)->colFlags & 2) != 0) {
          j = -1;
          nHidden ++;
        } else {
          j = i - nHidden;
        }
      } else {
        j = 0;
        while (j < pColumn->nId) {
          if ((pColumn->a + j)->idx == i) {
            break;
          }
          j ++;
        }
      }
      if (j < 0) {
        sqlite3ExprCodeFactorable(pParse, (pTab->aCol + i)->pDflt, iRegStore);
      } else
      if (nColumn == 0) {
        sqlite3ExprCodeFactorable(pParse, (pTab->aCol + i)->pDflt, iRegStore);
      } else
      if (pColumn) {
        if (j >= pColumn->nId) {
          sqlite3ExprCodeFactorable(pParse, (pTab->aCol + i)->pDflt, iRegStore);
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if (useTempTable) {
        sqlite3VdbeAddOp3(v, 90, srcTab, j, iRegStore);
      } else
      if (pSelect) {
        if (regFromSelect != regData) {
          sqlite3VdbeAddOp2(v, 79, regFromSelect + j, iRegStore);
        }
      } else {
        sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
    if (pTab->nModuleArg) {
      tmp___14 = sqlite3GetVTable(db, pTab);
      pVTab = (char const   *)tmp___14;
      sqlite3VtabMakeWritable(pParse, pTab);
      sqlite3VdbeAddOp4(v, 10, 1, (int )pTab->nCol + 2, regIns, pVTab, -12);
      if (onError == 11) {
        tmp___15 = 2;
      } else {
        tmp___15 = onError;
      }
      sqlite3VdbeChangeP5(v, (u16 )tmp___15);
      sqlite3MayAbort(pParse);
    } else {
      sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regIns,
                                      0, (u8 )(ipkColumn >= 0), (u8 )onError, endOfLoop,
                                      & isReplace, (int *)0, pUpsert);
      sqlite3FkCheck(pParse, pTab, 0, regIns, (int *)0, 0);
      if (isReplace == 0) {
        tmp___17 = 1;
      } else
      if ((unsigned long )pTrigger == (unsigned long )((Trigger *)0)) {
        if ((db->flags & 16384ULL) == 0ULL) {
          tmp___17 = 1;
        } else {
          tmp___16 = sqlite3FkReferences(pTab);
          if ((unsigned long )tmp___16 == (unsigned long )((FKey *)0)) {
            tmp___17 = 1;
          } else {
            tmp___17 = 0;
          }
        }
      } else {
        tmp___17 = 0;
      }
      bUseSeek = tmp___17;
      sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regIns, aRegIdx, 0,
                               (int )appendFlag, bUseSeek);
    }
  }
  if (regRowCount) {
    sqlite3VdbeAddOp2(v, 83, regRowCount, 1);
  }
  if (pTrigger) {
    sqlite3CodeRowTrigger(pParse, pTrigger, 123, (ExprList *)0, 2, pTab, (regData - 2) - (int )pTab->nCol,
                          onError, endOfLoop);
  }
  sqlite3VdbeResolveLabel(v, endOfLoop);
  if (useTempTable) {
    sqlite3VdbeAddOp2(v, 5, srcTab, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
    sqlite3VdbeAddOp1(v, 117, srcTab);
  } else
  if (pSelect) {
    sqlite3VdbeGoto(v, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
  }
  insert_end: 
  if ((int )pParse->nested == 0) {
    if ((unsigned long )pParse->pTriggerTab == (unsigned long )((Table *)0)) {
      sqlite3AutoincrementEnd(pParse);
    }
  }
  if (regRowCount) {
    sqlite3VdbeAddOp2(v, 81, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows inserted", (void (*)(void * ))0);
  }
  insert_cleanup: 
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pList);
  sqlite3UpsertDelete(db, pUpsert);
  sqlite3SelectDelete(db, pSelect);
  sqlite3IdListDelete(db, pColumn);
  sqlite3DbFree(db, (void *)aRegIdx);
  return;
}
}
static int checkConstraintExprNode(Walker *pWalker , Expr *pExpr ) 
{ 


  {
  if ((int )pExpr->op == 162) {
    if ((int )pExpr->iColumn >= 0) {
      if (*(pWalker->u.aiCol + pExpr->iColumn) >= 0) {
        pWalker->eCode = (u8 )((int )pWalker->eCode | 1);
      }
    } else {
      pWalker->eCode = (u8 )((int )pWalker->eCode | 2);
    }
  }
  return (0);
}
}
static int sqlite3ExprReferencesUpdatedColumn(Expr *pExpr , int *aiChng , int chngRowid ) 
{ 
  Walker w ;

  {
  memset((void *)(& w), 0, sizeof(w));
  w.eCode = (u8 )0;
  w.xExprCallback = & checkConstraintExprNode;
  w.u.aiCol = aiChng;
  sqlite3WalkExpr(& w, pExpr);
  if (! chngRowid) {
    w.eCode = (u8 )((int )w.eCode & -3);
  }
  return ((int )w.eCode != 0);
}
}
static void sqlite3GenerateConstraintChecks(Parse *pParse , Table *pTab , int *aRegIdx ,
                                            int iDataCur , int iIdxCur , int regNewData ,
                                            int regOldData , u8 pkChng , u8 overrideError ,
                                            int ignoreDest , int *pbMayReplace , int *aiChng ,
                                            Upsert *pUpsert ) 
{ 
  Vdbe *v ;
  Index *pIdx ;
  Index *pPk ;
  sqlite3 *db ;
  int i ;
  int ix ;
  int nCol ;
  int onError ;
  int addr1 ;
  int seenReplace ;
  int nPkField ;
  Index *pUpIdx ;
  u8 isUpdate ;
  u8 bAffinityDone ;
  int upsertBypass ;
  int upsertJump ;
  int ipkTop ;
  int ipkBottom ;
  char *zMsg ;
  char *tmp ;
  ExprList *pCheck ;
  int allOk ;
  Expr *pExpr ;
  int tmp___0 ;
  char *zName ;
  int addrRowidOk ;
  int tmp___1 ;
  int tmp___2 ;
  Trigger *pTrigger ;
  int tmp___3 ;
  int regIdx ;
  int regR ;
  int iThisCur ;
  int addrUniqueOk ;
  int iField ;
  int x___0 ;
  int tmp___4 ;
  Trigger *tmp___5 ;
  FKey *tmp___6 ;
  int tmp___7 ;
  int x___1 ;
  i16 tmp___8 ;
  int addrJump ;
  int tmp___9 ;
  int op ;
  int regCmp ;
  int tmp___10 ;
  char *p4 ;
  CollSeq *tmp___11 ;
  Trigger *pTrigger___0 ;
  int tmp___12 ;
  int tmp___13 ;
  int regRec ;

  {
  pPk = (Index *)0;
  seenReplace = 0;
  pUpIdx = (Index *)0;
  bAffinityDone = (u8 )0;
  upsertBypass = 0;
  upsertJump = 0;
  ipkTop = 0;
  ipkBottom = 0;
  isUpdate = (u8 )(regOldData != 0);
  db = pParse->db;
  v = sqlite3GetVdbe(pParse);
  nCol = (int )pTab->nCol;
  if ((pTab->tabFlags & 32U) == 0U) {
    pPk = (Index *)0;
    nPkField = 1;
  } else {
    pPk = sqlite3PrimaryKeyIndex(pTab);
    nPkField = (int )pPk->nKeyCol;
  }
  i = 0;
  while (i < nCol) {
    if (i == (int )pTab->iPKey) {
      goto __Cont;
    }
    if (aiChng) {
      if (*(aiChng + i) < 0) {
        goto __Cont;
      }
    }
    onError = (int )(pTab->aCol + i)->notNull;
    if (onError == 0) {
      goto __Cont;
    }
    if ((int )overrideError != 11) {
      onError = (int )overrideError;
    } else
    if (onError == 11) {
      onError = 2;
    }
    if (onError == 5) {
      if ((unsigned long )(pTab->aCol + i)->pDflt == (unsigned long )((Expr *)0)) {
        onError = 2;
      }
    }
    addr1 = 0;
    switch (onError) {
    case 5: 
    addr1 = sqlite3VdbeMakeLabel(pParse);
    sqlite3VdbeAddOp2(v, 51, (regNewData + 1) + i, addr1);
    sqlite3ExprCode(pParse, (pTab->aCol + i)->pDflt, (regNewData + 1) + i);
    sqlite3VdbeAddOp2(v, 51, (regNewData + 1) + i, addr1);
    onError = 2;
    case 2: 
    sqlite3MayAbort(pParse);
    case 3: 
    case 1: 
    tmp = sqlite3MPrintf(db, "%s.%s", pTab->zName, (pTab->aCol + i)->zName);
    zMsg = tmp;
    sqlite3VdbeAddOp3(v, 68, 19 | (5 << 8), onError, (regNewData + 1) + i);
    sqlite3VdbeAppendP4(v, (void *)zMsg, -7);
    sqlite3VdbeChangeP5(v, (u16 )1);
    if (addr1) {
      sqlite3VdbeResolveLabel(v, addr1);
    }
    break;
    default: 
    sqlite3VdbeAddOp2(v, 50, (regNewData + 1) + i, ignoreDest);
    break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (pTab->pCheck) {
    if ((db->flags & 512ULL) == 0ULL) {
      pCheck = pTab->pCheck;
      pParse->iSelfTab = - (regNewData + 1);
      if ((int )overrideError != 11) {
        onError = (int )overrideError;
      } else {
        onError = 2;
      }
      i = 0;
      while (i < pCheck->nExpr) {
        pExpr = pCheck->a[i].pExpr;
        if (aiChng) {
          tmp___0 = sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, (int )pkChng);
          if (! tmp___0) {
            goto __Cont___0;
          }
        }
        allOk = sqlite3VdbeMakeLabel(pParse);
        sqlite3ExprIfTrue(pParse, pExpr, allOk, 16);
        if (onError == 4) {
          sqlite3VdbeGoto(v, ignoreDest);
        } else {
          zName = pCheck->a[i].zName;
          if ((unsigned long )zName == (unsigned long )((char *)0)) {
            zName = pTab->zName;
          }
          if (onError == 5) {
            onError = 2;
          }
          sqlite3HaltConstraint(pParse, 19 | (1 << 8), onError, zName, (i8 )0, (u8 )3);
        }
        sqlite3VdbeResolveLabel(v, allOk);
        __Cont___0: /* CIL Label */ 
        i ++;
      }
      pParse->iSelfTab = 0;
    }
  }
  if (pUpsert) {
    if ((unsigned long )pUpsert->pUpsertTarget == (unsigned long )((ExprList *)0)) {
      overrideError = (u8 )4;
      pUpsert = (Upsert *)0;
    } else {
      pUpIdx = pUpsert->pUpsertIdx;
      if ((unsigned long )pUpIdx != (unsigned long )((Index *)0)) {
        upsertJump = sqlite3VdbeAddOp0(v, 11);
      }
    }
  }
  if (pkChng) {
    if ((unsigned long )pPk == (unsigned long )((Index *)0)) {
      tmp___1 = sqlite3VdbeMakeLabel(pParse);
      addrRowidOk = tmp___1;
      onError = (int )pTab->keyConf;
      if ((int )overrideError != 11) {
        onError = (int )overrideError;
      } else
      if (onError == 11) {
        onError = 2;
      }
      if (pUpsert) {
        if ((unsigned long )pUpsert->pUpsertIdx == (unsigned long )((Index *)0)) {
          if ((unsigned long )pUpsert->pUpsertSet == (unsigned long )((ExprList *)0)) {
            onError = 4;
          } else {
            onError = 6;
          }
        }
      }
      if (onError == 5) {
        if (onError != (int )overrideError) {
          if (pTab->pIndex) {
            tmp___2 = sqlite3VdbeAddOp0(v, 11);
            ipkTop = tmp___2 + 1;
          }
        }
      }
      if (isUpdate) {
        sqlite3VdbeAddOp3(v, 53, regNewData, addrRowidOk, regOldData);
        sqlite3VdbeChangeP5(v, (u16 )144);
      }
      sqlite3VdbeAddOp3(v, 31, iDataCur, addrRowidOk, regNewData);
      switch (onError) {
      default: 
      onError = 2;
      case 3: 
      case 2: 
      case 1: 
      sqlite3RowidConstraint(pParse, onError, pTab);
      break;
      case 5: 
      pTrigger = (Trigger *)0;
      if (db->flags & 8192ULL) {
        pTrigger = sqlite3TriggersExist(pParse, pTab, 124, (ExprList *)0, (int *)0);
      }
      if (pTrigger) {
        sqlite3MultiWrite(pParse);
        sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regNewData,
                                 (i16 )1, (u8 )0, (u8 )5, (u8 )1, -1);
      } else {
        tmp___3 = sqlite3FkRequired(pParse, pTab, (int *)0, 0);
        if (tmp___3) {
          sqlite3MultiWrite(pParse);
          sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regNewData,
                                   (i16 )1, (u8 )0, (u8 )5, (u8 )1, -1);
        } else
        if (pTab->pIndex) {
          sqlite3MultiWrite(pParse);
          sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, (int *)0,
                                        -1);
        }
      }
      seenReplace = 1;
      break;
      case 6: 
      sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, (Index *)0, iDataCur);
      case 4: 
      sqlite3VdbeGoto(v, ignoreDest);
      break;
      }
      sqlite3VdbeResolveLabel(v, addrRowidOk);
      if (ipkTop) {
        ipkBottom = sqlite3VdbeAddOp0(v, 11);
        sqlite3VdbeJumpHere(v, ipkTop - 1);
      }
    }
  }
  ix = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (*(aRegIdx + ix) == 0) {
      goto __Cont___1;
    }
    if ((unsigned long )pUpIdx == (unsigned long )pIdx) {
      addrUniqueOk = upsertJump + 1;
      upsertBypass = sqlite3VdbeGoto(v, 0);
      sqlite3VdbeJumpHere(v, upsertJump);
    } else {
      addrUniqueOk = sqlite3VdbeMakeLabel(pParse);
    }
    if ((int )bAffinityDone == 0) {
      if ((unsigned long )pUpIdx == (unsigned long )((Index *)0)) {
        sqlite3TableAffinity(v, pTab, regNewData + 1);
        bAffinityDone = (u8 )1;
      } else
      if ((unsigned long )pUpIdx == (unsigned long )pIdx) {
        sqlite3TableAffinity(v, pTab, regNewData + 1);
        bAffinityDone = (u8 )1;
      }
    }
    iThisCur = iIdxCur + ix;
    if (pIdx->pPartIdxWhere) {
      sqlite3VdbeAddOp2(v, 73, 0, *(aRegIdx + ix));
      pParse->iSelfTab = - (regNewData + 1);
      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk, 16);
      pParse->iSelfTab = 0;
    }
    regIdx = *(aRegIdx + ix) + 1;
    i = 0;
    while (i < (int )pIdx->nColumn) {
      iField = (int )*(pIdx->aiColumn + i);
      if (iField == -2) {
        pParse->iSelfTab = - (regNewData + 1);
        sqlite3ExprCodeCopy(pParse, (pIdx->aColExpr)->a[i].pExpr, regIdx + i);
        pParse->iSelfTab = 0;
      } else {
        if (iField == -1) {
          x___0 = regNewData;
        } else
        if (iField == (int )pTab->iPKey) {
          x___0 = regNewData;
        } else {
          x___0 = (iField + regNewData) + 1;
        }
        if (iField < 0) {
          tmp___4 = 80;
        } else {
          tmp___4 = 79;
        }
        sqlite3VdbeAddOp2(v, tmp___4, x___0, regIdx + i);
      }
      i ++;
    }
    sqlite3VdbeAddOp3(v, 92, regIdx, (int )pIdx->nColumn, *(aRegIdx + ix));
    if (isUpdate) {
      if ((unsigned long )pPk == (unsigned long )pIdx) {
        if ((int )pkChng == 0) {
          sqlite3VdbeResolveLabel(v, addrUniqueOk);
          goto __Cont___1;
        }
      }
    }
    onError = (int )pIdx->onError;
    if (onError == 0) {
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      goto __Cont___1;
    }
    if ((int )overrideError != 11) {
      onError = (int )overrideError;
    } else
    if (onError == 11) {
      onError = 2;
    }
    if ((unsigned long )pUpIdx == (unsigned long )pIdx) {
      if ((unsigned long )pUpsert->pUpsertSet == (unsigned long )((ExprList *)0)) {
        onError = 4;
      } else {
        onError = 6;
      }
    }
    if (ix == 0) {
      if ((unsigned long )pIdx->pNext == (unsigned long )((Index *)0)) {
        if ((unsigned long )pPk == (unsigned long )pIdx) {
          if (onError == 5) {
            if (0ULL == (db->flags & 8192ULL)) {
              goto _L;
            } else {
              tmp___5 = sqlite3TriggersExist(pParse, pTab, 124, (ExprList *)0, (int *)0);
              if ((unsigned long )((Trigger *)0) == (unsigned long )tmp___5) {
                _L: /* CIL Label */ 
                if (0ULL == (db->flags & 16384ULL)) {
                  sqlite3VdbeResolveLabel(v, addrUniqueOk);
                  goto __Cont___1;
                } else
                if ((unsigned long )((FKey *)0) == (unsigned long )pTab->pFKey) {
                  tmp___6 = sqlite3FkReferences(pTab);
                  if ((unsigned long )((FKey *)0) == (unsigned long )tmp___6) {
                    sqlite3VdbeResolveLabel(v, addrUniqueOk);
                    goto __Cont___1;
                  }
                }
              }
            }
          }
        }
      }
    }
    sqlite3VdbeAddOp4Int(v, 27, iThisCur, addrUniqueOk, regIdx, (int )pIdx->nKeyCol);
    if ((unsigned long )pIdx == (unsigned long )pPk) {
      regR = regIdx;
    } else {
      tmp___7 = sqlite3GetTempRange(pParse, nPkField);
      regR = tmp___7;
    }
    if (isUpdate) {
      goto _L___0;
    } else
    if (onError == 5) {
      _L___0: /* CIL Label */ 
      if ((pTab->tabFlags & 32U) == 0U) {
        sqlite3VdbeAddOp2(v, 135, iThisCur, regR);
        if (isUpdate) {
          sqlite3VdbeAddOp3(v, 53, regR, addrUniqueOk, regOldData);
          sqlite3VdbeChangeP5(v, (u16 )144);
        }
      } else {
        if ((unsigned long )pIdx != (unsigned long )pPk) {
          i = 0;
          while (i < (int )pPk->nKeyCol) {
            tmp___8 = sqlite3ColumnOfIndex(pIdx, *(pPk->aiColumn + i));
            x___1 = (int )tmp___8;
            sqlite3VdbeAddOp3(v, 90, iThisCur, x___1, regR + i);
            i ++;
          }
        }
        if (isUpdate) {
          tmp___9 = sqlite3VdbeCurrentAddr(v);
          addrJump = tmp___9 + (int )pPk->nKeyCol;
          op = 52;
          if (pIdx->idxType == 2U) {
            tmp___10 = regIdx;
          } else {
            tmp___10 = regR;
          }
          regCmp = tmp___10;
          i = 0;
          while (i < (int )pPk->nKeyCol) {
            tmp___11 = sqlite3LocateCollSeq(pParse, *(pPk->azColl + i));
            p4 = (char *)tmp___11;
            x___1 = (int )*(pPk->aiColumn + i);
            if (i == (int )pPk->nKeyCol - 1) {
              addrJump = addrUniqueOk;
              op = 53;
            }
            sqlite3VdbeAddOp4(v, op, (regOldData + 1) + x___1, addrJump, regCmp + i,
                              (char const   *)p4, -2);
            sqlite3VdbeChangeP5(v, (u16 )144);
            i ++;
          }
        }
      }
    }
    switch (onError) {
    case 3: 
    case 2: 
    case 1: 
    sqlite3UniqueConstraint(pParse, onError, pIdx);
    break;
    case 6: 
    sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur + ix);
    case 4: 
    sqlite3VdbeGoto(v, ignoreDest);
    break;
    default: 
    pTrigger___0 = (Trigger *)0;
    if (db->flags & 8192ULL) {
      pTrigger___0 = sqlite3TriggersExist(pParse, pTab, 124, (ExprList *)0, (int *)0);
    }
    if (pTrigger___0) {
      sqlite3MultiWrite(pParse);
    } else {
      tmp___12 = sqlite3FkRequired(pParse, pTab, (int *)0, 0);
      if (tmp___12) {
        sqlite3MultiWrite(pParse);
      }
    }
    if ((unsigned long )pIdx == (unsigned long )pPk) {
      tmp___13 = 1;
    } else {
      tmp___13 = 0;
    }
    sqlite3GenerateRowDelete(pParse, pTab, pTrigger___0, iDataCur, iIdxCur, regR,
                             (i16 )nPkField, (u8 )0, (u8 )5, (u8 )tmp___13, iThisCur);
    seenReplace = 1;
    break;
    }
    if ((unsigned long )pUpIdx == (unsigned long )pIdx) {
      sqlite3VdbeGoto(v, upsertJump + 1);
      sqlite3VdbeJumpHere(v, upsertBypass);
    } else {
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
    }
    if (regR != regIdx) {
      sqlite3ReleaseTempRange(pParse, regR, nPkField);
    }
    __Cont___1: /* CIL Label */ 
    pIdx = pIdx->pNext;
    ix ++;
  }
  if (ipkTop) {
    sqlite3VdbeGoto(v, ipkTop);
    sqlite3VdbeJumpHere(v, ipkBottom);
  }
  if ((pTab->tabFlags & 32U) == 0U) {
    regRec = *(aRegIdx + ix);
    sqlite3VdbeAddOp3(v, 92, regNewData + 1, (int )pTab->nCol, regRec);
    if (! bAffinityDone) {
      sqlite3TableAffinity(v, pTab, 0);
    }
  }
  *pbMayReplace = seenReplace;
  return;
}
}
static void sqlite3CompleteInsertion(Parse *pParse , Table *pTab , int iDataCur ,
                                     int iIdxCur , int regNewData , int *aRegIdx ,
                                     int update_flags , int appendBias , int useSeekResult ) 
{ 
  Vdbe *v ;
  Index *pIdx ;
  u8 pik_flags ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  v = sqlite3GetVdbe(pParse);
  i = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (*(aRegIdx + i) == 0) {
      goto __Cont;
    }
    if (pIdx->pPartIdxWhere) {
      tmp = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 50, *(aRegIdx + i), tmp + 2);
    }
    if (useSeekResult) {
      pik_flags = (u8 )16;
    } else {
      pik_flags = (u8 )0;
    }
    if (pIdx->idxType == 2U) {
      if (! ((pTab->tabFlags & 32U) == 0U)) {
        pik_flags = (u8 )((int )pik_flags | 1);
        pik_flags = (u8 )((int )pik_flags | (update_flags & 2));
      }
    }
    if (pIdx->uniqNotNull) {
      tmp___0 = (int )pIdx->nKeyCol;
    } else {
      tmp___0 = (int )pIdx->nColumn;
    }
    sqlite3VdbeAddOp4Int(v, 132, iIdxCur + i, *(aRegIdx + i), *(aRegIdx + i) + 1,
                         tmp___0);
    sqlite3VdbeChangeP5(v, (u16 )pik_flags);
    __Cont: /* CIL Label */ 
    pIdx = pIdx->pNext;
    i ++;
  }
  if (! ((pTab->tabFlags & 32U) == 0U)) {
    return;
  }
  if (pParse->nested) {
    pik_flags = (u8 )0;
  } else {
    pik_flags = (u8 )1;
    if (update_flags) {
      tmp___1 = update_flags;
    } else {
      tmp___1 = 32;
    }
    pik_flags = (u8 )((int )pik_flags | tmp___1);
  }
  if (appendBias) {
    pik_flags = (u8 )((int )pik_flags | 8);
  }
  if (useSeekResult) {
    pik_flags = (u8 )((int )pik_flags | 16);
  }
  sqlite3VdbeAddOp3(v, 122, iDataCur, *(aRegIdx + i), regNewData);
  if (! pParse->nested) {
    sqlite3VdbeAppendP4(v, (void *)pTab, -6);
  }
  sqlite3VdbeChangeP5(v, (u16 )pik_flags);
  return;
}
}
static int sqlite3OpenTableAndIndices(Parse *pParse , Table *pTab , int op , u8 p5 ,
                                      int iBase , u8 *aToOpen , int *piDataCur , int *piIdxCur ) 
{ 
  int i ;
  int iDb ;
  int iDataCur ;
  Index *pIdx ;
  Vdbe *v ;
  int tmp ;
  int iIdxCur ;
  int tmp___0 ;

  {
  if (pTab->nModuleArg) {
    return (0);
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  v = sqlite3GetVdbe(pParse);
  if (iBase < 0) {
    iBase = pParse->nTab;
  }
  tmp = iBase;
  iBase ++;
  iDataCur = tmp;
  if (piDataCur) {
    *piDataCur = iDataCur;
  }
  if ((pTab->tabFlags & 32U) == 0U) {
    if ((unsigned long )aToOpen == (unsigned long )((u8 *)0)) {
      sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);
    } else
    if (*(aToOpen + 0)) {
      sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);
    } else {
      sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )(op == 98), (char const   *)pTab->zName);
    }
  } else {
    sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )(op == 98), (char const   *)pTab->zName);
  }
  if (piIdxCur) {
    *piIdxCur = iBase;
  }
  i = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    tmp___0 = iBase;
    iBase ++;
    iIdxCur = tmp___0;
    if (pIdx->idxType == 2U) {
      if (! ((pTab->tabFlags & 32U) == 0U)) {
        if (piDataCur) {
          *piDataCur = iIdxCur;
        }
        p5 = (u8 )0;
      }
    }
    if ((unsigned long )aToOpen == (unsigned long )((u8 *)0)) {
      sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      sqlite3VdbeChangeP5(v, (u16 )p5);
    } else
    if (*(aToOpen + (i + 1))) {
      sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      sqlite3VdbeChangeP5(v, (u16 )p5);
    }
    pIdx = pIdx->pNext;
    i ++;
  }
  if (iBase > pParse->nTab) {
    pParse->nTab = iBase;
  }
  return (i);
}
}
static int xferCompatibleIndex(Index *pDest , Index *pSrc ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )pDest->nKeyCol != (int )pSrc->nKeyCol) {
    return (0);
  }
  if ((int )pDest->onError != (int )pSrc->onError) {
    return (0);
  }
  i = 0;
  while (i < (int )pSrc->nKeyCol) {
    if ((int )*(pSrc->aiColumn + i) != (int )*(pDest->aiColumn + i)) {
      return (0);
    }
    if ((int )*(pSrc->aiColumn + i) == -2) {
      tmp = sqlite3ExprCompare((Parse *)0, (pSrc->aColExpr)->a[i].pExpr, (pDest->aColExpr)->a[i].pExpr,
                               -1);
      if (tmp != 0) {
        return (0);
      }
    }
    if ((int )*(pSrc->aSortOrder + i) != (int )*(pDest->aSortOrder + i)) {
      return (0);
    }
    tmp___0 = sqlite3_stricmp(*(pSrc->azColl + i), *(pDest->azColl + i));
    if (tmp___0 != 0) {
      return (0);
    }
    i ++;
  }
  tmp___1 = sqlite3ExprCompare((Parse *)0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere,
                               -1);
  if (tmp___1) {
    return (0);
  }
  return (1);
}
}
static int xferOptimization(Parse *pParse , Table *pDest , Select *pSelect , int onError ,
                            int iDbDest ) 
{ 
  sqlite3 *db ;
  ExprList *pEList ;
  Table *pSrc ;
  Index *pSrcIdx ;
  Index *pDestIdx ;
  struct SrcList_item *pItem ;
  int i ;
  int iDbSrc ;
  int iSrc ;
  int iDest ;
  int addr1 ;
  int addr2 ;
  int emptyDestTest ;
  int emptySrcTest ;
  Vdbe *v ;
  int regAutoinc ;
  int destHasUniqueIdx ;
  int regData ;
  int regRowid ;
  Trigger *tmp ;
  Column *pDestCol ;
  Column *pSrcCol ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u8 insFlags ;
  u8 idxInsFlags ;
  int tmp___7 ;
  char const   *zColl ;
  int tmp___8 ;

  {
  db = pParse->db;
  emptyDestTest = 0;
  emptySrcTest = 0;
  destHasUniqueIdx = 0;
  if ((unsigned long )pSelect == (unsigned long )((Select *)0)) {
    return (0);
  }
  if (pParse->pWith) {
    return (0);
  } else
  if (pSelect->pWith) {
    return (0);
  }
  tmp = sqlite3TriggerList(pParse, pDest);
  if (tmp) {
    return (0);
  }
  if (pDest->nModuleArg) {
    return (0);
  }
  if (onError == 11) {
    if ((int )pDest->iPKey >= 0) {
      onError = (int )pDest->keyConf;
    }
    if (onError == 11) {
      onError = 2;
    }
  }
  if ((pSelect->pSrc)->nSrc != 1) {
    return (0);
  }
  if ((pSelect->pSrc)->a[0].pSelect) {
    return (0);
  }
  if (pSelect->pWhere) {
    return (0);
  }
  if (pSelect->pOrderBy) {
    return (0);
  }
  if (pSelect->pGroupBy) {
    return (0);
  }
  if (pSelect->pLimit) {
    return (0);
  }
  if (pSelect->pPrior) {
    return (0);
  }
  if (pSelect->selFlags & 1U) {
    return (0);
  }
  pEList = pSelect->pEList;
  if (pEList->nExpr != 1) {
    return (0);
  }
  if ((int )(pEList->a[0].pExpr)->op != 175) {
    return (0);
  }
  pItem = (pSelect->pSrc)->a;
  pSrc = sqlite3LocateTableItem(pParse, (u32 )0, pItem);
  if ((unsigned long )pSrc == (unsigned long )((Table *)0)) {
    return (0);
  }
  if (pSrc->tnum == pDest->tnum) {
    if ((unsigned long )pSrc->pSchema == (unsigned long )pDest->pSchema) {
      return (0);
    }
  }
  if (((pDest->tabFlags & 32U) == 0U) != ((pSrc->tabFlags & 32U) == 0U)) {
    return (0);
  }
  if (pSrc->nModuleArg) {
    return (0);
  }
  if (pSrc->pSelect) {
    return (0);
  }
  if ((int )pDest->nCol != (int )pSrc->nCol) {
    return (0);
  }
  if ((int )pDest->iPKey != (int )pSrc->iPKey) {
    return (0);
  }
  i = 0;
  while (i < (int )pDest->nCol) {
    pDestCol = pDest->aCol + i;
    pSrcCol = pSrc->aCol + i;
    if ((int )pDestCol->affinity != (int )pSrcCol->affinity) {
      return (0);
    }
    tmp___0 = sqlite3_stricmp((char const   *)pDestCol->zColl, (char const   *)pSrcCol->zColl);
    if (tmp___0 != 0) {
      return (0);
    }
    if (pDestCol->notNull) {
      if (! pSrcCol->notNull) {
        return (0);
      }
    }
    if (i > 0) {
      if (((unsigned long )pDestCol->pDflt == (unsigned long )((Expr *)0)) != ((unsigned long )pSrcCol->pDflt == (unsigned long )((Expr *)0))) {
        return (0);
      } else
      if (pDestCol->pDflt) {
        tmp___1 = strcmp((char const   *)(pDestCol->pDflt)->u.zToken, (char const   *)(pSrcCol->pDflt)->u.zToken);
        if (tmp___1 != 0) {
          return (0);
        }
      }
    }
    i ++;
  }
  pDestIdx = pDest->pIndex;
  while (pDestIdx) {
    if ((int )pDestIdx->onError != 0) {
      destHasUniqueIdx = 1;
    }
    pSrcIdx = pSrc->pIndex;
    while (pSrcIdx) {
      tmp___2 = xferCompatibleIndex(pDestIdx, pSrcIdx);
      if (tmp___2) {
        break;
      }
      pSrcIdx = pSrcIdx->pNext;
    }
    if ((unsigned long )pSrcIdx == (unsigned long )((Index *)0)) {
      return (0);
    }
    if (pSrcIdx->tnum == pDestIdx->tnum) {
      if ((unsigned long )pSrc->pSchema == (unsigned long )pDest->pSchema) {
        tmp___3 = sqlite3FaultSim(411);
        if (tmp___3 == 0) {
          return (0);
        }
      }
    }
    pDestIdx = pDestIdx->pNext;
  }
  if (pDest->pCheck) {
    tmp___4 = sqlite3ExprListCompare(pSrc->pCheck, pDest->pCheck, -1);
    if (tmp___4) {
      return (0);
    }
  }
  if ((db->flags & 16384ULL) != 0ULL) {
    if ((unsigned long )pDest->pFKey != (unsigned long )((FKey *)0)) {
      return (0);
    }
  }
  if ((db->flags & 128ULL) != 0ULL) {
    return (0);
  }
  iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);
  v = sqlite3GetVdbe(pParse);
  sqlite3CodeVerifySchema(pParse, iDbSrc);
  tmp___5 = pParse->nTab;
  (pParse->nTab) ++;
  iSrc = tmp___5;
  tmp___6 = pParse->nTab;
  (pParse->nTab) ++;
  iDest = tmp___6;
  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);
  regData = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, 98);
  if ((db->mDbFlags & 4U) == 0U) {
    if ((int )pDest->iPKey < 0) {
      if ((unsigned long )pDest->pIndex != (unsigned long )((Index *)0)) {
        addr1 = sqlite3VdbeAddOp2(v, 36, iDest, 0);
        emptyDestTest = sqlite3VdbeAddOp0(v, 11);
        sqlite3VdbeJumpHere(v, addr1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (destHasUniqueIdx) {
      addr1 = sqlite3VdbeAddOp2(v, 36, iDest, 0);
      emptyDestTest = sqlite3VdbeAddOp0(v, 11);
      sqlite3VdbeJumpHere(v, addr1);
    } else
    if (onError != 2) {
      if (onError != 1) {
        addr1 = sqlite3VdbeAddOp2(v, 36, iDest, 0);
        emptyDestTest = sqlite3VdbeAddOp0(v, 11);
        sqlite3VdbeJumpHere(v, addr1);
      }
    }
  }
  if ((pSrc->tabFlags & 32U) == 0U) {
    sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, 97);
    emptySrcTest = sqlite3VdbeAddOp2(v, 36, iSrc, 0);
    if ((int )pDest->iPKey >= 0) {
      addr1 = sqlite3VdbeAddOp2(v, 128, iSrc, regRowid);
      addr2 = sqlite3VdbeAddOp3(v, 31, iDest, 0, regRowid);
      sqlite3RowidConstraint(pParse, onError, pDest);
      sqlite3VdbeJumpHere(v, addr2);
      autoIncStep(pParse, regAutoinc, regRowid);
    } else
    if ((unsigned long )pDest->pIndex == (unsigned long )((Index *)0)) {
      if (! (db->mDbFlags & 8U)) {
        addr1 = sqlite3VdbeAddOp2(v, 121, iDest, regRowid);
      } else {
        addr1 = sqlite3VdbeAddOp2(v, 128, iSrc, regRowid);
      }
    } else {
      addr1 = sqlite3VdbeAddOp2(v, 128, iSrc, regRowid);
    }
    sqlite3VdbeAddOp3(v, 127, iSrc, regData, 1);
    if (db->mDbFlags & 4U) {
      sqlite3VdbeAddOp1(v, 130, iDest);
      insFlags = (u8 )57;
    } else {
      insFlags = (u8 )41;
    }
    sqlite3VdbeAddOp4(v, 122, iDest, regData, regRowid, (char const   *)((char *)pDest),
                      -6);
    sqlite3VdbeChangeP5(v, (u16 )insFlags);
    sqlite3VdbeAddOp2(v, 5, iSrc, addr1);
    sqlite3VdbeAddOp2(v, 117, iSrc, 0);
    sqlite3VdbeAddOp2(v, 117, iDest, 0);
  } else {
    sqlite3TableLock(pParse, iDbDest, pDest->tnum, (u8 )1, (char const   *)pDest->zName);
    sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, (u8 )0, (char const   *)pSrc->zName);
  }
  pDestIdx = pDest->pIndex;
  while (pDestIdx) {
    idxInsFlags = (u8 )0;
    pSrcIdx = pSrc->pIndex;
    while (pSrcIdx) {
      tmp___7 = xferCompatibleIndex(pDestIdx, pSrcIdx);
      if (tmp___7) {
        break;
      }
      pSrcIdx = pSrcIdx->pNext;
    }
    sqlite3VdbeAddOp3(v, 97, iSrc, pSrcIdx->tnum, iDbSrc);
    sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
    sqlite3VdbeAddOp3(v, 98, iDest, pDestIdx->tnum, iDbDest);
    sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
    sqlite3VdbeChangeP5(v, (u16 )1);
    addr1 = sqlite3VdbeAddOp2(v, 36, iSrc, 0);
    sqlite3VdbeAddOp3(v, 127, iSrc, regData, 1);
    if (db->mDbFlags & 4U) {
      i = 0;
      while (i < (int )pSrcIdx->nColumn) {
        zColl = *(pSrcIdx->azColl + i);
        tmp___8 = sqlite3_stricmp(sqlite3StrBINARY, zColl);
        if (tmp___8) {
          break;
        }
        i ++;
      }
      if (i == (int )pSrcIdx->nColumn) {
        idxInsFlags = (u8 )16;
        sqlite3VdbeAddOp1(v, 130, iDest);
      }
    }
    if (! ((pSrc->tabFlags & 32U) == 0U)) {
      if (pDestIdx->idxType == 2U) {
        idxInsFlags = (u8 )((int )idxInsFlags | 1);
      }
    }
    sqlite3VdbeAddOp2(v, 132, iDest, regData);
    sqlite3VdbeChangeP5(v, (u16 )((int )idxInsFlags | 8));
    sqlite3VdbeAddOp2(v, 5, iSrc, addr1 + 1);
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp2(v, 117, iSrc, 0);
    sqlite3VdbeAddOp2(v, 117, iDest, 0);
    pDestIdx = pDestIdx->pNext;
  }
  if (emptySrcTest) {
    sqlite3VdbeJumpHere(v, emptySrcTest);
  }
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regData);
  if (emptyDestTest) {
    sqlite3AutoincrementEnd(pParse);
    sqlite3VdbeAddOp2(v, 69, 0, 0);
    sqlite3VdbeJumpHere(v, emptyDestTest);
    sqlite3VdbeAddOp2(v, 117, iDest, 0);
    return (0);
  } else {
    return (1);
  }
}
}
int sqlite3_exec(sqlite3 *db , char const   *zSql , int (*xCallback)(void * , int  ,
                                                                     char ** , char ** ) ,
                 void *pArg , char **pzErrMsg ) 
{ 
  int rc ;
  char const   *zLeftover ;
  sqlite3_stmt *pStmt ;
  char **azCols ;
  int callbackIsInit ;
  int tmp ;
  int tmp___0 ;
  int nCol ;
  char **azVals ;
  int i ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
  rc = 0;
  pStmt = (sqlite3_stmt *)0;
  azCols = (char **)0;
  tmp___0 = sqlite3SafetyCheckOk(db);
  if (! tmp___0) {
    tmp = sqlite3MisuseError(119887);
    return (tmp);
  }
  if ((unsigned long )zSql == (unsigned long )((char const   *)0)) {
    zSql = "";
  }
  sqlite3Error(db, 0);
  while (1) {
    if (rc == 0) {
      if (! *(zSql + 0)) {
        break;
      }
    } else {
      break;
    }
    nCol = 0;
    azVals = (char **)0;
    pStmt = (sqlite3_stmt *)0;
    rc = sqlite3_prepare_v2(db, zSql, -1, & pStmt, & zLeftover);
    if (rc != 0) {
      continue;
    }
    if (! pStmt) {
      zSql = zLeftover;
      continue;
    }
    callbackIsInit = 0;
    while (1) {
      rc = sqlite3_step(pStmt);
      if (xCallback) {
        if (100 == rc) {
          goto _L;
        } else
        if (101 == rc) {
          if (! callbackIsInit) {
            if (db->flags & 256ULL) {
              _L: /* CIL Label */ 
              if (! callbackIsInit) {
                nCol = sqlite3_column_count(pStmt);
                tmp___1 = sqlite3DbMallocRaw(db, (u64 )((unsigned long )(2 * nCol + 1) * sizeof(char const   *)));
                azCols = (char **)tmp___1;
                if ((unsigned long )azCols == (unsigned long )((char **)0)) {
                  goto exec_out;
                }
                i = 0;
                while (i < nCol) {
                  tmp___2 = sqlite3_column_name(pStmt, i);
                  *(azCols + i) = (char *)tmp___2;
                  i ++;
                }
                callbackIsInit = 1;
              }
              if (rc == 100) {
                azVals = azCols + nCol;
                i = 0;
                while (i < nCol) {
                  tmp___3 = sqlite3_column_text(pStmt, i);
                  *(azVals + i) = (char *)tmp___3;
                  if (! *(azVals + i)) {
                    tmp___4 = sqlite3_column_type(pStmt, i);
                    if (tmp___4 != 5) {
                      sqlite3OomFault(db);
                      goto exec_out;
                    }
                  }
                  i ++;
                }
                *(azVals + i) = (char *)0;
              }
              tmp___5 = (*xCallback)(pArg, nCol, azVals, azCols);
              if (tmp___5) {
                rc = 4;
                sqlite3VdbeFinalize((Vdbe *)pStmt);
                pStmt = (sqlite3_stmt *)0;
                sqlite3Error(db, 4);
                goto exec_out;
              }
            }
          }
        }
      }
      if (rc != 100) {
        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);
        pStmt = (sqlite3_stmt *)0;
        zSql = zLeftover;
        while ((int const   )sqlite3CtypeMap[(unsigned char )*(zSql + 0)] & 1) {
          zSql ++;
        }
        break;
      }
    }
    sqlite3DbFree(db, (void *)azCols);
    azCols = (char **)0;
  }
  exec_out: 
  if (pStmt) {
    sqlite3VdbeFinalize((Vdbe *)pStmt);
  }
  sqlite3DbFree(db, (void *)azCols);
  rc = sqlite3ApiExit(db, rc);
  if (rc != 0) {
    if (pzErrMsg) {
      tmp___6 = sqlite3_errmsg(db);
      *pzErrMsg = sqlite3DbStrDup((sqlite3 *)0, tmp___6);
      if ((unsigned long )*pzErrMsg == (unsigned long )((char *)0)) {
        rc = 7;
        sqlite3Error(db, 7);
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (pzErrMsg) {
    *pzErrMsg = (char *)0;
  }
  return (rc);
}
}
static struct sqlite3AutoExtList sqlite3Autoext  =    {(u32 )0, (void (**)(void))0};
int sqlite3_auto_extension(void (*xInit)(void) ) 
{ 
  int rc ;
  u32 i ;
  u64 nByte ;
  void (**aNew)(void) ;
  void *tmp ;

  {
  rc = 0;
  rc = sqlite3_initialize();
  if (rc) {
    return (rc);
  } else {
    i = (u32 )0;
    while (i < sqlite3Autoext.nExt) {
      if ((unsigned long )*(sqlite3Autoext.aExt + i) == (unsigned long )xInit) {
        break;
      }
      i ++;
    }
    if (i == sqlite3Autoext.nExt) {
      nByte = (u64 )((unsigned long )(sqlite3Autoext.nExt + 1U) * sizeof(*(sqlite3Autoext.aExt + 0)));
      tmp = sqlite3_realloc64((void *)sqlite3Autoext.aExt, nByte);
      aNew = (void (**)(void))tmp;
      if ((unsigned long )aNew == (unsigned long )((void (**)(void))0)) {
        rc = 7;
      } else {
        sqlite3Autoext.aExt = aNew;
        *(sqlite3Autoext.aExt + sqlite3Autoext.nExt) = xInit;
        (sqlite3Autoext.nExt) ++;
      }
    }
    return (rc);
  }
}
}
int sqlite3_cancel_auto_extension(void (*xInit)(void) ) 
{ 
  int i ;
  int n ;

  {
  n = 0;
  i = (int )sqlite3Autoext.nExt - 1;
  while (i >= 0) {
    if ((unsigned long )*(sqlite3Autoext.aExt + i) == (unsigned long )xInit) {
      (sqlite3Autoext.nExt) --;
      *(sqlite3Autoext.aExt + i) = *(sqlite3Autoext.aExt + sqlite3Autoext.nExt);
      n ++;
      break;
    }
    i --;
  }
  return (n);
}
}
void sqlite3_reset_auto_extension(void) 
{ 
  int tmp ;

  {
  tmp = sqlite3_initialize();
  if (tmp == 0) {
    sqlite3_free((void *)sqlite3Autoext.aExt);
    sqlite3Autoext.aExt = (void (**)(void))0;
    sqlite3Autoext.nExt = (u32 )0;
  }
  return;
}
}
static void sqlite3AutoLoadExtensions(sqlite3 *db ) 
{ 
  u32 i ;
  int go ;
  int rc ;
  int (*xInit)(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pThunk ) ;
  char *zErrmsg ;
  sqlite3_api_routines const   *pThunk ;

  {
  go = 1;
  if (sqlite3Autoext.nExt == 0U) {
    return;
  }
  i = (u32 )0;
  while (go) {
    pThunk = (sqlite3_api_routines const   *)0;
    if (i >= sqlite3Autoext.nExt) {
      xInit = (int (*)(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pThunk ))0;
      go = 0;
    } else {
      xInit = (int (*)(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pThunk ))*(sqlite3Autoext.aExt + i);
    }
    zErrmsg = (char *)0;
    if (xInit) {
      rc = (*xInit)(db, & zErrmsg, pThunk);
      if (rc != 0) {
        sqlite3ErrorWithMsg(db, rc, "automatic extension loading failed: %s", zErrmsg);
        go = 0;
      }
    }
    sqlite3_free((void *)zErrmsg);
    i ++;
  }
  return;
}
}
static char const   * const  pragCName[47]  = 
  {      (char const   * const  )"id",      (char const   * const  )"seq",      (char const   * const  )"table",      (char const   * const  )"from", 
        (char const   * const  )"to",      (char const   * const  )"on_update",      (char const   * const  )"on_delete",      (char const   * const  )"match", 
        (char const   * const  )"cid",      (char const   * const  )"name",      (char const   * const  )"type",      (char const   * const  )"notnull", 
        (char const   * const  )"dflt_value",      (char const   * const  )"pk",      (char const   * const  )"hidden",      (char const   * const  )"seqno", 
        (char const   * const  )"cid",      (char const   * const  )"name",      (char const   * const  )"desc",      (char const   * const  )"coll", 
        (char const   * const  )"key",      (char const   * const  )"tbl",      (char const   * const  )"idx",      (char const   * const  )"wdth", 
        (char const   * const  )"hght",      (char const   * const  )"flgs",      (char const   * const  )"seq",      (char const   * const  )"name", 
        (char const   * const  )"unique",      (char const   * const  )"origin",      (char const   * const  )"partial",      (char const   * const  )"table", 
        (char const   * const  )"rowid",      (char const   * const  )"parent",      (char const   * const  )"fkid",      (char const   * const  )"seq", 
        (char const   * const  )"name",      (char const   * const  )"file",      (char const   * const  )"busy",      (char const   * const  )"log", 
        (char const   * const  )"checkpointed",      (char const   * const  )"name",      (char const   * const  )"builtin",      (char const   * const  )"database", 
        (char const   * const  )"status",      (char const   * const  )"cache_size",      (char const   * const  )"timeout"};
static PragmaName const   aPragmaName[63]  = 
  {      {(char const   * const  )"application_id", (u8 )0, (u8 )20, (u8 )0, (u8 )0, (u64 )8}, 
        {(char const   * const  )"auto_vacuum",
      (u8 )1, (u8 )149, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"automatic_index", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )32768}, 
        {(char const   * const  )"busy_timeout", (u8 )3, (u8 )16, (u8 )46, (u8 )1, (u64 )0}, 
        {(char const   * const  )"cache_size",
      (u8 )4, (u8 )149, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"cache_spill", (u8 )5, (u8 )148, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"case_sensitive_like",
      (u8 )6, (u8 )2, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"cell_size_check", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )2097152}, 
        {(char const   * const  )"checkpoint_fullfsync", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )16}, 
        {(char const   * const  )"collation_list", (u8 )7, (u8 )16, (u8 )26, (u8 )2,
      (u64 )0}, 
        {(char const   * const  )"compile_options", (u8 )8, (u8 )16, (u8 )0, (u8 )0,
      (u64 )0}, 
        {(char const   * const  )"count_changes", (u8 )2, (u8 )20, (u8 )0, (u8 )0, (u64 )128}, 
        {(char const   * const  )"data_version",
      (u8 )0, (u8 )24, (u8 )0, (u8 )0, (u64 )15}, 
        {(char const   * const  )"database_list", (u8 )10, (u8 )17, (u8 )35, (u8 )3,
      (u64 )0}, 
        {(char const   * const  )"default_cache_size", (u8 )11, (u8 )149, (u8 )45, (u8 )1,
      (u64 )0}, 
        {(char const   * const  )"defer_foreign_keys", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )524288}, 
        {(char const   * const  )"empty_result_callbacks", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )256}, 
        {(char const   * const  )"encoding", (u8 )12, (u8 )20, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"foreign_key_check",
      (u8 )13, (u8 )17, (u8 )31, (u8 )4, (u64 )0}, 
        {(char const   * const  )"foreign_key_list", (u8 )14, (u8 )97, (u8 )0, (u8 )8,
      (u64 )0}, 
        {(char const   * const  )"foreign_keys", (u8 )2, (u8 )20, (u8 )0, (u8 )0, (u64 )16384}, 
        {(char const   * const  )"freelist_count",
      (u8 )0, (u8 )24, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"full_column_names", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )4}, 
        {(char const   * const  )"fullfsync", (u8 )2, (u8 )20, (u8 )0, (u8 )0, (u64 )8}, 
        {(char const   * const  )"function_list",
      (u8 )15, (u8 )16, (u8 )41, (u8 )2, (u64 )0}, 
        {(char const   * const  )"ignore_check_constraints", (u8 )2, (u8 )20, (u8 )0,
      (u8 )0, (u64 )512}, 
        {(char const   * const  )"incremental_vacuum", (u8 )16, (u8 )3, (u8 )0, (u8 )0,
      (u64 )0}, 
        {(char const   * const  )"index_info", (u8 )17, (u8 )97, (u8 )15, (u8 )3, (u64 )0}, 
        {(char const   * const  )"index_list",
      (u8 )18, (u8 )97, (u8 )26, (u8 )5, (u64 )0}, 
        {(char const   * const  )"index_xinfo", (u8 )17, (u8 )97, (u8 )15, (u8 )6, (u64 )1}, 
        {(char const   * const  )"integrity_check",
      (u8 )19, (u8 )49, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"journal_mode", (u8 )20, (u8 )145, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"journal_size_limit",
      (u8 )21, (u8 )144, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"legacy_alter_table", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )67108864}, 
        {(char const   * const  )"legacy_file_format", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )2}, 
        {(char const   * const  )"locking_mode", (u8 )23, (u8 )144, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"max_page_count",
      (u8 )24, (u8 )145, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"mmap_size", (u8 )25, (u8 )0, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"module_list",
      (u8 )26, (u8 )16, (u8 )9, (u8 )1, (u64 )0}, 
        {(char const   * const  )"optimize", (u8 )27, (u8 )33, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"page_count",
      (u8 )24, (u8 )145, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"page_size", (u8 )28, (u8 )148, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"pragma_list",
      (u8 )29, (u8 )16, (u8 )9, (u8 )1, (u64 )0}, 
        {(char const   * const  )"query_only", (u8 )2, (u8 )20, (u8 )0, (u8 )0, (u64 )1048576}, 
        {(char const   * const  )"quick_check",
      (u8 )19, (u8 )49, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"read_uncommitted", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )1024}, 
        {(char const   * const  )"recursive_triggers", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )8192}, 
        {(char const   * const  )"reverse_unordered_selects", (u8 )2, (u8 )20, (u8 )0,
      (u8 )0, (u64 )4096}, 
        {(char const   * const  )"schema_version", (u8 )0, (u8 )20, (u8 )0, (u8 )0, (u64 )1}, 
        {(char const   * const  )"secure_delete",
      (u8 )30, (u8 )16, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"short_column_names", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )64}, 
        {(char const   * const  )"shrink_memory", (u8 )31, (u8 )2, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"soft_heap_limit",
      (u8 )32, (u8 )16, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"synchronous", (u8 )33, (u8 )149, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"table_info",
      (u8 )34, (u8 )97, (u8 )8, (u8 )6, (u64 )0}, 
        {(char const   * const  )"table_xinfo", (u8 )34, (u8 )97, (u8 )8, (u8 )7, (u64 )1}, 
        {(char const   * const  )"temp_store",
      (u8 )35, (u8 )20, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"temp_store_directory", (u8 )36, (u8 )4, (u8 )0, (u8 )0,
      (u64 )0}, 
        {(char const   * const  )"threads", (u8 )37, (u8 )16, (u8 )0, (u8 )0, (u64 )0}, 
        {(char const   * const  )"user_version",
      (u8 )0, (u8 )20, (u8 )0, (u8 )0, (u64 )6}, 
        {(char const   * const  )"wal_autocheckpoint", (u8 )38, (u8 )0, (u8 )0, (u8 )0,
      (u64 )0}, 
        {(char const   * const  )"wal_checkpoint", (u8 )39, (u8 )1, (u8 )38, (u8 )3,
      (u64 )0}, 
        {(char const   * const  )"writable_schema", (u8 )2, (u8 )20, (u8 )0, (u8 )0,
      (u64 )134217729}};
static u8 getSafetyLevel(char const   *z , int omitFull , u8 dflt ) ;
static char const   zText[25]  = 
  {      (char const   )'o',      (char const   )'n',      (char const   )'o',      (char const   )'f', 
        (char const   )'f',      (char const   )'a',      (char const   )'l',      (char const   )'s', 
        (char const   )'e',      (char const   )'y',      (char const   )'e',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'u',      (char const   )'e', 
        (char const   )'x',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'f',      (char const   )'u',      (char const   )'l',      (char const   )'l', 
        (char const   )'\000'};
static u8 const   iOffset[8]  = 
  {      (u8 const   )0,      (u8 const   )1,      (u8 const   )2,      (u8 const   )4, 
        (u8 const   )9,      (u8 const   )12,      (u8 const   )15,      (u8 const   )20};
static u8 const   iLength[8]  = 
  {      (u8 const   )2,      (u8 const   )2,      (u8 const   )3,      (u8 const   )5, 
        (u8 const   )3,      (u8 const   )4,      (u8 const   )5,      (u8 const   )4};
static u8 const   iValue[8]  = 
  {      (u8 const   )1,      (u8 const   )0,      (u8 const   )0,      (u8 const   )0, 
        (u8 const   )1,      (u8 const   )1,      (u8 const   )3,      (u8 const   )2};
static u8 getSafetyLevel(char const   *z , int omitFull , u8 dflt ) 
{ 
  int i ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
  if ((int const   )sqlite3CtypeMap[(unsigned char )*z] & 4) {
    tmp = sqlite3Atoi(z);
    return ((u8 )tmp);
  }
  n = sqlite3Strlen30(z);
  i = 0;
  while (i < (int )(sizeof(iLength) / sizeof(iLength[0]))) {
    if ((int const   )iLength[i] == (int const   )n) {
      tmp___0 = sqlite3_strnicmp(& zText[iOffset[i]], z, n);
      if (tmp___0 == 0) {
        if (! omitFull) {
          return ((u8 )iValue[i]);
        } else
        if ((int const   )iValue[i] <= 1) {
          return ((u8 )iValue[i]);
        }
      }
    }
    i ++;
  }
  return (dflt);
}
}
static u8 sqlite3GetBoolean(char const   *z , u8 dflt ) 
{ 
  u8 tmp ;

  {
  tmp = getSafetyLevel(z, 1, dflt);
  return ((u8 )((int )tmp != 0));
}
}
static int getLockingMode(char const   *z ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (z) {
    tmp = sqlite3StrICmp(z, "exclusive");
    if (0 == tmp) {
      return (1);
    }
    tmp___0 = sqlite3StrICmp(z, "normal");
    if (0 == tmp___0) {
      return (0);
    }
  }
  return (-1);
}
}
static int getAutoVacuum(char const   *z ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = sqlite3StrICmp(z, "none");
  if (0 == tmp) {
    return (0);
  }
  tmp___0 = sqlite3StrICmp(z, "full");
  if (0 == tmp___0) {
    return (1);
  }
  tmp___1 = sqlite3StrICmp(z, "incremental");
  if (0 == tmp___1) {
    return (2);
  }
  i = sqlite3Atoi(z);
  if (i >= 0) {
    if (i <= 2) {
      tmp___2 = i;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return ((int )((u8 )tmp___2));
}
}
static int getTempStore(char const   *z ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int const   )*(z + 0) >= 48) {
    if ((int const   )*(z + 0) <= 50) {
      return ((int )((int const   )*(z + 0) - 48));
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___0 = sqlite3StrICmp(z, "file");
    if (tmp___0 == 0) {
      return (1);
    } else {
      tmp = sqlite3StrICmp(z, "memory");
      if (tmp == 0) {
        return (2);
      } else {
        return (0);
      }
    }
  }
}
}
static int invalidateTempStorage(Parse *pParse ) 
{ 
  sqlite3 *db ;
  int tmp ;

  {
  db = pParse->db;
  if ((unsigned long )(db->aDb + 1)->pBt != (unsigned long )((Btree *)0)) {
    if (! db->autoCommit) {
      sqlite3ErrorMsg(pParse, "temporary storage cannot be changed from within a transaction");
      return (1);
    } else {
      tmp = sqlite3BtreeIsInReadTrans((db->aDb + 1)->pBt);
      if (tmp) {
        sqlite3ErrorMsg(pParse, "temporary storage cannot be changed from within a transaction");
        return (1);
      }
    }
    sqlite3BtreeClose((db->aDb + 1)->pBt);
    (db->aDb + 1)->pBt = (Btree *)0;
    sqlite3ResetAllSchemasOfConnection(db);
  }
  return (0);
}
}
static int changeTempStorage(Parse *pParse , char const   *zStorageType ) 
{ 
  int ts ;
  int tmp ;
  sqlite3 *db ;
  int tmp___0 ;

  {
  tmp = getTempStore(zStorageType);
  ts = tmp;
  db = pParse->db;
  if ((int )db->temp_store == ts) {
    return (0);
  }
  tmp___0 = invalidateTempStorage(pParse);
  if (tmp___0 != 0) {
    return (1);
  }
  db->temp_store = (u8 )ts;
  return (0);
}
}
static void setPragmaResultColumnNames(Vdbe *v , PragmaName const   *pPragma ) 
{ 
  u8 n ;
  int tmp ;
  int i ;
  int j ;

  {
  n = (u8 )pPragma->nPragCName;
  if ((int )n == 0) {
    tmp = 1;
  } else {
    tmp = (int )n;
  }
  sqlite3VdbeSetNumCols(v, tmp);
  if ((int )n == 0) {
    sqlite3VdbeSetColName(v, 0, 0, (char const   *)pPragma->zName, (void (*)(void * ))0);
  } else {
    i = 0;
    j = (int )pPragma->iPragCName;
    while (i < (int )n) {
      sqlite3VdbeSetColName(v, i, 0, (char const   *)pragCName[j], (void (*)(void * ))0);
      i ++;
      j ++;
    }
  }
  return;
}
}
static void returnSingleInt(Vdbe *v , i64 value ) 
{ 


  {
  sqlite3VdbeAddOp4Dup8(v, 71, 0, 1, 0, (u8 const   *)(& value), -14);
  sqlite3VdbeAddOp2(v, 81, 1, 1);
  return;
}
}
static void returnSingleText(Vdbe *v , char const   *zValue ) 
{ 


  {
  if (zValue) {
    sqlite3VdbeLoadString(v, 1, zValue);
    sqlite3VdbeAddOp2(v, 81, 1, 1);
  }
  return;
}
}
static void setAllPagerFlags(sqlite3 *db ) 
{ 
  Db *pDb ;
  int n ;
  int tmp ;

  {
  if (db->autoCommit) {
    pDb = db->aDb;
    n = db->nDb;
    while (1) {
      tmp = n;
      n --;
      if (! (tmp > 0)) {
        break;
      }
      if (pDb->pBt) {
        sqlite3BtreeSetPagerFlags(pDb->pBt, (unsigned int )((unsigned long long )pDb->safety_level | (db->flags & 56ULL)));
      }
      pDb ++;
    }
  }
  return;
}
}
static char const   *actionName(u8 action ) 
{ 
  char const   *zName ;

  {
  switch ((int )action) {
  case 8: 
  zName = "SET NULL";
  break;
  case 9: 
  zName = "SET DEFAULT";
  break;
  case 10: 
  zName = "CASCADE";
  break;
  case 7: 
  zName = "RESTRICT";
  break;
  default: 
  zName = "NO ACTION";
  break;
  }
  return (zName);
}
}
static char * const  azModeName[6]  = {      (char * const  )"delete",      (char * const  )"persist",      (char * const  )"off",      (char * const  )"truncate", 
        (char * const  )"memory",      (char * const  )"wal"};
static char const   *sqlite3JournalModename(int eMode ) 
{ 


  {
  if (eMode == (int )(sizeof(azModeName) / sizeof(azModeName[0]))) {
    return ((char const   *)0);
  }
  return ((char const   *)azModeName[eMode]);
}
}
static PragmaName const   *pragmaLocate(char const   *zName ) 
{ 
  int upr ;
  int lwr ;
  int mid ;
  int rc ;
  PragmaName const   *tmp ;

  {
  mid = 0;
  lwr = 0;
  upr = (int )(sizeof(aPragmaName) / sizeof(aPragmaName[0])) - 1;
  while (lwr <= upr) {
    mid = (lwr + upr) / 2;
    rc = sqlite3_stricmp(zName, (char const   *)aPragmaName[mid].zName);
    if (rc == 0) {
      break;
    }
    if (rc < 0) {
      upr = mid - 1;
    } else {
      lwr = mid + 1;
    }
  }
  if (lwr > upr) {
    tmp = (PragmaName const   *)0;
  } else {
    tmp = & aPragmaName[mid];
  }
  return (tmp);
}
}
static int integrityCheckResultRow(Vdbe *v ) 
{ 
  int addr ;
  int tmp ;

  {
  sqlite3VdbeAddOp2(v, 81, 3, 1);
  tmp = sqlite3VdbeCurrentAddr(v);
  addr = sqlite3VdbeAddOp3(v, 47, 1, tmp + 2, 1);
  sqlite3VdbeAddOp0(v, 69);
  return (addr);
}
}
static int const   iLn___2  =    (int const   )0;
static VdbeOpList const   getCacheSize[9]  = 
  {      {(u8 )2, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )94, (signed char)0, (signed char)1, (signed char)3}, 
        {(u8 )47, (signed char)1, (signed char)8, (signed char)0}, 
        {(u8 )70, (signed char)0, (signed char)2, (signed char)0}, 
        {(u8 )104, (signed char)1, (signed char)2, (signed char)1}, 
        {(u8 )47, (signed char)1, (signed char)8, (signed char)0}, 
        {(u8 )70, (signed char)0, (signed char)1, (signed char)0}, 
        {(u8 )170, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )81, (signed char)1, (signed char)1, (signed char)0}};
static int const   iLn___3  =    (int const   )0;
static VdbeOpList const   setMeta6[5]  = {      {(u8 )2, (signed char)0, (signed char)1, (signed char)0}, 
        {(u8 )94, (signed char)0, (signed char)1, (signed char)4}, 
        {(u8 )18, (signed char)1, (signed char)0, (signed char)0}, 
        {(u8 )69, (signed char)0, (signed char)2, (signed char)0}, 
        {(u8 )95, (signed char)0, (signed char)7, (signed char)0}};
static int const   iLn___4  =    (int const   )0;
static VdbeOpList const   endCode[7]  = {      {(u8 )83, (signed char)1, (signed char)0, (signed char)0}, 
        {(u8 )48, (signed char)1, (signed char)4, (signed char)0}, 
        {(u8 )113, (signed char)0, (signed char)3, (signed char)0}, 
        {(u8 )81, (signed char)3, (signed char)1, (signed char)0}, 
        {(u8 )69, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )113, (signed char)0, (signed char)3, (signed char)0}, 
        {(u8 )11, (signed char)0, (signed char)3, (signed char)0}};
static struct EncName  const  encnames[9]  = 
  {      {(char *)"UTF8", (u8 )1}, 
        {(char *)"UTF-8", (u8 )1}, 
        {(char *)"UTF-16le", (u8 )2}, 
        {(char *)"UTF-16be", (u8 )3}, 
        {(char *)"UTF16le", (u8 )2}, 
        {(char *)"UTF16be", (u8 )3}, 
        {(char *)"UTF-16", (u8 )0}, 
        {(char *)"UTF16", (u8 )0}, 
        {(char *)0, (u8 )0}};
static VdbeOpList const   setCookie[2]  = {      {(u8 )2, (signed char)0, (signed char)1, (signed char)0}, 
        {(u8 )95, (signed char)0, (signed char)0, (signed char)0}};
static VdbeOpList const   readCookie[3]  = {      {(u8 )2, (signed char)0, (signed char)0, (signed char)0}, 
        {(u8 )94, (signed char)0, (signed char)1, (signed char)0}, 
        {(u8 )81, (signed char)1, (signed char)1, (signed char)0}};
static void sqlite3Pragma(Parse *pParse , Token *pId1 , Token *pId2 , Token *pValue ,
                          int minusFlag ) 
{ 
  char *zLeft ;
  char *zRight ;
  char const   *zDb ;
  Token *pId ;
  char *aFcntl[4] ;
  int iDb ;
  int rc ;
  sqlite3 *db ;
  Db *pDb ;
  Vdbe *v ;
  Vdbe *tmp ;
  PragmaName const   *pPragma ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  VdbeOp *aOp___1 ;
  int size ;
  int tmp___3 ;
  int tmp___4 ;
  Btree *pBt ;
  int size___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Btree *pBt___0 ;
  int b ;
  u8 tmp___8 ;
  int tmp___9 ;
  int ii ;
  int iReg ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *zRet ;
  int eMode ;
  int tmp___12 ;
  Pager *pPager ;
  int ii___0 ;
  int eMode___0 ;
  int ii___1 ;
  char const   *zMode ;
  int n ;
  int tmp___13 ;
  int tmp___14 ;
  Pager *pPager___0 ;
  struct Pager *tmp___15 ;
  i64 iLimit ;
  Btree *pBt___1 ;
  int tmp___16 ;
  int eAuto ;
  int tmp___17 ;
  VdbeOp *aOp___2 ;
  int iAddr ;
  int tmp___18 ;
  int iLimit___0 ;
  int addr ;
  int tmp___19 ;
  int size___1 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int size___2 ;
  int tmp___23 ;
  u8 tmp___24 ;
  sqlite_int64 sz ;
  int ii___2 ;
  int res ;
  int iLevel ;
  u8 tmp___25 ;
  u64 mask ;
  u8 tmp___26 ;
  Table *pTab ;
  int iTabDb ;
  int tmp___27 ;
  int i ;
  int k ;
  int nHidden ;
  Column *pCol ;
  Index *pPk ;
  Index *tmp___28 ;
  int isHidden ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  Index *pIdx ;
  Table *pTab___0 ;
  int iIdxDb ;
  int tmp___33 ;
  int i___0 ;
  int mx ;
  i16 cnum ;
  char *tmp___34 ;
  Index *pIdx___0 ;
  Table *pTab___1 ;
  int i___1 ;
  int iTabDb___0 ;
  int tmp___35 ;
  char const   *azOrigin[3] ;
  int i___2 ;
  char const   *tmp___36 ;
  int i___3 ;
  HashElem *p ;
  CollSeq *pColl ;
  int tmp___37 ;
  int i___4 ;
  HashElem *j ;
  FuncDef *p___0 ;
  HashElem *j___0 ;
  Module *pMod ;
  int i___5 ;
  FKey *pFK ;
  Table *pTab___2 ;
  int iTabDb___1 ;
  int tmp___38 ;
  int i___6 ;
  int j___1 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  FKey *pFK___0 ;
  Table *pTab___3 ;
  Table *pParent ;
  Index *pIdx___1 ;
  int i___7 ;
  int j___2 ;
  HashElem *k___0 ;
  int x___0 ;
  int regResult ;
  int regKey ;
  int regRow ;
  int addrTop ;
  int addrOk ;
  int *aiCols ;
  int iTabDb___2 ;
  int iCol ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int jmp ;
  int tmp___43 ;
  u8 tmp___44 ;
  int i___8 ;
  int j___3 ;
  int addr___0 ;
  int mxErr ;
  int isQuick ;
  HashElem *x___1 ;
  Hash *pTbls ;
  int *aRoot ;
  int cnt ;
  int mxIdx ;
  Table *pTab___4 ;
  Index *pIdx___2 ;
  int nIdx ;
  void *tmp___45 ;
  Table *pTab___5 ;
  Index *pIdx___3 ;
  char *tmp___46 ;
  Table *pTab___6 ;
  Index *pIdx___4 ;
  Index *pPk___0 ;
  Index *pPrior ;
  int loopTop ;
  int iDataCur ;
  int iIdxCur ;
  int r1 ;
  Index *tmp___47 ;
  char *zErr ;
  int jmp2 ;
  ExprList *pCheck ;
  ExprList *tmp___48 ;
  int addrCkFault ;
  int tmp___49 ;
  int addrCkOk ;
  int tmp___50 ;
  char *zErr___0 ;
  int k___1 ;
  int jmp2___0 ;
  int jmp3 ;
  int jmp4 ;
  int jmp5 ;
  int ckUniq ;
  int tmp___51 ;
  int uniqOk ;
  int tmp___52 ;
  int jmp6 ;
  int kk ;
  int iCol___0 ;
  VdbeOp *aOp___3 ;
  char const   *tmp___53 ;
  int tmp___54 ;
  struct EncName  const  *pEnc ;
  int tmp___55 ;
  u8 tmp___56 ;
  int tmp___57 ;
  int iCookie ;
  VdbeOp *aOp___4 ;
  VdbeOp *aOp___5 ;
  int i___9 ;
  char const   *zOpt ;
  int tmp___58 ;
  int iBt ;
  int tmp___59 ;
  int eMode___1 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int iDbLast ;
  int iTabCur ;
  HashElem *k___2 ;
  Schema *pSchema ;
  Table *pTab___7 ;
  Index *pIdx___5 ;
  LogEst szThreshold ;
  char *zSubSql ;
  u32 opMask ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int r1___0 ;
  int tmp___68 ;
  int tmp___69 ;
  sqlite_int64 N ;
  int tmp___70 ;
  sqlite_int64 tmp___71 ;
  sqlite_int64 N___0 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;

  {
  zLeft = (char *)0;
  zRight = (char *)0;
  zDb = (char const   *)0;
  db = pParse->db;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    return;
  }
  sqlite3VdbeRunOnlyOnce(v);
  pParse->nMem = 2;
  iDb = sqlite3TwoPartName(pParse, pId1, pId2, & pId);
  if (iDb < 0) {
    return;
  }
  pDb = db->aDb + iDb;
  if (iDb == 1) {
    tmp___0 = sqlite3OpenTempDatabase(pParse);
    if (tmp___0) {
      return;
    }
  }
  zLeft = sqlite3NameFromToken(db, pId);
  if (! zLeft) {
    return;
  }
  if (minusFlag) {
    zRight = sqlite3MPrintf(db, "-%T", pValue);
  } else {
    zRight = sqlite3NameFromToken(db, pValue);
  }
  if (pId2->n > 0U) {
    zDb = (char const   *)pDb->zDbSName;
  } else {
    zDb = (char const   *)0;
  }
  tmp___1 = sqlite3AuthCheck(pParse, 19, (char const   *)zLeft, (char const   *)zRight,
                             zDb);
  if (tmp___1) {
    goto pragma_out;
  }
  aFcntl[0] = (char *)0;
  aFcntl[1] = zLeft;
  aFcntl[2] = zRight;
  aFcntl[3] = (char *)0;
  db->busyHandler.nBusy = 0;
  rc = sqlite3_file_control(db, zDb, 14, (void *)(aFcntl));
  if (rc == 0) {
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, (char const   *)aFcntl[0], (void (*)(void * ))-1);
    returnSingleText(v, (char const   *)aFcntl[0]);
    sqlite3_free((void *)aFcntl[0]);
    goto pragma_out;
  }
  if (rc != 12) {
    if (aFcntl[0]) {
      sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
      sqlite3_free((void *)aFcntl[0]);
    }
    (pParse->nErr) ++;
    pParse->rc = rc;
    goto pragma_out;
  }
  pPragma = pragmaLocate((char const   *)zLeft);
  if ((unsigned long )pPragma == (unsigned long )((PragmaName const   *)0)) {
    goto pragma_out;
  }
  if (((int const   )pPragma->mPragFlg & 1) != 0) {
    tmp___2 = sqlite3ReadSchema(pParse);
    if (tmp___2) {
      goto pragma_out;
    }
  }
  if (((int const   )pPragma->mPragFlg & 2) == 0) {
    if (((int const   )pPragma->mPragFlg & 4) == 0) {
      setPragmaResultColumnNames(v, pPragma);
    } else
    if ((unsigned long )zRight == (unsigned long )((char *)0)) {
      setPragmaResultColumnNames(v, pPragma);
    }
  }
  switch ((int const   )pPragma->ePragTyp) {
  case 11: 
  sqlite3VdbeUsesBtree(v, iDb);
  if (! zRight) {
    pParse->nMem += 2;
    aOp___1 = sqlite3VdbeAddOpList(v, (int )(sizeof(getCacheSize) / sizeof(getCacheSize[0])),
                                   getCacheSize, (int )iLn___2);
    (aOp___1 + 0)->p1 = iDb;
    (aOp___1 + 1)->p1 = iDb;
    (aOp___1 + 6)->p1 = -2000;
  } else {
    tmp___3 = sqlite3Atoi((char const   *)zRight);
    tmp___4 = sqlite3AbsInt32(tmp___3);
    size = tmp___4;
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3VdbeAddOp3(v, 95, iDb, 3, size);
    (pDb->pSchema)->cache_size = size;
    sqlite3BtreeSetCacheSize(pDb->pBt, (pDb->pSchema)->cache_size);
  }
  break;
  case 28: 
  pBt = pDb->pBt;
  if (! zRight) {
    if (pBt) {
      tmp___5 = sqlite3BtreeGetPageSize(pBt);
      tmp___6 = tmp___5;
    } else {
      tmp___6 = 0;
    }
    size___0 = tmp___6;
    returnSingleInt(v, (i64 )size___0);
  } else {
    db->nextPagesize = sqlite3Atoi((char const   *)zRight);
    tmp___7 = sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0);
    if (7 == tmp___7) {
      sqlite3OomFault(db);
    }
  }
  break;
  case 30: 
  pBt___0 = pDb->pBt;
  b = -1;
  if (zRight) {
    tmp___9 = sqlite3_stricmp((char const   *)zRight, "fast");
    if (tmp___9 == 0) {
      b = 2;
    } else {
      tmp___8 = sqlite3GetBoolean((char const   *)zRight, (u8 )0);
      b = (int )tmp___8;
    }
  }
  if (pId2->n == 0U) {
    if (b >= 0) {
      ii = 0;
      while (ii < db->nDb) {
        sqlite3BtreeSecureDelete((db->aDb + ii)->pBt, b);
        ii ++;
      }
    }
  }
  b = sqlite3BtreeSecureDelete(pBt___0, b);
  returnSingleInt(v, (i64 )b);
  break;
  case 24: 
  sqlite3CodeVerifySchema(pParse, iDb);
  (pParse->nMem) ++;
  iReg = pParse->nMem;
  if ((int const   )sqlite3UpperToLower[(unsigned char )*(zLeft + 0)] == 112) {
    sqlite3VdbeAddOp2(v, 166, iDb, iReg);
  } else {
    tmp___10 = sqlite3Atoi((char const   *)zRight);
    tmp___11 = sqlite3AbsInt32(tmp___10);
    sqlite3VdbeAddOp3(v, 167, iDb, iReg, tmp___11);
  }
  sqlite3VdbeAddOp2(v, 81, iReg, 1);
  break;
  case 23: 
  zRet = "normal";
  tmp___12 = getLockingMode((char const   *)zRight);
  eMode = tmp___12;
  if (pId2->n == 0U) {
    if (eMode == -1) {
      eMode = (int )db->dfltLockMode;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (pId2->n == 0U) {
      ii___0 = 2;
      while (ii___0 < db->nDb) {
        pPager = sqlite3BtreePager((db->aDb + ii___0)->pBt);
        sqlite3PagerLockingMode(pPager, eMode);
        ii___0 ++;
      }
      db->dfltLockMode = (u8 )eMode;
    }
    pPager = sqlite3BtreePager(pDb->pBt);
    eMode = sqlite3PagerLockingMode(pPager, eMode);
  }
  if (eMode == 1) {
    zRet = "exclusive";
  }
  returnSingleText(v, zRet);
  break;
  case 20: 
  if ((unsigned long )zRight == (unsigned long )((char *)0)) {
    eMode___0 = -1;
  } else {
    tmp___13 = sqlite3Strlen30((char const   *)zRight);
    n = tmp___13;
    eMode___0 = 0;
    while (1) {
      zMode = sqlite3JournalModename(eMode___0);
      if (! ((unsigned long )zMode != (unsigned long )((char const   *)0))) {
        break;
      }
      tmp___14 = sqlite3_strnicmp((char const   *)zRight, zMode, n);
      if (tmp___14 == 0) {
        break;
      }
      eMode___0 ++;
    }
    if (! zMode) {
      eMode___0 = -1;
    }
    if (eMode___0 == 2) {
      if ((db->flags & 268435456ULL) != 0ULL) {
        eMode___0 = -1;
      }
    }
  }
  if (eMode___0 == -1) {
    if (pId2->n == 0U) {
      iDb = 0;
      pId2->n = 1U;
    }
  }
  ii___1 = db->nDb - 1;
  while (ii___1 >= 0) {
    if ((db->aDb + ii___1)->pBt) {
      if (ii___1 == iDb) {
        sqlite3VdbeUsesBtree(v, ii___1);
        sqlite3VdbeAddOp3(v, 7, ii___1, 1, eMode___0);
      } else
      if (pId2->n == 0U) {
        sqlite3VdbeUsesBtree(v, ii___1);
        sqlite3VdbeAddOp3(v, 7, ii___1, 1, eMode___0);
      }
    }
    ii___1 --;
  }
  sqlite3VdbeAddOp2(v, 81, 1, 1);
  break;
  case 21: 
  tmp___15 = sqlite3BtreePager(pDb->pBt);
  pPager___0 = tmp___15;
  iLimit = (i64 )-2;
  if (zRight) {
    sqlite3DecOrHexToI64((char const   *)zRight, & iLimit);
    if (iLimit < -1LL) {
      iLimit = (i64 )-1;
    }
  }
  iLimit = sqlite3PagerJournalSizeLimit(pPager___0, iLimit);
  returnSingleInt(v, iLimit);
  break;
  case 1: 
  pBt___1 = pDb->pBt;
  if (! zRight) {
    tmp___16 = sqlite3BtreeGetAutoVacuum(pBt___1);
    returnSingleInt(v, (i64 )tmp___16);
  } else {
    tmp___17 = getAutoVacuum((char const   *)zRight);
    eAuto = tmp___17;
    db->nextAutovac = (signed char )((u8 )eAuto);
    rc = sqlite3BtreeSetAutoVacuum(pBt___1, eAuto);
    if (rc == 0) {
      if (eAuto == 1) {
        goto _L___0;
      } else
      if (eAuto == 2) {
        _L___0: /* CIL Label */ 
        tmp___18 = sqlite3VdbeCurrentAddr(v);
        iAddr = tmp___18;
        aOp___2 = sqlite3VdbeAddOpList(v, (int )(sizeof(setMeta6) / sizeof(setMeta6[0])),
                                       setMeta6, (int )iLn___3);
        (aOp___2 + 0)->p1 = iDb;
        (aOp___2 + 1)->p1 = iDb;
        (aOp___2 + 2)->p2 = iAddr + 4;
        (aOp___2 + 4)->p1 = iDb;
        (aOp___2 + 4)->p3 = eAuto - 1;
        sqlite3VdbeUsesBtree(v, iDb);
      }
    }
  }
  break;
  case 16: 
  if ((unsigned long )zRight == (unsigned long )((char *)0)) {
    iLimit___0 = 2147483647;
  } else {
    tmp___19 = sqlite3GetInt32((char const   *)zRight, & iLimit___0);
    if (tmp___19) {
      if (iLimit___0 <= 0) {
        iLimit___0 = 2147483647;
      }
    } else {
      iLimit___0 = 2147483647;
    }
  }
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  sqlite3VdbeAddOp2(v, 70, iLimit___0, 1);
  addr = sqlite3VdbeAddOp1(v, 59, iDb);
  sqlite3VdbeAddOp1(v, 81, 1);
  sqlite3VdbeAddOp2(v, 83, 1, -1);
  sqlite3VdbeAddOp2(v, 47, 1, addr);
  sqlite3VdbeJumpHere(v, addr);
  break;
  case 4: 
  if (! zRight) {
    returnSingleInt(v, (i64 )(pDb->pSchema)->cache_size);
  } else {
    tmp___20 = sqlite3Atoi((char const   *)zRight);
    size___1 = tmp___20;
    (pDb->pSchema)->cache_size = size___1;
    sqlite3BtreeSetCacheSize(pDb->pBt, (pDb->pSchema)->cache_size);
  }
  break;
  case 5: 
  if (! zRight) {
    if ((db->flags & 32ULL) == 0ULL) {
      tmp___22 = 0;
    } else {
      tmp___21 = sqlite3BtreeSetSpillSize(pDb->pBt, 0);
      tmp___22 = tmp___21;
    }
    returnSingleInt(v, (i64 )tmp___22);
  } else {
    size___2 = 1;
    tmp___23 = sqlite3GetInt32((char const   *)zRight, & size___2);
    if (tmp___23) {
      sqlite3BtreeSetSpillSize(pDb->pBt, size___2);
    }
    tmp___24 = sqlite3GetBoolean((char const   *)zRight, (u8 )(size___2 != 0));
    if (tmp___24) {
      db->flags |= 32ULL;
    } else {
      db->flags &= 0xffffffffffffffdfULL;
    }
    setAllPagerFlags(db);
  }
  break;
  case 25: 
  if (zRight) {
    sqlite3DecOrHexToI64((char const   *)zRight, & sz);
    if (sz < 0LL) {
      sz = sqlite3Config.szMmap;
    }
    if (pId2->n == 0U) {
      db->szMmap = sz;
    }
    ii___2 = db->nDb - 1;
    while (ii___2 >= 0) {
      if ((db->aDb + ii___2)->pBt) {
        if (ii___2 == iDb) {
          sqlite3BtreeSetMmapLimit((db->aDb + ii___2)->pBt, sz);
        } else
        if (pId2->n == 0U) {
          sqlite3BtreeSetMmapLimit((db->aDb + ii___2)->pBt, sz);
        }
      }
      ii___2 --;
    }
  }
  sz = (sqlite_int64 )-1;
  rc = sqlite3_file_control(db, zDb, 18, (void *)(& sz));
  if (rc == 0) {
    returnSingleInt(v, sz);
  } else
  if (rc != 12) {
    (pParse->nErr) ++;
    pParse->rc = rc;
  }
  break;
  case 35: 
  if (! zRight) {
    returnSingleInt(v, (i64 )db->temp_store);
  } else {
    changeTempStorage(pParse, (char const   *)zRight);
  }
  break;
  case 36: 
  if (! zRight) {
    returnSingleText(v, (char const   *)sqlite3_temp_directory);
  } else {
    if (*(zRight + 0)) {
      rc = sqlite3OsAccess(db->pVfs, (char const   *)zRight, 1, & res);
      if (rc != 0) {
        sqlite3ErrorMsg(pParse, "not a writable directory");
        goto pragma_out;
      } else
      if (res == 0) {
        sqlite3ErrorMsg(pParse, "not a writable directory");
        goto pragma_out;
      }
    }
    if ((int )db->temp_store <= 1) {
      invalidateTempStorage(pParse);
    }
    sqlite3_free((void *)sqlite3_temp_directory);
    if (*(zRight + 0)) {
      sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
    } else {
      sqlite3_temp_directory = (char *)0;
    }
  }
  break;
  case 33: 
  if (! zRight) {
    returnSingleInt(v, (i64 )((int )pDb->safety_level - 1));
  } else
  if (! db->autoCommit) {
    sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction");
  } else
  if (iDb != 1) {
    tmp___25 = getSafetyLevel((char const   *)zRight, 0, (u8 )1);
    iLevel = ((int )tmp___25 + 1) & 7;
    if (iLevel == 0) {
      iLevel = 1;
    }
    pDb->safety_level = (u8 )iLevel;
    pDb->bSyncSet = (u8 )1;
    setAllPagerFlags(db);
  }
  break;
  case 2: 
  if ((unsigned long )zRight == (unsigned long )((char *)0)) {
    setPragmaResultColumnNames(v, pPragma);
    returnSingleInt(v, (i64 )((db->flags & (unsigned long long )pPragma->iArg) != 0ULL));
  } else {
    mask = (u64 )pPragma->iArg;
    if ((int )db->autoCommit == 0) {
      mask &= 0xffffffffffffbfffULL;
    }
    tmp___26 = sqlite3GetBoolean((char const   *)zRight, (u8 )0);
    if (tmp___26) {
      db->flags |= mask;
    } else {
      db->flags &= ~ mask;
      if (mask == 524288ULL) {
        db->nDeferredImmCons = (i64 )0;
      }
    }
    sqlite3VdbeAddOp0(v, 158);
    setAllPagerFlags(db);
  }
  break;
  case 34: 
  if (zRight) {
    pTab = sqlite3LocateTable(pParse, (u32 )2, (char const   *)zRight, zDb);
    if (pTab) {
      tmp___27 = sqlite3SchemaToIndex(db, pTab->pSchema);
      iTabDb = tmp___27;
      nHidden = 0;
      tmp___28 = sqlite3PrimaryKeyIndex(pTab);
      pPk = tmp___28;
      pParse->nMem = 7;
      sqlite3CodeVerifySchema(pParse, iTabDb);
      sqlite3ViewGetColumnNames(pParse, pTab);
      i = 0;
      pCol = pTab->aCol;
      while (i < (int )pTab->nCol) {
        isHidden = ((int )pCol->colFlags & 2) != 0;
        if (isHidden) {
          if (pPragma->iArg == 0ULL) {
            nHidden ++;
            goto __Cont;
          }
        }
        if (((int )pCol->colFlags & 1) == 0) {
          k = 0;
        } else
        if ((unsigned long )pPk == (unsigned long )((Index *)0)) {
          k = 1;
        } else {
          k = 1;
          while (1) {
            if (k <= (int )pTab->nCol) {
              if (! ((int )*(pPk->aiColumn + (k - 1)) != i)) {
                break;
              }
            } else {
              break;
            }
            k ++;
          }
        }
        if (pCol->pDflt) {
          tmp___29 = (pCol->pDflt)->u.zToken;
        } else {
          tmp___29 = (char *)0;
        }
        if (pCol->notNull) {
          tmp___30 = 1;
        } else {
          tmp___30 = 0;
        }
        tmp___31 = sqlite3ColumnType(pCol, (char *)"");
        if (pPragma->iArg) {
          tmp___32 = "issisii";
        } else {
          tmp___32 = "issisi";
        }
        sqlite3VdbeMultiLoad(v, 1, tmp___32, i - nHidden, pCol->zName, tmp___31, tmp___30,
                             tmp___29, k, isHidden);
        __Cont: /* CIL Label */ 
        i ++;
        pCol ++;
      }
    }
  }
  break;
  case 17: 
  if (zRight) {
    pIdx = sqlite3FindIndex(db, (char const   *)zRight, zDb);
    if ((unsigned long )pIdx == (unsigned long )((Index *)0)) {
      pTab___0 = sqlite3LocateTable(pParse, (u32 )2, (char const   *)zRight, zDb);
      if (pTab___0) {
        if (! ((pTab___0->tabFlags & 32U) == 0U)) {
          pIdx = sqlite3PrimaryKeyIndex(pTab___0);
        }
      }
    }
    if (pIdx) {
      tmp___33 = sqlite3SchemaToIndex(db, pIdx->pSchema);
      iIdxDb = tmp___33;
      if (pPragma->iArg) {
        mx = (int )pIdx->nColumn;
        pParse->nMem = 6;
      } else {
        mx = (int )pIdx->nKeyCol;
        pParse->nMem = 3;
      }
      pTab___0 = pIdx->pTable;
      sqlite3CodeVerifySchema(pParse, iIdxDb);
      i___0 = 0;
      while (i___0 < mx) {
        cnum = *(pIdx->aiColumn + i___0);
        if ((int )cnum < 0) {
          tmp___34 = (char *)0;
        } else {
          tmp___34 = (pTab___0->aCol + cnum)->zName;
        }
        sqlite3VdbeMultiLoad(v, 1, "iisX", i___0, (int )cnum, tmp___34);
        if (pPragma->iArg) {
          sqlite3VdbeMultiLoad(v, 4, "isiX", (int )*(pIdx->aSortOrder + i___0), *(pIdx->azColl + i___0),
                               i___0 < (int )pIdx->nKeyCol);
        }
        sqlite3VdbeAddOp2(v, 81, 1, pParse->nMem);
        i___0 ++;
      }
    }
  }
  break;
  case 18: 
  if (zRight) {
    pTab___1 = sqlite3FindTable(db, (char const   *)zRight, zDb);
    if (pTab___1) {
      tmp___35 = sqlite3SchemaToIndex(db, pTab___1->pSchema);
      iTabDb___0 = tmp___35;
      pParse->nMem = 5;
      sqlite3CodeVerifySchema(pParse, iTabDb___0);
      pIdx___0 = pTab___1->pIndex;
      i___1 = 0;
      while (pIdx___0) {
        azOrigin[0] = "c";
        azOrigin[1] = "u";
        azOrigin[2] = "pk";
        sqlite3VdbeMultiLoad(v, 1, "isisi", i___1, pIdx___0->zName, (int )pIdx___0->onError != 0,
                             azOrigin[pIdx___0->idxType], (unsigned long )pIdx___0->pPartIdxWhere != (unsigned long )((Expr *)0));
        pIdx___0 = pIdx___0->pNext;
        i___1 ++;
      }
    }
  }
  break;
  case 10: 
  pParse->nMem = 3;
  i___2 = 0;
  while (i___2 < db->nDb) {
    if ((unsigned long )(db->aDb + i___2)->pBt == (unsigned long )((Btree *)0)) {
      goto __Cont___0;
    }
    tmp___36 = sqlite3BtreeGetFilename((db->aDb + i___2)->pBt);
    sqlite3VdbeMultiLoad(v, 1, "iss", i___2, (db->aDb + i___2)->zDbSName, tmp___36);
    __Cont___0: /* CIL Label */ 
    i___2 ++;
  }
  break;
  case 7: 
  i___3 = 0;
  pParse->nMem = 2;
  p = db->aCollSeq.first;
  while (p) {
    pColl = (CollSeq *)p->data;
    tmp___37 = i___3;
    i___3 ++;
    sqlite3VdbeMultiLoad(v, 1, "is", tmp___37, pColl->zName);
    p = p->next;
  }
  break;
  case 15: 
  pParse->nMem = 2;
  i___4 = 0;
  while (i___4 < 23) {
    p___0 = sqlite3BuiltinFunctions.a[i___4];
    while (p___0) {
      if (p___0->funcFlags & 262144U) {
        goto __Cont___1;
      }
      sqlite3VdbeMultiLoad(v, 1, "si", p___0->zName, 1);
      __Cont___1: /* CIL Label */ 
      p___0 = p___0->u.pHash;
    }
    i___4 ++;
  }
  j = db->aFunc.first;
  while (j) {
    p___0 = (FuncDef *)j->data;
    sqlite3VdbeMultiLoad(v, 1, "si", p___0->zName, 0);
    j = j->next;
  }
  break;
  case 26: 
  pParse->nMem = 1;
  j___0 = db->aModule.first;
  while (j___0) {
    pMod = (Module *)j___0->data;
    sqlite3VdbeMultiLoad(v, 1, "s", pMod->zName);
    j___0 = j___0->next;
  }
  break;
  case 29: 
  i___5 = 0;
  while (i___5 < (int )(sizeof(aPragmaName) / sizeof(aPragmaName[0]))) {
    sqlite3VdbeMultiLoad(v, 1, "s", aPragmaName[i___5].zName);
    i___5 ++;
  }
  break;
  case 14: 
  if (zRight) {
    pTab___2 = sqlite3FindTable(db, (char const   *)zRight, zDb);
    if (pTab___2) {
      pFK = pTab___2->pFKey;
      if (pFK) {
        tmp___38 = sqlite3SchemaToIndex(db, pTab___2->pSchema);
        iTabDb___1 = tmp___38;
        i___6 = 0;
        pParse->nMem = 8;
        sqlite3CodeVerifySchema(pParse, iTabDb___1);
        while (pFK) {
          j___1 = 0;
          while (j___1 < pFK->nCol) {
            tmp___39 = actionName(pFK->aAction[0]);
            tmp___40 = actionName(pFK->aAction[1]);
            sqlite3VdbeMultiLoad(v, 1, "iissssss", i___6, j___1, pFK->zTo, (pTab___2->aCol + pFK->aCol[j___1].iFrom)->zName,
                                 pFK->aCol[j___1].zCol, tmp___40, tmp___39, "NONE");
            j___1 ++;
          }
          i___6 ++;
          pFK = pFK->pNextFrom;
        }
      }
    }
  }
  break;
  case 13: 
  regResult = pParse->nMem + 1;
  pParse->nMem += 4;
  (pParse->nMem) ++;
  regKey = pParse->nMem;
  (pParse->nMem) ++;
  regRow = pParse->nMem;
  k___0 = ((db->aDb + iDb)->pSchema)->tblHash.first;
  while (k___0) {
    if (zRight) {
      pTab___3 = sqlite3LocateTable(pParse, (u32 )0, (char const   *)zRight, zDb);
      k___0 = (HashElem *)0;
    } else {
      pTab___3 = (Table *)k___0->data;
      k___0 = k___0->next;
    }
    if ((unsigned long )pTab___3 == (unsigned long )((Table *)0)) {
      continue;
    } else
    if ((unsigned long )pTab___3->pFKey == (unsigned long )((FKey *)0)) {
      continue;
    }
    iTabDb___2 = sqlite3SchemaToIndex(db, pTab___3->pSchema);
    sqlite3CodeVerifySchema(pParse, iTabDb___2);
    sqlite3TableLock(pParse, iTabDb___2, pTab___3->tnum, (u8 )0, (char const   *)pTab___3->zName);
    if ((int )pTab___3->nCol + regRow > pParse->nMem) {
      pParse->nMem = (int )pTab___3->nCol + regRow;
    }
    sqlite3OpenTable(pParse, 0, iTabDb___2, pTab___3, 97);
    sqlite3VdbeLoadString(v, regResult, (char const   *)pTab___3->zName);
    i___7 = 1;
    pFK___0 = pTab___3->pFKey;
    while (pFK___0) {
      pParent = sqlite3FindTable(db, (char const   *)pFK___0->zTo, zDb);
      if ((unsigned long )pParent == (unsigned long )((Table *)0)) {
        goto __Cont___2;
      }
      pIdx___1 = (Index *)0;
      sqlite3TableLock(pParse, iTabDb___2, pParent->tnum, (u8 )0, (char const   *)pParent->zName);
      x___0 = sqlite3FkLocateIndex(pParse, pParent, pFK___0, & pIdx___1, (int **)0);
      if (x___0 == 0) {
        if ((unsigned long )pIdx___1 == (unsigned long )((Index *)0)) {
          sqlite3OpenTable(pParse, i___7, iTabDb___2, pParent, 97);
        } else {
          sqlite3VdbeAddOp3(v, 97, i___7, pIdx___1->tnum, iTabDb___2);
          sqlite3VdbeSetP4KeyInfo(pParse, pIdx___1);
        }
      } else {
        k___0 = (HashElem *)0;
        break;
      }
      __Cont___2: /* CIL Label */ 
      i___7 ++;
      pFK___0 = pFK___0->pNextFrom;
    }
    if (pFK___0) {
      break;
    }
    if (pParse->nTab < i___7) {
      pParse->nTab = i___7;
    }
    addrTop = sqlite3VdbeAddOp1(v, 36, 0);
    i___7 = 1;
    pFK___0 = pTab___3->pFKey;
    while (pFK___0) {
      pParent = sqlite3FindTable(db, (char const   *)pFK___0->zTo, zDb);
      pIdx___1 = (Index *)0;
      aiCols = (int *)0;
      if (pParent) {
        x___0 = sqlite3FkLocateIndex(pParse, pParent, pFK___0, & pIdx___1, & aiCols);
      }
      addrOk = sqlite3VdbeMakeLabel(pParse);
      j___2 = 0;
      while (j___2 < pFK___0->nCol) {
        if (aiCols) {
          tmp___41 = *(aiCols + j___2);
        } else {
          tmp___41 = pFK___0->aCol[j___2].iFrom;
        }
        iCol = tmp___41;
        sqlite3ExprCodeGetColumnOfTable(v, pTab___3, 0, iCol, regRow + j___2);
        sqlite3VdbeAddOp2(v, 50, regRow + j___2, addrOk);
        j___2 ++;
      }
      if (pIdx___1) {
        tmp___42 = sqlite3IndexAffinityStr(db, pIdx___1);
        sqlite3VdbeAddOp4(v, 92, regRow, pFK___0->nCol, regKey, tmp___42, pFK___0->nCol);
        sqlite3VdbeAddOp4Int(v, 29, i___7, addrOk, regKey, 0);
      } else
      if (pParent) {
        tmp___43 = sqlite3VdbeCurrentAddr(v);
        jmp = tmp___43 + 2;
        sqlite3VdbeAddOp3(v, 30, i___7, jmp, regRow);
        sqlite3VdbeGoto(v, addrOk);
      }
      if ((pTab___3->tabFlags & 32U) == 0U) {
        sqlite3VdbeAddOp2(v, 128, 0, regResult + 1);
      } else {
        sqlite3VdbeAddOp2(v, 73, 0, regResult + 1);
      }
      sqlite3VdbeMultiLoad(v, regResult + 2, "siX", pFK___0->zTo, i___7 - 1);
      sqlite3VdbeAddOp2(v, 81, regResult, 4);
      sqlite3VdbeResolveLabel(v, addrOk);
      sqlite3DbFree(db, (void *)aiCols);
      i___7 ++;
      pFK___0 = pFK___0->pNextFrom;
    }
    sqlite3VdbeAddOp2(v, 5, 0, addrTop + 1);
    sqlite3VdbeJumpHere(v, addrTop);
  }
  break;
  case 6: 
  if (zRight) {
    tmp___44 = sqlite3GetBoolean((char const   *)zRight, (u8 )0);
    sqlite3RegisterLikeFunctions(db, (int )tmp___44);
  }
  break;
  case 19: 
  isQuick = (int const   )sqlite3UpperToLower[(unsigned char )*(zLeft + 0)] == 113;
  if ((unsigned long )pId2->z == (unsigned long )((char const   *)0)) {
    iDb = -1;
  }
  pParse->nMem = 6;
  mxErr = 100;
  if (zRight) {
    sqlite3GetInt32((char const   *)zRight, & mxErr);
    if (mxErr <= 0) {
      mxErr = 100;
    }
  }
  sqlite3VdbeAddOp2(v, 70, mxErr - 1, 1);
  i___8 = 0;
  while (i___8 < db->nDb) {
    cnt = 0;
    mxIdx = 0;
    if (iDb >= 0) {
      if (i___8 != iDb) {
        goto __Cont___3;
      }
    }
    sqlite3CodeVerifySchema(pParse, i___8);
    pTbls = & ((db->aDb + i___8)->pSchema)->tblHash;
    cnt = 0;
    x___1 = pTbls->first;
    while (x___1) {
      pTab___4 = (Table *)x___1->data;
      if ((pTab___4->tabFlags & 32U) == 0U) {
        cnt ++;
      }
      nIdx = 0;
      pIdx___2 = pTab___4->pIndex;
      while (pIdx___2) {
        cnt ++;
        pIdx___2 = pIdx___2->pNext;
        nIdx ++;
      }
      if (nIdx > mxIdx) {
        mxIdx = nIdx;
      }
      x___1 = x___1->next;
    }
    tmp___45 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(int ) * (unsigned long )(cnt + 1)));
    aRoot = (int *)tmp___45;
    if ((unsigned long )aRoot == (unsigned long )((int *)0)) {
      break;
    }
    cnt = 0;
    x___1 = pTbls->first;
    while (x___1) {
      pTab___5 = (Table *)x___1->data;
      if ((pTab___5->tabFlags & 32U) == 0U) {
        cnt ++;
        *(aRoot + cnt) = pTab___5->tnum;
      }
      pIdx___3 = pTab___5->pIndex;
      while (pIdx___3) {
        cnt ++;
        *(aRoot + cnt) = pIdx___3->tnum;
        pIdx___3 = pIdx___3->pNext;
      }
      x___1 = x___1->next;
    }
    *(aRoot + 0) = cnt;
    if (pParse->nMem > 8 + mxIdx) {
      pParse->nMem = pParse->nMem;
    } else {
      pParse->nMem = 8 + mxIdx;
    }
    sqlite3ClearTempRegCache(pParse);
    sqlite3VdbeAddOp4(v, 146, 2, cnt, 1, (char const   *)((char *)aRoot), -15);
    sqlite3VdbeChangeP5(v, (u16 )((u8 )i___8));
    addr___0 = sqlite3VdbeAddOp1(v, 50, 2);
    tmp___46 = sqlite3MPrintf(db, "*** in database %s ***\n", (db->aDb + i___8)->zDbSName);
    sqlite3VdbeAddOp4(v, 113, 0, 3, 0, (char const   *)tmp___46, -7);
    sqlite3VdbeAddOp3(v, 108, 2, 3, 3);
    integrityCheckResultRow(v);
    sqlite3VdbeJumpHere(v, addr___0);
    x___1 = pTbls->first;
    while (x___1) {
      pTab___6 = (Table *)x___1->data;
      pPrior = (Index *)0;
      r1 = -1;
      if (pTab___6->tnum < 1) {
        goto __Cont___4;
      }
      if ((pTab___6->tabFlags & 32U) == 0U) {
        pPk___0 = (Index *)0;
      } else {
        tmp___47 = sqlite3PrimaryKeyIndex(pTab___6);
        pPk___0 = tmp___47;
      }
      sqlite3OpenTableAndIndices(pParse, pTab___6, 97, (u8 )0, 1, (u8 *)0, & iDataCur,
                                 & iIdxCur);
      sqlite3VdbeAddOp2(v, 70, 0, 7);
      j___3 = 0;
      pIdx___4 = pTab___6->pIndex;
      while (pIdx___4) {
        sqlite3VdbeAddOp2(v, 70, 0, 8 + j___3);
        pIdx___4 = pIdx___4->pNext;
        j___3 ++;
      }
      sqlite3VdbeAddOp2(v, 36, iDataCur, 0);
      loopTop = sqlite3VdbeAddOp2(v, 83, 7, 1);
      if (! isQuick) {
        sqlite3VdbeAddOp3(v, 90, iDataCur, (int )pTab___6->nCol - 1, 3);
        sqlite3VdbeChangeP5(v, (u16 )128);
      }
      j___3 = 0;
      while (j___3 < (int )pTab___6->nCol) {
        if (j___3 == (int )pTab___6->iPKey) {
          goto __Cont___5;
        }
        if ((int )(pTab___6->aCol + j___3)->notNull == 0) {
          goto __Cont___5;
        }
        sqlite3ExprCodeGetColumnOfTable(v, pTab___6, iDataCur, j___3, 3);
        sqlite3VdbeChangeP5(v, (u16 )128);
        jmp2 = sqlite3VdbeAddOp1(v, 51, 3);
        zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab___6->zName, (pTab___6->aCol + j___3)->zName);
        sqlite3VdbeAddOp4(v, 113, 0, 3, 0, (char const   *)zErr, -7);
        integrityCheckResultRow(v);
        sqlite3VdbeJumpHere(v, jmp2);
        __Cont___5: /* CIL Label */ 
        j___3 ++;
      }
      if (pTab___6->pCheck) {
        if ((db->flags & 512ULL) == 0ULL) {
          tmp___48 = sqlite3ExprListDup(db, pTab___6->pCheck, 0);
          pCheck = tmp___48;
          if ((int )db->mallocFailed == 0) {
            tmp___49 = sqlite3VdbeMakeLabel(pParse);
            addrCkFault = tmp___49;
            tmp___50 = sqlite3VdbeMakeLabel(pParse);
            addrCkOk = tmp___50;
            pParse->iSelfTab = iDataCur + 1;
            k___1 = pCheck->nExpr - 1;
            while (k___1 > 0) {
              sqlite3ExprIfFalse(pParse, pCheck->a[k___1].pExpr, addrCkFault, 0);
              k___1 --;
            }
            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, 16);
            sqlite3VdbeResolveLabel(v, addrCkFault);
            pParse->iSelfTab = 0;
            zErr___0 = sqlite3MPrintf(db, "CHECK constraint failed in %s", pTab___6->zName);
            sqlite3VdbeAddOp4(v, 113, 0, 3, 0, (char const   *)zErr___0, -7);
            integrityCheckResultRow(v);
            sqlite3VdbeResolveLabel(v, addrCkOk);
          }
          sqlite3ExprListDelete(db, pCheck);
        }
      }
      if (! isQuick) {
        j___3 = 0;
        pIdx___4 = pTab___6->pIndex;
        while (pIdx___4) {
          tmp___51 = sqlite3VdbeMakeLabel(pParse);
          ckUniq = tmp___51;
          if ((unsigned long )pPk___0 == (unsigned long )pIdx___4) {
            goto __Cont___6;
          }
          r1 = sqlite3GenerateIndexKey(pParse, pIdx___4, iDataCur, 0, 0, & jmp3, pPrior,
                                       r1);
          pPrior = pIdx___4;
          sqlite3VdbeAddOp2(v, 83, 8 + j___3, 1);
          jmp2___0 = sqlite3VdbeAddOp4Int(v, 29, iIdxCur + j___3, ckUniq, r1, (int )pIdx___4->nColumn);
          sqlite3VdbeLoadString(v, 3, "row ");
          sqlite3VdbeAddOp3(v, 108, 7, 3, 3);
          sqlite3VdbeLoadString(v, 4, " missing from index ");
          sqlite3VdbeAddOp3(v, 108, 4, 3, 3);
          jmp5 = sqlite3VdbeLoadString(v, 4, (char const   *)pIdx___4->zName);
          sqlite3VdbeAddOp3(v, 108, 4, 3, 3);
          jmp4 = integrityCheckResultRow(v);
          sqlite3VdbeJumpHere(v, jmp2___0);
          if ((int )pIdx___4->onError != 0) {
            tmp___52 = sqlite3VdbeMakeLabel(pParse);
            uniqOk = tmp___52;
            kk = 0;
            while (kk < (int )pIdx___4->nKeyCol) {
              iCol___0 = (int )*(pIdx___4->aiColumn + kk);
              if (iCol___0 >= 0) {
                if ((pTab___6->aCol + iCol___0)->notNull) {
                  goto __Cont___7;
                }
              }
              sqlite3VdbeAddOp2(v, 50, r1 + kk, uniqOk);
              __Cont___7: /* CIL Label */ 
              kk ++;
            }
            jmp6 = sqlite3VdbeAddOp1(v, 5, iIdxCur + j___3);
            sqlite3VdbeGoto(v, uniqOk);
            sqlite3VdbeJumpHere(v, jmp6);
            sqlite3VdbeAddOp4Int(v, 38, iIdxCur + j___3, uniqOk, r1, (int )pIdx___4->nKeyCol);
            sqlite3VdbeLoadString(v, 3, "non-unique entry in index ");
            sqlite3VdbeGoto(v, jmp5);
            sqlite3VdbeResolveLabel(v, uniqOk);
          }
          sqlite3VdbeJumpHere(v, jmp4);
          sqlite3ResolvePartIdxLabel(pParse, jmp3);
          __Cont___6: /* CIL Label */ 
          pIdx___4 = pIdx___4->pNext;
          j___3 ++;
        }
      }
      sqlite3VdbeAddOp2(v, 5, iDataCur, loopTop);
      sqlite3VdbeJumpHere(v, loopTop - 1);
      if (! isQuick) {
        sqlite3VdbeLoadString(v, 2, "wrong # of entries in index ");
        j___3 = 0;
        pIdx___4 = pTab___6->pIndex;
        while (pIdx___4) {
          if ((unsigned long )pPk___0 == (unsigned long )pIdx___4) {
            goto __Cont___8;
          }
          sqlite3VdbeAddOp2(v, 93, iIdxCur + j___3, 3);
          addr___0 = sqlite3VdbeAddOp3(v, 53, 8 + j___3, 0, 3);
          sqlite3VdbeChangeP5(v, (u16 )144);
          sqlite3VdbeLoadString(v, 4, (char const   *)pIdx___4->zName);
          sqlite3VdbeAddOp3(v, 108, 4, 2, 3);
          integrityCheckResultRow(v);
          sqlite3VdbeJumpHere(v, addr___0);
          __Cont___8: /* CIL Label */ 
          pIdx___4 = pIdx___4->pNext;
          j___3 ++;
        }
      }
      __Cont___4: /* CIL Label */ 
      x___1 = x___1->next;
    }
    __Cont___3: /* CIL Label */ 
    i___8 ++;
  }
  aOp___3 = sqlite3VdbeAddOpList(v, (int )(sizeof(endCode) / sizeof(endCode[0])),
                                 endCode, (int )iLn___4);
  if (aOp___3) {
    (aOp___3 + 0)->p2 = 1 - mxErr;
    (aOp___3 + 2)->p4type = (signed char)-1;
    (aOp___3 + 2)->p4.z = (char *)"ok";
    (aOp___3 + 5)->p4type = (signed char)-1;
    tmp___53 = sqlite3ErrStr(11);
    (aOp___3 + 5)->p4.z = (char *)tmp___53;
  }
  tmp___54 = sqlite3VdbeCurrentAddr(v);
  sqlite3VdbeChangeP3(v, 0, tmp___54 - 2);
  break;
  case 12: 
  if (! zRight) {
    tmp___55 = sqlite3ReadSchema(pParse);
    if (tmp___55) {
      goto pragma_out;
    }
    returnSingleText(v, (char const   *)encnames[(pParse->db)->enc].zName);
  } else
  if (! (((int )((db->aDb + 0)->pSchema)->schemaFlags & 1) == 1)) {
    goto _L___1;
  } else
  if (((int )((db->aDb + 0)->pSchema)->schemaFlags & 4) == 4) {
    _L___1: /* CIL Label */ 
    pEnc = & encnames[0];
    while (pEnc->zName) {
      tmp___57 = sqlite3StrICmp((char const   *)zRight, (char const   *)pEnc->zName);
      if (0 == tmp___57) {
        if (pEnc->enc) {
          tmp___56 = (u8 )pEnc->enc;
        } else {
          tmp___56 = (u8 )2;
        }
        db->enc = tmp___56;
        ((db->aDb + 0)->pSchema)->enc = tmp___56;
        break;
      }
      pEnc ++;
    }
    if (! pEnc->zName) {
      sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
    }
  }
  break;
  case 0: 
  iCookie = (int )pPragma->iArg;
  sqlite3VdbeUsesBtree(v, iDb);
  if (zRight) {
    if (((int const   )pPragma->mPragFlg & 8) == 0) {
      aOp___4 = sqlite3VdbeAddOpList(v, (int )(sizeof(setCookie) / sizeof(setCookie[0])),
                                     setCookie, 0);
      (aOp___4 + 0)->p1 = iDb;
      (aOp___4 + 1)->p1 = iDb;
      (aOp___4 + 1)->p2 = iCookie;
      (aOp___4 + 1)->p3 = sqlite3Atoi((char const   *)zRight);
    } else {
      aOp___5 = sqlite3VdbeAddOpList(v, (int )(sizeof(readCookie) / sizeof(readCookie[0])),
                                     readCookie, 0);
      (aOp___5 + 0)->p1 = iDb;
      (aOp___5 + 1)->p1 = iDb;
      (aOp___5 + 1)->p3 = iCookie;
      sqlite3VdbeReusable(v);
    }
  } else {
    aOp___5 = sqlite3VdbeAddOpList(v, (int )(sizeof(readCookie) / sizeof(readCookie[0])),
                                   readCookie, 0);
    (aOp___5 + 0)->p1 = iDb;
    (aOp___5 + 1)->p1 = iDb;
    (aOp___5 + 1)->p3 = iCookie;
    sqlite3VdbeReusable(v);
  }
  break;
  case 8: 
  i___9 = 0;
  pParse->nMem = 1;
  while (1) {
    tmp___58 = i___9;
    i___9 ++;
    zOpt = sqlite3_compileoption_get(tmp___58);
    if (! ((unsigned long )zOpt != (unsigned long )((char const   *)0))) {
      break;
    }
    sqlite3VdbeLoadString(v, 1, zOpt);
    sqlite3VdbeAddOp2(v, 81, 1, 1);
  }
  sqlite3VdbeReusable(v);
  break;
  case 39: 
  if (pId2->z) {
    tmp___59 = iDb;
  } else {
    tmp___59 = 10;
  }
  iBt = tmp___59;
  eMode___1 = 0;
  if (zRight) {
    tmp___62 = sqlite3StrICmp((char const   *)zRight, "full");
    if (tmp___62 == 0) {
      eMode___1 = 1;
    } else {
      tmp___61 = sqlite3StrICmp((char const   *)zRight, "restart");
      if (tmp___61 == 0) {
        eMode___1 = 2;
      } else {
        tmp___60 = sqlite3StrICmp((char const   *)zRight, "truncate");
        if (tmp___60 == 0) {
          eMode___1 = 3;
        }
      }
    }
  }
  pParse->nMem = 3;
  sqlite3VdbeAddOp3(v, 6, iBt, eMode___1, 1);
  sqlite3VdbeAddOp2(v, 81, 1, 3);
  break;
  case 38: 
  if (zRight) {
    tmp___63 = sqlite3Atoi((char const   *)zRight);
    sqlite3_wal_autocheckpoint(db, tmp___63);
  }
  if ((unsigned long )db->xWalCallback == (unsigned long )(& sqlite3WalDefaultHook)) {
    tmp___64 = (int )((long )db->pWalArg);
  } else {
    tmp___64 = 0;
  }
  returnSingleInt(v, (i64 )tmp___64);
  break;
  case 31: 
  sqlite3_db_release_memory(db);
  break;
  case 27: 
  if (zRight) {
    tmp___65 = sqlite3Atoi((char const   *)zRight);
    opMask = (u32 )tmp___65;
    if ((opMask & 2U) == 0U) {
      break;
    }
  } else {
    opMask = (u32 )65534;
  }
  tmp___66 = pParse->nTab;
  (pParse->nTab) ++;
  iTabCur = tmp___66;
  if (zDb) {
    iDbLast = iDb;
  } else {
    iDbLast = db->nDb - 1;
  }
  while (iDb <= iDbLast) {
    if (iDb == 1) {
      goto __Cont___9;
    }
    sqlite3CodeVerifySchema(pParse, iDb);
    pSchema = (db->aDb + iDb)->pSchema;
    k___2 = pSchema->tblHash.first;
    while (k___2) {
      pTab___7 = (Table *)k___2->data;
      if ((pTab___7->tabFlags & 256U) == 0U) {
        goto __Cont___10;
      }
      szThreshold = (LogEst )((int )pTab___7->nRowLogEst + 46);
      pIdx___5 = pTab___7->pIndex;
      while (pIdx___5) {
        if (! pIdx___5->hasStat1) {
          szThreshold = (LogEst )0;
          break;
        }
        pIdx___5 = pIdx___5->pNext;
      }
      if (szThreshold) {
        sqlite3OpenTable(pParse, iTabCur, iDb, pTab___7, 97);
        tmp___67 = sqlite3VdbeCurrentAddr(v);
        sqlite3VdbeAddOp3(v, 33, iTabCur, (int )((unsigned int )(tmp___67 + 2) + (opMask & 1U)),
                          (int )szThreshold);
      }
      zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"", (db->aDb + iDb)->zDbSName,
                               pTab___7->zName);
      if (opMask & 1U) {
        tmp___68 = sqlite3GetTempReg(pParse);
        r1___0 = tmp___68;
        sqlite3VdbeAddOp4(v, 113, 0, r1___0, 0, (char const   *)zSubSql, -7);
        sqlite3VdbeAddOp2(v, 81, r1___0, 1);
      } else {
        sqlite3VdbeAddOp4(v, 140, 0, 0, 0, (char const   *)zSubSql, -7);
      }
      __Cont___10: /* CIL Label */ 
      k___2 = k___2->next;
    }
    __Cont___9: /* CIL Label */ 
    iDb ++;
  }
  sqlite3VdbeAddOp0(v, 158);
  break;
  default: 
  if (zRight) {
    tmp___69 = sqlite3Atoi((char const   *)zRight);
    sqlite3_busy_timeout(db, tmp___69);
  }
  returnSingleInt(v, (i64 )db->busyTimeout);
  break;
  case 32: 
  if (zRight) {
    tmp___70 = sqlite3DecOrHexToI64((char const   *)zRight, & N);
    if (tmp___70 == 0) {
      sqlite3_soft_heap_limit64(N);
    }
  }
  tmp___71 = sqlite3_soft_heap_limit64((sqlite_int64 )-1);
  returnSingleInt(v, tmp___71);
  break;
  case 37: 
  if (zRight) {
    tmp___72 = sqlite3DecOrHexToI64((char const   *)zRight, & N___0);
    if (tmp___72 == 0) {
      if (N___0 >= 0LL) {
        sqlite3_limit(db, 11, (int )(N___0 & 2147483647LL));
      }
    }
  }
  tmp___73 = sqlite3_limit(db, 11, -1);
  returnSingleInt(v, (i64 )tmp___73);
  break;
  }
  if ((int const   )pPragma->mPragFlg & 4) {
    if (zRight) {
      tmp___74 = 1;
    } else {
      tmp___74 = 0;
    }
  } else {
    tmp___74 = 0;
  }
  pragma_out: 
  sqlite3DbFree(db, (void *)zLeft);
  sqlite3DbFree(db, (void *)zRight);
  return;
}
}
static int pragmaVtabConnect(sqlite3 *db , void *pAux , int argc , char const   * const  *argv ,
                             sqlite3_vtab **ppVtab , char **pzErr ) 
{ 
  PragmaName const   *pPragma ;
  PragmaVtab *pTab ;
  int rc ;
  int i ;
  int j ;
  char cSep ;
  StrAccum acc ;
  char zBuf[200] ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  pPragma = (PragmaName const   *)pAux;
  pTab = (PragmaVtab *)0;
  cSep = (char )'(';
  sqlite3StrAccumInit(& acc, (sqlite3 *)0, zBuf, (int )sizeof(zBuf), 0);
  sqlite3_str_appendall(& acc, "CREATE TABLE x");
  i = 0;
  j = (int )pPragma->iPragCName;
  while (i < (int )pPragma->nPragCName) {
    sqlite3_str_appendf(& acc, "%c\"%s\"", (int )cSep, pragCName[j]);
    cSep = (char )',';
    i ++;
    j ++;
  }
  if (i == 0) {
    sqlite3_str_appendf(& acc, "(\"%s\"", pPragma->zName);
    i ++;
  }
  j = 0;
  if ((int const   )pPragma->mPragFlg & 32) {
    sqlite3_str_appendall(& acc, ",arg HIDDEN");
    j ++;
  }
  if ((int const   )pPragma->mPragFlg & 192) {
    sqlite3_str_appendall(& acc, ",schema HIDDEN");
    j ++;
  }
  sqlite3_str_append(& acc, ")", 1);
  sqlite3StrAccumFinish(& acc);
  rc = sqlite3_declare_vtab(db, (char const   *)(zBuf));
  if (rc == 0) {
    tmp = sqlite3_malloc((int )sizeof(PragmaVtab ));
    pTab = (PragmaVtab *)tmp;
    if ((unsigned long )pTab == (unsigned long )((PragmaVtab *)0)) {
      rc = 7;
    } else {
      memset((void *)pTab, 0, sizeof(PragmaVtab ));
      pTab->pName = pPragma;
      pTab->db = db;
      pTab->iHidden = (u8 )i;
      pTab->nHidden = (u8 )j;
    }
  } else {
    tmp___0 = sqlite3_errmsg(db);
    *pzErr = sqlite3_mprintf("%s", tmp___0);
  }
  *ppVtab = (sqlite3_vtab *)pTab;
  return (rc);
}
}
static int pragmaVtabDisconnect(sqlite3_vtab *pVtab ) 
{ 
  PragmaVtab *pTab ;

  {
  pTab = (PragmaVtab *)pVtab;
  sqlite3_free((void *)pTab);
  return (0);
}
}
static int pragmaVtabBestIndex(sqlite3_vtab *tab , sqlite3_index_info *pIdxInfo ) 
{ 
  PragmaVtab *pTab ;
  struct sqlite3_index_constraint  const  *pConstraint ;
  int i ;
  int j ;
  int seen[2] ;

  {
  pTab = (PragmaVtab *)tab;
  pIdxInfo->estimatedCost = (double )1;
  if ((int )pTab->nHidden == 0) {
    return (0);
  }
  pConstraint = (struct sqlite3_index_constraint  const  *)pIdxInfo->aConstraint;
  seen[0] = 0;
  seen[1] = 0;
  i = 0;
  while (i < pIdxInfo->nConstraint) {
    if ((int const   )pConstraint->usable == 0) {
      goto __Cont;
    }
    if ((int const   )pConstraint->op != 2) {
      goto __Cont;
    }
    if (pConstraint->iColumn < (int const   )pTab->iHidden) {
      goto __Cont;
    }
    j = (int )(pConstraint->iColumn - (int const   )pTab->iHidden);
    seen[j] = i + 1;
    __Cont: /* CIL Label */ 
    i ++;
    pConstraint ++;
  }
  if (seen[0] == 0) {
    pIdxInfo->estimatedCost = (double )2147483647;
    pIdxInfo->estimatedRows = (sqlite_int64 )2147483647;
    return (0);
  }
  j = seen[0] - 1;
  (pIdxInfo->aConstraintUsage + j)->argvIndex = 1;
  (pIdxInfo->aConstraintUsage + j)->omit = (unsigned char)1;
  if (seen[1] == 0) {
    return (0);
  }
  pIdxInfo->estimatedCost = (double )20;
  pIdxInfo->estimatedRows = (sqlite_int64 )20;
  j = seen[1] - 1;
  (pIdxInfo->aConstraintUsage + j)->argvIndex = 2;
  (pIdxInfo->aConstraintUsage + j)->omit = (unsigned char)1;
  return (0);
}
}
static int pragmaVtabOpen(sqlite3_vtab *pVtab , sqlite3_vtab_cursor **ppCursor ) 
{ 
  PragmaVtabCursor *pCsr ;
  void *tmp ;

  {
  tmp = sqlite3_malloc((int )sizeof(*pCsr));
  pCsr = (PragmaVtabCursor *)tmp;
  if ((unsigned long )pCsr == (unsigned long )((PragmaVtabCursor *)0)) {
    return (7);
  }
  memset((void *)pCsr, 0, sizeof(PragmaVtabCursor ));
  pCsr->base.pVtab = pVtab;
  *ppCursor = & pCsr->base;
  return (0);
}
}
static void pragmaVtabCursorClear(PragmaVtabCursor *pCsr ) 
{ 
  int i ;

  {
  sqlite3_finalize(pCsr->pPragma);
  pCsr->pPragma = (sqlite3_stmt *)0;
  i = 0;
  while (i < (int )(sizeof(pCsr->azArg) / sizeof(pCsr->azArg[0]))) {
    sqlite3_free((void *)pCsr->azArg[i]);
    pCsr->azArg[i] = (char *)0;
    i ++;
  }
  return;
}
}
static int pragmaVtabClose(sqlite3_vtab_cursor *cur ) 
{ 
  PragmaVtabCursor *pCsr ;

  {
  pCsr = (PragmaVtabCursor *)cur;
  pragmaVtabCursorClear(pCsr);
  sqlite3_free((void *)pCsr);
  return (0);
}
}
static int pragmaVtabNext(sqlite3_vtab_cursor *pVtabCursor ) 
{ 
  PragmaVtabCursor *pCsr ;
  int rc ;
  int tmp ;

  {
  pCsr = (PragmaVtabCursor *)pVtabCursor;
  rc = 0;
  (pCsr->iRowid) ++;
  tmp = sqlite3_step(pCsr->pPragma);
  if (100 != tmp) {
    rc = sqlite3_finalize(pCsr->pPragma);
    pCsr->pPragma = (sqlite3_stmt *)0;
    pragmaVtabCursorClear(pCsr);
  }
  return (rc);
}
}
static int pragmaVtabFilter(sqlite3_vtab_cursor *pVtabCursor , int idxNum , char const   *idxStr ,
                            int argc , sqlite3_value **argv ) 
{ 
  PragmaVtabCursor *pCsr ;
  PragmaVtab *pTab ;
  int rc ;
  int i ;
  int j ;
  StrAccum acc ;
  char *zSql ;
  char const   *zText___0 ;
  unsigned char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  pCsr = (PragmaVtabCursor *)pVtabCursor;
  pTab = (PragmaVtab *)pVtabCursor->pVtab;
  pragmaVtabCursorClear(pCsr);
  if (((int const   )(pTab->pName)->mPragFlg & 32) != 0) {
    j = 0;
  } else {
    j = 1;
  }
  i = 0;
  while (i < argc) {
    tmp = sqlite3_value_text(*(argv + i));
    zText___0 = (char const   *)tmp;
    if (zText___0) {
      pCsr->azArg[j] = sqlite3_mprintf("%s", zText___0);
      if ((unsigned long )pCsr->azArg[j] == (unsigned long )((char *)0)) {
        return (7);
      }
    }
    i ++;
    j ++;
  }
  sqlite3StrAccumInit(& acc, (sqlite3 *)0, (char *)0, 0, (pTab->db)->aLimit[1]);
  sqlite3_str_appendall(& acc, "PRAGMA ");
  if (pCsr->azArg[1]) {
    sqlite3_str_appendf(& acc, "%Q.", pCsr->azArg[1]);
  }
  sqlite3_str_appendall(& acc, (char const   *)(pTab->pName)->zName);
  if (pCsr->azArg[0]) {
    sqlite3_str_appendf(& acc, "=%Q", pCsr->azArg[0]);
  }
  zSql = sqlite3StrAccumFinish(& acc);
  if ((unsigned long )zSql == (unsigned long )((char *)0)) {
    return (7);
  }
  rc = sqlite3_prepare_v2(pTab->db, (char const   *)zSql, -1, & pCsr->pPragma, (char const   **)0);
  sqlite3_free((void *)zSql);
  if (rc != 0) {
    tmp___0 = sqlite3_errmsg(pTab->db);
    pTab->base.zErrMsg = sqlite3_mprintf("%s", tmp___0);
    return (rc);
  }
  tmp___1 = pragmaVtabNext(pVtabCursor);
  return (tmp___1);
}
}
static int pragmaVtabEof(sqlite3_vtab_cursor *pVtabCursor ) 
{ 
  PragmaVtabCursor *pCsr ;

  {
  pCsr = (PragmaVtabCursor *)pVtabCursor;
  return ((unsigned long )pCsr->pPragma == (unsigned long )((sqlite3_stmt *)0));
}
}
static int pragmaVtabColumn(sqlite3_vtab_cursor *pVtabCursor , sqlite3_context *ctx ,
                            int i ) 
{ 
  PragmaVtabCursor *pCsr ;
  PragmaVtab *pTab ;
  sqlite3_value *tmp ;

  {
  pCsr = (PragmaVtabCursor *)pVtabCursor;
  pTab = (PragmaVtab *)pVtabCursor->pVtab;
  if (i < (int )pTab->iHidden) {
    tmp = sqlite3_column_value(pCsr->pPragma, i);
    sqlite3_result_value(ctx, tmp);
  } else {
    sqlite3_result_text(ctx, (char const   *)pCsr->azArg[i - (int )pTab->iHidden],
                        -1, (void (*)(void * ))-1);
  }
  return (0);
}
}
static int pragmaVtabRowid(sqlite3_vtab_cursor *pVtabCursor , sqlite_int64 *p ) 
{ 
  PragmaVtabCursor *pCsr ;

  {
  pCsr = (PragmaVtabCursor *)pVtabCursor;
  *p = pCsr->iRowid;
  return (0);
}
}
static struct sqlite3_module  const  pragmaVtabModule  = 
     {0, (int (*)(sqlite3 * , void *pAux , int argc , char const   * const  *argv ,
                sqlite3_vtab **ppVTab , char ** ))0, & pragmaVtabConnect, & pragmaVtabBestIndex,
    & pragmaVtabDisconnect, (int (*)(sqlite3_vtab *pVTab ))0, & pragmaVtabOpen, & pragmaVtabClose,
    & pragmaVtabFilter, & pragmaVtabNext, & pragmaVtabEof, & pragmaVtabColumn, & pragmaVtabRowid,
    (int (*)(sqlite3_vtab * , int  , sqlite3_value ** , sqlite_int64 * ))0, (int (*)(sqlite3_vtab *pVTab ))0,
    (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0,
    (int (*)(sqlite3_vtab *pVtab , int nArg , char const   *zName , void (**pxFunc)(sqlite3_context * ,
                                                                                    int  ,
                                                                                    sqlite3_value ** ) ,
             void **ppArg ))0, (int (*)(sqlite3_vtab *pVtab , char const   *zNew ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(sqlite3_vtab *pVTab , int  ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(char const   * ))0};
static Module *sqlite3PragmaVtabRegister(sqlite3 *db , char const   *zName ) 
{ 
  PragmaName const   *pName ;
  Module *tmp ;

  {
  pName = pragmaLocate(zName + 7);
  if ((unsigned long )pName == (unsigned long )((PragmaName const   *)0)) {
    return ((Module *)0);
  }
  if (((int const   )pName->mPragFlg & 48) == 0) {
    return ((Module *)0);
  }
  tmp = sqlite3VtabCreateModule(db, zName, & pragmaVtabModule, (void *)pName, (void (*)(void * ))0);
  return (tmp);
}
}
static void corruptSchema(InitData *pData , char const   *zObj , char const   *zExtra ) 
{ 
  sqlite3 *db ;
  char *z ;

  {
  db = pData->db;
  if (db->mallocFailed) {
    pData->rc = 7;
  } else
  if (! ((unsigned long )*(pData->pzErrMsg + 0) != (unsigned long )((char *)0))) {
    if (pData->mInitFlags & 1U) {
      *(pData->pzErrMsg) = sqlite3DbStrDup(db, zExtra);
      pData->rc = 1;
    } else
    if (db->flags & 1ULL) {
      pData->rc = sqlite3CorruptError(124694);
    } else {
      if ((unsigned long )zObj == (unsigned long )((char const   *)0)) {
        zObj = "?";
      }
      z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
      if (zExtra) {
        if (*(zExtra + 0)) {
          z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
        }
      }
      *(pData->pzErrMsg) = z;
      pData->rc = sqlite3CorruptError(124701);
    }
  }
  return;
}
}
static int sqlite3IndexHasDuplicateRootPage(Index *pIndex ) 
{ 
  Index *p ;

  {
  p = (pIndex->pTable)->pIndex;
  while (p) {
    if (p->tnum == pIndex->tnum) {
      if ((unsigned long )p != (unsigned long )pIndex) {
        return (1);
      }
    }
    p = p->pNext;
  }
  return (0);
}
}
static int sqlite3InitCallback(void *pInit , int argc , char **argv , char **NotUsed ) 
{ 
  InitData *pData ;
  sqlite3 *db ;
  int iDb ;
  int rc ;
  u8 saved_iDb ;
  sqlite3_stmt *pStmt ;
  char const   *tmp ;
  Index *pIndex ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pData = (InitData *)pInit;
  db = pData->db;
  iDb = pData->iDb;
  ((db->aDb + iDb)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + iDb)->pSchema)->schemaFlags & -5);
  (pData->nInitRow) ++;
  if (db->mallocFailed) {
    corruptSchema(pData, (char const   *)*(argv + 1), (char const   *)0);
    return (1);
  }
  if ((unsigned long )argv == (unsigned long )((char **)0)) {
    return (0);
  }
  if ((unsigned long )*(argv + 3) == (unsigned long )((char *)0)) {
    corruptSchema(pData, (char const   *)*(argv + 1), (char const   *)0);
  } else {
    tmp___3 = sqlite3_strnicmp((char const   *)*(argv + 4), "create ", 7);
    if (tmp___3 == 0) {
      saved_iDb = db->init.iDb;
      db->init.iDb = (u8 )iDb;
      db->init.newTnum = sqlite3Atoi((char const   *)*(argv + 3));
      db->init.orphanTrigger = 0U;
      db->init.azInit = argv;
      sqlite3_prepare(db, (char const   *)*(argv + 4), -1, & pStmt, (char const   **)0);
      rc = db->errCode;
      db->init.iDb = saved_iDb;
      if (0 != rc) {
        if (! db->init.orphanTrigger) {
          if (rc > pData->rc) {
            pData->rc = rc;
          }
          if (rc == 7) {
            sqlite3OomFault(db);
          } else
          if (rc != 9) {
            if ((rc & 255) != 6) {
              tmp = sqlite3_errmsg(db);
              corruptSchema(pData, (char const   *)*(argv + 1), tmp);
            }
          }
        }
      }
      sqlite3_finalize(pStmt);
    } else
    if ((unsigned long )*(argv + 1) == (unsigned long )((char *)0)) {
      corruptSchema(pData, (char const   *)*(argv + 1), (char const   *)0);
    } else
    if ((unsigned long )*(argv + 4) != (unsigned long )((char *)0)) {
      if ((int )*(*(argv + 4) + 0) != 0) {
        corruptSchema(pData, (char const   *)*(argv + 1), (char const   *)0);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      pIndex = sqlite3FindIndex(db, (char const   *)*(argv + 1), (char const   *)(db->aDb + iDb)->zDbSName);
      if ((unsigned long )pIndex == (unsigned long )((Index *)0)) {
        goto _L;
      } else {
        tmp___1 = sqlite3GetInt32((char const   *)*(argv + 3), & pIndex->tnum);
        if (tmp___1 == 0) {
          goto _L;
        } else
        if (pIndex->tnum < 2) {
          goto _L;
        } else {
          tmp___2 = sqlite3IndexHasDuplicateRootPage(pIndex);
          if (tmp___2) {
            _L: /* CIL Label */ 
            if (pIndex) {
              tmp___0 = "invalid rootpage";
            } else {
              tmp___0 = "orphan index";
            }
            corruptSchema(pData, (char const   *)*(argv + 1), tmp___0);
          }
        }
      }
    }
  }
  return (0);
}
}
static int sqlite3InitOne(sqlite3 *db , int iDb , char **pzErrMsg , u32 mFlags ) 
{ 
  int rc ;
  int i ;
  int size ;
  Db *pDb ;
  char const   *azArg[6] ;
  int meta[5] ;
  InitData initData ;
  char const   *zMasterName ;
  int openedTransaction ;
  char const   *tmp ;
  int tmp___0 ;
  u8 encoding ;
  char *zSql ;
  int (*xAuth)(void * , int  , char const   * , char const   * , char const   * ,
               char const   * ) ;

  {
  openedTransaction = 0;
  db->init.busy = (u8 )1;
  azArg[0] = "table";
  if (iDb == 1) {
    zMasterName = "sqlite_temp_master";
  } else {
    zMasterName = "sqlite_master";
  }
  azArg[1] = zMasterName;
  azArg[2] = azArg[1];
  azArg[3] = "1";
  azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)";
  azArg[5] = (char const   *)0;
  initData.db = db;
  initData.iDb = iDb;
  initData.rc = 0;
  initData.pzErrMsg = pzErrMsg;
  initData.mInitFlags = mFlags;
  initData.nInitRow = (u32 )0;
  sqlite3InitCallback((void *)(& initData), 5, (char **)(azArg), (char **)0);
  if (initData.rc) {
    rc = initData.rc;
    goto error_out;
  }
  pDb = db->aDb + iDb;
  if ((unsigned long )pDb->pBt == (unsigned long )((Btree *)0)) {
    ((db->aDb + 1)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + 1)->pSchema)->schemaFlags | 1);
    rc = 0;
    goto error_out;
  }
  sqlite3BtreeEnter(pDb->pBt);
  tmp___0 = sqlite3BtreeIsInReadTrans(pDb->pBt);
  if (! tmp___0) {
    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, (int *)0);
    if (rc != 0) {
      tmp = sqlite3ErrStr(rc);
      sqlite3SetString(pzErrMsg, db, tmp);
      goto initone_error_out;
    }
    openedTransaction = 1;
  }
  i = 0;
  while (i < (int )(sizeof(meta) / sizeof(meta[0]))) {
    sqlite3BtreeGetMeta(pDb->pBt, i + 1, (u32 *)(& meta[i]));
    i ++;
  }
  if ((db->flags & 33554432ULL) != 0ULL) {
    memset((void *)(meta), 0, sizeof(meta));
  }
  (pDb->pSchema)->schema_cookie = meta[0];
  if (meta[4]) {
    if (iDb == 0) {
      encoding = (u8 )((int )((u8 )meta[4]) & 3);
      if ((int )encoding == 0) {
        encoding = (u8 )1;
      }
      db->enc = encoding;
    } else
    if (meta[4] != (int )db->enc) {
      sqlite3SetString(pzErrMsg, db, "attached databases must use the same text encoding as main database");
      rc = 1;
      goto initone_error_out;
    }
  } else {
    ((db->aDb + iDb)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + iDb)->pSchema)->schemaFlags | 4);
  }
  (pDb->pSchema)->enc = db->enc;
  if ((pDb->pSchema)->cache_size == 0) {
    size = sqlite3AbsInt32(meta[2]);
    if (size == 0) {
      size = -2000;
    }
    (pDb->pSchema)->cache_size = size;
    sqlite3BtreeSetCacheSize(pDb->pBt, (pDb->pSchema)->cache_size);
  }
  (pDb->pSchema)->file_format = (u8 )meta[1];
  if ((int )(pDb->pSchema)->file_format == 0) {
    (pDb->pSchema)->file_format = (u8 )1;
  }
  if ((int )(pDb->pSchema)->file_format > 4) {
    sqlite3SetString(pzErrMsg, db, "unsupported file format");
    rc = 1;
    goto initone_error_out;
  }
  if (iDb == 0) {
    if (meta[1] >= 4) {
      db->flags &= 0xfffffffffffffffdULL;
    }
  }
  zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\".%s ORDER BY rowid", (db->aDb + iDb)->zDbSName,
                        zMasterName);
  xAuth = db->xAuth;
  db->xAuth = (int (*)(void * , int  , char const   * , char const   * , char const   * ,
                       char const   * ))0;
  rc = sqlite3_exec(db, (char const   *)zSql, & sqlite3InitCallback, (void *)(& initData),
                    (char **)0);
  db->xAuth = xAuth;
  if (rc == 0) {
    rc = initData.rc;
  }
  sqlite3DbFree(db, (void *)zSql);
  if (rc == 0) {
    sqlite3AnalysisLoad(db, iDb);
  }
  if (db->mallocFailed) {
    rc = 7;
    sqlite3ResetAllSchemasOfConnection(db);
  }
  if (rc == 0) {
    ((db->aDb + iDb)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + iDb)->pSchema)->schemaFlags | 1);
    rc = 0;
  } else
  if (db->flags & 134217728ULL) {
    ((db->aDb + iDb)->pSchema)->schemaFlags = (u16 )((int )((db->aDb + iDb)->pSchema)->schemaFlags | 1);
    rc = 0;
  }
  initone_error_out: 
  if (openedTransaction) {
    sqlite3BtreeCommit(pDb->pBt);
  }
  error_out: 
  if (rc) {
    if (rc == 7) {
      sqlite3OomFault(db);
    } else
    if (rc == (10 | (12 << 8))) {
      sqlite3OomFault(db);
    }
    sqlite3ResetOneSchema(db, iDb);
  }
  db->init.busy = (u8 )0;
  return (rc);
}
}
static int sqlite3Init(sqlite3 *db , char **pzErrMsg ) 
{ 
  int i ;
  int rc ;
  int commit_internal ;

  {
  commit_internal = ! (db->mDbFlags & 1U);
  db->enc = ((db->aDb + 0)->pSchema)->enc;
  if (! (((int )((db->aDb + 0)->pSchema)->schemaFlags & 1) == 1)) {
    rc = sqlite3InitOne(db, 0, pzErrMsg, (u32 )0);
    if (rc) {
      return (rc);
    }
  }
  i = db->nDb - 1;
  while (i > 0) {
    if (! (((int )((db->aDb + i)->pSchema)->schemaFlags & 1) == 1)) {
      rc = sqlite3InitOne(db, i, pzErrMsg, (u32 )0);
      if (rc) {
        return (rc);
      }
    }
    i --;
  }
  if (commit_internal) {
    sqlite3CommitInternalChanges(db);
  }
  return (0);
}
}
static int sqlite3ReadSchema(Parse *pParse ) 
{ 
  int rc ;
  sqlite3 *db ;

  {
  rc = 0;
  db = pParse->db;
  if (! db->init.busy) {
    rc = sqlite3Init(db, & pParse->zErrMsg);
    if (rc != 0) {
      pParse->rc = rc;
      (pParse->nErr) ++;
    } else
    if (db->noSharedCache) {
      db->mDbFlags |= 16U;
    }
  }
  return (rc);
}
}
static void schemaIsValid(Parse *pParse ) 
{ 
  sqlite3 *db ;
  int iDb ;
  int rc ;
  int cookie ;
  int openedTransaction ;
  Btree *pBt ;
  int tmp ;

  {
  db = pParse->db;
  iDb = 0;
  while (iDb < db->nDb) {
    openedTransaction = 0;
    pBt = (db->aDb + iDb)->pBt;
    if ((unsigned long )pBt == (unsigned long )((Btree *)0)) {
      goto __Cont;
    }
    tmp = sqlite3BtreeIsInReadTrans(pBt);
    if (! tmp) {
      rc = sqlite3BtreeBeginTrans(pBt, 0, (int *)0);
      if (rc == 7) {
        sqlite3OomFault(db);
      } else
      if (rc == (10 | (12 << 8))) {
        sqlite3OomFault(db);
      }
      if (rc != 0) {
        return;
      }
      openedTransaction = 1;
    }
    sqlite3BtreeGetMeta(pBt, 1, (u32 *)(& cookie));
    if (cookie != ((db->aDb + iDb)->pSchema)->schema_cookie) {
      sqlite3ResetOneSchema(db, iDb);
      pParse->rc = 17;
    }
    if (openedTransaction) {
      sqlite3BtreeCommit(pBt);
    }
    __Cont: /* CIL Label */ 
    iDb ++;
  }
  return;
}
}
static int sqlite3SchemaToIndex(sqlite3 *db , Schema *pSchema ) 
{ 
  int i ;

  {
  i = -1000000;
  if (pSchema) {
    i = 0;
    while (! ((unsigned long )(db->aDb + i)->pSchema == (unsigned long )pSchema)) {
      i ++;
    }
  }
  return (i);
}
}
static void sqlite3ParserReset(Parse *pParse ) 
{ 
  sqlite3 *db ;

  {
  db = pParse->db;
  sqlite3DbFree(db, (void *)pParse->aLabel);
  sqlite3ExprListDelete(db, pParse->pConstExpr);
  if (db) {
    db->lookaside.bDisable -= (u32 )pParse->disableLookaside;
  }
  pParse->disableLookaside = (u8 )0;
  return;
}
}
static int sqlite3Prepare(sqlite3 *db , char const   *zSql , int nBytes , u32 prepFlags ,
                          Vdbe *pReprepare , sqlite3_stmt **ppStmt , char const   **pzTail ) ;
static char const   * const  azColName[12]  = 
  {      (char const   * const  )"addr",      (char const   * const  )"opcode",      (char const   * const  )"p1",      (char const   * const  )"p2", 
        (char const   * const  )"p3",      (char const   * const  )"p4",      (char const   * const  )"p5",      (char const   * const  )"comment", 
        (char const   * const  )"id",      (char const   * const  )"parent",      (char const   * const  )"notused",      (char const   * const  )"detail"};
static int sqlite3Prepare(sqlite3 *db , char const   *zSql , int nBytes , u32 prepFlags ,
                          Vdbe *pReprepare , sqlite3_stmt **ppStmt , char const   **pzTail ) 
{ 
  char *zErrMsg ;
  int rc ;
  int i ;
  Parse sParse ;
  Btree *pBt ;
  char const   *zDb ;
  char *zSqlCopy ;
  int mxLen ;
  int iFirst ;
  int mx ;
  TriggerPrg *pT ;

  {
  zErrMsg = (char *)0;
  rc = 0;
  memset((void *)(& sParse), 0, (unsigned long )(& ((Parse *)0)->aTempReg));
  memset((void *)((char *)(& sParse) + (unsigned long )(& ((Parse *)0)->sLastToken)),
         0, sizeof(Parse ) - (unsigned long )(& ((Parse *)0)->sLastToken));
  sParse.pReprepare = pReprepare;
  if (prepFlags & 1U) {
    sParse.disableLookaside = (u8 )((int )sParse.disableLookaside + 1);
    (db->lookaside.bDisable) ++;
  }
  sParse.disableVtab = (u8 )((prepFlags & 4U) != 0U);
  i = 0;
  while (i < db->nDb) {
    pBt = (db->aDb + i)->pBt;
    if (pBt) {
      rc = sqlite3BtreeSchemaLocked(pBt);
      if (rc) {
        zDb = (char const   *)(db->aDb + i)->zDbSName;
        sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);
        goto end_prepare;
      }
    }
    i ++;
  }
  sqlite3VtabUnlockList(db);
  sParse.db = db;
  if (nBytes >= 0) {
    if (nBytes == 0) {
      goto _L;
    } else
    if ((int const   )*(zSql + (nBytes - 1)) != 0) {
      _L: /* CIL Label */ 
      mxLen = db->aLimit[1];
      if (nBytes > mxLen) {
        sqlite3ErrorWithMsg(db, 18, "statement too long");
        rc = sqlite3ApiExit(db, 18);
        goto end_prepare;
      }
      zSqlCopy = sqlite3DbStrNDup(db, zSql, (u64 )nBytes);
      if (zSqlCopy) {
        sqlite3RunParser(& sParse, (char const   *)zSqlCopy, & zErrMsg);
        sParse.zTail = zSql + (sParse.zTail - (char const   *)zSqlCopy);
        sqlite3DbFree(db, (void *)zSqlCopy);
      } else {
        sParse.zTail = zSql + nBytes;
      }
    } else {
      sqlite3RunParser(& sParse, zSql, & zErrMsg);
    }
  } else {
    sqlite3RunParser(& sParse, zSql, & zErrMsg);
  }
  if (sParse.rc == 101) {
    sParse.rc = 0;
  }
  if (sParse.checkSchema) {
    schemaIsValid(& sParse);
  }
  if (db->mallocFailed) {
    sParse.rc = 7;
  }
  if (pzTail) {
    *pzTail = sParse.zTail;
  }
  rc = sParse.rc;
  if (sParse.explain) {
    if (rc == 0) {
      if (sParse.pVdbe) {
        if ((int )sParse.explain == 2) {
          sqlite3VdbeSetNumCols(sParse.pVdbe, 4);
          iFirst = 8;
          mx = 12;
        } else {
          sqlite3VdbeSetNumCols(sParse.pVdbe, 8);
          iFirst = 0;
          mx = 8;
        }
        i = iFirst;
        while (i < mx) {
          sqlite3VdbeSetColName(sParse.pVdbe, i - iFirst, 0, (char const   *)azColName[i],
                                (void (*)(void * ))0);
          i ++;
        }
      }
    }
  }
  if ((int )db->init.busy == 0) {
    sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int )(sParse.zTail - zSql), (u8 )prepFlags);
  }
  if (rc != 0) {
    goto _L___0;
  } else
  if (db->mallocFailed) {
    _L___0: /* CIL Label */ 
    if (sParse.pVdbe) {
      sqlite3VdbeFinalize(sParse.pVdbe);
    }
  } else {
    *ppStmt = (sqlite3_stmt *)sParse.pVdbe;
  }
  if (zErrMsg) {
    sqlite3ErrorWithMsg(db, rc, "%s", zErrMsg);
    sqlite3DbFree(db, (void *)zErrMsg);
  } else {
    sqlite3Error(db, rc);
  }
  while (sParse.pTriggerPrg) {
    pT = sParse.pTriggerPrg;
    sParse.pTriggerPrg = pT->pNext;
    sqlite3DbFree(db, (void *)pT);
  }
  end_prepare: 
  sqlite3ParserReset(& sParse);
  return (rc);
}
}
static int sqlite3LockAndPrepare(sqlite3 *db , char const   *zSql , int nBytes , u32 prepFlags ,
                                 Vdbe *pOld , sqlite3_stmt **ppStmt , char const   **pzTail ) 
{ 
  int rc ;
  int cnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  cnt = 0;
  *ppStmt = (sqlite3_stmt *)0;
  tmp___0 = sqlite3SafetyCheckOk(db);
  if (tmp___0) {
    if ((unsigned long )zSql == (unsigned long )((char const   *)0)) {
      tmp = sqlite3MisuseError(125372);
      return (tmp);
    }
  } else {
    tmp = sqlite3MisuseError(125372);
    return (tmp);
  }
  sqlite3BtreeEnterAll(db);
  while (1) {
    rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);
    if (! (rc == (1 | (2 << 8)))) {
      if (rc == 17) {
        sqlite3ResetOneSchema(db, -1);
        tmp___1 = cnt;
        cnt ++;
        if (! (tmp___1 == 0)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
static int sqlite3Reprepare(Vdbe *p ) 
{ 
  int rc ;
  sqlite3_stmt *pNew ;
  char const   *zSql ;
  sqlite3 *db ;
  u8 prepFlags ;

  {
  zSql = sqlite3_sql((sqlite3_stmt *)p);
  db = sqlite3VdbeDb(p);
  prepFlags = sqlite3VdbePrepareFlags(p);
  rc = sqlite3LockAndPrepare(db, zSql, -1, (u32 )prepFlags, p, & pNew, (char const   **)0);
  if (rc) {
    if (rc == 7) {
      sqlite3OomFault(db);
    }
    return (rc);
  }
  sqlite3VdbeSwap((Vdbe *)pNew, p);
  sqlite3TransferBindings(pNew, (sqlite3_stmt *)p);
  sqlite3VdbeResetStepResult((Vdbe *)pNew);
  sqlite3VdbeFinalize((Vdbe *)pNew);
  return (0);
}
}
int sqlite3_prepare(sqlite3 *db , char const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                    char const   **pzTail ) 
{ 
  int rc ;

  {
  rc = sqlite3LockAndPrepare(db, zSql, nBytes, (u32 )0, (Vdbe *)0, ppStmt, pzTail);
  return (rc);
}
}
int sqlite3_prepare_v2(sqlite3 *db , char const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                       char const   **pzTail ) 
{ 
  int rc ;

  {
  rc = sqlite3LockAndPrepare(db, zSql, nBytes, (u32 )128, (Vdbe *)0, ppStmt, pzTail);
  return (rc);
}
}
int sqlite3_prepare_v3(sqlite3 *db , char const   *zSql , int nBytes , unsigned int prepFlags ,
                       sqlite3_stmt **ppStmt , char const   **pzTail ) 
{ 
  int rc ;

  {
  rc = sqlite3LockAndPrepare(db, zSql, nBytes, 128U | (prepFlags & 15U), (Vdbe *)0,
                             ppStmt, pzTail);
  return (rc);
}
}
static int sqlite3Prepare16(sqlite3 *db , void const   *zSql , int nBytes , u32 prepFlags ,
                            sqlite3_stmt **ppStmt , void const   **pzTail ) 
{ 
  char *zSql8 ;
  char const   *zTail8 ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int sz ;
  char const   *z ;
  int chars_parsed ;
  int tmp___1 ;
  int tmp___2 ;

  {
  zTail8 = (char const   *)0;
  rc = 0;
  *ppStmt = (sqlite3_stmt *)0;
  tmp___0 = sqlite3SafetyCheckOk(db);
  if (tmp___0) {
    if ((unsigned long )zSql == (unsigned long )((void const   *)0)) {
      tmp = sqlite3MisuseError(125518);
      return (tmp);
    }
  } else {
    tmp = sqlite3MisuseError(125518);
    return (tmp);
  }
  if (nBytes >= 0) {
    z = (char const   *)zSql;
    sz = 0;
    while (1) {
      if (sz < nBytes) {
        if (! ((int const   )*(z + sz) != 0)) {
          if (! ((int const   )*(z + (sz + 1)) != 0)) {
            break;
          }
        }
      } else {
        break;
      }
      sz += 2;
    }
    nBytes = sz;
  }
  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, (u8 )2);
  if (zSql8) {
    rc = sqlite3LockAndPrepare(db, (char const   *)zSql8, -1, prepFlags, (Vdbe *)0,
                               ppStmt, & zTail8);
  }
  if (zTail8) {
    if (pzTail) {
      tmp___1 = sqlite3Utf8CharLen((char const   *)zSql8, (int )(zTail8 - (char const   *)zSql8));
      chars_parsed = tmp___1;
      tmp___2 = sqlite3Utf16ByteLen(zSql, chars_parsed);
      *pzTail = (void const   *)((u8 *)zSql + tmp___2);
    }
  }
  sqlite3DbFree(db, (void *)zSql8);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_prepare16(sqlite3 *db , void const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                      void const   **pzTail ) 
{ 
  int rc ;

  {
  rc = sqlite3Prepare16(db, zSql, nBytes, (u32 )0, ppStmt, pzTail);
  return (rc);
}
}
int sqlite3_prepare16_v2(sqlite3 *db , void const   *zSql , int nBytes , sqlite3_stmt **ppStmt ,
                         void const   **pzTail ) 
{ 
  int rc ;

  {
  rc = sqlite3Prepare16(db, zSql, nBytes, (u32 )128, ppStmt, pzTail);
  return (rc);
}
}
int sqlite3_prepare16_v3(sqlite3 *db , void const   *zSql , int nBytes , unsigned int prepFlags ,
                         sqlite3_stmt **ppStmt , void const   **pzTail ) 
{ 
  int rc ;

  {
  rc = sqlite3Prepare16(db, zSql, nBytes, 128U | (prepFlags & 15U), ppStmt, pzTail);
  return (rc);
}
}
static void clearSelect(sqlite3 *db , Select *p , int bFree ) 
{ 
  Select *pPrior ;

  {
  while (p) {
    pPrior = p->pPrior;
    sqlite3ExprListDelete(db, p->pEList);
    sqlite3SrcListDelete(db, p->pSrc);
    sqlite3ExprDelete(db, p->pWhere);
    sqlite3ExprListDelete(db, p->pGroupBy);
    sqlite3ExprDelete(db, p->pHaving);
    sqlite3ExprListDelete(db, p->pOrderBy);
    sqlite3ExprDelete(db, p->pLimit);
    if (p->pWinDefn) {
      sqlite3WindowListDelete(db, p->pWinDefn);
    }
    if (p->pWith) {
      sqlite3WithDelete(db, p->pWith);
    }
    if (bFree) {
      sqlite3DbFreeNN(db, (void *)p);
    }
    p = pPrior;
    bFree = 1;
  }
  return;
}
}
static void sqlite3SelectDestInit(SelectDest *pDest , int eDest , int iParm ) 
{ 


  {
  pDest->eDest = (u8 )eDest;
  pDest->iSDParm = iParm;
  pDest->zAffSdst = (char *)0;
  pDest->iSdst = 0;
  pDest->nSdst = 0;
  return;
}
}
static Select *sqlite3SelectNew(Parse *pParse , ExprList *pEList , SrcList *pSrc ,
                                Expr *pWhere , ExprList *pGroupBy , Expr *pHaving ,
                                ExprList *pOrderBy , u32 selFlags , Expr *pLimit ) 
{ 
  Select *pNew ;
  Select standin ;
  void *tmp ;
  Expr *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sqlite3DbMallocRawNN(pParse->db, (u64 )sizeof(*pNew));
  pNew = (Select *)tmp;
  if ((unsigned long )pNew == (unsigned long )((Select *)0)) {
    pNew = & standin;
  }
  if ((unsigned long )pEList == (unsigned long )((ExprList *)0)) {
    tmp___0 = sqlite3Expr(pParse->db, 175, (char const   *)0);
    pEList = sqlite3ExprListAppend(pParse, (ExprList *)0, tmp___0);
  }
  pNew->pEList = pEList;
  pNew->op = (u8 )134;
  pNew->selFlags = selFlags;
  pNew->iLimit = 0;
  pNew->iOffset = 0;
  (pParse->nSelect) ++;
  pNew->selId = (u32 )pParse->nSelect;
  pNew->addrOpenEphm[0] = -1;
  pNew->addrOpenEphm[1] = -1;
  pNew->nSelectRow = (LogEst )0;
  if ((unsigned long )pSrc == (unsigned long )((SrcList *)0)) {
    tmp___1 = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(*pSrc));
    pSrc = (SrcList *)tmp___1;
  }
  pNew->pSrc = pSrc;
  pNew->pWhere = pWhere;
  pNew->pGroupBy = pGroupBy;
  pNew->pHaving = pHaving;
  pNew->pOrderBy = pOrderBy;
  pNew->pPrior = (Select *)0;
  pNew->pNext = (Select *)0;
  pNew->pLimit = pLimit;
  pNew->pWith = (With *)0;
  pNew->pWin = (Window *)0;
  pNew->pWinDefn = (Window *)0;
  if ((pParse->db)->mallocFailed) {
    clearSelect(pParse->db, pNew, (unsigned long )pNew != (unsigned long )(& standin));
    pNew = (Select *)0;
  }
  return (pNew);
}
}
static void sqlite3SelectDelete(sqlite3 *db , Select *p ) 
{ 


  {
  if (p) {
    clearSelect(db, p, 1);
  }
  return;
}
}
static Select *findRightmost(Select *p ) 
{ 


  {
  while (p->pNext) {
    p = p->pNext;
  }
  return (p);
}
}
static char const   zKeyText[34]  = 
  {      (char const   )'n',      (char const   )'a',      (char const   )'t',      (char const   )'u', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )'e', 
        (char const   )'f',      (char const   )'t',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )'f', 
        (char const   )'u',      (char const   )'l',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'n',      (char const   )'e',      (char const   )'r', 
        (char const   )'c',      (char const   )'r',      (char const   )'o',      (char const   )'s', 
        (char const   )'s',      (char const   )'\000'};
static struct __anonstruct_aKeyword_561017541  const  aKeyword[7]  = {      {(u8 )0, (u8 )7, (u8 )4}, 
        {(u8 )6, (u8 )4, (u8 )40}, 
        {(u8 )10, (u8 )5, (u8 )32}, 
        {(u8 )14, (u8 )5, (u8 )48}, 
        {(u8 )19, (u8 )4, (u8 )56}, 
        {(u8 )23, (u8 )5, (u8 )1}, 
        {(u8 )28, (u8 )5, (u8 )3}};
static int sqlite3JoinType(Parse *pParse , Token *pA , Token *pB , Token *pC ) 
{ 
  int jointype ;
  Token *apAll[3] ;
  Token *p ;
  int i ;
  int j ;
  int tmp ;
  char const   *zSp ;

  {
  jointype = 0;
  apAll[0] = pA;
  apAll[1] = pB;
  apAll[2] = pC;
  i = 0;
  while (1) {
    if (i < 3) {
      if (! apAll[i]) {
        break;
      }
    } else {
      break;
    }
    p = apAll[i];
    j = 0;
    while (j < (int )(sizeof(aKeyword) / sizeof(aKeyword[0]))) {
      if (p->n == (unsigned int )aKeyword[j].nChar) {
        tmp = sqlite3_strnicmp((char const   *)((char *)p->z), & zKeyText[aKeyword[j].i],
                               (int )p->n);
        if (tmp == 0) {
          jointype |= (int )aKeyword[j].code;
          break;
        }
      }
      j ++;
    }
    if (j >= (int )(sizeof(aKeyword) / sizeof(aKeyword[0]))) {
      jointype |= 64;
      break;
    }
    i ++;
  }
  if ((jointype & 33) == 33) {
    goto _L;
  } else
  if ((jointype & 64) != 0) {
    _L: /* CIL Label */ 
    zSp = " ";
    if ((unsigned long )pC == (unsigned long )((Token *)0)) {
      zSp ++;
    }
    sqlite3ErrorMsg(pParse, "unknown or unsupported join type: %T %T%s%T", pA, pB,
                    zSp, pC);
    jointype = 1;
  } else
  if ((jointype & 32) != 0) {
    if ((jointype & 24) != 8) {
      sqlite3ErrorMsg(pParse, "RIGHT and FULL OUTER JOINs are not currently supported");
      jointype = 1;
    }
  }
  return (jointype);
}
}
static int columnIndex(Table *pTab , char const   *zCol ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < (int )pTab->nCol) {
    tmp = sqlite3StrICmp((char const   *)(pTab->aCol + i)->zName, zCol);
    if (tmp == 0) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
static int tableAndColumnIndex(SrcList *pSrc , int N , char const   *zCol , int *piTab ,
                               int *piCol ) 
{ 
  int i ;
  int iCol ;

  {
  i = 0;
  while (i < N) {
    iCol = columnIndex(pSrc->a[i].pTab, zCol);
    if (iCol >= 0) {
      if (piTab) {
        *piTab = i;
        *piCol = iCol;
      }
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static void addWhereTerm(Parse *pParse , SrcList *pSrc , int iLeft , int iColLeft ,
                         int iRight , int iColRight , int isOuterJoin , Expr **ppWhere ) 
{ 
  sqlite3 *db ;
  Expr *pE1 ;
  Expr *pE2 ;
  Expr *pEq ;

  {
  db = pParse->db;
  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);
  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);
  pEq = sqlite3PExpr(pParse, 53, pE1, pE2);
  if (pEq) {
    if (isOuterJoin) {
      pEq->flags |= 1U;
      pEq->iRightJoinTable = (i16 )pE2->iTable;
    }
  }
  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);
  return;
}
}
static void setJoinExpr(Expr *p , int iTable ) 
{ 
  int i ;

  {
  while (p) {
    p->flags |= 1U;
    p->iRightJoinTable = (i16 )iTable;
    if ((int )p->op == 167) {
      if (p->x.pList) {
        i = 0;
        while (i < (p->x.pList)->nExpr) {
          setJoinExpr((p->x.pList)->a[i].pExpr, iTable);
          i ++;
        }
      }
    }
    setJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  }
  return;
}
}
static void unsetJoinExpr(Expr *p , int iTable ) 
{ 
  int i ;

  {
  while (p) {
    if ((p->flags & 1U) != 0U) {
      if (iTable < 0) {
        p->flags &= 4294967294U;
      } else
      if ((int )p->iRightJoinTable == iTable) {
        p->flags &= 4294967294U;
      }
    }
    if ((int )p->op == 167) {
      if (p->x.pList) {
        i = 0;
        while (i < (p->x.pList)->nExpr) {
          unsetJoinExpr((p->x.pList)->a[i].pExpr, iTable);
          i ++;
        }
      }
    }
    unsetJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  }
  return;
}
}
static int sqliteProcessJoin(Parse *pParse , Select *p ) 
{ 
  SrcList *pSrc ;
  int i ;
  int j ;
  struct SrcList_item *pLeft ;
  struct SrcList_item *pRight ;
  Table *pRightTab ;
  int isOuter ;
  char *zName ;
  int iLeft ;
  int iLeftCol ;
  int tmp ;
  IdList *pList ;
  char *zName___0 ;
  int iLeft___0 ;
  int iLeftCol___0 ;
  int iRightCol ;
  int tmp___0 ;

  {
  pSrc = p->pSrc;
  pLeft = & pSrc->a[0];
  pRight = pLeft + 1;
  i = 0;
  while (i < pSrc->nSrc - 1) {
    pRightTab = pRight->pTab;
    if ((unsigned long )pLeft->pTab == (unsigned long )((Table *)0)) {
      goto __Cont;
    } else
    if ((unsigned long )pRightTab == (unsigned long )((Table *)0)) {
      goto __Cont;
    }
    isOuter = ((int )pRight->fg.jointype & 32) != 0;
    if ((int )pRight->fg.jointype & 4) {
      if (pRight->pOn) {
        sqlite3ErrorMsg(pParse, "a NATURAL join may not have an ON or USING clause",
                        0);
        return (1);
      } else
      if (pRight->pUsing) {
        sqlite3ErrorMsg(pParse, "a NATURAL join may not have an ON or USING clause",
                        0);
        return (1);
      }
      j = 0;
      while (j < (int )pRightTab->nCol) {
        zName = (pRightTab->aCol + j)->zName;
        tmp = tableAndColumnIndex(pSrc, i + 1, (char const   *)zName, & iLeft, & iLeftCol);
        if (tmp) {
          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i + 1, j, isOuter, & p->pWhere);
        }
        j ++;
      }
    }
    if (pRight->pOn) {
      if (pRight->pUsing) {
        sqlite3ErrorMsg(pParse, "cannot have both ON and USING clauses in the same join");
        return (1);
      }
    }
    if (pRight->pOn) {
      if (isOuter) {
        setJoinExpr(pRight->pOn, pRight->iCursor);
      }
      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);
      pRight->pOn = (Expr *)0;
    }
    if (pRight->pUsing) {
      pList = pRight->pUsing;
      j = 0;
      while (j < pList->nId) {
        zName___0 = (pList->a + j)->zName;
        iRightCol = columnIndex(pRightTab, (char const   *)zName___0);
        if (iRightCol < 0) {
          sqlite3ErrorMsg(pParse, "cannot join using column %s - column not present in both tables",
                          zName___0);
          return (1);
        } else {
          tmp___0 = tableAndColumnIndex(pSrc, i + 1, (char const   *)zName___0, & iLeft___0,
                                        & iLeftCol___0);
          if (! tmp___0) {
            sqlite3ErrorMsg(pParse, "cannot join using column %s - column not present in both tables",
                            zName___0);
            return (1);
          }
        }
        addWhereTerm(pParse, pSrc, iLeft___0, iLeftCol___0, i + 1, iRightCol, isOuter,
                     & p->pWhere);
        j ++;
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
    pRight ++;
    pLeft ++;
  }
  return (0);
}
}
static void innerLoopLoadRow(Parse *pParse , Select *pSelect , RowLoadInfo *pInfo ) 
{ 


  {
  sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult, 0, pInfo->ecelFlags);
  return;
}
}
static int makeSorterRecord(Parse *pParse , SortCtx *pSort , Select *pSelect , int regBase ,
                            int nBase ) 
{ 
  int nOBSat ;
  Vdbe *v ;
  int regOut ;

  {
  nOBSat = pSort->nOBSat;
  v = pParse->pVdbe;
  (pParse->nMem) ++;
  regOut = pParse->nMem;
  if (pSort->pDeferredRowLoad) {
    innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);
  }
  sqlite3VdbeAddOp3(v, 92, regBase + nOBSat, nBase - nOBSat, regOut);
  return (regOut);
}
}
static void pushOntoSorter(Parse *pParse , SortCtx *pSort , Select *pSelect , int regData ,
                           int regOrigData , int nData , int nPrefixReg ) 
{ 
  Vdbe *v ;
  int bSeq ;
  int nExpr ;
  int nBase ;
  int regBase ;
  int regRecord ;
  int nOBSat ;
  int op ;
  int iLimit ;
  int iSkip ;
  int tmp ;
  int regPrevKey ;
  int addrFirst ;
  int addrJmp ;
  VdbeOp *pOp ;
  int nKey ;
  KeyInfo *pKI ;
  int iCsr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  v = pParse->pVdbe;
  bSeq = ((int )pSort->sortFlags & 1) == 0;
  nExpr = (pSort->pOrderBy)->nExpr;
  nBase = (nExpr + bSeq) + nData;
  regRecord = 0;
  nOBSat = pSort->nOBSat;
  iSkip = 0;
  if (nPrefixReg) {
    regBase = regData - nPrefixReg;
  } else {
    regBase = pParse->nMem + 1;
    pParse->nMem += nBase;
  }
  if (pSelect->iOffset) {
    iLimit = pSelect->iOffset + 1;
  } else {
    iLimit = pSelect->iLimit;
  }
  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);
  if (regOrigData) {
    tmp = 4;
  } else {
    tmp = 0;
  }
  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData, (u8 )(1 | tmp));
  if (bSeq) {
    sqlite3VdbeAddOp2(v, 120, pSort->iECursor, regBase + nExpr);
  }
  if (nPrefixReg == 0) {
    if (nData > 0) {
      sqlite3ExprCodeMove(pParse, regData, (regBase + nExpr) + bSeq, nData);
    }
  }
  if (nOBSat > 0) {
    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
    regPrevKey = pParse->nMem + 1;
    pParse->nMem += pSort->nOBSat;
    nKey = (nExpr - pSort->nOBSat) + bSeq;
    if (bSeq) {
      addrFirst = sqlite3VdbeAddOp1(v, 20, regBase + nExpr);
    } else {
      addrFirst = sqlite3VdbeAddOp1(v, 115, pSort->iECursor);
    }
    sqlite3VdbeAddOp3(v, 87, regPrevKey, regBase, pSort->nOBSat);
    pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
    if ((pParse->db)->mallocFailed) {
      return;
    }
    pOp->p2 = nKey + nData;
    pKI = pOp->p4.pKeyInfo;
    memset((void *)pKI->aSortFlags, 0, (size_t )pKI->nKeyField);
    sqlite3VdbeChangeP4(v, -1, (char const   *)((char *)pKI), -9);
    pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pSort->pOrderBy, nOBSat,
                                                  ((int )pKI->nAllField - (int )pKI->nKeyField) - 1);
    addrJmp = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp3(v, 16, addrJmp + 1, 0, addrJmp + 1);
    pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);
    (pParse->nMem) ++;
    pSort->regReturn = pParse->nMem;
    sqlite3VdbeAddOp2(v, 12, pSort->regReturn, pSort->labelBkOut);
    sqlite3VdbeAddOp1(v, 138, pSort->iECursor);
    if (iLimit) {
      sqlite3VdbeAddOp2(v, 20, iLimit, pSort->labelDone);
    }
    sqlite3VdbeJumpHere(v, addrFirst);
    sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);
    sqlite3VdbeJumpHere(v, addrJmp);
  }
  if (iLimit) {
    iCsr = pSort->iECursor;
    tmp___0 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 48, iLimit, tmp___0 + 4);
    sqlite3VdbeAddOp2(v, 32, iCsr, 0);
    iSkip = sqlite3VdbeAddOp4Int(v, 37, iCsr, 0, regBase + nOBSat, nExpr - nOBSat);
    sqlite3VdbeAddOp1(v, 123, iCsr);
  }
  if (regRecord == 0) {
    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
  }
  if ((int )pSort->sortFlags & 1) {
    op = 131;
  } else {
    op = 132;
  }
  sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord, regBase + nOBSat, nBase - nOBSat);
  if (iSkip) {
    if (pSort->labelOBLopt) {
      tmp___2 = pSort->labelOBLopt;
    } else {
      tmp___1 = sqlite3VdbeCurrentAddr(v);
      tmp___2 = tmp___1;
    }
    sqlite3VdbeChangeP2(v, iSkip, tmp___2);
  }
  return;
}
}
static void codeOffset(Vdbe *v , int iOffset___0 , int iContinue ) 
{ 


  {
  if (iOffset___0 > 0) {
    sqlite3VdbeAddOp3(v, 47, iOffset___0, iContinue, 1);
  }
  return;
}
}
static void codeDistinct(Parse *pParse , int iTab , int addrRepeat , int N , int iMem ) 
{ 
  Vdbe *v ;
  int r1 ;

  {
  v = pParse->pVdbe;
  r1 = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp4Int(v, 29, iTab, addrRepeat, iMem, N);
  sqlite3VdbeAddOp3(v, 92, iMem, N, r1);
  sqlite3VdbeAddOp4Int(v, 132, iTab, r1, iMem, N);
  sqlite3VdbeChangeP5(v, (u16 )16);
  sqlite3ReleaseTempReg(pParse, r1);
  return;
}
}
static void selectInnerLoop(Parse *pParse , Select *p , int srcTab , SortCtx *pSort ,
                            DistinctCtx *pDistinct , SelectDest *pDest , int iContinue ,
                            int iBreak ) 
{ 
  Vdbe *v ;
  int i ;
  int hasDistinct ;
  int eDest ;
  int iParm ;
  int nResultCol ;
  int nPrefixReg ;
  RowLoadInfo sRowLoadInfo ;
  int regResult ;
  int regOrig ;
  u8 ecelFlags ;
  ExprList *pEList ;
  int j ;
  VdbeOp *pOp ;
  int iJump ;
  int regPrev ;
  int tmp ;
  CollSeq *pColl ;
  CollSeq *tmp___0 ;
  int r1 ;
  int r1___0 ;
  int tmp___1 ;
  int addr ;
  int tmp___2 ;
  int r2 ;
  int tmp___3 ;
  int r1___1 ;
  int tmp___4 ;
  int nKey ;
  int r1___2 ;
  int r2___0 ;
  int r3 ;
  int addrTest ;
  ExprList *pSO ;

  {
  v = pParse->pVdbe;
  eDest = (int )pDest->eDest;
  iParm = pDest->iSDParm;
  nPrefixReg = 0;
  if (pDistinct) {
    hasDistinct = (int )pDistinct->eTnctType;
  } else {
    hasDistinct = 0;
  }
  if (pSort) {
    if ((unsigned long )pSort->pOrderBy == (unsigned long )((ExprList *)0)) {
      pSort = (SortCtx *)0;
    }
  }
  if ((unsigned long )pSort == (unsigned long )((SortCtx *)0)) {
    if (! hasDistinct) {
      codeOffset(v, p->iOffset, iContinue);
    }
  }
  nResultCol = (p->pEList)->nExpr;
  if (pDest->iSdst == 0) {
    if (pSort) {
      nPrefixReg = (pSort->pOrderBy)->nExpr;
      if (! ((int )pSort->sortFlags & 1)) {
        nPrefixReg ++;
      }
      pParse->nMem += nPrefixReg;
    }
    pDest->iSdst = pParse->nMem + 1;
    pParse->nMem += nResultCol;
  } else
  if (pDest->iSdst + nResultCol > pParse->nMem) {
    pParse->nMem += nResultCol;
  }
  pDest->nSdst = nResultCol;
  regResult = pDest->iSdst;
  regOrig = regResult;
  if (srcTab >= 0) {
    i = 0;
    while (i < nResultCol) {
      sqlite3VdbeAddOp3(v, 90, srcTab, i, regResult + i);
      i ++;
    }
  } else
  if (eDest != 3) {
    if (eDest == 10) {
      ecelFlags = (u8 )1;
    } else
    if (eDest == 9) {
      ecelFlags = (u8 )1;
    } else
    if (eDest == 13) {
      ecelFlags = (u8 )1;
    } else {
      ecelFlags = (u8 )0;
    }
    if (pSort) {
      if (hasDistinct == 0) {
        if (eDest != 12) {
          if (eDest != 14) {
            ecelFlags = (u8 )((int )ecelFlags | 12);
            i = pSort->nOBSat;
            while (i < (pSort->pOrderBy)->nExpr) {
              j = (int )(pSort->pOrderBy)->a[i].u.x.iOrderByCol;
              if (j > 0) {
                (p->pEList)->a[j - 1].u.x.iOrderByCol = (u16 )((i + 1) - pSort->nOBSat);
              }
              i ++;
            }
            pEList = p->pEList;
            i = 0;
            while (i < pEList->nExpr) {
              if ((int )pEList->a[i].u.x.iOrderByCol > 0) {
                nResultCol --;
                regOrig = 0;
              }
              i ++;
            }
          }
        }
      }
    }
    sRowLoadInfo.regResult = regResult;
    sRowLoadInfo.ecelFlags = ecelFlags;
    if (p->iLimit) {
      if (((int )ecelFlags & 8) != 0) {
        if (nPrefixReg > 0) {
          pSort->pDeferredRowLoad = & sRowLoadInfo;
          regOrig = 0;
        } else {
          innerLoopLoadRow(pParse, p, & sRowLoadInfo);
        }
      } else {
        innerLoopLoadRow(pParse, p, & sRowLoadInfo);
      }
    } else {
      innerLoopLoadRow(pParse, p, & sRowLoadInfo);
    }
  }
  if (hasDistinct) {
    switch ((int )pDistinct->eTnctType) {
    case 2: 
    regPrev = pParse->nMem + 1;
    pParse->nMem += nResultCol;
    sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
    pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct);
    pOp->opcode = (u8 )73;
    pOp->p1 = 1;
    pOp->p2 = regPrev;
    tmp = sqlite3VdbeCurrentAddr(v);
    iJump = tmp + nResultCol;
    i = 0;
    while (i < nResultCol) {
      tmp___0 = sqlite3ExprCollSeq(pParse, (p->pEList)->a[i].pExpr);
      pColl = tmp___0;
      if (i < nResultCol - 1) {
        sqlite3VdbeAddOp3(v, 52, regResult + i, iJump, regPrev + i);
      } else {
        sqlite3VdbeAddOp3(v, 53, regResult + i, iContinue, regPrev + i);
      }
      sqlite3VdbeChangeP4(v, -1, (char const   *)pColl, -2);
      sqlite3VdbeChangeP5(v, (u16 )128);
      i ++;
    }
    sqlite3VdbeAddOp3(v, 78, regResult, regPrev, nResultCol - 1);
    break;
    case 1: 
    sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
    break;
    default: 
    codeDistinct(pParse, pDistinct->tabTnct, iContinue, nResultCol, regResult);
    break;
    }
    if ((unsigned long )pSort == (unsigned long )((SortCtx *)0)) {
      codeOffset(v, p->iOffset, iContinue);
    }
  }
  switch (eDest) {
  case 1: 
  r1 = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp3(v, 92, regResult, nResultCol, r1);
  sqlite3VdbeAddOp4Int(v, 132, iParm, r1, regResult, nResultCol);
  sqlite3ReleaseTempReg(pParse, r1);
  break;
  case 2: 
  sqlite3VdbeAddOp3(v, 133, iParm, regResult, nResultCol);
  break;
  case 12: 
  case 14: 
  case 6: 
  case 5: 
  tmp___1 = sqlite3GetTempRange(pParse, nPrefixReg + 1);
  r1___0 = tmp___1;
  sqlite3VdbeAddOp3(v, 92, regResult, nResultCol, r1___0 + nPrefixReg);
  if (eDest == 6) {
    tmp___2 = sqlite3VdbeCurrentAddr(v);
    addr = tmp___2 + 4;
    sqlite3VdbeAddOp4Int(v, 29, iParm + 1, addr, r1___0, 0);
    sqlite3VdbeAddOp4Int(v, 132, iParm + 1, r1___0, regResult, nResultCol);
  }
  if (pSort) {
    pushOntoSorter(pParse, pSort, p, r1___0 + nPrefixReg, regOrig, 1, nPrefixReg);
  } else {
    tmp___3 = sqlite3GetTempReg(pParse);
    r2 = tmp___3;
    sqlite3VdbeAddOp2(v, 121, iParm, r2);
    sqlite3VdbeAddOp3(v, 122, iParm, r1___0, r2);
    sqlite3VdbeChangeP5(v, (u16 )8);
    sqlite3ReleaseTempReg(pParse, r2);
  }
  sqlite3ReleaseTempRange(pParse, r1___0, nPrefixReg + 1);
  break;
  case 11: 
  if (pSort) {
    pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
  } else {
    tmp___4 = sqlite3GetTempReg(pParse);
    r1___1 = tmp___4;
    sqlite3VdbeAddOp4(v, 92, regResult, nResultCol, r1___1, (char const   *)pDest->zAffSdst,
                      nResultCol);
    sqlite3VdbeAddOp4Int(v, 132, iParm, r1___1, regResult, nResultCol);
    sqlite3ReleaseTempReg(pParse, r1___1);
  }
  break;
  case 3: 
  sqlite3VdbeAddOp2(v, 70, 1, iParm);
  break;
  case 10: 
  if (pSort) {
    pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
  }
  break;
  case 9: 
  case 13: 
  if (pSort) {
    pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
  } else
  if (eDest == 13) {
    sqlite3VdbeAddOp1(v, 14, pDest->iSDParm);
  } else {
    sqlite3VdbeAddOp2(v, 81, regResult, nResultCol);
  }
  break;
  case 7: 
  case 8: 
  addrTest = 0;
  pSO = pDest->pOrderBy;
  nKey = pSO->nExpr;
  r1___2 = sqlite3GetTempReg(pParse);
  r2___0 = sqlite3GetTempRange(pParse, nKey + 2);
  r3 = (r2___0 + nKey) + 1;
  if (eDest == 8) {
    addrTest = sqlite3VdbeAddOp4Int(v, 29, iParm + 1, 0, regResult, nResultCol);
  }
  sqlite3VdbeAddOp3(v, 92, regResult, nResultCol, r3);
  if (eDest == 8) {
    sqlite3VdbeAddOp2(v, 132, iParm + 1, r3);
    sqlite3VdbeChangeP5(v, (u16 )16);
  }
  i = 0;
  while (i < nKey) {
    sqlite3VdbeAddOp2(v, 79, (regResult + (int )pSO->a[i].u.x.iOrderByCol) - 1, r2___0 + i);
    i ++;
  }
  sqlite3VdbeAddOp2(v, 120, iParm, r2___0 + nKey);
  sqlite3VdbeAddOp3(v, 92, r2___0, nKey + 2, r1___2);
  sqlite3VdbeAddOp4Int(v, 132, iParm, r1___2, r2___0, nKey + 2);
  if (addrTest) {
    sqlite3VdbeJumpHere(v, addrTest);
  }
  sqlite3ReleaseTempReg(pParse, r1___2);
  sqlite3ReleaseTempRange(pParse, r2___0, nKey + 2);
  break;
  default: 
  break;
  }
  if ((unsigned long )pSort == (unsigned long )((SortCtx *)0)) {
    if (p->iLimit) {
      sqlite3VdbeAddOp2(v, 49, p->iLimit, iBreak);
    }
  }
  return;
}
}
static KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db , int N , int X ) 
{ 
  int nExtra ;
  KeyInfo *p ;
  void *tmp ;

  {
  nExtra = (int )((unsigned long )(N + X) * (sizeof(CollSeq *) + 1UL) - sizeof(CollSeq *));
  tmp = sqlite3DbMallocRawNN(db, (u64 )(sizeof(KeyInfo ) + (unsigned long )nExtra));
  p = (KeyInfo *)tmp;
  if (p) {
    p->aSortFlags = (u8 *)(& p->aColl[N + X]);
    p->nKeyField = (u16 )N;
    p->nAllField = (u16 )(N + X);
    p->enc = db->enc;
    p->db = db;
    p->nRef = (u32 )1;
    memset((void *)(p + 1), 0, (size_t )nExtra);
  } else {
    sqlite3OomFault(db);
  }
  return (p);
}
}
static void sqlite3KeyInfoUnref(KeyInfo *p ) 
{ 


  {
  if (p) {
    (p->nRef) --;
    if (p->nRef == 0U) {
      sqlite3DbFreeNN(p->db, (void *)p);
    }
  }
  return;
}
}
static KeyInfo *sqlite3KeyInfoRef(KeyInfo *p ) 
{ 


  {
  if (p) {
    (p->nRef) ++;
  }
  return (p);
}
}
static KeyInfo *sqlite3KeyInfoFromExprList(Parse *pParse , ExprList *pList , int iStart ,
                                           int nExtra ) 
{ 
  int nExpr ;
  KeyInfo *pInfo ;
  struct ExprList_item *pItem ;
  sqlite3 *db ;
  int i ;

  {
  db = pParse->db;
  nExpr = pList->nExpr;
  pInfo = sqlite3KeyInfoAlloc(db, nExpr - iStart, nExtra + 1);
  if (pInfo) {
    i = iStart;
    pItem = pList->a + iStart;
    while (i < nExpr) {
      pInfo->aColl[i - iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
      *(pInfo->aSortFlags + (i - iStart)) = pItem->sortFlags;
      i ++;
      pItem ++;
    }
  }
  return (pInfo);
}
}
static char const   *selectOpName(int id ) 
{ 
  char *z ;

  {
  switch (id) {
  case 131: 
  z = (char *)"UNION ALL";
  break;
  case 133: 
  z = (char *)"INTERSECT";
  break;
  case 132: 
  z = (char *)"EXCEPT";
  break;
  default: 
  z = (char *)"UNION";
  break;
  }
  return ((char const   *)z);
}
}
static void explainTempTable(Parse *pParse , char const   *zUsage ) 
{ 


  {
  sqlite3VdbeExplain(pParse, (u8 )0, "USE TEMP B-TREE FOR %s", zUsage);
  return;
}
}
static void generateSortTail(Parse *pParse , Select *p , SortCtx *pSort , int nColumn ,
                             SelectDest *pDest ) 
{ 
  Vdbe *v ;
  int addrBreak ;
  int addrContinue ;
  int tmp ;
  int addr ;
  int addrOnce ;
  int iTab ;
  ExprList *pOrderBy ;
  int eDest ;
  int iParm ;
  int regRow ;
  int regRowid ;
  int iCol ;
  int nKey ;
  int iSortTab ;
  int i ;
  int bSeq ;
  int nRefKey ;
  struct ExprList_item *aOutEx ;
  int regSortOut ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int iRead ;
  int tmp___3 ;

  {
  v = pParse->pVdbe;
  addrBreak = pSort->labelDone;
  tmp = sqlite3VdbeMakeLabel(pParse);
  addrContinue = tmp;
  addrOnce = 0;
  pOrderBy = pSort->pOrderBy;
  eDest = (int )pDest->eDest;
  iParm = pDest->iSDParm;
  nRefKey = 0;
  aOutEx = (p->pEList)->a;
  if (pSort->labelBkOut) {
    sqlite3VdbeAddOp2(v, 12, pSort->regReturn, pSort->labelBkOut);
    sqlite3VdbeGoto(v, addrBreak);
    sqlite3VdbeResolveLabel(v, pSort->labelBkOut);
  }
  iTab = pSort->iECursor;
  if (eDest == 9) {
    regRowid = 0;
    regRow = pDest->iSdst;
  } else
  if (eDest == 13) {
    regRowid = 0;
    regRow = pDest->iSdst;
  } else
  if (eDest == 10) {
    regRowid = 0;
    regRow = pDest->iSdst;
  } else {
    regRowid = sqlite3GetTempReg(pParse);
    if (eDest == 12) {
      regRow = sqlite3GetTempReg(pParse);
      nColumn = 0;
    } else
    if (eDest == 14) {
      regRow = sqlite3GetTempReg(pParse);
      nColumn = 0;
    } else {
      regRow = sqlite3GetTempRange(pParse, nColumn);
    }
  }
  nKey = pOrderBy->nExpr - pSort->nOBSat;
  if ((int )pSort->sortFlags & 1) {
    (pParse->nMem) ++;
    regSortOut = pParse->nMem;
    tmp___0 = pParse->nTab;
    (pParse->nTab) ++;
    iSortTab = tmp___0;
    if (pSort->labelBkOut) {
      addrOnce = sqlite3VdbeAddOp0(v, 17);
    }
    sqlite3VdbeAddOp3(v, 116, iSortTab, regSortOut, ((nKey + 1) + nColumn) + nRefKey);
    if (addrOnce) {
      sqlite3VdbeJumpHere(v, addrOnce);
    }
    tmp___1 = sqlite3VdbeAddOp2(v, 34, iTab, addrBreak);
    addr = 1 + tmp___1;
    codeOffset(v, p->iOffset, addrContinue);
    sqlite3VdbeAddOp3(v, 126, iTab, regSortOut, iSortTab);
    bSeq = 0;
  } else {
    tmp___2 = sqlite3VdbeAddOp2(v, 35, iTab, addrBreak);
    addr = 1 + tmp___2;
    codeOffset(v, p->iOffset, addrContinue);
    iSortTab = iTab;
    bSeq = 1;
  }
  i = 0;
  iCol = (nKey + bSeq) - 1;
  while (i < nColumn) {
    if ((int )(aOutEx + i)->u.x.iOrderByCol == 0) {
      iCol ++;
    }
    i ++;
  }
  i = nColumn - 1;
  while (i >= 0) {
    if ((aOutEx + i)->u.x.iOrderByCol) {
      iRead = (int )(aOutEx + i)->u.x.iOrderByCol - 1;
    } else {
      tmp___3 = iCol;
      iCol --;
      iRead = tmp___3;
    }
    sqlite3VdbeAddOp3(v, 90, iSortTab, iRead, regRow + i);
    i --;
  }
  switch (eDest) {
  case 12: 
  case 14: 
  sqlite3VdbeAddOp3(v, 90, iSortTab, nKey + bSeq, regRow);
  sqlite3VdbeAddOp2(v, 121, iParm, regRowid);
  sqlite3VdbeAddOp3(v, 122, iParm, regRow, regRowid);
  sqlite3VdbeChangeP5(v, (u16 )8);
  break;
  case 11: 
  sqlite3VdbeAddOp4(v, 92, regRow, nColumn, regRowid, (char const   *)pDest->zAffSdst,
                    nColumn);
  sqlite3VdbeAddOp4Int(v, 132, iParm, regRowid, regRow, nColumn);
  break;
  case 10: 
  break;
  default: 
  if (eDest == 9) {
    sqlite3VdbeAddOp2(v, 81, pDest->iSdst, nColumn);
  } else {
    sqlite3VdbeAddOp1(v, 14, pDest->iSDParm);
  }
  break;
  }
  if (regRowid) {
    if (eDest == 11) {
      sqlite3ReleaseTempRange(pParse, regRow, nColumn);
    } else {
      sqlite3ReleaseTempReg(pParse, regRow);
    }
    sqlite3ReleaseTempReg(pParse, regRowid);
  }
  sqlite3VdbeResolveLabel(v, addrContinue);
  if ((int )pSort->sortFlags & 1) {
    sqlite3VdbeAddOp2(v, 3, iTab, addr);
  } else {
    sqlite3VdbeAddOp2(v, 5, iTab, addr);
  }
  if (pSort->regReturn) {
    sqlite3VdbeAddOp1(v, 66, pSort->regReturn);
  }
  sqlite3VdbeResolveLabel(v, addrBreak);
  return;
}
}
static char const   *columnTypeImpl(NameContext *pNC , Expr *pExpr ) 
{ 
  char const   *zType ;
  int j ;
  Table *pTab ;
  Select *pS ;
  int iCol ;
  SrcList *pTabList ;
  NameContext sNC ;
  Expr *p ;
  char *tmp ;
  NameContext sNC___0 ;
  Select *pS___0 ;
  Expr *p___0 ;

  {
  zType = (char const   *)0;
  switch ((int )pExpr->op) {
  case 162: 
  pTab = (Table *)0;
  pS = (Select *)0;
  iCol = (int )pExpr->iColumn;
  while (1) {
    if (pNC) {
      if (! (! pTab)) {
        break;
      }
    } else {
      break;
    }
    pTabList = pNC->pSrcList;
    j = 0;
    while (1) {
      if (j < pTabList->nSrc) {
        if (! (pTabList->a[j].iCursor != pExpr->iTable)) {
          break;
        }
      } else {
        break;
      }
      j ++;
    }
    if (j < pTabList->nSrc) {
      pTab = pTabList->a[j].pTab;
      pS = pTabList->a[j].pSelect;
    } else {
      pNC = pNC->pNext;
    }
  }
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    break;
  }
  if (pS) {
    if (iCol >= 0) {
      if (iCol < (pS->pEList)->nExpr) {
        p = (pS->pEList)->a[iCol].pExpr;
        sNC.pSrcList = pS->pSrc;
        sNC.pNext = pNC;
        sNC.pParse = pNC->pParse;
        zType = columnTypeImpl(& sNC, p);
      }
    }
  } else
  if (iCol < 0) {
    zType = "INTEGER";
  } else {
    tmp = sqlite3ColumnType(pTab->aCol + iCol, (char *)0);
    zType = (char const   *)tmp;
  }
  break;
  case 134: 
  pS___0 = pExpr->x.pSelect;
  p___0 = (pS___0->pEList)->a[0].pExpr;
  sNC___0.pSrcList = pS___0->pSrc;
  sNC___0.pNext = pNC;
  sNC___0.pParse = pNC->pParse;
  zType = columnTypeImpl(& sNC___0, p___0);
  break;
  }
  return (zType);
}
}
static void generateColumnTypes(Parse *pParse , SrcList *pTabList , ExprList *pEList ) 
{ 
  Vdbe *v ;
  int i ;
  NameContext sNC ;
  Expr *p ;
  char const   *zType ;

  {
  v = pParse->pVdbe;
  sNC.pSrcList = pTabList;
  sNC.pParse = pParse;
  sNC.pNext = (NameContext *)0;
  i = 0;
  while (i < pEList->nExpr) {
    p = pEList->a[i].pExpr;
    zType = columnTypeImpl(& sNC, p);
    sqlite3VdbeSetColName(v, i, 1, zType, (void (*)(void * ))-1);
    i ++;
  }
  return;
}
}
static void generateColumnNames(Parse *pParse , Select *pSelect ) 
{ 
  Vdbe *v ;
  int i ;
  Table *pTab ;
  SrcList *pTabList ;
  ExprList *pEList ;
  sqlite3 *db ;
  int fullName ;
  int srcName ;
  int tmp ;
  Expr *p ;
  char *zName ;
  char *zCol ;
  int iCol ;
  char *zName___0 ;
  char const   *z ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  v = pParse->pVdbe;
  db = pParse->db;
  if (pParse->explain) {
    return;
  }
  if (pParse->colNamesSet) {
    return;
  }
  while (pSelect->pPrior) {
    pSelect = pSelect->pPrior;
  }
  pTabList = pSelect->pSrc;
  pEList = pSelect->pEList;
  pParse->colNamesSet = (u8 )1;
  fullName = (db->flags & 4ULL) != 0ULL;
  if ((db->flags & 64ULL) != 0ULL) {
    tmp = 1;
  } else
  if (fullName) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  srcName = tmp;
  sqlite3VdbeSetNumCols(v, pEList->nExpr);
  i = 0;
  while (i < pEList->nExpr) {
    p = pEList->a[i].pExpr;
    if (pEList->a[i].zName) {
      zName = pEList->a[i].zName;
      sqlite3VdbeSetColName(v, i, 0, (char const   *)zName, (void (*)(void * ))-1);
    } else
    if (srcName) {
      if ((int )p->op == 162) {
        iCol = (int )p->iColumn;
        pTab = p->y.pTab;
        if (iCol < 0) {
          iCol = (int )pTab->iPKey;
        }
        if (iCol < 0) {
          zCol = (char *)"rowid";
        } else {
          zCol = (pTab->aCol + iCol)->zName;
        }
        if (fullName) {
          zName___0 = (char *)0;
          zName___0 = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
          sqlite3VdbeSetColName(v, i, 0, (char const   *)zName___0, (void (*)(void * ))(& sqlite3MallocSize));
        } else {
          sqlite3VdbeSetColName(v, i, 0, (char const   *)zCol, (void (*)(void * ))-1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      z = (char const   *)pEList->a[i].zSpan;
      if ((unsigned long )z == (unsigned long )((char const   *)0)) {
        tmp___0 = sqlite3MPrintf(db, "column%d", i + 1);
        z = (char const   *)tmp___0;
      } else {
        tmp___1 = sqlite3DbStrDup(db, z);
        z = (char const   *)tmp___1;
      }
      sqlite3VdbeSetColName(v, i, 0, z, (void (*)(void * ))(& sqlite3MallocSize));
    }
    i ++;
  }
  generateColumnTypes(pParse, pTabList, pEList);
  return;
}
}
static int sqlite3ColumnsFromExprList(Parse *pParse , ExprList *pEList , i16 *pnCol ,
                                      Column **paCol ) 
{ 
  sqlite3 *db ;
  int i ;
  int j ;
  u32 cnt ;
  Column *aCol ;
  Column *pCol ;
  int nCol ;
  char *zName ;
  int nName ;
  Hash ht ;
  void *tmp ;
  Expr *pColExpr ;
  Expr *tmp___0 ;
  int iCol ;
  Table *pTab ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  db = pParse->db;
  sqlite3HashInit(& ht);
  if (pEList) {
    nCol = pEList->nExpr;
    tmp = sqlite3DbMallocZero(db, (u64 )(sizeof(*(aCol + 0)) * (unsigned long )nCol));
    aCol = (Column *)tmp;
    if (nCol > 32767) {
      nCol = 32767;
    }
  } else {
    nCol = 0;
    aCol = (Column *)0;
  }
  *pnCol = (i16 )nCol;
  *paCol = aCol;
  i = 0;
  pCol = aCol;
  while (1) {
    if (i < nCol) {
      if (! (! db->mallocFailed)) {
        break;
      }
    } else {
      break;
    }
    zName = pEList->a[i].zName;
    if (! ((unsigned long )zName != (unsigned long )((char *)0))) {
      tmp___0 = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);
      pColExpr = tmp___0;
      while ((int )pColExpr->op == 137) {
        pColExpr = pColExpr->pRight;
      }
      if ((int )pColExpr->op == 162) {
        iCol = (int )pColExpr->iColumn;
        pTab = pColExpr->y.pTab;
        if (iCol < 0) {
          iCol = (int )pTab->iPKey;
        }
        if (iCol >= 0) {
          zName = (pTab->aCol + iCol)->zName;
        } else {
          zName = (char *)"rowid";
        }
      } else
      if ((int )pColExpr->op == 59) {
        zName = pColExpr->u.zToken;
      } else {
        zName = pEList->a[i].zSpan;
      }
    }
    if (zName) {
      zName = sqlite3DbStrDup(db, (char const   *)zName);
    } else {
      zName = sqlite3MPrintf(db, "column%d", i + 1);
    }
    cnt = (u32 )0;
    while (1) {
      if (zName) {
        tmp___1 = sqlite3HashFind((Hash const   *)(& ht), (char const   *)zName);
        if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      nName = sqlite3Strlen30((char const   *)zName);
      if (nName > 0) {
        j = nName - 1;
        while (1) {
          if (j > 0) {
            if (! ((int const   )sqlite3CtypeMap[(unsigned char )*(zName + j)] & 4)) {
              break;
            }
          } else {
            break;
          }
          j --;
        }
        if ((int )*(zName + j) == 58) {
          nName = j;
        }
      }
      cnt ++;
      zName = sqlite3MPrintf(db, "%.*z:%u", nName, zName, cnt);
      if (cnt > 3U) {
        sqlite3_randomness((int )sizeof(cnt), (void *)(& cnt));
      }
    }
    pCol->zName = zName;
    if (zName) {
      tmp___2 = sqlite3HashInsert(& ht, (char const   *)zName, (void *)pCol);
      if ((unsigned long )tmp___2 == (unsigned long )pCol) {
        sqlite3OomFault(db);
      }
    }
    i ++;
    pCol ++;
  }
  sqlite3HashClear(& ht);
  if (db->mallocFailed) {
    j = 0;
    while (j < i) {
      sqlite3DbFree(db, (void *)(aCol + j)->zName);
      j ++;
    }
    sqlite3DbFree(db, (void *)aCol);
    *paCol = (Column *)0;
    *pnCol = (i16 )0;
    return (7);
  }
  return (0);
}
}
static void sqlite3SelectAddColumnTypeAndCollation(Parse *pParse , Table *pTab , Select *pSelect ,
                                                   char aff ) 
{ 
  sqlite3 *db ;
  NameContext sNC ;
  Column *pCol ;
  CollSeq *pColl ;
  int i ;
  Expr *p ;
  struct ExprList_item *a___0 ;
  char const   *zType ;
  int n ;
  int m ;
  void *tmp ;

  {
  db = pParse->db;
  if (db->mallocFailed) {
    return;
  }
  memset((void *)(& sNC), 0, sizeof(sNC));
  sNC.pSrcList = pSelect->pSrc;
  a___0 = (pSelect->pEList)->a;
  i = 0;
  pCol = pTab->aCol;
  while (i < (int )pTab->nCol) {
    p = (a___0 + i)->pExpr;
    zType = columnTypeImpl(& sNC, p);
    pCol->affinity = sqlite3ExprAffinity(p);
    if (zType) {
      m = sqlite3Strlen30(zType);
      n = sqlite3Strlen30((char const   *)pCol->zName);
      tmp = sqlite3DbReallocOrFree(db, (void *)pCol->zName, (u64 )((n + m) + 2));
      pCol->zName = (char *)tmp;
      if (pCol->zName) {
        memcpy((void * __restrict  )(pCol->zName + (n + 1)), (void const   * __restrict  )zType,
               (size_t )(m + 1));
        pCol->colFlags = (u8 )((int )pCol->colFlags | 4);
      }
    }
    if ((int )pCol->affinity <= 64) {
      pCol->affinity = aff;
    }
    pColl = sqlite3ExprCollSeq(pParse, p);
    if (pColl) {
      if ((unsigned long )pCol->zColl == (unsigned long )((char *)0)) {
        pCol->zColl = sqlite3DbStrDup(db, (char const   *)pColl->zName);
      }
    }
    i ++;
    pCol ++;
  }
  pTab->szTabRow = (LogEst )1;
  return;
}
}
static Table *sqlite3ResultSetOfSelect(Parse *pParse , Select *pSelect , char aff ) 
{ 
  Table *pTab ;
  sqlite3 *db ;
  u64 savedFlags ;
  void *tmp ;

  {
  db = pParse->db;
  savedFlags = db->flags;
  db->flags &= 0xfffffffffffffffbULL;
  db->flags |= 64ULL;
  sqlite3SelectPrep(pParse, pSelect, (NameContext *)0);
  db->flags = savedFlags;
  if (pParse->nErr) {
    return ((Table *)0);
  }
  while (pSelect->pPrior) {
    pSelect = pSelect->pPrior;
  }
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(Table ));
  pTab = (Table *)tmp;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return ((Table *)0);
  }
  pTab->nTabRef = (u32 )1;
  pTab->zName = (char *)0;
  pTab->nRowLogEst = (LogEst )200;
  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, & pTab->nCol, & pTab->aCol);
  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);
  pTab->iPKey = (i16 )-1;
  if (db->mallocFailed) {
    sqlite3DeleteTable(db, pTab);
    return ((Table *)0);
  }
  return (pTab);
}
}
static Vdbe *sqlite3GetVdbe(Parse *pParse ) 
{ 
  Vdbe *tmp ;

  {
  if (pParse->pVdbe) {
    return (pParse->pVdbe);
  }
  if ((unsigned long )pParse->pToplevel == (unsigned long )((Parse *)0)) {
    if (((int )(pParse->db)->dbOptFlags & 8) == 0) {
      pParse->okConstFactor = (u8 )1;
    }
  }
  tmp = sqlite3VdbeCreate(pParse);
  return (tmp);
}
}
static void computeLimitRegisters(Parse *pParse , Select *p , int iBreak ) 
{ 
  Vdbe *v ;
  int iLimit ;
  int iOffset___0 ;
  int n ;
  Expr *pLimit ;
  LogEst tmp ;
  int tmp___0 ;

  {
  v = (Vdbe *)0;
  iLimit = 0;
  pLimit = p->pLimit;
  if (p->iLimit) {
    return;
  }
  if (pLimit) {
    (pParse->nMem) ++;
    iLimit = pParse->nMem;
    p->iLimit = iLimit;
    v = sqlite3GetVdbe(pParse);
    tmp___0 = sqlite3ExprIsInteger(pLimit->pLeft, & n);
    if (tmp___0) {
      sqlite3VdbeAddOp2(v, 70, n, iLimit);
      if (n == 0) {
        sqlite3VdbeGoto(v, iBreak);
      } else
      if (n >= 0) {
        tmp = sqlite3LogEst((u64 )n);
        if ((int )p->nSelectRow > (int )tmp) {
          p->nSelectRow = sqlite3LogEst((u64 )n);
          p->selFlags |= 16384U;
        }
      }
    } else {
      sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);
      sqlite3VdbeAddOp1(v, 15, iLimit);
      sqlite3VdbeAddOp2(v, 20, iLimit, iBreak);
    }
    if (pLimit->pRight) {
      (pParse->nMem) ++;
      iOffset___0 = pParse->nMem;
      p->iOffset = iOffset___0;
      (pParse->nMem) ++;
      sqlite3ExprCode(pParse, pLimit->pRight, iOffset___0);
      sqlite3VdbeAddOp1(v, 15, iOffset___0);
      sqlite3VdbeAddOp3(v, 152, iLimit, iOffset___0 + 1, iOffset___0);
    }
  }
  return;
}
}
static CollSeq *multiSelectCollSeq(Parse *pParse , Select *p , int iCol ) 
{ 
  CollSeq *pRet ;

  {
  if (p->pPrior) {
    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
  } else {
    pRet = (CollSeq *)0;
  }
  if ((unsigned long )pRet == (unsigned long )((CollSeq *)0)) {
    if (iCol < (p->pEList)->nExpr) {
      pRet = sqlite3ExprCollSeq(pParse, (p->pEList)->a[iCol].pExpr);
    }
  }
  return (pRet);
}
}
static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse , Select *p , int nExtra ) 
{ 
  ExprList *pOrderBy ;
  int nOrderBy ;
  sqlite3 *db ;
  KeyInfo *pRet ;
  KeyInfo *tmp ;
  int i ;
  struct ExprList_item *pItem ;
  Expr *pTerm ;
  CollSeq *pColl ;

  {
  pOrderBy = p->pOrderBy;
  nOrderBy = (p->pOrderBy)->nExpr;
  db = pParse->db;
  tmp = sqlite3KeyInfoAlloc(db, nOrderBy + nExtra, 1);
  pRet = tmp;
  if (pRet) {
    i = 0;
    while (i < nOrderBy) {
      pItem = & pOrderBy->a[i];
      pTerm = pItem->pExpr;
      if (pTerm->flags & 256U) {
        pColl = sqlite3ExprCollSeq(pParse, pTerm);
      } else {
        pColl = multiSelectCollSeq(pParse, p, (int )pItem->u.x.iOrderByCol - 1);
        if ((unsigned long )pColl == (unsigned long )((CollSeq *)0)) {
          pColl = db->pDfltColl;
        }
        pOrderBy->a[i].pExpr = sqlite3ExprAddCollateString(pParse, pTerm, (char const   *)pColl->zName);
      }
      pRet->aColl[i] = pColl;
      *(pRet->aSortFlags + i) = pOrderBy->a[i].sortFlags;
      i ++;
    }
  }
  return (pRet);
}
}
static void generateWithRecursiveQuery(Parse *pParse , Select *p , SelectDest *pDest ) 
{ 
  SrcList *pSrc ;
  int nCol ;
  Vdbe *v ;
  Select *pSetup ;
  int addrTop ;
  int addrCont ;
  int addrBreak ;
  int iCurrent ;
  int regCurrent ;
  int iQueue ;
  int iDistinct ;
  int eDest ;
  SelectDest destQueue ;
  int i ;
  int rc ;
  ExprList *pOrderBy ;
  Expr *pLimit ;
  int regLimit ;
  int regOffset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  KeyInfo *pKeyInfo ;
  KeyInfo *tmp___3 ;

  {
  pSrc = p->pSrc;
  nCol = (p->pEList)->nExpr;
  v = pParse->pVdbe;
  pSetup = p->pPrior;
  iCurrent = 0;
  iDistinct = 0;
  eDest = 5;
  if (p->pWin) {
    sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
    return;
  }
  tmp = sqlite3AuthCheck(pParse, 33, (char const   *)0, (char const   *)0, (char const   *)0);
  if (tmp) {
    return;
  }
  addrBreak = sqlite3VdbeMakeLabel(pParse);
  p->nSelectRow = (LogEst )320;
  computeLimitRegisters(pParse, p, addrBreak);
  pLimit = p->pLimit;
  regLimit = p->iLimit;
  regOffset = p->iOffset;
  p->pLimit = (Expr *)0;
  tmp___0 = 0;
  p->iOffset = tmp___0;
  p->iLimit = tmp___0;
  pOrderBy = p->pOrderBy;
  i = 0;
  while (i < pSrc->nSrc) {
    if (pSrc->a[i].fg.isRecursive) {
      iCurrent = pSrc->a[i].iCursor;
      break;
    }
    i ++;
  }
  tmp___1 = pParse->nTab;
  (pParse->nTab) ++;
  iQueue = tmp___1;
  if ((int )p->op == 130) {
    if (pOrderBy) {
      eDest = 8;
    } else {
      eDest = 6;
    }
    tmp___2 = pParse->nTab;
    (pParse->nTab) ++;
    iDistinct = tmp___2;
  } else
  if (pOrderBy) {
    eDest = 7;
  } else {
    eDest = 5;
  }
  sqlite3SelectDestInit(& destQueue, eDest, iQueue);
  (pParse->nMem) ++;
  regCurrent = pParse->nMem;
  sqlite3VdbeAddOp3(v, 116, iCurrent, regCurrent, nCol);
  if (pOrderBy) {
    tmp___3 = multiSelectOrderByKeyInfo(pParse, p, 1);
    pKeyInfo = tmp___3;
    sqlite3VdbeAddOp4(v, 112, iQueue, pOrderBy->nExpr + 2, 0, (char const   *)((char *)pKeyInfo),
                      -9);
    destQueue.pOrderBy = pOrderBy;
  } else {
    sqlite3VdbeAddOp2(v, 112, iQueue, nCol);
  }
  if (iDistinct) {
    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, 112, iDistinct, 0);
    p->selFlags |= 32U;
  }
  p->pOrderBy = (ExprList *)0;
  pSetup->pNext = (Select *)0;
  sqlite3VdbeExplain(pParse, (u8 )1, "SETUP");
  rc = sqlite3Select(pParse, pSetup, & destQueue);
  pSetup->pNext = p;
  if (rc) {
    goto end_of_recursive_query;
  }
  addrTop = sqlite3VdbeAddOp2(v, 36, iQueue, addrBreak);
  sqlite3VdbeAddOp1(v, 129, iCurrent);
  if (pOrderBy) {
    sqlite3VdbeAddOp3(v, 90, iQueue, pOrderBy->nExpr + 1, regCurrent);
  } else {
    sqlite3VdbeAddOp2(v, 127, iQueue, regCurrent);
  }
  sqlite3VdbeAddOp1(v, 123, iQueue);
  addrCont = sqlite3VdbeMakeLabel(pParse);
  codeOffset(v, regOffset, addrCont);
  selectInnerLoop(pParse, p, iCurrent, (SortCtx *)0, (DistinctCtx *)0, pDest, addrCont,
                  addrBreak);
  if (regLimit) {
    sqlite3VdbeAddOp2(v, 49, regLimit, addrBreak);
  }
  sqlite3VdbeResolveLabel(v, addrCont);
  if (p->selFlags & 8U) {
    sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
  } else {
    p->pPrior = (Select *)0;
    sqlite3VdbeExplain(pParse, (u8 )1, "RECURSIVE STEP");
    sqlite3Select(pParse, p, & destQueue);
    p->pPrior = pSetup;
  }
  sqlite3VdbeGoto(v, addrTop);
  sqlite3VdbeResolveLabel(v, addrBreak);
  end_of_recursive_query: 
  sqlite3ExprListDelete(pParse->db, p->pOrderBy);
  p->pOrderBy = pOrderBy;
  p->pLimit = pLimit;
  return;
}
}
static int multiSelectOrderBy(Parse *pParse , Select *p , SelectDest *pDest ) ;
static int multiSelectValues(Parse *pParse , Select *p , SelectDest *pDest ) 
{ 
  int nRow ;
  int rc ;
  int bShowAll ;
  char const   *tmp ;

  {
  nRow = 1;
  rc = 0;
  bShowAll = (unsigned long )p->pLimit == (unsigned long )((Expr *)0);
  while (! ((unsigned long )p->pPrior == (unsigned long )((Select *)0))) {
    p = p->pPrior;
    nRow += bShowAll;
  }
  if (nRow == 1) {
    tmp = "";
  } else {
    tmp = "S";
  }
  sqlite3VdbeExplain(pParse, (u8 )0, "SCAN %d CONSTANT ROW%s", nRow, tmp);
  while (p) {
    selectInnerLoop(pParse, p, -1, (SortCtx *)0, (DistinctCtx *)0, pDest, 1, 1);
    if (! bShowAll) {
      break;
    }
    p->nSelectRow = (LogEst )nRow;
    p = p->pNext;
  }
  return (rc);
}
}
static int multiSelect(Parse *pParse , Select *p , SelectDest *pDest ) 
{ 
  int rc ;
  Select *pPrior ;
  Vdbe *v ;
  SelectDest dest ;
  Select *pDelete ;
  sqlite3 *db ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int addr ;
  int nLimit ;
  int tmp___2 ;
  LogEst tmp___3 ;
  int unionTab ;
  u8 op ;
  int priorOp ;
  Expr *pLimit ;
  int addr___0 ;
  SelectDest uniondest ;
  int tmp___4 ;
  Select *tmp___5 ;
  char const   *tmp___6 ;
  int iCont ;
  int iBreak ;
  int iStart ;
  int tab1 ;
  int tab2 ;
  int iCont___0 ;
  int iBreak___0 ;
  int iStart___0 ;
  Expr *pLimit___0 ;
  int addr___1 ;
  SelectDest intersectdest ;
  int r1 ;
  int tmp___7 ;
  int tmp___8 ;
  Select *tmp___9 ;
  char const   *tmp___10 ;
  int i ;
  KeyInfo *pKeyInfo ;
  Select *pLoop ;
  CollSeq **apColl ;
  int nCol ;
  int addr___2 ;
  KeyInfo *tmp___11 ;

  {
  rc = 0;
  pDelete = (Select *)0;
  db = pParse->db;
  pPrior = p->pPrior;
  dest = *pDest;
  if (pPrior->pOrderBy) {
    goto _L;
  } else
  if (pPrior->pLimit) {
    _L: /* CIL Label */ 
    tmp = selectOpName((int )p->op);
    if ((unsigned long )pPrior->pOrderBy != (unsigned long )((ExprList *)0)) {
      tmp___0 = "ORDER BY";
    } else {
      tmp___0 = "LIMIT";
    }
    sqlite3ErrorMsg(pParse, "%s clause should come after %s not before", tmp___0,
                    tmp);
    rc = 1;
    goto multi_select_end;
  }
  v = sqlite3GetVdbe(pParse);
  if ((int )dest.eDest == 12) {
    sqlite3VdbeAddOp2(v, 112, dest.iSDParm, (p->pEList)->nExpr);
    dest.eDest = (u8 )14;
  }
  if (p->selFlags & 1024U) {
    rc = multiSelectValues(pParse, p, & dest);
    goto multi_select_end;
  }
  if (p->selFlags & 8192U) {
    generateWithRecursiveQuery(pParse, p, & dest);
  } else
  if (p->pOrderBy) {
    tmp___1 = multiSelectOrderBy(pParse, p, pDest);
    return (tmp___1);
  } else {
    if ((unsigned long )pPrior->pPrior == (unsigned long )((Select *)0)) {
      sqlite3VdbeExplain(pParse, (u8 )1, "COMPOUND QUERY");
      sqlite3VdbeExplain(pParse, (u8 )1, "LEFT-MOST SUBQUERY");
    }
    switch ((int )p->op) {
    case 131: 
    addr = 0;
    pPrior->iLimit = p->iLimit;
    pPrior->iOffset = p->iOffset;
    pPrior->pLimit = p->pLimit;
    rc = sqlite3Select(pParse, pPrior, & dest);
    p->pLimit = (Expr *)0;
    if (rc) {
      goto multi_select_end;
    }
    p->pPrior = (Select *)0;
    p->iLimit = pPrior->iLimit;
    p->iOffset = pPrior->iOffset;
    if (p->iLimit) {
      addr = sqlite3VdbeAddOp1(v, 20, p->iLimit);
      if (p->iOffset) {
        sqlite3VdbeAddOp3(v, 152, p->iLimit, p->iOffset + 1, p->iOffset);
      }
    }
    sqlite3VdbeExplain(pParse, (u8 )1, "UNION ALL");
    rc = sqlite3Select(pParse, p, & dest);
    pDelete = p->pPrior;
    p->pPrior = pPrior;
    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
    if (pPrior->pLimit) {
      tmp___2 = sqlite3ExprIsInteger((pPrior->pLimit)->pLeft, & nLimit);
      if (tmp___2) {
        if (nLimit > 0) {
          tmp___3 = sqlite3LogEst((u64 )nLimit);
          if ((int )p->nSelectRow > (int )tmp___3) {
            p->nSelectRow = sqlite3LogEst((u64 )nLimit);
          }
        }
      }
    }
    if (addr) {
      sqlite3VdbeJumpHere(v, addr);
    }
    break;
    case 130: 
    case 132: 
    op = (u8 )0;
    priorOp = 1;
    if ((int )dest.eDest == priorOp) {
      unionTab = dest.iSDParm;
    } else {
      tmp___4 = pParse->nTab;
      (pParse->nTab) ++;
      unionTab = tmp___4;
      addr___0 = sqlite3VdbeAddOp2(v, 112, unionTab, 0);
      p->addrOpenEphm[0] = addr___0;
      tmp___5 = findRightmost(p);
      tmp___5->selFlags |= 32U;
    }
    sqlite3SelectDestInit(& uniondest, priorOp, unionTab);
    rc = sqlite3Select(pParse, pPrior, & uniondest);
    if (rc) {
      goto multi_select_end;
    }
    if ((int )p->op == 132) {
      op = (u8 )2;
    } else {
      op = (u8 )1;
    }
    p->pPrior = (Select *)0;
    pLimit = p->pLimit;
    p->pLimit = (Expr *)0;
    uniondest.eDest = op;
    tmp___6 = selectOpName((int )p->op);
    sqlite3VdbeExplain(pParse, (u8 )1, "%s USING TEMP B-TREE", tmp___6);
    rc = sqlite3Select(pParse, p, & uniondest);
    sqlite3ExprListDelete(db, p->pOrderBy);
    pDelete = p->pPrior;
    p->pPrior = pPrior;
    p->pOrderBy = (ExprList *)0;
    if ((int )p->op == 130) {
      p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
    }
    sqlite3ExprDelete(db, p->pLimit);
    p->pLimit = pLimit;
    p->iLimit = 0;
    p->iOffset = 0;
    if ((int )dest.eDest != priorOp) {
      iBreak = sqlite3VdbeMakeLabel(pParse);
      iCont = sqlite3VdbeMakeLabel(pParse);
      computeLimitRegisters(pParse, p, iBreak);
      sqlite3VdbeAddOp2(v, 36, unionTab, iBreak);
      iStart = sqlite3VdbeCurrentAddr(v);
      selectInnerLoop(pParse, p, unionTab, (SortCtx *)0, (DistinctCtx *)0, & dest,
                      iCont, iBreak);
      sqlite3VdbeResolveLabel(v, iCont);
      sqlite3VdbeAddOp2(v, 5, unionTab, iStart);
      sqlite3VdbeResolveLabel(v, iBreak);
      sqlite3VdbeAddOp2(v, 117, unionTab, 0);
    }
    break;
    default: 
    tmp___7 = pParse->nTab;
    (pParse->nTab) ++;
    tab1 = tmp___7;
    tmp___8 = pParse->nTab;
    (pParse->nTab) ++;
    tab2 = tmp___8;
    addr___1 = sqlite3VdbeAddOp2(v, 112, tab1, 0);
    p->addrOpenEphm[0] = addr___1;
    tmp___9 = findRightmost(p);
    tmp___9->selFlags |= 32U;
    sqlite3SelectDestInit(& intersectdest, 1, tab1);
    rc = sqlite3Select(pParse, pPrior, & intersectdest);
    if (rc) {
      goto multi_select_end;
    }
    addr___1 = sqlite3VdbeAddOp2(v, 112, tab2, 0);
    p->addrOpenEphm[1] = addr___1;
    p->pPrior = (Select *)0;
    pLimit___0 = p->pLimit;
    p->pLimit = (Expr *)0;
    intersectdest.iSDParm = tab2;
    tmp___10 = selectOpName((int )p->op);
    sqlite3VdbeExplain(pParse, (u8 )1, "%s USING TEMP B-TREE", tmp___10);
    rc = sqlite3Select(pParse, p, & intersectdest);
    pDelete = p->pPrior;
    p->pPrior = pPrior;
    if ((int )p->nSelectRow > (int )pPrior->nSelectRow) {
      p->nSelectRow = pPrior->nSelectRow;
    }
    sqlite3ExprDelete(db, p->pLimit);
    p->pLimit = pLimit___0;
    iBreak___0 = sqlite3VdbeMakeLabel(pParse);
    iCont___0 = sqlite3VdbeMakeLabel(pParse);
    computeLimitRegisters(pParse, p, iBreak___0);
    sqlite3VdbeAddOp2(v, 36, tab1, iBreak___0);
    r1 = sqlite3GetTempReg(pParse);
    iStart___0 = sqlite3VdbeAddOp2(v, 127, tab1, r1);
    sqlite3VdbeAddOp4Int(v, 28, tab2, iCont___0, r1, 0);
    sqlite3ReleaseTempReg(pParse, r1);
    selectInnerLoop(pParse, p, tab1, (SortCtx *)0, (DistinctCtx *)0, & dest, iCont___0,
                    iBreak___0);
    sqlite3VdbeResolveLabel(v, iCont___0);
    sqlite3VdbeAddOp2(v, 5, tab1, iStart___0);
    sqlite3VdbeResolveLabel(v, iBreak___0);
    sqlite3VdbeAddOp2(v, 117, tab2, 0);
    sqlite3VdbeAddOp2(v, 117, tab1, 0);
    break;
    }
    if ((unsigned long )p->pNext == (unsigned long )((Select *)0)) {
      sqlite3VdbeExplainPop(pParse);
    }
  }
  if (p->selFlags & 32U) {
    nCol = (p->pEList)->nExpr;
    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);
    if (! pKeyInfo) {
      rc = 7;
      goto multi_select_end;
    }
    i = 0;
    apColl = pKeyInfo->aColl;
    while (i < nCol) {
      *apColl = multiSelectCollSeq(pParse, p, i);
      if ((unsigned long )((CollSeq *)0) == (unsigned long )*apColl) {
        *apColl = db->pDfltColl;
      }
      i ++;
      apColl ++;
    }
    pLoop = p;
    while (pLoop) {
      i = 0;
      while (i < 2) {
        addr___2 = pLoop->addrOpenEphm[i];
        if (addr___2 < 0) {
          break;
        }
        sqlite3VdbeChangeP2(v, addr___2, nCol);
        tmp___11 = sqlite3KeyInfoRef(pKeyInfo);
        sqlite3VdbeChangeP4(v, addr___2, (char const   *)((char *)tmp___11), -9);
        pLoop->addrOpenEphm[i] = -1;
        i ++;
      }
      pLoop = pLoop->pPrior;
    }
    sqlite3KeyInfoUnref(pKeyInfo);
  }
  multi_select_end: 
  pDest->iSdst = dest.iSdst;
  pDest->nSdst = dest.nSdst;
  sqlite3SelectDelete(db, pDelete);
  return (rc);
}
}
static void sqlite3SelectWrongNumTermsError(Parse *pParse , Select *p ) 
{ 
  char const   *tmp ;

  {
  if (p->selFlags & 512U) {
    sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
  } else {
    tmp = selectOpName((int )p->op);
    sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s do not have the same number of result columns",
                    tmp);
  }
  return;
}
}
static int generateOutputSubroutine(Parse *pParse , Select *p , SelectDest *pIn ,
                                    SelectDest *pDest , int regReturn , int regPrev ,
                                    KeyInfo *pKeyInfo , int iBreak ) 
{ 
  Vdbe *v ;
  int iContinue ;
  int addr ;
  int addr1 ;
  int addr2 ;
  KeyInfo *tmp ;
  int r1 ;
  int tmp___0 ;
  int r2 ;
  int tmp___1 ;
  int r1___0 ;

  {
  v = pParse->pVdbe;
  addr = sqlite3VdbeCurrentAddr(v);
  iContinue = sqlite3VdbeMakeLabel(pParse);
  if (regPrev) {
    addr1 = sqlite3VdbeAddOp1(v, 20, regPrev);
    tmp = sqlite3KeyInfoRef(pKeyInfo);
    addr2 = sqlite3VdbeAddOp4(v, 87, pIn->iSdst, regPrev + 1, pIn->nSdst, (char const   *)((char *)tmp),
                              -9);
    sqlite3VdbeAddOp3(v, 16, addr2 + 2, iContinue, addr2 + 2);
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp3(v, 78, pIn->iSdst, regPrev + 1, pIn->nSdst - 1);
    sqlite3VdbeAddOp2(v, 70, 1, regPrev);
  }
  if ((pParse->db)->mallocFailed) {
    return (0);
  }
  codeOffset(v, p->iOffset, iContinue);
  switch ((int )pDest->eDest) {
  case 12: 
  tmp___0 = sqlite3GetTempReg(pParse);
  r1 = tmp___0;
  tmp___1 = sqlite3GetTempReg(pParse);
  r2 = tmp___1;
  sqlite3VdbeAddOp3(v, 92, pIn->iSdst, pIn->nSdst, r1);
  sqlite3VdbeAddOp2(v, 121, pDest->iSDParm, r2);
  sqlite3VdbeAddOp3(v, 122, pDest->iSDParm, r1, r2);
  sqlite3VdbeChangeP5(v, (u16 )8);
  sqlite3ReleaseTempReg(pParse, r2);
  sqlite3ReleaseTempReg(pParse, r1);
  break;
  case 11: 
  r1___0 = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp4(v, 92, pIn->iSdst, pIn->nSdst, r1___0, (char const   *)pDest->zAffSdst,
                    pIn->nSdst);
  sqlite3VdbeAddOp4Int(v, 132, pDest->iSDParm, r1___0, pIn->iSdst, pIn->nSdst);
  sqlite3ReleaseTempReg(pParse, r1___0);
  break;
  case 10: 
  if (pParse->nErr == 0) {
    sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);
  }
  break;
  case 13: 
  if (pDest->iSdst == 0) {
    pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);
    pDest->nSdst = pIn->nSdst;
  }
  sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);
  sqlite3VdbeAddOp1(v, 14, pDest->iSDParm);
  break;
  default: 
  sqlite3VdbeAddOp2(v, 81, pIn->iSdst, pIn->nSdst);
  break;
  }
  if (p->iLimit) {
    sqlite3VdbeAddOp2(v, 49, p->iLimit, iBreak);
  }
  sqlite3VdbeResolveLabel(v, iContinue);
  sqlite3VdbeAddOp1(v, 66, regReturn);
  return (addr);
}
}
static int multiSelectOrderBy(Parse *pParse , Select *p , SelectDest *pDest ) 
{ 
  int i ;
  int j ;
  Select *pPrior ;
  Vdbe *v ;
  SelectDest destA ;
  SelectDest destB ;
  int regAddrA ;
  int regAddrB ;
  int addrSelectA ;
  int addrSelectB ;
  int regOutA ;
  int regOutB ;
  int addrOutA ;
  int addrOutB ;
  int addrEofA ;
  int addrEofA_noB ;
  int addrEofB ;
  int addrAltB ;
  int addrAeqB ;
  int addrAgtB ;
  int regLimitA ;
  int regLimitB ;
  int regPrev ;
  int savedLimit ;
  int savedOffset ;
  int labelCmpr ;
  int labelEnd ;
  int addr1 ;
  int op ;
  KeyInfo *pKeyDup ;
  KeyInfo *pKeyMerge ;
  sqlite3 *db ;
  ExprList *pOrderBy ;
  int nOrderBy ;
  int *aPermute ;
  struct ExprList_item *pItem ;
  Expr *pNew ;
  Expr *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct ExprList_item *pItem___0 ;
  int nExpr ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  addrOutB = 0;
  pKeyDup = (KeyInfo *)0;
  db = pParse->db;
  v = pParse->pVdbe;
  labelEnd = sqlite3VdbeMakeLabel(pParse);
  labelCmpr = sqlite3VdbeMakeLabel(pParse);
  op = (int )p->op;
  pPrior = p->pPrior;
  pOrderBy = p->pOrderBy;
  nOrderBy = pOrderBy->nExpr;
  if (op != 131) {
    i = 1;
    while (1) {
      if ((int )db->mallocFailed == 0) {
        if (! (i <= (p->pEList)->nExpr)) {
          break;
        }
      } else {
        break;
      }
      j = 0;
      pItem = pOrderBy->a;
      while (j < nOrderBy) {
        if ((int )pItem->u.x.iOrderByCol == i) {
          break;
        }
        j ++;
        pItem ++;
      }
      if (j == nOrderBy) {
        tmp = sqlite3Expr(db, 150, (char const   *)0);
        pNew = tmp;
        if ((unsigned long )pNew == (unsigned long )((Expr *)0)) {
          return (7);
        }
        pNew->flags |= 1024U;
        pNew->u.iValue = i;
        pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
        p->pOrderBy = pOrderBy;
        if (pOrderBy) {
          tmp___0 = nOrderBy;
          nOrderBy ++;
          pOrderBy->a[tmp___0].u.x.iOrderByCol = (u16 )i;
        }
      }
      i ++;
    }
  }
  tmp___1 = sqlite3DbMallocRawNN(db, (u64 )(sizeof(int ) * (unsigned long )(nOrderBy + 1)));
  aPermute = (int *)tmp___1;
  if (aPermute) {
    *(aPermute + 0) = nOrderBy;
    i = 1;
    pItem___0 = pOrderBy->a;
    while (i <= nOrderBy) {
      *(aPermute + i) = (int )pItem___0->u.x.iOrderByCol - 1;
      i ++;
      pItem___0 ++;
    }
    pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);
  } else {
    pKeyMerge = (KeyInfo *)0;
  }
  p->pOrderBy = pOrderBy;
  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);
  if (op == 131) {
    regPrev = 0;
  } else {
    nExpr = (p->pEList)->nExpr;
    regPrev = pParse->nMem + 1;
    pParse->nMem += nExpr + 1;
    sqlite3VdbeAddOp2(v, 70, 0, regPrev);
    pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);
    if (pKeyDup) {
      i = 0;
      while (i < nExpr) {
        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
        *(pKeyDup->aSortFlags + i) = (u8 )0;
        i ++;
      }
    }
  }
  p->pPrior = (Select *)0;
  pPrior->pNext = (Select *)0;
  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
  if ((unsigned long )pPrior->pPrior == (unsigned long )((Select *)0)) {
    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
  }
  computeLimitRegisters(pParse, p, labelEnd);
  if (p->iLimit) {
    if (op == 131) {
      (pParse->nMem) ++;
      regLimitA = pParse->nMem;
      (pParse->nMem) ++;
      regLimitB = pParse->nMem;
      if (p->iOffset) {
        tmp___2 = p->iOffset + 1;
      } else {
        tmp___2 = p->iLimit;
      }
      sqlite3VdbeAddOp2(v, 78, tmp___2, regLimitA);
      sqlite3VdbeAddOp2(v, 78, regLimitA, regLimitB);
    } else {
      regLimitB = 0;
      regLimitA = regLimitB;
    }
  } else {
    regLimitB = 0;
    regLimitA = regLimitB;
  }
  sqlite3ExprDelete(db, p->pLimit);
  p->pLimit = (Expr *)0;
  (pParse->nMem) ++;
  regAddrA = pParse->nMem;
  (pParse->nMem) ++;
  regAddrB = pParse->nMem;
  (pParse->nMem) ++;
  regOutA = pParse->nMem;
  (pParse->nMem) ++;
  regOutB = pParse->nMem;
  sqlite3SelectDestInit(& destA, 13, regAddrA);
  sqlite3SelectDestInit(& destB, 13, regAddrB);
  tmp___3 = selectOpName((int )p->op);
  sqlite3VdbeExplain(pParse, (u8 )1, "MERGE (%s)", tmp___3);
  tmp___4 = sqlite3VdbeCurrentAddr(v);
  addrSelectA = tmp___4 + 1;
  addr1 = sqlite3VdbeAddOp3(v, 13, regAddrA, 0, addrSelectA);
  pPrior->iLimit = regLimitA;
  sqlite3VdbeExplain(pParse, (u8 )1, "LEFT");
  sqlite3Select(pParse, pPrior, & destA);
  sqlite3VdbeEndCoroutine(v, regAddrA);
  sqlite3VdbeJumpHere(v, addr1);
  tmp___5 = sqlite3VdbeCurrentAddr(v);
  addrSelectB = tmp___5 + 1;
  addr1 = sqlite3VdbeAddOp3(v, 13, regAddrB, 0, addrSelectB);
  savedLimit = p->iLimit;
  savedOffset = p->iOffset;
  p->iLimit = regLimitB;
  p->iOffset = 0;
  sqlite3VdbeExplain(pParse, (u8 )1, "RIGHT");
  sqlite3Select(pParse, p, & destB);
  p->iLimit = savedLimit;
  p->iOffset = savedOffset;
  sqlite3VdbeEndCoroutine(v, regAddrB);
  addrOutA = generateOutputSubroutine(pParse, p, & destA, pDest, regOutA, regPrev,
                                      pKeyDup, labelEnd);
  if (op == 131) {
    addrOutB = generateOutputSubroutine(pParse, p, & destB, pDest, regOutB, regPrev,
                                        pKeyDup, labelEnd);
  } else
  if (op == 130) {
    addrOutB = generateOutputSubroutine(pParse, p, & destB, pDest, regOutB, regPrev,
                                        pKeyDup, labelEnd);
  }
  sqlite3KeyInfoUnref(pKeyDup);
  if (op == 132) {
    addrEofA = labelEnd;
    addrEofA_noB = addrEofA;
  } else
  if (op == 133) {
    addrEofA = labelEnd;
    addrEofA_noB = addrEofA;
  } else {
    addrEofA = sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB);
    addrEofA_noB = sqlite3VdbeAddOp2(v, 14, regAddrB, labelEnd);
    sqlite3VdbeGoto(v, addrEofA);
    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
  }
  if (op == 133) {
    addrEofB = addrEofA;
    if ((int )p->nSelectRow > (int )pPrior->nSelectRow) {
      p->nSelectRow = pPrior->nSelectRow;
    }
  } else {
    addrEofB = sqlite3VdbeAddOp2(v, 12, regOutA, addrOutA);
    sqlite3VdbeAddOp2(v, 14, regAddrA, labelEnd);
    sqlite3VdbeGoto(v, addrEofB);
  }
  addrAltB = sqlite3VdbeAddOp2(v, 12, regOutA, addrOutA);
  sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA);
  sqlite3VdbeGoto(v, labelCmpr);
  if (op == 131) {
    addrAeqB = addrAltB;
  } else
  if (op == 133) {
    addrAeqB = addrAltB;
    addrAltB ++;
  } else {
    addrAeqB = sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA);
    sqlite3VdbeGoto(v, labelCmpr);
  }
  addrAgtB = sqlite3VdbeCurrentAddr(v);
  if (op == 131) {
    sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB);
  } else
  if (op == 130) {
    sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB);
  }
  sqlite3VdbeAddOp2(v, 14, regAddrB, addrEofB);
  sqlite3VdbeGoto(v, labelCmpr);
  sqlite3VdbeJumpHere(v, addr1);
  sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA_noB);
  sqlite3VdbeAddOp2(v, 14, regAddrB, addrEofB);
  sqlite3VdbeResolveLabel(v, labelCmpr);
  sqlite3VdbeAddOp4(v, 86, 0, 0, 0, (char const   *)((char *)aPermute), -15);
  sqlite3VdbeAddOp4(v, 87, destA.iSdst, destB.iSdst, nOrderBy, (char const   *)((char *)pKeyMerge),
                    -9);
  sqlite3VdbeChangeP5(v, (u16 )1);
  sqlite3VdbeAddOp3(v, 16, addrAltB, addrAeqB, addrAgtB);
  sqlite3VdbeResolveLabel(v, labelEnd);
  if (p->pPrior) {
    sqlite3SelectDelete(db, p->pPrior);
  }
  p->pPrior = pPrior;
  pPrior->pNext = p;
  sqlite3VdbeExplainPop(pParse);
  return (pParse->nErr != 0);
}
}
static void substExprList(SubstContext *pSubst , ExprList *pList ) ;
static void substSelect(SubstContext *pSubst , Select *p , int doPrior ) ;
static Expr *substExpr(SubstContext *pSubst , Expr *pExpr ) 
{ 
  Expr *pNew ;
  Expr *pCopy ;
  Expr ifNullRow ;
  sqlite3 *db ;
  CollSeq *pColl ;
  CollSeq *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return ((Expr *)0);
  }
  if ((pExpr->flags & 1U) != 0U) {
    if ((int )pExpr->iRightJoinTable == pSubst->iTable) {
      pExpr->iRightJoinTable = (i16 )pSubst->iNewTable;
    }
  }
  if ((int )pExpr->op == 162) {
    if (pExpr->iTable == pSubst->iTable) {
      if ((int )pExpr->iColumn < 0) {
        pExpr->op = (u8 )117;
      } else {
        pCopy = (pSubst->pEList)->a[pExpr->iColumn].pExpr;
        tmp___1 = sqlite3ExprIsVector(pCopy);
        if (tmp___1) {
          sqlite3VectorErrorMsg(pSubst->pParse, pCopy);
        } else {
          db = (pSubst->pParse)->db;
          if (pSubst->isLeftJoin) {
            if ((int )pCopy->op != 162) {
              memset((void *)(& ifNullRow), 0, sizeof(ifNullRow));
              ifNullRow.op = (u8 )174;
              ifNullRow.pLeft = pCopy;
              ifNullRow.iTable = pSubst->iNewTable;
              pCopy = & ifNullRow;
            }
          }
          pNew = sqlite3ExprDup(db, pCopy, 0);
          if (pNew) {
            if (pSubst->isLeftJoin) {
              pNew->flags |= 1048576U;
            }
          }
          if (pNew) {
            if ((pExpr->flags & 1U) != 0U) {
              pNew->iRightJoinTable = pExpr->iRightJoinTable;
              pNew->flags |= 1U;
            }
          }
          sqlite3ExprDelete(db, pExpr);
          pExpr = pNew;
          if (pExpr) {
            if ((int )pExpr->op != 162) {
              if ((int )pExpr->op != 109) {
                tmp = sqlite3ExprCollSeq(pSubst->pParse, pExpr);
                pColl = tmp;
                if (pColl) {
                  tmp___0 = (char const   *)pColl->zName;
                } else {
                  tmp___0 = "BINARY";
                }
                pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr, tmp___0);
              }
            }
            pExpr->flags &= 4294967039U;
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if ((int )pExpr->op == 174) {
      if (pExpr->iTable == pSubst->iTable) {
        pExpr->iTable = pSubst->iNewTable;
      }
    }
    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);
    pExpr->pRight = substExpr(pSubst, pExpr->pRight);
    if ((pExpr->flags & 2048U) != 0U) {
      substSelect(pSubst, pExpr->x.pSelect, 1);
    } else {
      substExprList(pSubst, pExpr->x.pList);
    }
  }
  return (pExpr);
}
}
static void substExprList(SubstContext *pSubst , ExprList *pList ) 
{ 
  int i ;

  {
  if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
    return;
  }
  i = 0;
  while (i < pList->nExpr) {
    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);
    i ++;
  }
  return;
}
}
static void substSelect(SubstContext *pSubst , Select *p , int doPrior ) 
{ 
  SrcList *pSrc ;
  struct SrcList_item *pItem ;
  int i ;

  {
  if (! p) {
    return;
  }
  while (1) {
    substExprList(pSubst, p->pEList);
    substExprList(pSubst, p->pGroupBy);
    substExprList(pSubst, p->pOrderBy);
    p->pHaving = substExpr(pSubst, p->pHaving);
    p->pWhere = substExpr(pSubst, p->pWhere);
    pSrc = p->pSrc;
    i = pSrc->nSrc;
    pItem = pSrc->a;
    while (i > 0) {
      substSelect(pSubst, pItem->pSelect, 1);
      if (pItem->fg.isTabFunc) {
        substExprList(pSubst, pItem->u1.pFuncArg);
      }
      i --;
      pItem ++;
    }
    if (doPrior) {
      p = p->pPrior;
      if (! ((unsigned long )p != (unsigned long )((Select *)0))) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static int flattenSubquery(Parse *pParse , Select *p , int iFrom , int isAgg ) 
{ 
  char const   *zSavedAuthContext ;
  Select *pParent ;
  Select *pSub ;
  Select *pSub1 ;
  SrcList *pSrc ;
  SrcList *pSubSrc ;
  int iParent ;
  int iNewParent ;
  int isLeftJoin ;
  int i ;
  Expr *pWhere ;
  struct SrcList_item *pSubitem ;
  sqlite3 *db ;
  int ii ;
  Select *pNew ;
  ExprList *pOrderBy ;
  Expr *pLimit ;
  Select *pPrior ;
  Table *pTabToDel ;
  Parse *pToplevel ;
  Parse *tmp ;
  int nSubSrc ;
  u8 jointype ;
  ExprList *pOrderBy___0 ;
  SubstContext x___0 ;

  {
  zSavedAuthContext = pParse->zAuthContext;
  iNewParent = -1;
  isLeftJoin = 0;
  db = pParse->db;
  if (((int )db->dbOptFlags & 1) != 0) {
    return (0);
  }
  pSrc = p->pSrc;
  pSubitem = & pSrc->a[iFrom];
  iParent = pSubitem->iCursor;
  pSub = pSubitem->pSelect;
  if (p->pWin) {
    return (0);
  } else
  if (pSub->pWin) {
    return (0);
  }
  pSubSrc = pSub->pSrc;
  if (pSub->pLimit) {
    if (p->pLimit) {
      return (0);
    }
  }
  if (pSub->pLimit) {
    if ((pSub->pLimit)->pRight) {
      return (0);
    }
  }
  if ((p->selFlags & 256U) != 0U) {
    if (pSub->pLimit) {
      return (0);
    }
  }
  if (pSubSrc->nSrc == 0) {
    return (0);
  }
  if (pSub->selFlags & 1U) {
    return (0);
  }
  if (pSub->pLimit) {
    if (pSrc->nSrc > 1) {
      return (0);
    } else
    if (isAgg) {
      return (0);
    }
  }
  if (p->pOrderBy) {
    if (pSub->pOrderBy) {
      return (0);
    }
  }
  if (isAgg) {
    if (pSub->pOrderBy) {
      return (0);
    }
  }
  if (pSub->pLimit) {
    if (p->pWhere) {
      return (0);
    }
  }
  if (pSub->pLimit) {
    if ((p->selFlags & 1U) != 0U) {
      return (0);
    }
  }
  if (pSub->selFlags & 8192U) {
    return (0);
  }
  if (((int )pSubitem->fg.jointype & 32) != 0) {
    isLeftJoin = 1;
    if (pSubSrc->nSrc > 1) {
      return (0);
    } else
    if (isAgg) {
      return (0);
    } else
    if ((pSubSrc->a[0].pTab)->nModuleArg) {
      return (0);
    }
  }
  if (pSub->pPrior) {
    if (pSub->pOrderBy) {
      return (0);
    }
    if (isAgg) {
      return (0);
    } else
    if ((p->selFlags & 1U) != 0U) {
      return (0);
    } else
    if (pSrc->nSrc != 1) {
      return (0);
    }
    pSub1 = pSub;
    while (pSub1) {
      if ((pSub1->selFlags & 9U) != 0U) {
        return (0);
      } else
      if (pSub1->pPrior) {
        if ((int )pSub1->op != 131) {
          return (0);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((pSub1->pSrc)->nSrc < 1) {
        return (0);
      }
      pSub1 = pSub1->pPrior;
    }
    if (p->pOrderBy) {
      ii = 0;
      while (ii < (p->pOrderBy)->nExpr) {
        if ((int )(p->pOrderBy)->a[ii].u.x.iOrderByCol == 0) {
          return (0);
        }
        ii ++;
      }
    }
  }
  pParse->zAuthContext = (char const   *)pSubitem->zName;
  sqlite3AuthCheck(pParse, 21, (char const   *)0, (char const   *)0, (char const   *)0);
  pParse->zAuthContext = zSavedAuthContext;
  pSub = pSub->pPrior;
  while (pSub) {
    pOrderBy = p->pOrderBy;
    pLimit = p->pLimit;
    pPrior = p->pPrior;
    p->pOrderBy = (ExprList *)0;
    p->pSrc = (SrcList *)0;
    p->pPrior = (Select *)0;
    p->pLimit = (Expr *)0;
    pNew = sqlite3SelectDup(db, p, 0);
    p->pLimit = pLimit;
    p->pOrderBy = pOrderBy;
    p->pSrc = pSrc;
    p->op = (u8 )131;
    if ((unsigned long )pNew == (unsigned long )((Select *)0)) {
      p->pPrior = pPrior;
    } else {
      pNew->pPrior = pPrior;
      if (pPrior) {
        pPrior->pNext = pNew;
      }
      pNew->pNext = p;
      p->pPrior = pNew;
    }
    if (db->mallocFailed) {
      return (1);
    }
    pSub = pSub->pPrior;
  }
  pSub1 = pSubitem->pSelect;
  pSub = pSub1;
  sqlite3DbFree(db, (void *)pSubitem->zDatabase);
  sqlite3DbFree(db, (void *)pSubitem->zName);
  sqlite3DbFree(db, (void *)pSubitem->zAlias);
  pSubitem->zDatabase = (char *)0;
  pSubitem->zName = (char *)0;
  pSubitem->zAlias = (char *)0;
  pSubitem->pSelect = (Select *)0;
  if ((unsigned long )pSubitem->pTab != (unsigned long )((Table *)0)) {
    pTabToDel = pSubitem->pTab;
    if (pTabToDel->nTabRef == 1U) {
      if (pParse->pToplevel) {
        tmp = pParse->pToplevel;
      } else {
        tmp = pParse;
      }
      pToplevel = tmp;
      pTabToDel->pNextZombie = pToplevel->pZombieTab;
      pToplevel->pZombieTab = pTabToDel;
    } else {
      (pTabToDel->nTabRef) --;
    }
    pSubitem->pTab = (Table *)0;
  }
  pParent = p;
  while (pParent) {
    jointype = (u8 )0;
    pSubSrc = pSub->pSrc;
    nSubSrc = pSubSrc->nSrc;
    pSrc = pParent->pSrc;
    if (pSrc) {
      jointype = pSubitem->fg.jointype;
    } else {
      pSrc = sqlite3SrcListAppend(pParse, (SrcList *)0, (Token *)0, (Token *)0);
      if ((unsigned long )pSrc == (unsigned long )((SrcList *)0)) {
        break;
      }
      pParent->pSrc = pSrc;
    }
    if (nSubSrc > 1) {
      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc - 1, iFrom + 1);
      if ((unsigned long )pSrc == (unsigned long )((SrcList *)0)) {
        break;
      }
      pParent->pSrc = pSrc;
    }
    i = 0;
    while (i < nSubSrc) {
      sqlite3IdListDelete(db, pSrc->a[i + iFrom].pUsing);
      pSrc->a[i + iFrom] = pSubSrc->a[i];
      iNewParent = pSubSrc->a[i].iCursor;
      memset((void *)(& pSubSrc->a[i]), 0, sizeof(pSubSrc->a[i]));
      i ++;
    }
    pSrc->a[iFrom].fg.jointype = jointype;
    if (pSub->pOrderBy) {
      pOrderBy___0 = pSub->pOrderBy;
      i = 0;
      while (i < pOrderBy___0->nExpr) {
        pOrderBy___0->a[i].u.x.iOrderByCol = (u16 )0;
        i ++;
      }
      pParent->pOrderBy = pOrderBy___0;
      pSub->pOrderBy = (ExprList *)0;
    }
    pWhere = pSub->pWhere;
    pSub->pWhere = (Expr *)0;
    if (isLeftJoin > 0) {
      setJoinExpr(pWhere, iNewParent);
    }
    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);
    if ((int )db->mallocFailed == 0) {
      x___0.pParse = pParse;
      x___0.iTable = iParent;
      x___0.iNewTable = iNewParent;
      x___0.isLeftJoin = isLeftJoin;
      x___0.pEList = pSub->pEList;
      substSelect(& x___0, pParent, 0);
    }
    pParent->selFlags |= pSub->selFlags & 256U;
    if (pSub->pLimit) {
      pParent->pLimit = pSub->pLimit;
      pSub->pLimit = (Expr *)0;
    }
    pParent = pParent->pPrior;
    pSub = pSub->pPrior;
  }
  sqlite3SelectDelete(db, pSub1);
  return (1);
}
}
static void constInsert(WhereConst *pConst , Expr *pColumn , Expr *pValue ) 
{ 
  int i ;
  Expr const   *pExpr ;
  void *tmp ;

  {
  i = 0;
  while (i < pConst->nConst) {
    pExpr = (Expr const   *)*(pConst->apExpr + i * 2);
    if (pExpr->iTable == (int const   )pColumn->iTable) {
      if ((int const   )pExpr->iColumn == (int const   )pColumn->iColumn) {
        return;
      }
    }
    i ++;
  }
  (pConst->nConst) ++;
  tmp = sqlite3DbReallocOrFree((pConst->pParse)->db, (void *)pConst->apExpr, (u64 )((unsigned long )(pConst->nConst * 2) * sizeof(Expr *)));
  pConst->apExpr = (Expr **)tmp;
  if ((unsigned long )pConst->apExpr == (unsigned long )((Expr **)0)) {
    pConst->nConst = 0;
  } else {
    if ((pValue->flags & 8U) != 0U) {
      pValue = pValue->pLeft;
    }
    *(pConst->apExpr + (pConst->nConst * 2 - 2)) = pColumn;
    *(pConst->apExpr + (pConst->nConst * 2 - 1)) = pValue;
  }
  return;
}
}
static void findConstInWhere(WhereConst *pConst , Expr *pExpr ) 
{ 
  Expr *pRight ;
  Expr *pLeft ;
  int tmp ;
  CollSeq *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  CollSeq *tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return;
  }
  if ((pExpr->flags & 1U) != 0U) {
    return;
  }
  if ((int )pExpr->op == 44) {
    findConstInWhere(pConst, pExpr->pRight);
    findConstInWhere(pConst, pExpr->pLeft);
    return;
  }
  if ((int )pExpr->op != 53) {
    return;
  }
  pRight = pExpr->pRight;
  pLeft = pExpr->pLeft;
  if ((int )pRight->op == 162) {
    if (! ((pRight->flags & 8U) != 0U)) {
      tmp___2 = sqlite3ExprIsConstant(pLeft);
      if (tmp___2) {
        tmp___3 = sqlite3BinaryCompareCollSeq(pConst->pParse, pLeft, pRight);
        tmp___4 = sqlite3IsBinary((CollSeq const   *)tmp___3);
        if (tmp___4) {
          constInsert(pConst, pRight, pLeft);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((int )pLeft->op == 162) {
    if (! ((pLeft->flags & 8U) != 0U)) {
      tmp = sqlite3ExprIsConstant(pRight);
      if (tmp) {
        tmp___0 = sqlite3BinaryCompareCollSeq(pConst->pParse, pLeft, pRight);
        tmp___1 = sqlite3IsBinary((CollSeq const   *)tmp___0);
        if (tmp___1) {
          constInsert(pConst, pLeft, pRight);
        }
      }
    }
  }
  return;
}
}
static int propagateConstantExprRewrite(Walker *pWalker , Expr *pExpr ) 
{ 
  int i ;
  WhereConst *pConst ;
  Expr *pColumn ;

  {
  if ((int )pExpr->op != 162) {
    return (0);
  }
  if ((pExpr->flags & 8U) != 0U) {
    return (0);
  }
  pConst = pWalker->u.pConst;
  i = 0;
  while (i < pConst->nConst) {
    pColumn = *(pConst->apExpr + i * 2);
    if ((unsigned long )pColumn == (unsigned long )pExpr) {
      goto __Cont;
    }
    if (pColumn->iTable != pExpr->iTable) {
      goto __Cont;
    }
    if ((int )pColumn->iColumn != (int )pExpr->iColumn) {
      goto __Cont;
    }
    (pConst->nChng) ++;
    pExpr->flags &= 4286578687U;
    pExpr->flags |= 8U;
    pExpr->pLeft = sqlite3ExprDup((pConst->pParse)->db, *(pConst->apExpr + (i * 2 + 1)),
                                  0);
    break;
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (1);
}
}
static int propagateConstants(Parse *pParse , Select *p ) 
{ 
  WhereConst x___0 ;
  Walker w ;
  int nChng ;

  {
  nChng = 0;
  x___0.pParse = pParse;
  while (1) {
    x___0.nConst = 0;
    x___0.nChng = 0;
    x___0.apExpr = (Expr **)0;
    findConstInWhere(& x___0, p->pWhere);
    if (x___0.nConst) {
      memset((void *)(& w), 0, sizeof(w));
      w.pParse = pParse;
      w.xExprCallback = & propagateConstantExprRewrite;
      w.xSelectCallback = & sqlite3SelectWalkNoop;
      w.xSelectCallback2 = (void (*)(Walker * , Select * ))0;
      w.walkerDepth = 0;
      w.u.pConst = & x___0;
      sqlite3WalkExpr(& w, p->pWhere);
      sqlite3DbFree((x___0.pParse)->db, (void *)x___0.apExpr);
      nChng += x___0.nChng;
    }
    if (! x___0.nChng) {
      break;
    }
  }
  return (nChng);
}
}
static int pushDownWhereTerms(Parse *pParse , Select *pSubq , Expr *pWhere , int iCursor ,
                              int isLeftJoin ) 
{ 
  Expr *pNew ;
  int nChng ;
  int tmp ;
  SubstContext x___0 ;
  int tmp___0 ;

  {
  nChng = 0;
  if ((unsigned long )pWhere == (unsigned long )((Expr *)0)) {
    return (0);
  }
  if (pSubq->selFlags & 8192U) {
    return (0);
  }
  if (pSubq->pWin) {
    return (0);
  }
  if ((unsigned long )pSubq->pLimit != (unsigned long )((Expr *)0)) {
    return (0);
  }
  while ((int )pWhere->op == 44) {
    tmp = pushDownWhereTerms(pParse, pSubq, pWhere->pRight, iCursor, isLeftJoin);
    nChng += tmp;
    pWhere = pWhere->pLeft;
  }
  if (isLeftJoin) {
    if (((pWhere->flags & 1U) != 0U) == 0) {
      return (0);
    } else
    if ((int )pWhere->iRightJoinTable != iCursor) {
      return (0);
    }
  }
  if ((pWhere->flags & 1U) != 0U) {
    if ((int )pWhere->iRightJoinTable != iCursor) {
      return (0);
    }
  }
  tmp___0 = sqlite3ExprIsTableConstant(pWhere, iCursor);
  if (tmp___0) {
    nChng ++;
    while (pSubq) {
      pNew = sqlite3ExprDup(pParse->db, pWhere, 0);
      unsetJoinExpr(pNew, -1);
      x___0.pParse = pParse;
      x___0.iTable = iCursor;
      x___0.iNewTable = iCursor;
      x___0.isLeftJoin = 0;
      x___0.pEList = pSubq->pEList;
      pNew = substExpr(& x___0, pNew);
      if (pSubq->selFlags & 8U) {
        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);
      } else {
        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);
      }
      pSubq = pSubq->pPrior;
    }
  }
  return (nChng);
}
}
static u8 minMaxQuery(sqlite3 *db , Expr *pFunc , ExprList **ppMinMax ) 
{ 
  int eRet ;
  ExprList *pEList ;
  char const   *zFunc ;
  ExprList *pOrderBy ;
  u8 sortFlags ;
  int tmp ;
  int tmp___0 ;

  {
  eRet = 0;
  pEList = pFunc->x.pList;
  if ((unsigned long )pEList == (unsigned long )((ExprList *)0)) {
    return ((u8 )eRet);
  } else
  if (pEList->nExpr != 1) {
    return ((u8 )eRet);
  } else
  if ((pFunc->flags & 16777216U) != 0U) {
    return ((u8 )eRet);
  }
  zFunc = (char const   *)pFunc->u.zToken;
  tmp___0 = sqlite3StrICmp(zFunc, "min");
  if (tmp___0 == 0) {
    eRet = 1;
    sortFlags = (u8 )2;
  } else {
    tmp = sqlite3StrICmp(zFunc, "max");
    if (tmp == 0) {
      eRet = 2;
      sortFlags = (u8 )1;
    } else {
      return ((u8 )eRet);
    }
  }
  pOrderBy = sqlite3ExprListDup(db, pEList, 0);
  *ppMinMax = pOrderBy;
  if (pOrderBy) {
    pOrderBy->a[0].sortFlags = sortFlags;
  }
  return ((u8 )eRet);
}
}
static Table *isSimpleCount(Select *p , AggInfo *pAggInfo ) 
{ 
  Table *pTab ;
  Expr *pExpr ;

  {
  if (p->pWhere) {
    return ((Table *)0);
  } else
  if ((p->pEList)->nExpr != 1) {
    return ((Table *)0);
  } else
  if ((p->pSrc)->nSrc != 1) {
    return ((Table *)0);
  } else
  if ((p->pSrc)->a[0].pSelect) {
    return ((Table *)0);
  }
  pTab = (p->pSrc)->a[0].pTab;
  pExpr = (p->pEList)->a[0].pExpr;
  if (pTab->nModuleArg) {
    return ((Table *)0);
  }
  if ((int )pExpr->op != 163) {
    return ((Table *)0);
  }
  if (pAggInfo->nFunc == 0) {
    return ((Table *)0);
  }
  if ((((pAggInfo->aFunc + 0)->pFunc)->funcFlags & 256U) == 0U) {
    return ((Table *)0);
  }
  if ((pExpr->flags & 16777218U) != 0U) {
    return ((Table *)0);
  }
  return (pTab);
}
}
static int sqlite3IndexedByLookup(Parse *pParse , struct SrcList_item *pFrom ) 
{ 
  Table *pTab ;
  char *zIndexedBy ;
  Index *pIdx ;
  int tmp ;

  {
  if (pFrom->pTab) {
    if (pFrom->fg.isIndexedBy) {
      pTab = pFrom->pTab;
      zIndexedBy = pFrom->u1.zIndexedBy;
      pIdx = pTab->pIndex;
      while (1) {
        if (pIdx) {
          tmp = sqlite3StrICmp((char const   *)pIdx->zName, (char const   *)zIndexedBy);
          if (! tmp) {
            break;
          }
        } else {
          break;
        }
        pIdx = pIdx->pNext;
      }
      if (! pIdx) {
        sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, 0);
        pParse->checkSchema = (u8 )1;
        return (1);
      }
      pFrom->pIBIndex = pIdx;
    }
  }
  return (0);
}
}
static int convertCompoundSelectToSubquery(Walker *pWalker , Select *p ) 
{ 
  int i ;
  Select *pNew ;
  Select *pX ;
  sqlite3 *db ;
  struct ExprList_item *a___0 ;
  SrcList *pNewSrc ;
  Parse *pParse ;
  Token dummy___0 ;
  void *tmp ;
  Expr *tmp___0 ;

  {
  if ((unsigned long )p->pPrior == (unsigned long )((Select *)0)) {
    return (0);
  }
  if ((unsigned long )p->pOrderBy == (unsigned long )((ExprList *)0)) {
    return (0);
  }
  pX = p;
  while (1) {
    if (pX) {
      if (! ((int )pX->op == 131)) {
        if (! ((int )pX->op == 134)) {
          break;
        }
      }
    } else {
      break;
    }
    pX = pX->pPrior;
  }
  if ((unsigned long )pX == (unsigned long )((Select *)0)) {
    return (0);
  }
  a___0 = (p->pOrderBy)->a;
  i = (p->pOrderBy)->nExpr - 1;
  while (i >= 0) {
    if (((a___0 + i)->pExpr)->flags & 256U) {
      break;
    }
    i --;
  }
  if (i < 0) {
    return (0);
  }
  pParse = pWalker->pParse;
  db = pParse->db;
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(*pNew));
  pNew = (Select *)tmp;
  if ((unsigned long )pNew == (unsigned long )((Select *)0)) {
    return (2);
  }
  memset((void *)(& dummy___0), 0, sizeof(dummy___0));
  pNewSrc = sqlite3SrcListAppendFromTerm(pParse, (SrcList *)0, (Token *)0, (Token *)0,
                                         & dummy___0, pNew, (Expr *)0, (IdList *)0);
  if ((unsigned long )pNewSrc == (unsigned long )((SrcList *)0)) {
    return (2);
  }
  *pNew = *p;
  p->pSrc = pNewSrc;
  tmp___0 = sqlite3Expr(db, 175, (char const   *)0);
  p->pEList = sqlite3ExprListAppend(pParse, (ExprList *)0, tmp___0);
  p->op = (u8 )134;
  p->pWhere = (Expr *)0;
  pNew->pGroupBy = (ExprList *)0;
  pNew->pHaving = (Expr *)0;
  pNew->pOrderBy = (ExprList *)0;
  p->pPrior = (Select *)0;
  p->pNext = (Select *)0;
  p->pWith = (With *)0;
  p->selFlags &= 4294967039U;
  p->selFlags |= 65536U;
  (pNew->pPrior)->pNext = pNew;
  pNew->pLimit = (Expr *)0;
  return (0);
}
}
static int cannotBeFunction(Parse *pParse , struct SrcList_item *pFrom ) 
{ 


  {
  if (pFrom->fg.isTabFunc) {
    sqlite3ErrorMsg(pParse, "\'%s\' is not a function", pFrom->zName);
    return (1);
  }
  return (0);
}
}
static struct Cte *searchWith(With *pWith , struct SrcList_item *pItem , With **ppContext ) 
{ 
  char const   *zName ;
  With *p ;
  int i ;
  int tmp ;

  {
  if ((unsigned long )pItem->zDatabase == (unsigned long )((char *)0)) {
    zName = (char const   *)pItem->zName;
    if ((unsigned long )zName != (unsigned long )((char const   *)0)) {
      p = pWith;
      while (p) {
        i = 0;
        while (i < p->nCte) {
          tmp = sqlite3StrICmp(zName, (char const   *)p->a[i].zName);
          if (tmp == 0) {
            *ppContext = p;
            return (& p->a[i]);
          }
          i ++;
        }
        p = p->pOuter;
      }
    }
  }
  return ((struct Cte *)0);
}
}
static void sqlite3WithPush(Parse *pParse , With *pWith , u8 bFree ) 
{ 


  {
  if (pWith) {
    pWith->pOuter = pParse->pWith;
    pParse->pWith = pWith;
    if (bFree) {
      pParse->pWithToFree = pWith;
    }
  }
  return;
}
}
static int withExpand(Walker *pWalker , struct SrcList_item *pFrom ) 
{ 
  Parse *pParse ;
  sqlite3 *db ;
  struct Cte *pCte ;
  With *pWith ;
  Table *pTab ;
  ExprList *pEList ;
  Select *pSel ;
  Select *pLeft ;
  int bMayRecursive ;
  With *pSavedWith ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int i ;
  SrcList *pSrc ;
  struct SrcList_item *pItem ;
  int tmp___2 ;
  Select *pPrior ;

  {
  pParse = pWalker->pParse;
  db = pParse->db;
  pCte = searchWith(pParse->pWith, pFrom, & pWith);
  if (pCte) {
    if (pCte->zCteErr) {
      sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);
      return (1);
    }
    tmp = cannotBeFunction(pParse, pFrom);
    if (tmp) {
      return (1);
    }
    tmp___0 = sqlite3DbMallocZero(db, (u64 )sizeof(Table ));
    pTab = (Table *)tmp___0;
    pFrom->pTab = pTab;
    if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
      return (2);
    }
    pTab->nTabRef = (u32 )1;
    pTab->zName = sqlite3DbStrDup(db, (char const   *)pCte->zName);
    pTab->iPKey = (i16 )-1;
    pTab->nRowLogEst = (LogEst )200;
    pTab->tabFlags |= 66U;
    pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);
    if (db->mallocFailed) {
      return (7);
    }
    pSel = pFrom->pSelect;
    if ((int )pSel->op == 131) {
      tmp___1 = 1;
    } else
    if ((int )pSel->op == 130) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    bMayRecursive = tmp___1;
    if (bMayRecursive) {
      pSrc = (pFrom->pSelect)->pSrc;
      i = 0;
      while (i < pSrc->nSrc) {
        pItem = & pSrc->a[i];
        if ((unsigned long )pItem->zDatabase == (unsigned long )((char *)0)) {
          if ((unsigned long )pItem->zName != (unsigned long )((char *)0)) {
            tmp___2 = sqlite3StrICmp((char const   *)pItem->zName, (char const   *)pCte->zName);
            if (0 == tmp___2) {
              pItem->pTab = pTab;
              pItem->fg.isRecursive = 1U;
              (pTab->nTabRef) ++;
              pSel->selFlags |= 8192U;
            }
          }
        }
        i ++;
      }
    }
    if (pTab->nTabRef > 2U) {
      sqlite3ErrorMsg(pParse, "multiple references to recursive table: %s", pCte->zName);
      return (1);
    }
    pCte->zCteErr = "circular reference: %s";
    pSavedWith = pParse->pWith;
    pParse->pWith = pWith;
    if (bMayRecursive) {
      pPrior = pSel->pPrior;
      pPrior->pWith = pSel->pWith;
      sqlite3WalkSelect(pWalker, pPrior);
      pPrior->pWith = (With *)0;
    } else {
      sqlite3WalkSelect(pWalker, pSel);
    }
    pParse->pWith = pWith;
    pLeft = pSel;
    while (pLeft->pPrior) {
      pLeft = pLeft->pPrior;
    }
    pEList = pLeft->pEList;
    if (pCte->pCols) {
      if (pEList) {
        if (pEList->nExpr != (pCte->pCols)->nExpr) {
          sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns", pCte->zName,
                          pEList->nExpr, (pCte->pCols)->nExpr);
          pParse->pWith = pSavedWith;
          return (1);
        }
      }
      pEList = pCte->pCols;
    }
    sqlite3ColumnsFromExprList(pParse, pEList, & pTab->nCol, & pTab->aCol);
    if (bMayRecursive) {
      if (pSel->selFlags & 8192U) {
        pCte->zCteErr = "multiple recursive references: %s";
      } else {
        pCte->zCteErr = "recursive reference in a subquery: %s";
      }
      sqlite3WalkSelect(pWalker, pSel);
    }
    pCte->zCteErr = (char const   *)0;
    pParse->pWith = pSavedWith;
  }
  return (0);
}
}
static void selectPopWith(Walker *pWalker , Select *p ) 
{ 
  Parse *pParse ;
  With *pWith ;
  Select *tmp ;

  {
  pParse = pWalker->pParse;
  if (pParse->pWith) {
    if ((unsigned long )p->pPrior == (unsigned long )((Select *)0)) {
      tmp = findRightmost(p);
      pWith = tmp->pWith;
      if ((unsigned long )pWith != (unsigned long )((With *)0)) {
        pParse->pWith = pWith->pOuter;
      }
    }
  }
  return;
}
}
static int sqlite3ExpandSubquery(Parse *pParse , struct SrcList_item *pFrom ) 
{ 
  Select *pSel ;
  Table *pTab ;
  void *tmp ;
  int tmp___0 ;

  {
  pSel = pFrom->pSelect;
  tmp = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(Table ));
  pTab = (Table *)tmp;
  pFrom->pTab = pTab;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return (7);
  }
  pTab->nTabRef = (u32 )1;
  if (pFrom->zAlias) {
    pTab->zName = sqlite3DbStrDup(pParse->db, (char const   *)pFrom->zAlias);
  } else {
    pTab->zName = sqlite3MPrintf(pParse->db, "subquery_%u", pSel->selId);
  }
  while (pSel->pPrior) {
    pSel = pSel->pPrior;
  }
  sqlite3ColumnsFromExprList(pParse, pSel->pEList, & pTab->nCol, & pTab->aCol);
  pTab->iPKey = (i16 )-1;
  pTab->nRowLogEst = (LogEst )200;
  pTab->tabFlags |= 2U;
  if (pParse->nErr) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int selectExpander(Walker *pWalker , Select *p ) 
{ 
  Parse *pParse ;
  int i ;
  int j ;
  int k ;
  SrcList *pTabList ;
  ExprList *pEList ;
  struct SrcList_item *pFrom ;
  sqlite3 *db ;
  Expr *pE ;
  Expr *pRight ;
  Expr *pExpr ;
  u16 selFlags ;
  u32 elistFlags ;
  Table *pTab ;
  int tmp ;
  Select *pSel ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  i16 nCol ;
  u8 eCodeOrig ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct ExprList_item *a___0 ;
  ExprList *pNew ;
  int flags___0 ;
  int longNames ;
  int tmp___6 ;
  int tableSeen ;
  char *zTName ;
  Table *pTab___0 ;
  Select *pSub ;
  char *zTabName ;
  char const   *zSchemaName ;
  int iDb ;
  int tmp___7 ;
  char *zName ;
  char *zColname ;
  char *zToFree ;
  Token sColname ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  Expr *pLeft ;
  struct ExprList_item *pX ;

  {
  pParse = pWalker->pParse;
  db = pParse->db;
  selFlags = (u16 )p->selFlags;
  elistFlags = (u32 )0;
  p->selFlags |= 64U;
  if (db->mallocFailed) {
    return (2);
  }
  if (((int )selFlags & 64) != 0) {
    return (1);
  }
  if (pWalker->eCode) {
    (pParse->nSelect) ++;
    p->selId = (u32 )pParse->nSelect;
  }
  pTabList = p->pSrc;
  pEList = p->pEList;
  sqlite3WithPush(pParse, p->pWith, (u8 )0);
  sqlite3SrcListAssignCursors(pParse, pTabList);
  i = 0;
  pFrom = pTabList->a;
  while (i < pTabList->nSrc) {
    if (pFrom->fg.isRecursive) {
      goto __Cont;
    }
    tmp = withExpand(pWalker, pFrom);
    if (tmp) {
      return (2);
    }
    if (! pFrom->pTab) {
      if ((unsigned long )pFrom->zName == (unsigned long )((char *)0)) {
        pSel = pFrom->pSelect;
        tmp___0 = sqlite3WalkSelect(pWalker, pSel);
        if (tmp___0) {
          return (2);
        }
        tmp___1 = sqlite3ExpandSubquery(pParse, pFrom);
        if (tmp___1) {
          return (2);
        }
      } else {
        pTab = sqlite3LocateTableItem(pParse, (u32 )0, pFrom);
        pFrom->pTab = pTab;
        if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
          return (2);
        }
        if (pTab->nTabRef >= 65535U) {
          sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535", pTab->zName);
          pFrom->pTab = (Table *)0;
          return (2);
        }
        (pTab->nTabRef) ++;
        if (! pTab->nModuleArg) {
          tmp___2 = cannotBeFunction(pParse, pFrom);
          if (tmp___2) {
            return (2);
          }
        }
        if (pTab->nModuleArg) {
          goto _L;
        } else
        if (pTab->pSelect) {
          _L: /* CIL Label */ 
          eCodeOrig = pWalker->eCode;
          tmp___3 = sqlite3ViewGetColumnNames(pParse, pTab);
          if (tmp___3) {
            return (2);
          }
          if (pTab->pSelect) {
            if ((db->flags & 2147483648ULL) == 0ULL) {
              sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited", pTab->zName);
            }
          }
          pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
          nCol = pTab->nCol;
          pTab->nCol = (i16 )-1;
          pWalker->eCode = (u8 )1;
          sqlite3WalkSelect(pWalker, pFrom->pSelect);
          pWalker->eCode = eCodeOrig;
          pTab->nCol = nCol;
        }
      }
    }
    tmp___4 = sqlite3IndexedByLookup(pParse, pFrom);
    if (tmp___4) {
      return (2);
    }
    __Cont: /* CIL Label */ 
    i ++;
    pFrom ++;
  }
  if (db->mallocFailed) {
    return (2);
  } else {
    tmp___5 = sqliteProcessJoin(pParse, p);
    if (tmp___5) {
      return (2);
    }
  }
  k = 0;
  while (k < pEList->nExpr) {
    pE = pEList->a[k].pExpr;
    if ((int )pE->op == 175) {
      break;
    }
    if ((int )pE->op == 137) {
      if ((int )(pE->pRight)->op == 175) {
        break;
      }
    }
    elistFlags |= pE->flags;
    k ++;
  }
  if (k < pEList->nExpr) {
    a___0 = pEList->a;
    pNew = (ExprList *)0;
    flags___0 = (int )(pParse->db)->flags;
    if ((flags___0 & 4) != 0) {
      if ((flags___0 & 64) == 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    } else {
      tmp___6 = 0;
    }
    longNames = tmp___6;
    k = 0;
    while (k < pEList->nExpr) {
      pE = (a___0 + k)->pExpr;
      elistFlags |= pE->flags;
      pRight = pE->pRight;
      if ((int )pE->op != 175) {
        if ((int )pE->op != 137) {
          goto _L___3;
        } else
        if ((int )pRight->op != 175) {
          _L___3: /* CIL Label */ 
          pNew = sqlite3ExprListAppend(pParse, pNew, (a___0 + k)->pExpr);
          if (pNew) {
            pNew->a[pNew->nExpr - 1].zName = (a___0 + k)->zName;
            pNew->a[pNew->nExpr - 1].zSpan = (a___0 + k)->zSpan;
            (a___0 + k)->zName = (char *)0;
            (a___0 + k)->zSpan = (char *)0;
          }
          (a___0 + k)->pExpr = (Expr *)0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        tableSeen = 0;
        zTName = (char *)0;
        if ((int )pE->op == 137) {
          zTName = (pE->pLeft)->u.zToken;
        }
        i = 0;
        pFrom = pTabList->a;
        while (i < pTabList->nSrc) {
          pTab___0 = pFrom->pTab;
          pSub = pFrom->pSelect;
          zTabName = pFrom->zAlias;
          zSchemaName = (char const   *)0;
          if ((unsigned long )zTabName == (unsigned long )((char *)0)) {
            zTabName = pTab___0->zName;
          }
          if (db->mallocFailed) {
            break;
          }
          if ((unsigned long )pSub == (unsigned long )((Select *)0)) {
            goto _L___0;
          } else
          if ((pSub->selFlags & 2048U) == 0U) {
            _L___0: /* CIL Label */ 
            pSub = (Select *)0;
            if (zTName) {
              tmp___7 = sqlite3StrICmp((char const   *)zTName, (char const   *)zTabName);
              if (tmp___7 != 0) {
                goto __Cont___0;
              }
            }
            iDb = sqlite3SchemaToIndex(db, pTab___0->pSchema);
            if (iDb >= 0) {
              zSchemaName = (char const   *)(db->aDb + iDb)->zDbSName;
            } else {
              zSchemaName = "*";
            }
          }
          j = 0;
          while (j < (int )pTab___0->nCol) {
            zName = (pTab___0->aCol + j)->zName;
            if (zTName) {
              if (pSub) {
                tmp___8 = sqlite3MatchSpanName((char const   *)(pSub->pEList)->a[j].zSpan,
                                               (char const   *)0, (char const   *)zTName,
                                               (char const   *)0);
                if (tmp___8 == 0) {
                  goto __Cont___1;
                }
              }
            }
            if ((p->selFlags & 131072U) == 0U) {
              if (((int )(pTab___0->aCol + j)->colFlags & 2) != 0) {
                goto __Cont___1;
              }
            }
            tableSeen = 1;
            if (i > 0) {
              if ((unsigned long )zTName == (unsigned long )((char *)0)) {
                if (((int )pFrom->fg.jointype & 4) != 0) {
                  tmp___9 = tableAndColumnIndex(pTabList, i, (char const   *)zName,
                                                (int *)0, (int *)0);
                  if (tmp___9) {
                    goto __Cont___1;
                  }
                }
                tmp___10 = sqlite3IdListIndex(pFrom->pUsing, (char const   *)zName);
                if (tmp___10 >= 0) {
                  goto __Cont___1;
                }
              }
            }
            pRight = sqlite3Expr(db, 59, (char const   *)zName);
            zColname = zName;
            zToFree = (char *)0;
            if (longNames) {
              goto _L___1;
            } else
            if (pTabList->nSrc > 1) {
              _L___1: /* CIL Label */ 
              pLeft = sqlite3Expr(db, 59, (char const   *)zTabName);
              pExpr = sqlite3PExpr(pParse, 137, pLeft, pRight);
              if (zSchemaName) {
                pLeft = sqlite3Expr(db, 59, zSchemaName);
                pExpr = sqlite3PExpr(pParse, 137, pLeft, pExpr);
              }
              if (longNames) {
                zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
                zToFree = zColname;
              }
            } else {
              pExpr = pRight;
            }
            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
            sqlite3TokenInit(& sColname, zColname);
            sqlite3ExprListSetName(pParse, pNew, & sColname, 0);
            if (pNew) {
              if ((p->selFlags & 2048U) != 0U) {
                pX = & pNew->a[pNew->nExpr - 1];
                if (pSub) {
                  pX->zSpan = sqlite3DbStrDup(db, (char const   *)(pSub->pEList)->a[j].zSpan);
                } else {
                  pX->zSpan = sqlite3MPrintf(db, "%s.%s.%s", zSchemaName, zTabName,
                                             zColname);
                }
                pX->bSpanIsTab = 1U;
              }
            }
            sqlite3DbFree(db, (void *)zToFree);
            __Cont___1: /* CIL Label */ 
            j ++;
          }
          __Cont___0: /* CIL Label */ 
          i ++;
          pFrom ++;
        }
        if (! tableSeen) {
          if (zTName) {
            sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
          } else {
            sqlite3ErrorMsg(pParse, "no tables specified");
          }
        }
      }
      k ++;
    }
    sqlite3ExprListDelete(db, pEList);
    p->pEList = pNew;
  }
  if (p->pEList) {
    if ((p->pEList)->nExpr > db->aLimit[2]) {
      sqlite3ErrorMsg(pParse, "too many columns in result set");
      return (2);
    }
    if ((elistFlags & 2097156U) != 0U) {
      p->selFlags |= 262144U;
    }
  }
  return (0);
}
}
static int sqlite3ExprWalkNoop(Walker *NotUsed , Expr *NotUsed2 ) 
{ 


  {
  return (0);
}
}
static int sqlite3SelectWalkNoop(Walker *NotUsed , Select *NotUsed2 ) 
{ 


  {
  return (0);
}
}
static void sqlite3SelectExpand(Parse *pParse , Select *pSelect ) 
{ 
  Walker w ;

  {
  w.xExprCallback = & sqlite3ExprWalkNoop;
  w.pParse = pParse;
  if (pParse->hasCompound) {
    w.xSelectCallback = & convertCompoundSelectToSubquery;
    w.xSelectCallback2 = (void (*)(Walker * , Select * ))0;
    sqlite3WalkSelect(& w, pSelect);
  }
  w.xSelectCallback = & selectExpander;
  w.xSelectCallback2 = & selectPopWith;
  w.eCode = (u8 )0;
  sqlite3WalkSelect(& w, pSelect);
  return;
}
}
static void selectAddSubqueryTypeInfo(Walker *pWalker , Select *p ) 
{ 
  Parse *pParse ;
  int i ;
  SrcList *pTabList ;
  struct SrcList_item *pFrom ;
  Table *pTab ;
  Select *pSel ;

  {
  if (p->selFlags & 128U) {
    return;
  }
  p->selFlags |= 128U;
  pParse = pWalker->pParse;
  pTabList = p->pSrc;
  i = 0;
  pFrom = pTabList->a;
  while (i < pTabList->nSrc) {
    pTab = pFrom->pTab;
    if ((pTab->tabFlags & 2U) != 0U) {
      pSel = pFrom->pSelect;
      if (pSel) {
        while (pSel->pPrior) {
          pSel = pSel->pPrior;
        }
        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel, (char)64);
      }
    }
    i ++;
    pFrom ++;
  }
  return;
}
}
static void sqlite3SelectAddTypeInfo(Parse *pParse , Select *pSelect ) 
{ 
  Walker w ;

  {
  w.xSelectCallback = & sqlite3SelectWalkNoop;
  w.xSelectCallback2 = & selectAddSubqueryTypeInfo;
  w.xExprCallback = & sqlite3ExprWalkNoop;
  w.pParse = pParse;
  sqlite3WalkSelect(& w, pSelect);
  return;
}
}
static void sqlite3SelectPrep(Parse *pParse , Select *p , NameContext *pOuterNC ) 
{ 


  {
  if ((pParse->db)->mallocFailed) {
    return;
  }
  if (p->selFlags & 128U) {
    return;
  }
  sqlite3SelectExpand(pParse, p);
  if (pParse->nErr) {
    return;
  } else
  if ((pParse->db)->mallocFailed) {
    return;
  }
  sqlite3ResolveSelectNames(pParse, p, pOuterNC);
  if (pParse->nErr) {
    return;
  } else
  if ((pParse->db)->mallocFailed) {
    return;
  }
  sqlite3SelectAddTypeInfo(pParse, p);
  return;
}
}
static void resetAccumulator(Parse *pParse , AggInfo *pAggInfo ) 
{ 
  Vdbe *v ;
  int i ;
  struct AggInfo_func *pFunc ;
  int nReg ;
  Expr *pE ;
  KeyInfo *pKeyInfo ;
  KeyInfo *tmp ;

  {
  v = pParse->pVdbe;
  nReg = pAggInfo->nFunc + pAggInfo->nColumn;
  if (nReg == 0) {
    return;
  }
  sqlite3VdbeAddOp3(v, 73, 0, pAggInfo->mnReg, pAggInfo->mxReg);
  pFunc = pAggInfo->aFunc;
  i = 0;
  while (i < pAggInfo->nFunc) {
    if (pFunc->iDistinct >= 0) {
      pE = pFunc->pExpr;
      if ((unsigned long )pE->x.pList == (unsigned long )((ExprList *)0)) {
        sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one argument");
        pFunc->iDistinct = -1;
      } else
      if ((pE->x.pList)->nExpr != 1) {
        sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one argument");
        pFunc->iDistinct = -1;
      } else {
        tmp = sqlite3KeyInfoFromExprList(pParse, pE->x.pList, 0, 0);
        pKeyInfo = tmp;
        sqlite3VdbeAddOp4(v, 112, pFunc->iDistinct, 0, 0, (char const   *)((char *)pKeyInfo),
                          -9);
      }
    }
    i ++;
    pFunc ++;
  }
  return;
}
}
static void finalizeAggFunctions(Parse *pParse , AggInfo *pAggInfo ) 
{ 
  Vdbe *v ;
  int i ;
  struct AggInfo_func *pF ;
  ExprList *pList ;
  int tmp ;

  {
  v = pParse->pVdbe;
  i = 0;
  pF = pAggInfo->aFunc;
  while (i < pAggInfo->nFunc) {
    pList = (pF->pExpr)->x.pList;
    if (pList) {
      tmp = pList->nExpr;
    } else {
      tmp = 0;
    }
    sqlite3VdbeAddOp2(v, 157, pF->iMem, tmp);
    sqlite3VdbeAppendP4(v, (void *)pF->pFunc, -8);
    i ++;
    pF ++;
  }
  return;
}
}
static void updateAccumulator(Parse *pParse , int regAcc , AggInfo *pAggInfo ) 
{ 
  Vdbe *v ;
  int i ;
  int regHit ;
  int addrHitTest ;
  struct AggInfo_func *pF ;
  struct AggInfo_col *pC ;
  int nArg ;
  int addrNext ;
  int regAgg ;
  ExprList *pList ;
  Expr *pFilter ;
  CollSeq *pColl ;
  struct ExprList_item *pItem ;
  int j ;

  {
  v = pParse->pVdbe;
  regHit = 0;
  addrHitTest = 0;
  pAggInfo->directMode = (u8 )1;
  i = 0;
  pF = pAggInfo->aFunc;
  while (i < pAggInfo->nFunc) {
    addrNext = 0;
    pList = (pF->pExpr)->x.pList;
    if (((pF->pExpr)->flags & 16777216U) != 0U) {
      pFilter = ((pF->pExpr)->y.pWin)->pFilter;
      if (pAggInfo->nAccumulator) {
        if ((pF->pFunc)->funcFlags & 32U) {
          if (regHit == 0) {
            (pParse->nMem) ++;
            regHit = pParse->nMem;
          }
          sqlite3VdbeAddOp2(v, 78, regAcc, regHit);
        }
      }
      addrNext = sqlite3VdbeMakeLabel(pParse);
      sqlite3ExprIfFalse(pParse, pFilter, addrNext, 16);
    }
    if (pList) {
      nArg = pList->nExpr;
      regAgg = sqlite3GetTempRange(pParse, nArg);
      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, (u8 )1);
    } else {
      nArg = 0;
      regAgg = 0;
    }
    if (pF->iDistinct >= 0) {
      if (addrNext == 0) {
        addrNext = sqlite3VdbeMakeLabel(pParse);
      }
      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
    }
    if ((pF->pFunc)->funcFlags & 32U) {
      pColl = (CollSeq *)0;
      j = 0;
      pItem = pList->a;
      while (1) {
        if (! pColl) {
          if (! (j < nArg)) {
            break;
          }
        } else {
          break;
        }
        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
        j ++;
        pItem ++;
      }
      if (! pColl) {
        pColl = (pParse->db)->pDfltColl;
      }
      if (regHit == 0) {
        if (pAggInfo->nAccumulator) {
          (pParse->nMem) ++;
          regHit = pParse->nMem;
        }
      }
      sqlite3VdbeAddOp4(v, 82, regHit, 0, 0, (char const   *)((char *)pColl), -2);
    }
    sqlite3VdbeAddOp3(v, 154, 0, regAgg, pF->iMem);
    sqlite3VdbeAppendP4(v, (void *)pF->pFunc, -8);
    sqlite3VdbeChangeP5(v, (u16 )((u8 )nArg));
    sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    if (addrNext) {
      sqlite3VdbeResolveLabel(v, addrNext);
    }
    i ++;
    pF ++;
  }
  if (regHit == 0) {
    if (pAggInfo->nAccumulator) {
      regHit = regAcc;
    }
  }
  if (regHit) {
    addrHitTest = sqlite3VdbeAddOp1(v, 18, regHit);
  }
  i = 0;
  pC = pAggInfo->aCol;
  while (i < pAggInfo->nAccumulator) {
    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);
    i ++;
    pC ++;
  }
  pAggInfo->directMode = (u8 )0;
  if (addrHitTest) {
    sqlite3VdbeJumpHere(v, addrHitTest);
  }
  return;
}
}
static void explainSimpleCount(Parse *pParse , Table *pTab , Index *pIdx ) 
{ 
  int bCover ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  if ((int )pParse->explain == 2) {
    if ((unsigned long )pIdx != (unsigned long )((Index *)0)) {
      if ((pTab->tabFlags & 32U) == 0U) {
        tmp = 1;
      } else
      if (! (pIdx->idxType == 2U)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    bCover = tmp;
    if (bCover) {
      tmp___0 = (char const   *)pIdx->zName;
    } else {
      tmp___0 = "";
    }
    if (bCover) {
      tmp___1 = " USING COVERING INDEX ";
    } else {
      tmp___1 = "";
    }
    sqlite3VdbeExplain(pParse, (u8 )0, "SCAN TABLE %s%s%s", pTab->zName, tmp___1,
                       tmp___0);
  }
  return;
}
}
static int havingToWhereExprCb(Walker *pWalker , Expr *pExpr ) 
{ 
  Select *pS ;
  sqlite3 *db ;
  Expr *pNew ;
  Expr *tmp ;
  Expr *pWhere ;
  Expr t ;
  int tmp___0 ;

  {
  if ((int )pExpr->op != 44) {
    pS = pWalker->u.pSelect;
    tmp___0 = sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy);
    if (tmp___0) {
      db = (pWalker->pParse)->db;
      tmp = sqlite3Expr(db, 150, "1");
      pNew = tmp;
      if (pNew) {
        pWhere = pS->pWhere;
        t = *pNew;
        *pNew = *pExpr;
        *pExpr = t;
        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);
        pS->pWhere = pNew;
        pWalker->eCode = (u8 )1;
      }
    }
    return (1);
  }
  return (0);
}
}
static void havingToWhere(Parse *pParse , Select *p ) 
{ 
  Walker sWalker ;

  {
  memset((void *)(& sWalker), 0, sizeof(sWalker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = & havingToWhereExprCb;
  sWalker.u.pSelect = p;
  sqlite3WalkExpr(& sWalker, p->pHaving);
  return;
}
}
static struct SrcList_item *isSelfJoinView(SrcList *pTabList , struct SrcList_item *pThis ) 
{ 
  struct SrcList_item *pItem ;
  Select *pS1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pItem = pTabList->a;
  while ((unsigned long )pItem < (unsigned long )pThis) {
    if ((unsigned long )pItem->pSelect == (unsigned long )((Select *)0)) {
      goto __Cont;
    }
    if (pItem->fg.viaCoroutine) {
      goto __Cont;
    }
    if ((unsigned long )pItem->zName == (unsigned long )((char *)0)) {
      goto __Cont;
    }
    if ((unsigned long )(pItem->pTab)->pSchema != (unsigned long )(pThis->pTab)->pSchema) {
      goto __Cont;
    }
    tmp = sqlite3_stricmp((char const   *)pItem->zName, (char const   *)pThis->zName);
    if (tmp != 0) {
      goto __Cont;
    }
    pS1 = pItem->pSelect;
    if ((unsigned long )(pItem->pTab)->pSchema == (unsigned long )((Schema *)0)) {
      if ((pThis->pSelect)->selId != pS1->selId) {
        goto __Cont;
      }
    }
    tmp___0 = sqlite3ExprCompare((Parse *)0, (pThis->pSelect)->pWhere, pS1->pWhere,
                                 -1);
    if (tmp___0) {
      goto __Cont;
    } else {
      tmp___1 = sqlite3ExprCompare((Parse *)0, (pThis->pSelect)->pHaving, pS1->pHaving,
                                   -1);
      if (tmp___1) {
        goto __Cont;
      }
    }
    return (pItem);
    __Cont: /* CIL Label */ 
    pItem ++;
  }
  return ((struct SrcList_item *)0);
}
}
static int sqlite3Select(Parse *pParse , Select *p , SelectDest *pDest ) 
{ 
  int i ;
  int j ;
  WhereInfo *pWInfo ;
  Vdbe *v ;
  int isAgg ;
  ExprList *pEList ;
  SrcList *pTabList ;
  Expr *pWhere ;
  ExprList *pGroupBy ;
  Expr *pHaving ;
  int rc ;
  DistinctCtx sDistinct ;
  SortCtx sSort ;
  AggInfo sAggInfo ;
  int iEnd ;
  sqlite3 *db ;
  ExprList *pMinMaxOrderBy ;
  u8 minMaxFlag ;
  int tmp ;
  int tmp___0 ;
  struct SrcList_item *pItem ;
  Select *pSub ;
  Table *pTab ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct SrcList_item *pItem___0 ;
  SelectDest dest ;
  Select *pSub___0 ;
  char const   *zSavedAuthContext ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int addrTop ;
  int tmp___8 ;
  int topAddr ;
  int onceAddr ;
  int retAddr ;
  struct SrcList_item *pPrior ;
  int tmp___9 ;
  ExprList *tmp___10 ;
  int tmp___11 ;
  KeyInfo *pKeyInfo ;
  int tmp___12 ;
  int tmp___13 ;
  KeyInfo *tmp___14 ;
  u16 wctrlFlags ;
  int tmp___15 ;
  Window *pWin ;
  LogEst tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int addrGosub ;
  int tmp___19 ;
  int iCont ;
  int tmp___20 ;
  int iBreak ;
  int tmp___21 ;
  int regGosub ;
  int tmp___22 ;
  int tmp___23 ;
  NameContext sNC ;
  int iAMem ;
  int iBMem ;
  int iUseFlag ;
  int iAbortFlag ;
  int groupBySort ;
  int addrEnd ;
  int sortPTab ;
  int sortOut ;
  int orderByGrp ;
  int k ;
  struct ExprList_item *pItem___1 ;
  int ii ;
  u8 sortFlags ;
  int tmp___24 ;
  Expr *pExpr ;
  KeyInfo *pKeyInfo___0 ;
  int addr1 ;
  int addrOutputRow ;
  int regOutputRow ;
  int addrSetAbort ;
  int addrTopOfLoop ;
  int addrSortingIdx ;
  int addrReset ;
  int regReset ;
  int tmp___25 ;
  int tmp___26 ;
  int regBase ;
  int regRecord ;
  int nCol ;
  int nGroupBy ;
  char const   *tmp___27 ;
  struct AggInfo_col *pCol ;
  int r1 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  KeyInfo *tmp___31 ;
  Table *pTab___0 ;
  int iDb ;
  int tmp___32 ;
  int iCsr ;
  int tmp___33 ;
  Index *pIdx ;
  KeyInfo *pKeyInfo___1 ;
  Index *pBest ;
  int iRoot ;
  int regAcc ;
  int tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;

  {
  pEList = (ExprList *)0;
  rc = 1;
  pMinMaxOrderBy = (ExprList *)0;
  db = pParse->db;
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )p == (unsigned long )((Select *)0)) {
    return (1);
  } else
  if (db->mallocFailed) {
    return (1);
  } else
  if (pParse->nErr) {
    return (1);
  }
  tmp = sqlite3AuthCheck(pParse, 21, (char const   *)0, (char const   *)0, (char const   *)0);
  if (tmp) {
    return (1);
  }
  memset((void *)(& sAggInfo), 0, sizeof(sAggInfo));
  if ((int )pDest->eDest <= 8) {
    sqlite3ExprListDelete(db, p->pOrderBy);
    p->pOrderBy = (ExprList *)0;
    p->selFlags &= 4294967294U;
  }
  sqlite3SelectPrep(pParse, p, (NameContext *)0);
  if (pParse->nErr) {
    goto select_end;
  } else
  if (db->mallocFailed) {
    goto select_end;
  }
  if ((int )pDest->eDest == 9) {
    generateColumnNames(pParse, p);
  }
  tmp___0 = sqlite3WindowRewrite(pParse, p);
  if (tmp___0) {
    goto select_end;
  }
  pTabList = p->pSrc;
  isAgg = (p->selFlags & 8U) != 0U;
  memset((void *)(& sSort), 0, sizeof(sSort));
  sSort.pOrderBy = p->pOrderBy;
  i = 0;
  while (1) {
    if (! p->pPrior) {
      if (! (i < pTabList->nSrc)) {
        break;
      }
    } else {
      break;
    }
    pItem = & pTabList->a[i];
    pSub = pItem->pSelect;
    pTab = pItem->pTab;
    if (((int )pItem->fg.jointype & 8) != 0) {
      tmp___1 = sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor);
      if (tmp___1) {
        if (((int )db->dbOptFlags & 8192) == 0) {
          pItem->fg.jointype = (u8 )((int )pItem->fg.jointype & -41);
          unsetJoinExpr(p->pWhere, pItem->iCursor);
        }
      }
    }
    if ((unsigned long )pSub == (unsigned long )((Select *)0)) {
      goto __Cont;
    }
    if ((int )pTab->nCol != (pSub->pEList)->nExpr) {
      sqlite3ErrorMsg(pParse, "expected %d columns for \'%s\' but got %d", (int )pTab->nCol,
                      pTab->zName, (pSub->pEList)->nExpr);
      goto select_end;
    }
    if ((pSub->selFlags & 8U) != 0U) {
      goto __Cont;
    }
    if ((unsigned long )pSub->pOrderBy != (unsigned long )((ExprList *)0)) {
      if (i == 0) {
        if ((p->selFlags & 262144U) != 0U) {
          if (pTabList->nSrc == 1) {
            goto __Cont;
          } else
          if (((int )pTabList->a[1].fg.jointype & 10) != 0) {
            goto __Cont;
          }
        }
      }
    }
    tmp___2 = flattenSubquery(pParse, p, i, isAgg);
    if (tmp___2) {
      if (pParse->nErr) {
        goto select_end;
      }
      i = -1;
    }
    pTabList = p->pSrc;
    if (db->mallocFailed) {
      goto select_end;
    }
    if (! ((int )pDest->eDest <= 8)) {
      sSort.pOrderBy = p->pOrderBy;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (p->pPrior) {
    rc = multiSelect(pParse, p, pDest);
    if ((unsigned long )p->pNext == (unsigned long )((Select *)0)) {
      sqlite3VdbeExplainPop(pParse);
    }
    return (rc);
  }
  if (pTabList->nSrc > 1) {
    if (((int )db->dbOptFlags & 32768) == 0) {
      tmp___3 = propagateConstants(pParse, p);
      if (tmp___3) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  i = 0;
  while (i < pTabList->nSrc) {
    pItem___0 = & pTabList->a[i];
    if (pItem___0->colUsed == 0ULL) {
      if ((unsigned long )pItem___0->zName != (unsigned long )((char *)0)) {
        sqlite3AuthCheck(pParse, 20, (char const   *)pItem___0->zName, "", (char const   *)pItem___0->zDatabase);
      }
    }
    pSub___0 = pItem___0->pSelect;
    if ((unsigned long )pSub___0 == (unsigned long )((Select *)0)) {
      goto __Cont___0;
    }
    tmp___5 = sqlite3SelectExprHeight(p);
    pParse->nHeight += tmp___5;
    if (((int )db->dbOptFlags & 4096) == 0) {
      tmp___6 = pushDownWhereTerms(pParse, pSub___0, p->pWhere, pItem___0->iCursor,
                                   ((int )pItem___0->fg.jointype & 32) != 0);
      if (tmp___6) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    zSavedAuthContext = pParse->zAuthContext;
    pParse->zAuthContext = (char const   *)pItem___0->zName;
    if (i == 0) {
      if (pTabList->nSrc == 1) {
        goto _L___0;
      } else
      if (((int )pTabList->a[1].fg.jointype & 10) != 0) {
        _L___0: /* CIL Label */ 
        tmp___8 = sqlite3VdbeCurrentAddr(v);
        addrTop = tmp___8 + 1;
        (pParse->nMem) ++;
        pItem___0->regReturn = pParse->nMem;
        sqlite3VdbeAddOp3(v, 13, pItem___0->regReturn, 0, addrTop);
        pItem___0->addrFillSub = addrTop;
        sqlite3SelectDestInit(& dest, 13, pItem___0->regReturn);
        sqlite3VdbeExplain(pParse, (u8 )1, "CO-ROUTINE %u", pSub___0->selId);
        sqlite3Select(pParse, pSub___0, & dest);
        (pItem___0->pTab)->nRowLogEst = pSub___0->nSelectRow;
        pItem___0->fg.viaCoroutine = 1U;
        pItem___0->regResult = dest.iSdst;
        sqlite3VdbeEndCoroutine(v, pItem___0->regReturn);
        sqlite3VdbeJumpHere(v, addrTop - 1);
        sqlite3ClearTempRegCache(pParse);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      onceAddr = 0;
      (pParse->nMem) ++;
      pItem___0->regReturn = pParse->nMem;
      topAddr = sqlite3VdbeAddOp2(v, 70, 0, pItem___0->regReturn);
      pItem___0->addrFillSub = topAddr + 1;
      if (pItem___0->fg.isCorrelated == 0U) {
        onceAddr = sqlite3VdbeAddOp0(v, 17);
      }
      pPrior = isSelfJoinView(pTabList, pItem___0);
      if (pPrior) {
        sqlite3VdbeAddOp2(v, 109, pItem___0->iCursor, pPrior->iCursor);
        pSub___0->nSelectRow = (pPrior->pSelect)->nSelectRow;
      } else {
        sqlite3SelectDestInit(& dest, 12, pItem___0->iCursor);
        sqlite3VdbeExplain(pParse, (u8 )1, "MATERIALIZE %u", pSub___0->selId);
        sqlite3Select(pParse, pSub___0, & dest);
      }
      (pItem___0->pTab)->nRowLogEst = pSub___0->nSelectRow;
      if (onceAddr) {
        sqlite3VdbeJumpHere(v, onceAddr);
      }
      retAddr = sqlite3VdbeAddOp1(v, 66, pItem___0->regReturn);
      sqlite3VdbeChangeP1(v, topAddr, retAddr);
      sqlite3ClearTempRegCache(pParse);
    }
    if (db->mallocFailed) {
      goto select_end;
    }
    tmp___9 = sqlite3SelectExprHeight(p);
    pParse->nHeight -= tmp___9;
    pParse->zAuthContext = zSavedAuthContext;
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  pEList = p->pEList;
  pWhere = p->pWhere;
  pGroupBy = p->pGroupBy;
  pHaving = p->pHaving;
  sDistinct.isTnct = (u8 )((p->selFlags & 1U) != 0U);
  if ((p->selFlags & 9U) == 1U) {
    tmp___11 = sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1);
    if (tmp___11 == 0) {
      p->selFlags &= 4294967294U;
      tmp___10 = sqlite3ExprListDup(db, pEList, 0);
      p->pGroupBy = tmp___10;
      pGroupBy = tmp___10;
    }
  }
  if (sSort.pOrderBy) {
    pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, 0, pEList->nExpr);
    tmp___12 = pParse->nTab;
    (pParse->nTab) ++;
    sSort.iECursor = tmp___12;
    sSort.addrSortIndex = sqlite3VdbeAddOp4(v, 112, sSort.iECursor, ((sSort.pOrderBy)->nExpr + 1) + pEList->nExpr,
                                            0, (char const   *)((char *)pKeyInfo),
                                            -9);
  } else {
    sSort.addrSortIndex = -1;
  }
  if ((int )pDest->eDest == 12) {
    sqlite3VdbeAddOp2(v, 112, pDest->iSDParm, pEList->nExpr);
  }
  iEnd = sqlite3VdbeMakeLabel(pParse);
  if ((p->selFlags & 16384U) == 0U) {
    p->nSelectRow = (LogEst )320;
  }
  computeLimitRegisters(pParse, p, iEnd);
  if (p->iLimit == 0) {
    if (sSort.addrSortIndex >= 0) {
      sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, (u8 )114);
      sSort.sortFlags = (u8 )((int )sSort.sortFlags | 1);
    }
  }
  if (p->selFlags & 1U) {
    tmp___13 = pParse->nTab;
    (pParse->nTab) ++;
    sDistinct.tabTnct = tmp___13;
    tmp___14 = sqlite3KeyInfoFromExprList(pParse, p->pEList, 0, 0);
    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 112, sDistinct.tabTnct, 0, 0, (char const   *)((char *)tmp___14),
                                           -9);
    sqlite3VdbeChangeP5(v, (u16 )8);
    sDistinct.eTnctType = (u8 )3;
  } else {
    sDistinct.eTnctType = (u8 )0;
  }
  if (! isAgg) {
    if ((unsigned long )pGroupBy == (unsigned long )((ExprList *)0)) {
      if (sDistinct.isTnct) {
        tmp___15 = 256;
      } else {
        tmp___15 = 0;
      }
      wctrlFlags = (u16 )((unsigned int )tmp___15 | (p->selFlags & 16384U));
      pWin = p->pWin;
      if (pWin) {
        sqlite3WindowCodeInit(pParse, pWin);
      }
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p->pEList,
                                 wctrlFlags, (int )p->nSelectRow);
      if ((unsigned long )pWInfo == (unsigned long )((WhereInfo *)0)) {
        goto select_end;
      }
      tmp___16 = sqlite3WhereOutputRowCount(pWInfo);
      if ((int )tmp___16 < (int )p->nSelectRow) {
        p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);
      }
      if (sDistinct.isTnct) {
        tmp___18 = sqlite3WhereIsDistinct(pWInfo);
        if (tmp___18) {
          tmp___17 = sqlite3WhereIsDistinct(pWInfo);
          sDistinct.eTnctType = (u8 )tmp___17;
        }
      }
      if (sSort.pOrderBy) {
        sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);
        sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);
        if (sSort.nOBSat == (sSort.pOrderBy)->nExpr) {
          sSort.pOrderBy = (ExprList *)0;
        }
      }
      if (sSort.addrSortIndex >= 0) {
        if ((unsigned long )sSort.pOrderBy == (unsigned long )((ExprList *)0)) {
          sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
        }
      }
      if (pWin) {
        tmp___19 = sqlite3VdbeMakeLabel(pParse);
        addrGosub = tmp___19;
        tmp___20 = sqlite3VdbeMakeLabel(pParse);
        iCont = tmp___20;
        tmp___21 = sqlite3VdbeMakeLabel(pParse);
        iBreak = tmp___21;
        (pParse->nMem) ++;
        regGosub = pParse->nMem;
        sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);
        sqlite3VdbeAddOp2(v, 11, 0, iBreak);
        sqlite3VdbeResolveLabel(v, addrGosub);
        sSort.labelOBLopt = 0;
        selectInnerLoop(pParse, p, -1, & sSort, & sDistinct, pDest, iCont, iBreak);
        sqlite3VdbeResolveLabel(v, iCont);
        sqlite3VdbeAddOp1(v, 66, regGosub);
        sqlite3VdbeResolveLabel(v, iBreak);
      } else {
        tmp___22 = sqlite3WhereBreakLabel(pWInfo);
        tmp___23 = sqlite3WhereContinueLabel(pWInfo);
        selectInnerLoop(pParse, p, -1, & sSort, & sDistinct, pDest, tmp___23, tmp___22);
        sqlite3WhereEnd(pWInfo);
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    sortPTab = 0;
    sortOut = 0;
    orderByGrp = 0;
    if (pGroupBy) {
      k = (p->pEList)->nExpr;
      pItem___1 = (p->pEList)->a;
      while (k > 0) {
        pItem___1->u.x.iAlias = (u16 )0;
        k --;
        pItem___1 ++;
      }
      k = pGroupBy->nExpr;
      pItem___1 = pGroupBy->a;
      while (k > 0) {
        pItem___1->u.x.iAlias = (u16 )0;
        k --;
        pItem___1 ++;
      }
      if ((int )p->nSelectRow > 66) {
        p->nSelectRow = (LogEst )66;
      }
      if (sSort.pOrderBy) {
        if (pGroupBy->nExpr == (sSort.pOrderBy)->nExpr) {
          ii = 0;
          while (ii < pGroupBy->nExpr) {
            sortFlags = (u8 )((int )(sSort.pOrderBy)->a[ii].sortFlags & 1);
            pGroupBy->a[ii].sortFlags = sortFlags;
            ii ++;
          }
          tmp___24 = sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1);
          if (tmp___24 == 0) {
            orderByGrp = 1;
          }
        }
      }
    } else {
      p->nSelectRow = (LogEst )0;
    }
    addrEnd = sqlite3VdbeMakeLabel(pParse);
    memset((void *)(& sNC), 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    sNC.uNC.pAggInfo = & sAggInfo;
    sAggInfo.mnReg = pParse->nMem + 1;
    if (pGroupBy) {
      sAggInfo.nSortingColumn = pGroupBy->nExpr;
    } else {
      sAggInfo.nSortingColumn = 0;
    }
    sAggInfo.pGroupBy = pGroupBy;
    sqlite3ExprAnalyzeAggList(& sNC, pEList);
    sqlite3ExprAnalyzeAggList(& sNC, sSort.pOrderBy);
    if (pHaving) {
      if (pGroupBy) {
        havingToWhere(pParse, p);
        pWhere = p->pWhere;
      }
      sqlite3ExprAnalyzeAggregates(& sNC, pHaving);
    }
    sAggInfo.nAccumulator = sAggInfo.nColumn;
    if ((unsigned long )p->pGroupBy == (unsigned long )((ExprList *)0)) {
      if ((unsigned long )p->pHaving == (unsigned long )((Expr *)0)) {
        if (sAggInfo.nFunc == 1) {
          minMaxFlag = minMaxQuery(db, (sAggInfo.aFunc + 0)->pExpr, & pMinMaxOrderBy);
        } else {
          minMaxFlag = (u8 )0;
        }
      } else {
        minMaxFlag = (u8 )0;
      }
    } else {
      minMaxFlag = (u8 )0;
    }
    i = 0;
    while (i < sAggInfo.nFunc) {
      pExpr = (sAggInfo.aFunc + i)->pExpr;
      sNC.ncFlags |= 8;
      sqlite3ExprAnalyzeAggList(& sNC, pExpr->x.pList);
      if ((pExpr->flags & 16777216U) != 0U) {
        sqlite3ExprAnalyzeAggregates(& sNC, (pExpr->y.pWin)->pFilter);
      }
      sNC.ncFlags &= -9;
      i ++;
    }
    sAggInfo.mxReg = pParse->nMem;
    if (db->mallocFailed) {
      goto select_end;
    }
    if (pGroupBy) {
      tmp___25 = pParse->nTab;
      (pParse->nTab) ++;
      sAggInfo.sortingIdx = tmp___25;
      pKeyInfo___0 = sqlite3KeyInfoFromExprList(pParse, pGroupBy, 0, sAggInfo.nColumn);
      addrSortingIdx = sqlite3VdbeAddOp4(v, 114, sAggInfo.sortingIdx, sAggInfo.nSortingColumn,
                                         0, (char const   *)((char *)pKeyInfo___0),
                                         -9);
      (pParse->nMem) ++;
      iUseFlag = pParse->nMem;
      (pParse->nMem) ++;
      iAbortFlag = pParse->nMem;
      (pParse->nMem) ++;
      regOutputRow = pParse->nMem;
      addrOutputRow = sqlite3VdbeMakeLabel(pParse);
      (pParse->nMem) ++;
      regReset = pParse->nMem;
      addrReset = sqlite3VdbeMakeLabel(pParse);
      iAMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      iBMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      sqlite3VdbeAddOp2(v, 70, 0, iAbortFlag);
      sqlite3VdbeAddOp3(v, 73, 0, iAMem, (iAMem + pGroupBy->nExpr) - 1);
      sqlite3VdbeAddOp2(v, 12, regReset, addrReset);
      if (orderByGrp) {
        tmp___26 = 512;
      } else {
        tmp___26 = 0;
      }
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, (ExprList *)0,
                                 (u16 )(64 | tmp___26), 0);
      if ((unsigned long )pWInfo == (unsigned long )((WhereInfo *)0)) {
        goto select_end;
      }
      tmp___29 = sqlite3WhereIsOrdered(pWInfo);
      if (tmp___29 == pGroupBy->nExpr) {
        groupBySort = 0;
      } else {
        if (sDistinct.isTnct) {
          if ((p->selFlags & 1U) == 0U) {
            tmp___27 = "DISTINCT";
          } else {
            tmp___27 = "GROUP BY";
          }
        } else {
          tmp___27 = "GROUP BY";
        }
        explainTempTable(pParse, tmp___27);
        groupBySort = 1;
        nGroupBy = pGroupBy->nExpr;
        nCol = nGroupBy;
        j = nGroupBy;
        i = 0;
        while (i < sAggInfo.nColumn) {
          if ((sAggInfo.aCol + i)->iSorterColumn >= j) {
            nCol ++;
            j ++;
          }
          i ++;
        }
        regBase = sqlite3GetTempRange(pParse, nCol);
        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, (u8 )0);
        j = nGroupBy;
        i = 0;
        while (i < sAggInfo.nColumn) {
          pCol = sAggInfo.aCol + i;
          if (pCol->iSorterColumn >= j) {
            r1 = j + regBase;
            sqlite3ExprCodeGetColumnOfTable(v, pCol->pTab, pCol->iTable, pCol->iColumn,
                                            r1);
            j ++;
          }
          i ++;
        }
        regRecord = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 92, regBase, nCol, regRecord);
        sqlite3VdbeAddOp2(v, 131, sAggInfo.sortingIdx, regRecord);
        sqlite3ReleaseTempReg(pParse, regRecord);
        sqlite3ReleaseTempRange(pParse, regBase, nCol);
        sqlite3WhereEnd(pWInfo);
        tmp___28 = pParse->nTab;
        (pParse->nTab) ++;
        sortPTab = tmp___28;
        sAggInfo.sortingIdxPTab = sortPTab;
        sortOut = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 116, sortPTab, sortOut, nCol);
        sqlite3VdbeAddOp2(v, 34, sAggInfo.sortingIdx, addrEnd);
        sAggInfo.useSortingIdx = (u8 )1;
      }
      if (orderByGrp) {
        if (((int )db->dbOptFlags & 4) == 0) {
          if (groupBySort) {
            sSort.pOrderBy = (ExprList *)0;
            sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
          } else {
            tmp___30 = sqlite3WhereIsSorted(pWInfo);
            if (tmp___30) {
              sSort.pOrderBy = (ExprList *)0;
              sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
            }
          }
        }
      }
      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
      if (groupBySort) {
        sqlite3VdbeAddOp3(v, 126, sAggInfo.sortingIdx, sortOut, sortPTab);
      }
      j = 0;
      while (j < pGroupBy->nExpr) {
        if (groupBySort) {
          sqlite3VdbeAddOp3(v, 90, sortPTab, j, iBMem + j);
        } else {
          sAggInfo.directMode = (u8 )1;
          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem + j);
        }
        j ++;
      }
      tmp___31 = sqlite3KeyInfoRef(pKeyInfo___0);
      sqlite3VdbeAddOp4(v, 87, iAMem, iBMem, pGroupBy->nExpr, (char const   *)((char *)tmp___31),
                        -9);
      addr1 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp3(v, 16, addr1 + 1, 0, addr1 + 1);
      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
      sqlite3VdbeAddOp2(v, 12, regOutputRow, addrOutputRow);
      sqlite3VdbeAddOp2(v, 47, iAbortFlag, addrEnd);
      sqlite3VdbeAddOp2(v, 12, regReset, addrReset);
      sqlite3VdbeJumpHere(v, addr1);
      updateAccumulator(pParse, iUseFlag, & sAggInfo);
      sqlite3VdbeAddOp2(v, 70, 1, iUseFlag);
      if (groupBySort) {
        sqlite3VdbeAddOp2(v, 3, sAggInfo.sortingIdx, addrTopOfLoop);
      } else {
        sqlite3WhereEnd(pWInfo);
        sqlite3VdbeChangeToNoop(v, addrSortingIdx);
      }
      sqlite3VdbeAddOp2(v, 12, regOutputRow, addrOutputRow);
      sqlite3VdbeGoto(v, addrEnd);
      addrSetAbort = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 70, 1, iAbortFlag);
      sqlite3VdbeAddOp1(v, 66, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrOutputRow);
      addrOutputRow = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 47, iUseFlag, addrOutputRow + 2);
      sqlite3VdbeAddOp1(v, 66, regOutputRow);
      finalizeAggFunctions(pParse, & sAggInfo);
      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow + 1, 16);
      selectInnerLoop(pParse, p, -1, & sSort, & sDistinct, pDest, addrOutputRow + 1,
                      addrSetAbort);
      sqlite3VdbeAddOp1(v, 66, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrReset);
      resetAccumulator(pParse, & sAggInfo);
      sqlite3VdbeAddOp2(v, 70, 0, iUseFlag);
      sqlite3VdbeAddOp1(v, 66, regReset);
    } else {
      pTab___0 = isSimpleCount(p, & sAggInfo);
      if ((unsigned long )pTab___0 != (unsigned long )((Table *)0)) {
        tmp___32 = sqlite3SchemaToIndex(pParse->db, pTab___0->pSchema);
        iDb = tmp___32;
        tmp___33 = pParse->nTab;
        (pParse->nTab) ++;
        iCsr = tmp___33;
        pKeyInfo___1 = (KeyInfo *)0;
        pBest = (Index *)0;
        iRoot = pTab___0->tnum;
        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3TableLock(pParse, iDb, pTab___0->tnum, (u8 )0, (char const   *)pTab___0->zName);
        if (! ((pTab___0->tabFlags & 32U) == 0U)) {
          pBest = sqlite3PrimaryKeyIndex(pTab___0);
        }
        pIdx = pTab___0->pIndex;
        while (pIdx) {
          if (pIdx->bUnordered == 0U) {
            if ((int )pIdx->szIdxRow < (int )pTab___0->szTabRow) {
              if ((unsigned long )pIdx->pPartIdxWhere == (unsigned long )((Expr *)0)) {
                if (! pBest) {
                  pBest = pIdx;
                } else
                if ((int )pIdx->szIdxRow < (int )pBest->szIdxRow) {
                  pBest = pIdx;
                }
              }
            }
          }
          pIdx = pIdx->pNext;
        }
        if (pBest) {
          iRoot = pBest->tnum;
          pKeyInfo___1 = sqlite3KeyInfoOfIndex(pParse, pBest);
        }
        sqlite3VdbeAddOp4Int(v, 97, iCsr, iRoot, iDb, 1);
        if (pKeyInfo___1) {
          sqlite3VdbeChangeP4(v, -1, (char const   *)((char *)pKeyInfo___1), -9);
        }
        sqlite3VdbeAddOp2(v, 93, iCsr, (sAggInfo.aFunc + 0)->iMem);
        sqlite3VdbeAddOp1(v, 117, iCsr);
        explainSimpleCount(pParse, pTab___0, pBest);
      } else {
        regAcc = 0;
        if (sAggInfo.nAccumulator) {
          i = 0;
          while (i < sAggInfo.nFunc) {
            if ((((sAggInfo.aFunc + i)->pExpr)->flags & 16777216U) != 0U) {
              goto __Cont___1;
            }
            if (((sAggInfo.aFunc + i)->pFunc)->funcFlags & 32U) {
              break;
            }
            __Cont___1: /* CIL Label */ 
            i ++;
          }
          if (i == sAggInfo.nFunc) {
            (pParse->nMem) ++;
            regAcc = pParse->nMem;
            sqlite3VdbeAddOp2(v, 70, 0, regAcc);
          }
        }
        resetAccumulator(pParse, & sAggInfo);
        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, (ExprList *)0,
                                   (u16 )minMaxFlag, 0);
        if ((unsigned long )pWInfo == (unsigned long )((WhereInfo *)0)) {
          goto select_end;
        }
        updateAccumulator(pParse, regAcc, & sAggInfo);
        if (regAcc) {
          sqlite3VdbeAddOp2(v, 70, 1, regAcc);
        }
        tmp___35 = sqlite3WhereIsOrdered(pWInfo);
        if (tmp___35 > 0) {
          tmp___34 = sqlite3WhereBreakLabel(pWInfo);
          sqlite3VdbeGoto(v, tmp___34);
        }
        sqlite3WhereEnd(pWInfo);
        finalizeAggFunctions(pParse, & sAggInfo);
      }
      sSort.pOrderBy = (ExprList *)0;
      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 16);
      selectInnerLoop(pParse, p, -1, (SortCtx *)0, (DistinctCtx *)0, pDest, addrEnd,
                      addrEnd);
    }
    sqlite3VdbeResolveLabel(v, addrEnd);
  }
  if ((int )sDistinct.eTnctType == 3) {
    explainTempTable(pParse, "DISTINCT");
  }
  if (sSort.pOrderBy) {
    if (sSort.nOBSat > 0) {
      tmp___36 = "RIGHT PART OF ORDER BY";
    } else {
      tmp___36 = "ORDER BY";
    }
    explainTempTable(pParse, tmp___36);
    generateSortTail(pParse, p, & sSort, pEList->nExpr, pDest);
  }
  sqlite3VdbeResolveLabel(v, iEnd);
  rc = pParse->nErr > 0;
  select_end: 
  sqlite3ExprListDelete(db, pMinMaxOrderBy);
  sqlite3DbFree(db, (void *)sAggInfo.aCol);
  sqlite3DbFree(db, (void *)sAggInfo.aFunc);
  sqlite3VdbeExplainPop(pParse);
  return (rc);
}
}
static int sqlite3_get_table_cb(void *pArg , int nCol , char **argv , char **colv ) 
{ 
  TabResult *p ;
  int need ;
  int i ;
  char *z ;
  char **azNew ;
  void *tmp ;
  u32 tmp___0 ;
  int n ;
  int tmp___1 ;
  void *tmp___2 ;
  u32 tmp___3 ;

  {
  p = (TabResult *)pArg;
  if (p->nRow == 0U) {
    if ((unsigned long )argv != (unsigned long )((char **)0)) {
      need = nCol * 2;
    } else {
      need = nCol;
    }
  } else {
    need = nCol;
  }
  if (p->nData + (u32 )need > p->nAlloc) {
    p->nAlloc = p->nAlloc * 2U + (u32 )need;
    tmp = sqlite3_realloc64((void *)p->azResult, (sqlite_uint64 )(sizeof(char *) * (unsigned long )p->nAlloc));
    azNew = (char **)tmp;
    if ((unsigned long )azNew == (unsigned long )((char **)0)) {
      goto malloc_failed;
    }
    p->azResult = azNew;
  }
  if (p->nRow == 0U) {
    p->nColumn = (u32 )nCol;
    i = 0;
    while (i < nCol) {
      z = sqlite3_mprintf("%s", *(colv + i));
      if ((unsigned long )z == (unsigned long )((char *)0)) {
        goto malloc_failed;
      }
      tmp___0 = p->nData;
      (p->nData) ++;
      *(p->azResult + tmp___0) = z;
      i ++;
    }
  } else
  if ((int )p->nColumn != nCol) {
    sqlite3_free((void *)p->zErrMsg);
    p->zErrMsg = sqlite3_mprintf("sqlite3_get_table() called with two or more incompatible queries");
    p->rc = 1;
    return (1);
  }
  if ((unsigned long )argv != (unsigned long )((char **)0)) {
    i = 0;
    while (i < nCol) {
      if ((unsigned long )*(argv + i) == (unsigned long )((char *)0)) {
        z = (char *)0;
      } else {
        tmp___1 = sqlite3Strlen30((char const   *)*(argv + i));
        n = tmp___1 + 1;
        tmp___2 = sqlite3_malloc64((sqlite_uint64 )n);
        z = (char *)tmp___2;
        if ((unsigned long )z == (unsigned long )((char *)0)) {
          goto malloc_failed;
        }
        memcpy((void * __restrict  )z, (void const   * __restrict  )*(argv + i), (size_t )n);
      }
      tmp___3 = p->nData;
      (p->nData) ++;
      *(p->azResult + tmp___3) = z;
      i ++;
    }
    (p->nRow) ++;
  }
  return (0);
  malloc_failed: 
  p->rc = 7;
  return (1);
}
}
int sqlite3_get_table(sqlite3 *db , char const   *zSql , char ***pazResult , int *pnRow ,
                      int *pnColumn , char **pzErrMsg ) 
{ 
  int rc ;
  TabResult res ;
  void *tmp ;
  char **azNew ;
  void *tmp___0 ;

  {
  *pazResult = (char **)0;
  if (pnColumn) {
    *pnColumn = 0;
  }
  if (pnRow) {
    *pnRow = 0;
  }
  if (pzErrMsg) {
    *pzErrMsg = (char *)0;
  }
  res.zErrMsg = (char *)0;
  res.nRow = (u32 )0;
  res.nColumn = (u32 )0;
  res.nData = (u32 )1;
  res.nAlloc = (u32 )20;
  res.rc = 0;
  tmp = sqlite3_malloc64((sqlite_uint64 )(sizeof(char *) * (unsigned long )res.nAlloc));
  res.azResult = (char **)tmp;
  if ((unsigned long )res.azResult == (unsigned long )((char **)0)) {
    db->errCode = 7;
    return (7);
  }
  *(res.azResult + 0) = (char *)0;
  rc = sqlite3_exec(db, zSql, & sqlite3_get_table_cb, (void *)(& res), pzErrMsg);
  *(res.azResult + 0) = (char *)((void *)((long )res.nData));
  if ((rc & 255) == 4) {
    sqlite3_free_table(res.azResult + 1);
    if (res.zErrMsg) {
      if (pzErrMsg) {
        sqlite3_free((void *)*pzErrMsg);
        *pzErrMsg = sqlite3_mprintf("%s", res.zErrMsg);
      }
      sqlite3_free((void *)res.zErrMsg);
    }
    db->errCode = res.rc;
    return (res.rc);
  }
  sqlite3_free((void *)res.zErrMsg);
  if (rc != 0) {
    sqlite3_free_table(res.azResult + 1);
    return (rc);
  }
  if (res.nAlloc > res.nData) {
    tmp___0 = sqlite3_realloc64((void *)res.azResult, (sqlite_uint64 )(sizeof(char *) * (unsigned long )res.nData));
    azNew = (char **)tmp___0;
    if ((unsigned long )azNew == (unsigned long )((char **)0)) {
      sqlite3_free_table(res.azResult + 1);
      db->errCode = 7;
      return (7);
    }
    res.azResult = azNew;
  }
  *pazResult = res.azResult + 1;
  if (pnColumn) {
    *pnColumn = (int )res.nColumn;
  }
  if (pnRow) {
    *pnRow = (int )res.nRow;
  }
  return (rc);
}
}
void sqlite3_free_table(char **azResult ) 
{ 
  int i ;
  int n ;

  {
  if (azResult) {
    azResult --;
    n = (int )((long )*(azResult + 0));
    i = 1;
    while (i < n) {
      if (*(azResult + i)) {
        sqlite3_free((void *)*(azResult + i));
      }
      i ++;
    }
    sqlite3_free((void *)azResult);
  }
  return;
}
}
static void sqlite3DeleteTriggerStep(sqlite3 *db , TriggerStep *pTriggerStep ) 
{ 
  TriggerStep *pTmp ;

  {
  while (pTriggerStep) {
    pTmp = pTriggerStep;
    pTriggerStep = pTriggerStep->pNext;
    sqlite3ExprDelete(db, pTmp->pWhere);
    sqlite3ExprListDelete(db, pTmp->pExprList);
    sqlite3SelectDelete(db, pTmp->pSelect);
    sqlite3IdListDelete(db, pTmp->pIdList);
    sqlite3UpsertDelete(db, pTmp->pUpsert);
    sqlite3DbFree(db, (void *)pTmp->zSpan);
    sqlite3DbFree(db, (void *)pTmp);
  }
  return;
}
}
static Trigger *sqlite3TriggerList(Parse *pParse , Table *pTab ) 
{ 
  Schema *pTmpSchema ;
  Trigger *pList ;
  HashElem *p ;
  Trigger *pTrig ;
  int tmp ;
  Trigger *tmp___0 ;

  {
  pTmpSchema = ((pParse->db)->aDb + 1)->pSchema;
  pList = (Trigger *)0;
  if (pParse->disableTriggers) {
    return ((Trigger *)0);
  }
  if ((unsigned long )pTmpSchema != (unsigned long )pTab->pSchema) {
    p = pTmpSchema->trigHash.first;
    while (p) {
      pTrig = (Trigger *)p->data;
      if ((unsigned long )pTrig->pTabSchema == (unsigned long )pTab->pSchema) {
        tmp = sqlite3StrICmp((char const   *)pTrig->table, (char const   *)pTab->zName);
        if (0 == tmp) {
          if (pList) {
            pTrig->pNext = pList;
          } else {
            pTrig->pNext = pTab->pTrigger;
          }
          pList = pTrig;
        }
      }
      p = p->next;
    }
  }
  if (pList) {
    tmp___0 = pList;
  } else {
    tmp___0 = pTab->pTrigger;
  }
  return (tmp___0);
}
}
static void sqlite3BeginTrigger(Parse *pParse , Token *pName1 , Token *pName2 , int tr_tm ,
                                int op , IdList *pColumns , SrcList *pTableName ,
                                Expr *pWhen , int isTemp , int noErr ) 
{ 
  Trigger *pTrigger ;
  Table *pTab ;
  char *zName ;
  sqlite3 *db ;
  int iDb ;
  Token *pName ;
  DbFixer sFix ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int iTabDb ;
  int tmp___4 ;
  int code ;
  char const   *zDb ;
  char const   *zDbTrig ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
  pTrigger = (Trigger *)0;
  zName = (char *)0;
  db = pParse->db;
  if (isTemp) {
    if (pName2->n > 0U) {
      sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
      goto trigger_cleanup;
    }
    iDb = 1;
    pName = pName1;
  } else {
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, & pName);
    if (iDb < 0) {
      goto trigger_cleanup;
    }
  }
  if (! pTableName) {
    goto trigger_cleanup;
  } else
  if (db->mallocFailed) {
    goto trigger_cleanup;
  }
  if (db->init.busy) {
    if (iDb != 1) {
      sqlite3DbFree(db, (void *)pTableName->a[0].zDatabase);
      pTableName->a[0].zDatabase = (char *)0;
    }
  }
  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if ((int )db->init.busy == 0) {
    if (pName2->n == 0U) {
      if (pTab) {
        if ((unsigned long )pTab->pSchema == (unsigned long )(db->aDb + 1)->pSchema) {
          iDb = 1;
        }
      }
    }
  }
  if (db->mallocFailed) {
    goto trigger_cleanup;
  }
  sqlite3FixInit(& sFix, pParse, iDb, "trigger", (Token const   *)pName);
  tmp = sqlite3FixSrcList(& sFix, pTableName);
  if (tmp) {
    goto trigger_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if (! pTab) {
    if ((int )db->init.iDb == 1) {
      db->init.orphanTrigger = 1U;
    }
    goto trigger_cleanup;
  }
  if (pTab->nModuleArg) {
    sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
    goto trigger_cleanup;
  }
  zName = sqlite3NameFromToken(db, pName);
  if ((unsigned long )zName == (unsigned long )((char *)0)) {
    goto trigger_cleanup;
  }
  tmp___0 = sqlite3CheckObjectName(pParse, (char const   *)zName, "trigger", (char const   *)pTab->zName);
  if (tmp___0) {
    goto trigger_cleanup;
  }
  if (! ((int )pParse->eParseMode >= 2)) {
    tmp___1 = sqlite3HashFind((Hash const   *)(& ((db->aDb + iDb)->pSchema)->trigHash),
                              (char const   *)zName);
    if (tmp___1) {
      if (! noErr) {
        sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
      } else {
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto trigger_cleanup;
    }
  }
  tmp___2 = sqlite3_strnicmp((char const   *)pTab->zName, "sqlite_", 7);
  if (tmp___2 == 0) {
    sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
    goto trigger_cleanup;
  }
  if (pTab->pSelect) {
    if (tr_tm != 65) {
      if (tr_tm == 33) {
        tmp___3 = "BEFORE";
      } else {
        tmp___3 = "AFTER";
      }
      sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", tmp___3, pTableName,
                      0);
      goto trigger_cleanup;
    }
  }
  if (! pTab->pSelect) {
    if (tr_tm == 65) {
      sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF trigger on table: %S", pTableName,
                      0);
      goto trigger_cleanup;
    }
  }
  if (! ((int )pParse->eParseMode >= 2)) {
    tmp___4 = sqlite3SchemaToIndex(db, pTab->pSchema);
    iTabDb = tmp___4;
    code = 7;
    zDb = (char const   *)(db->aDb + iTabDb)->zDbSName;
    if (isTemp) {
      tmp___5 = (char const   *)(db->aDb + 1)->zDbSName;
    } else {
      tmp___5 = zDb;
    }
    zDbTrig = tmp___5;
    if (iTabDb == 1) {
      code = 5;
    } else
    if (isTemp) {
      code = 5;
    }
    tmp___6 = sqlite3AuthCheck(pParse, code, (char const   *)zName, (char const   *)pTab->zName,
                               zDbTrig);
    if (tmp___6) {
      goto trigger_cleanup;
    }
    if (iTabDb == 1) {
      tmp___7 = "sqlite_temp_master";
    } else {
      tmp___7 = "sqlite_master";
    }
    tmp___8 = sqlite3AuthCheck(pParse, 18, tmp___7, (char const   *)0, zDb);
    if (tmp___8) {
      goto trigger_cleanup;
    }
  }
  if (tr_tm == 65) {
    tr_tm = 33;
  }
  tmp___9 = sqlite3DbMallocZero(db, (u64 )sizeof(Trigger ));
  pTrigger = (Trigger *)tmp___9;
  if ((unsigned long )pTrigger == (unsigned long )((Trigger *)0)) {
    goto trigger_cleanup;
  }
  pTrigger->zName = zName;
  zName = (char *)0;
  pTrigger->table = sqlite3DbStrDup(db, (char const   *)pTableName->a[0].zName);
  pTrigger->pSchema = (db->aDb + iDb)->pSchema;
  pTrigger->pTabSchema = pTab->pSchema;
  pTrigger->op = (u8 )op;
  if (tr_tm == 33) {
    pTrigger->tr_tm = (u8 )1;
  } else {
    pTrigger->tr_tm = (u8 )2;
  }
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameTokenRemap(pParse, (void *)pTrigger->table, (void *)pTableName->a[0].zName);
    pTrigger->pWhen = pWhen;
    pWhen = (Expr *)0;
  } else {
    pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 1);
  }
  pTrigger->pColumns = pColumns;
  pColumns = (IdList *)0;
  pParse->pNewTrigger = pTrigger;
  trigger_cleanup: 
  sqlite3DbFree(db, (void *)zName);
  sqlite3SrcListDelete(db, pTableName);
  sqlite3IdListDelete(db, pColumns);
  sqlite3ExprDelete(db, pWhen);
  if (! pParse->pNewTrigger) {
    sqlite3DeleteTrigger(db, pTrigger);
  }
  return;
}
}
static void sqlite3FinishTrigger(Parse *pParse , TriggerStep *pStepList , Token *pAll ) 
{ 
  Trigger *pTrig ;
  char *zName ;
  sqlite3 *db ;
  DbFixer sFix ;
  int iDb ;
  Token nameToken ;
  int tmp ;
  int tmp___0 ;
  Vdbe *v ;
  char *z ;
  char *tmp___1 ;
  Trigger *pLink ;
  Hash *pHash ;
  void *tmp___2 ;
  Table *pTab ;
  void *tmp___3 ;

  {
  pTrig = pParse->pNewTrigger;
  db = pParse->db;
  pParse->pNewTrigger = (Trigger *)0;
  if (pParse->nErr) {
    goto triggerfinish_cleanup;
  } else
  if (! pTrig) {
    goto triggerfinish_cleanup;
  }
  zName = pTrig->zName;
  iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
  pTrig->step_list = pStepList;
  while (pStepList) {
    pStepList->pTrig = pTrig;
    pStepList = pStepList->pNext;
  }
  sqlite3TokenInit(& nameToken, pTrig->zName);
  sqlite3FixInit(& sFix, pParse, iDb, "trigger", (Token const   *)(& nameToken));
  tmp = sqlite3FixTriggerStep(& sFix, pTrig->step_list);
  if (tmp) {
    goto triggerfinish_cleanup;
  } else {
    tmp___0 = sqlite3FixExpr(& sFix, pTrig->pWhen);
    if (tmp___0) {
      goto triggerfinish_cleanup;
    }
  }
  if ((int )pParse->eParseMode >= 2) {
    pParse->pNewTrigger = pTrig;
    pTrig = (Trigger *)0;
  } else
  if (! db->init.busy) {
    v = sqlite3GetVdbe(pParse);
    if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
      goto triggerfinish_cleanup;
    }
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    z = sqlite3DbStrNDup(db, (char const   *)((char *)pAll->z), (u64 )pAll->n);
    sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES(\'trigger\',%Q,%Q,0,\'CREATE TRIGGER %q\')",
                       (db->aDb + iDb)->zDbSName, "sqlite_master", zName, pTrig->table,
                       z);
    sqlite3DbFree(db, (void *)z);
    sqlite3ChangeCookie(pParse, iDb);
    tmp___1 = sqlite3MPrintf(db, "type=\'trigger\' AND name=\'%q\'", zName);
    sqlite3VdbeAddParseSchemaOp(v, iDb, tmp___1);
  }
  if (db->init.busy) {
    pLink = pTrig;
    pHash = & ((db->aDb + iDb)->pSchema)->trigHash;
    tmp___2 = sqlite3HashInsert(pHash, (char const   *)zName, (void *)pTrig);
    pTrig = (Trigger *)tmp___2;
    if (pTrig) {
      sqlite3OomFault(db);
    } else
    if ((unsigned long )pLink->pSchema == (unsigned long )pLink->pTabSchema) {
      tmp___3 = sqlite3HashFind((Hash const   *)(& (pLink->pTabSchema)->tblHash),
                                (char const   *)pLink->table);
      pTab = (Table *)tmp___3;
      pLink->pNext = pTab->pTrigger;
      pTab->pTrigger = pLink;
    }
  }
  triggerfinish_cleanup: 
  sqlite3DeleteTrigger(db, pTrig);
  sqlite3DeleteTriggerStep(db, pStepList);
  return;
}
}
static char *triggerSpanDup(sqlite3 *db , char const   *zStart , char const   *zEnd ) 
{ 
  char *z ;
  char *tmp ;
  int i ;

  {
  tmp = sqlite3DbSpanDup(db, zStart, zEnd);
  z = tmp;
  if (z) {
    i = 0;
    while (*(z + i)) {
      if ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 1) {
        *(z + i) = (char )' ';
      }
      i ++;
    }
  }
  return (z);
}
}
static TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db , Select *pSelect , char const   *zStart ,
                                             char const   *zEnd ) 
{ 
  TriggerStep *pTriggerStep ;
  void *tmp ;

  {
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(TriggerStep ));
  pTriggerStep = (TriggerStep *)tmp;
  if ((unsigned long )pTriggerStep == (unsigned long )((TriggerStep *)0)) {
    sqlite3SelectDelete(db, pSelect);
    return ((TriggerStep *)0);
  }
  pTriggerStep->op = (u8 )134;
  pTriggerStep->pSelect = pSelect;
  pTriggerStep->orconf = (u8 )11;
  pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);
  return (pTriggerStep);
}
}
static TriggerStep *triggerStepAllocate(Parse *pParse , u8 op , Token *pName , char const   *zStart ,
                                        char const   *zEnd ) 
{ 
  sqlite3 *db ;
  TriggerStep *pTriggerStep ;
  void *tmp ;
  char *z ;

  {
  db = pParse->db;
  tmp = sqlite3DbMallocZero(db, (u64 )((sizeof(TriggerStep ) + (unsigned long )pName->n) + 1UL));
  pTriggerStep = (TriggerStep *)tmp;
  if (pTriggerStep) {
    z = (char *)(pTriggerStep + 1);
    memcpy((void * __restrict  )z, (void const   * __restrict  )pName->z, (size_t )pName->n);
    sqlite3Dequote(z);
    pTriggerStep->zTarget = z;
    pTriggerStep->op = op;
    pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameTokenMap(pParse, (void *)pTriggerStep->zTarget, pName);
    }
  }
  return (pTriggerStep);
}
}
static TriggerStep *sqlite3TriggerInsertStep(Parse *pParse , Token *pTableName , IdList *pColumn ,
                                             Select *pSelect , u8 orconf , Upsert *pUpsert ,
                                             char const   *zStart , char const   *zEnd ) 
{ 
  sqlite3 *db ;
  TriggerStep *pTriggerStep ;

  {
  db = pParse->db;
  pTriggerStep = triggerStepAllocate(pParse, (u8 )123, pTableName, zStart, zEnd);
  if (pTriggerStep) {
    if ((int )pParse->eParseMode >= 2) {
      pTriggerStep->pSelect = pSelect;
      pSelect = (Select *)0;
    } else {
      pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, 1);
    }
    pTriggerStep->pIdList = pColumn;
    pTriggerStep->pUpsert = pUpsert;
    pTriggerStep->orconf = orconf;
    if (pUpsert) {
      sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget);
    }
  } else {
    sqlite3IdListDelete(db, pColumn);
    sqlite3UpsertDelete(db, pUpsert);
  }
  sqlite3SelectDelete(db, pSelect);
  return (pTriggerStep);
}
}
static TriggerStep *sqlite3TriggerUpdateStep(Parse *pParse , Token *pTableName , ExprList *pEList ,
                                             Expr *pWhere , u8 orconf , char const   *zStart ,
                                             char const   *zEnd ) 
{ 
  sqlite3 *db ;
  TriggerStep *pTriggerStep ;

  {
  db = pParse->db;
  pTriggerStep = triggerStepAllocate(pParse, (u8 )125, pTableName, zStart, zEnd);
  if (pTriggerStep) {
    if ((int )pParse->eParseMode >= 2) {
      pTriggerStep->pExprList = pEList;
      pTriggerStep->pWhere = pWhere;
      pEList = (ExprList *)0;
      pWhere = (Expr *)0;
    } else {
      pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 1);
      pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 1);
    }
    pTriggerStep->orconf = orconf;
  }
  sqlite3ExprListDelete(db, pEList);
  sqlite3ExprDelete(db, pWhere);
  return (pTriggerStep);
}
}
static TriggerStep *sqlite3TriggerDeleteStep(Parse *pParse , Token *pTableName , Expr *pWhere ,
                                             char const   *zStart , char const   *zEnd ) 
{ 
  sqlite3 *db ;
  TriggerStep *pTriggerStep ;

  {
  db = pParse->db;
  pTriggerStep = triggerStepAllocate(pParse, (u8 )124, pTableName, zStart, zEnd);
  if (pTriggerStep) {
    if ((int )pParse->eParseMode >= 2) {
      pTriggerStep->pWhere = pWhere;
      pWhere = (Expr *)0;
    } else {
      pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 1);
    }
    pTriggerStep->orconf = (u8 )11;
  }
  sqlite3ExprDelete(db, pWhere);
  return (pTriggerStep);
}
}
static void sqlite3DeleteTrigger(sqlite3 *db , Trigger *pTrigger ) 
{ 


  {
  if ((unsigned long )pTrigger == (unsigned long )((Trigger *)0)) {
    return;
  }
  sqlite3DeleteTriggerStep(db, pTrigger->step_list);
  sqlite3DbFree(db, (void *)pTrigger->zName);
  sqlite3DbFree(db, (void *)pTrigger->table);
  sqlite3ExprDelete(db, pTrigger->pWhen);
  sqlite3IdListDelete(db, pTrigger->pColumns);
  sqlite3DbFree(db, (void *)pTrigger);
  return;
}
}
static void sqlite3DropTrigger(Parse *pParse , SrcList *pName , int noErr ) 
{ 
  Trigger *pTrigger ;
  int i ;
  char const   *zDb ;
  char const   *zName ;
  sqlite3 *db ;
  int tmp ;
  int j ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  pTrigger = (Trigger *)0;
  db = pParse->db;
  if (db->mallocFailed) {
    goto drop_trigger_cleanup;
  }
  tmp = sqlite3ReadSchema(pParse);
  if (0 != tmp) {
    goto drop_trigger_cleanup;
  }
  zDb = (char const   *)pName->a[0].zDatabase;
  zName = (char const   *)pName->a[0].zName;
  i = 0;
  while (i < db->nDb) {
    if (i < 2) {
      tmp___0 = i ^ 1;
    } else {
      tmp___0 = i;
    }
    j = tmp___0;
    if (zDb) {
      tmp___1 = sqlite3StrICmp((char const   *)(db->aDb + j)->zDbSName, zDb);
      if (tmp___1) {
        goto __Cont;
      }
    }
    tmp___2 = sqlite3HashFind((Hash const   *)(& ((db->aDb + j)->pSchema)->trigHash),
                              zName);
    pTrigger = (Trigger *)tmp___2;
    if (pTrigger) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! pTrigger) {
    if (! noErr) {
      sqlite3ErrorMsg(pParse, "no such trigger: %S", pName, 0);
    } else {
      sqlite3CodeVerifyNamedSchema(pParse, zDb);
    }
    pParse->checkSchema = (u8 )1;
    goto drop_trigger_cleanup;
  }
  sqlite3DropTriggerPtr(pParse, pTrigger);
  drop_trigger_cleanup: 
  sqlite3SrcListDelete(db, pName);
  return;
}
}
static Table *tableOfTrigger(Trigger *pTrigger ) 
{ 
  void *tmp ;

  {
  tmp = sqlite3HashFind((Hash const   *)(& (pTrigger->pTabSchema)->tblHash), (char const   *)pTrigger->table);
  return ((Table *)tmp);
}
}
static void sqlite3DropTriggerPtr(Parse *pParse , Trigger *pTrigger ) 
{ 
  Table *pTable ;
  Vdbe *v ;
  sqlite3 *db ;
  int iDb ;
  int code ;
  char const   *zDb ;
  char const   *zTab ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  db = pParse->db;
  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
  pTable = tableOfTrigger(pTrigger);
  if (pTable) {
    code = 16;
    zDb = (char const   *)(db->aDb + iDb)->zDbSName;
    if (iDb == 1) {
      tmp = "sqlite_temp_master";
    } else {
      tmp = "sqlite_master";
    }
    zTab = tmp;
    if (iDb == 1) {
      code = 14;
    }
    tmp___0 = sqlite3AuthCheck(pParse, code, (char const   *)pTrigger->zName, (char const   *)pTable->zName,
                               zDb);
    if (tmp___0) {
      return;
    } else {
      tmp___1 = sqlite3AuthCheck(pParse, 9, zTab, (char const   *)0, zDb);
      if (tmp___1) {
        return;
      }
    }
  }
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v != (unsigned long )((Vdbe *)0)) {
    sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE name=%Q AND type=\'trigger\'",
                       (db->aDb + iDb)->zDbSName, "sqlite_master", pTrigger->zName);
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp4(v, 145, iDb, 0, 0, (char const   *)pTrigger->zName, 0);
  }
  return;
}
}
static void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db , int iDb , char const   *zName ) 
{ 
  Trigger *pTrigger ;
  Hash *pHash ;
  void *tmp ;
  Table *pTab ;
  Table *tmp___0 ;
  Trigger **pp ;

  {
  pHash = & ((db->aDb + iDb)->pSchema)->trigHash;
  tmp = sqlite3HashInsert(pHash, zName, (void *)0);
  pTrigger = (Trigger *)tmp;
  if (pTrigger) {
    if ((unsigned long )pTrigger->pSchema == (unsigned long )pTrigger->pTabSchema) {
      tmp___0 = tableOfTrigger(pTrigger);
      pTab = tmp___0;
      if (pTab) {
        pp = & pTab->pTrigger;
        while ((unsigned long )*pp != (unsigned long )pTrigger) {
          pp = & (*pp)->pNext;
        }
        *pp = (*pp)->pNext;
      }
    }
    sqlite3DeleteTrigger(db, pTrigger);
    db->mDbFlags |= 1U;
  }
  return;
}
}
static int checkColumnOverlap(IdList *pIdList , ExprList *pEList ) 
{ 
  int e ;
  int tmp ;

  {
  if ((unsigned long )pIdList == (unsigned long )((IdList *)0)) {
    return (1);
  } else
  if ((unsigned long )pEList == (unsigned long )((ExprList *)0)) {
    return (1);
  }
  e = 0;
  while (e < pEList->nExpr) {
    tmp = sqlite3IdListIndex(pIdList, (char const   *)pEList->a[e].zName);
    if (tmp >= 0) {
      return (1);
    }
    e ++;
  }
  return (0);
}
}
static Trigger *sqlite3TriggersExist(Parse *pParse , Table *pTab , int op , ExprList *pChanges ,
                                     int *pMask ) 
{ 
  int mask ;
  Trigger *pList ;
  Trigger *p ;
  int tmp ;
  Trigger *tmp___0 ;

  {
  mask = 0;
  pList = (Trigger *)0;
  if (((pParse->db)->flags & 262144ULL) != 0ULL) {
    pList = sqlite3TriggerList(pParse, pTab);
  }
  p = pList;
  while (p) {
    if ((int )p->op == op) {
      tmp = checkColumnOverlap(p->pColumns, pChanges);
      if (tmp) {
        mask |= (int )p->tr_tm;
      }
    }
    p = p->pNext;
  }
  if (pMask) {
    *pMask = mask;
  }
  if (mask) {
    tmp___0 = pList;
  } else {
    tmp___0 = (Trigger *)0;
  }
  return (tmp___0);
}
}
static SrcList *targetSrcList(Parse *pParse , TriggerStep *pStep ) 
{ 
  sqlite3 *db ;
  int iDb ;
  SrcList *pSrc ;
  char const   *zDb ;

  {
  db = pParse->db;
  pSrc = sqlite3SrcListAppend(pParse, (SrcList *)0, (Token *)0, (Token *)0);
  if (pSrc) {
    pSrc->a[pSrc->nSrc - 1].zName = sqlite3DbStrDup(db, (char const   *)pStep->zTarget);
    iDb = sqlite3SchemaToIndex(db, (pStep->pTrig)->pSchema);
    if (iDb == 0) {
      zDb = (char const   *)(db->aDb + iDb)->zDbSName;
      pSrc->a[pSrc->nSrc - 1].zDatabase = sqlite3DbStrDup(db, zDb);
    } else
    if (iDb >= 2) {
      zDb = (char const   *)(db->aDb + iDb)->zDbSName;
      pSrc->a[pSrc->nSrc - 1].zDatabase = sqlite3DbStrDup(db, zDb);
    }
  }
  return (pSrc);
}
}
static int codeTriggerProgram(Parse *pParse , TriggerStep *pStepList , int orconf ) 
{ 
  TriggerStep *pStep ;
  Vdbe *v ;
  sqlite3 *db ;
  char *tmp ;
  Expr *tmp___0 ;
  ExprList *tmp___1 ;
  SrcList *tmp___2 ;
  Upsert *tmp___3 ;
  IdList *tmp___4 ;
  Select *tmp___5 ;
  SrcList *tmp___6 ;
  Expr *tmp___7 ;
  SrcList *tmp___8 ;
  SelectDest sDest ;
  Select *pSelect ;
  Select *tmp___9 ;

  {
  v = pParse->pVdbe;
  db = pParse->db;
  pStep = pStepList;
  while (pStep) {
    if (orconf == 11) {
      pParse->eOrconf = pStep->orconf;
    } else {
      pParse->eOrconf = (u8 )orconf;
    }
    if (pStep->zSpan) {
      tmp = sqlite3MPrintf(db, "-- %s", pStep->zSpan);
      sqlite3VdbeAddOp4(v, 168, 2147483647, 1, 0, (char const   *)tmp, -7);
    }
    switch ((int )pStep->op) {
    case 125: 
    tmp___0 = sqlite3ExprDup(db, pStep->pWhere, 0);
    tmp___1 = sqlite3ExprListDup(db, pStep->pExprList, 0);
    tmp___2 = targetSrcList(pParse, pStep);
    sqlite3Update(pParse, tmp___2, tmp___1, tmp___0, (int )pParse->eOrconf, (ExprList *)0,
                  (Expr *)0, (Upsert *)0);
    break;
    case 123: 
    tmp___3 = sqlite3UpsertDup(db, pStep->pUpsert);
    tmp___4 = sqlite3IdListDup(db, pStep->pIdList);
    tmp___5 = sqlite3SelectDup(db, pStep->pSelect, 0);
    tmp___6 = targetSrcList(pParse, pStep);
    sqlite3Insert(pParse, tmp___6, tmp___5, tmp___4, (int )pParse->eOrconf, tmp___3);
    break;
    case 124: 
    tmp___7 = sqlite3ExprDup(db, pStep->pWhere, 0);
    tmp___8 = targetSrcList(pParse, pStep);
    sqlite3DeleteFrom(pParse, tmp___8, tmp___7, (ExprList *)0, (Expr *)0);
    break;
    default: 
    tmp___9 = sqlite3SelectDup(db, pStep->pSelect, 0);
    pSelect = tmp___9;
    sqlite3SelectDestInit(& sDest, 4, 0);
    sqlite3Select(pParse, pSelect, & sDest);
    sqlite3SelectDelete(db, pSelect);
    break;
    }
    if ((int )pStep->op != 134) {
      sqlite3VdbeAddOp0(v, 124);
    }
    pStep = pStep->pNext;
  }
  return (0);
}
}
static void transferParseError(Parse *pTo , Parse *pFrom ) 
{ 


  {
  if (pTo->nErr == 0) {
    pTo->zErrMsg = pFrom->zErrMsg;
    pTo->nErr = pFrom->nErr;
    pTo->rc = pFrom->rc;
  } else {
    sqlite3DbFree(pFrom->db, (void *)pFrom->zErrMsg);
  }
  return;
}
}
static TriggerPrg *codeRowTrigger(Parse *pParse , Trigger *pTrigger , Table *pTab ,
                                  int orconf ) 
{ 
  Parse *pTop ;
  Parse *tmp ;
  sqlite3 *db ;
  TriggerPrg *pPrg ;
  Expr *pWhen ;
  Vdbe *v ;
  NameContext sNC ;
  SubProgram *pProgram ;
  Parse *pSubParse ;
  int iEndTrigger ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pTop = tmp;
  db = pParse->db;
  pWhen = (Expr *)0;
  pProgram = (SubProgram *)0;
  iEndTrigger = 0;
  tmp___0 = sqlite3DbMallocZero(db, (u64 )sizeof(TriggerPrg ));
  pPrg = (TriggerPrg *)tmp___0;
  if (! pPrg) {
    return ((TriggerPrg *)0);
  }
  pPrg->pNext = pTop->pTriggerPrg;
  pTop->pTriggerPrg = pPrg;
  tmp___1 = sqlite3DbMallocZero(db, (u64 )sizeof(SubProgram ));
  pProgram = (SubProgram *)tmp___1;
  pPrg->pProgram = pProgram;
  if (! pProgram) {
    return ((TriggerPrg *)0);
  }
  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);
  pPrg->pTrigger = pTrigger;
  pPrg->orconf = orconf;
  pPrg->aColmask[0] = 4294967295U;
  pPrg->aColmask[1] = 4294967295U;
  tmp___2 = sqlite3DbMallocZero(db, (u64 )sizeof(Parse ));
  pSubParse = (Parse *)tmp___2;
  if (! pSubParse) {
    return ((TriggerPrg *)0);
  }
  memset((void *)(& sNC), 0, sizeof(sNC));
  sNC.pParse = pSubParse;
  pSubParse->db = db;
  pSubParse->pTriggerTab = pTab;
  pSubParse->pToplevel = pTop;
  pSubParse->zAuthContext = (char const   *)pTrigger->zName;
  pSubParse->eTriggerOp = pTrigger->op;
  pSubParse->nQueryLoop = pParse->nQueryLoop;
  pSubParse->disableVtab = pParse->disableVtab;
  v = sqlite3GetVdbe(pSubParse);
  if (v) {
    if (pTrigger->zName) {
      tmp___3 = sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName);
      sqlite3VdbeChangeP4(v, -1, (char const   *)tmp___3, -7);
    }
    if (pTrigger->pWhen) {
      pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);
      tmp___4 = sqlite3ResolveExprNames(& sNC, pWhen);
      if (0 == tmp___4) {
        if ((int )db->mallocFailed == 0) {
          iEndTrigger = sqlite3VdbeMakeLabel(pSubParse);
          sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, 16);
        }
      }
      sqlite3ExprDelete(db, pWhen);
    }
    codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);
    if (iEndTrigger) {
      sqlite3VdbeResolveLabel(v, iEndTrigger);
    }
    sqlite3VdbeAddOp0(v, 69);
    transferParseError(pParse, pSubParse);
    if ((int )db->mallocFailed == 0) {
      if (pParse->nErr == 0) {
        pProgram->aOp = sqlite3VdbeTakeOpArray(v, & pProgram->nOp, & pTop->nMaxArg);
      }
    }
    pProgram->nMem = pSubParse->nMem;
    pProgram->nCsr = pSubParse->nTab;
    pProgram->token = (void *)pTrigger;
    pPrg->aColmask[0] = pSubParse->oldmask;
    pPrg->aColmask[1] = pSubParse->newmask;
    sqlite3VdbeDelete(v);
  }
  sqlite3ParserReset(pSubParse);
  sqlite3DbFree(db, (void *)pSubParse);
  return (pPrg);
}
}
static TriggerPrg *getRowTrigger(Parse *pParse , Trigger *pTrigger , Table *pTab ,
                                 int orconf ) 
{ 
  Parse *pRoot ;
  Parse *tmp ;
  TriggerPrg *pPrg ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pRoot = tmp;
  pPrg = pRoot->pTriggerPrg;
  while (1) {
    if (pPrg) {
      if (! ((unsigned long )pPrg->pTrigger != (unsigned long )pTrigger)) {
        if (! (pPrg->orconf != orconf)) {
          break;
        }
      }
    } else {
      break;
    }
    pPrg = pPrg->pNext;
  }
  if (! pPrg) {
    pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);
  }
  return (pPrg);
}
}
static void sqlite3CodeRowTriggerDirect(Parse *pParse , Trigger *p , Table *pTab ,
                                        int reg , int orconf , int ignoreJump ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  TriggerPrg *pPrg ;
  int bRecursive ;
  int tmp___0 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  pPrg = getRowTrigger(pParse, p, pTab, orconf);
  if (pPrg) {
    if (p->zName) {
      if (0ULL == ((pParse->db)->flags & 8192ULL)) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    bRecursive = tmp___0;
    (pParse->nMem) ++;
    sqlite3VdbeAddOp4(v, 45, reg, ignoreJump, pParse->nMem, (char const   *)pPrg->pProgram,
                      -4);
    sqlite3VdbeChangeP5(v, (u16 )((u8 )bRecursive));
  }
  return;
}
}
static void sqlite3CodeRowTrigger(Parse *pParse , Trigger *pTrigger , int op , ExprList *pChanges ,
                                  int tr_tm , Table *pTab , int reg , int orconf ,
                                  int ignoreJump ) 
{ 
  Trigger *p ;
  int tmp ;

  {
  p = pTrigger;
  while (p) {
    if ((int )p->op == op) {
      if ((int )p->tr_tm == tr_tm) {
        tmp = checkColumnOverlap(p->pColumns, pChanges);
        if (tmp) {
          sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
        }
      }
    }
    p = p->pNext;
  }
  return;
}
}
static u32 sqlite3TriggerColmask(Parse *pParse , Trigger *pTrigger , ExprList *pChanges ,
                                 int isNew , int tr_tm , Table *pTab , int orconf ) 
{ 
  int op ;
  int tmp ;
  u32 mask ;
  Trigger *p ;
  TriggerPrg *pPrg ;
  int tmp___0 ;

  {
  if (pChanges) {
    tmp = 125;
  } else {
    tmp = 124;
  }
  op = tmp;
  mask = (u32 )0;
  p = pTrigger;
  while (p) {
    if ((int )p->op == op) {
      if (tr_tm & (int )p->tr_tm) {
        tmp___0 = checkColumnOverlap(p->pColumns, pChanges);
        if (tmp___0) {
          pPrg = getRowTrigger(pParse, p, pTab, orconf);
          if (pPrg) {
            mask |= pPrg->aColmask[isNew];
          }
        }
      }
    }
    p = p->pNext;
  }
  return (mask);
}
}
static void updateVirtualTable(Parse *pParse , SrcList *pSrc , Table *pTab , ExprList *pChanges ,
                               Expr *pRowid , int *aXRef , Expr *pWhere , int onError ) ;
static void sqlite3ColumnDefault(Vdbe *v , Table *pTab , int i , int iReg ) 
{ 
  sqlite3_value *pValue ;
  u8 enc ;
  sqlite3 *tmp ;
  Column *pCol ;
  sqlite3 *tmp___0 ;

  {
  if (! pTab->pSelect) {
    pValue = (sqlite3_value *)0;
    tmp = sqlite3VdbeDb(v);
    enc = tmp->enc;
    pCol = pTab->aCol + i;
    tmp___0 = sqlite3VdbeDb(v);
    sqlite3ValueFromExpr(tmp___0, pCol->pDflt, enc, (u8 )pCol->affinity, & pValue);
    if (pValue) {
      sqlite3VdbeAppendP4(v, (void *)pValue, -11);
    }
  }
  if ((int )(pTab->aCol + i)->affinity == 69) {
    sqlite3VdbeAddOp1(v, 84, iReg);
  }
  return;
}
}
static int indexColumnIsBeingUpdated(Index *pIdx , int iCol , int *aXRef , int chngRowid ) 
{ 
  i16 iIdxCol ;
  int tmp ;

  {
  iIdxCol = *(pIdx->aiColumn + iCol);
  if ((int )iIdxCol >= 0) {
    return (*(aXRef + iIdxCol) >= 0);
  }
  tmp = sqlite3ExprReferencesUpdatedColumn((pIdx->aColExpr)->a[iCol].pExpr, aXRef,
                                           chngRowid);
  return (tmp);
}
}
static int indexWhereClauseMightChange(Index *pIdx , int *aXRef , int chngRowid ) 
{ 
  int tmp ;

  {
  if ((unsigned long )pIdx->pPartIdxWhere == (unsigned long )((Expr *)0)) {
    return (0);
  }
  tmp = sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere, aXRef, chngRowid);
  return (tmp);
}
}
static void sqlite3Update(Parse *pParse , SrcList *pTabList , ExprList *pChanges ,
                          Expr *pWhere , int onError , ExprList *pOrderBy , Expr *pLimit ,
                          Upsert *pUpsert ) 
{ 
  int i ;
  int j ;
  Table *pTab ;
  int addrTop ;
  WhereInfo *pWInfo ;
  Vdbe *v ;
  Index *pIdx ;
  Index *pPk ;
  int nIdx ;
  int nAllIdx ;
  int iBaseCur ;
  int iDataCur ;
  int iIdxCur ;
  sqlite3 *db ;
  int *aRegIdx ;
  int *aXRef ;
  u8 *aToOpen ;
  u8 chngPk ;
  u8 chngRowid ;
  u8 chngKey ;
  Expr *pRowidExpr ;
  AuthContext sContext ;
  NameContext sNC ;
  int iDb ;
  int eOnePass ;
  int hasFK ;
  int labelBreak ;
  int labelContinue ;
  int flags___0 ;
  int isView ;
  Trigger *pTrigger ;
  int tmask ;
  int newmask ;
  int iEph ;
  int nKey ;
  int aiCurOnePass[2] ;
  int addrOpen ;
  int iPk ;
  i16 nPk ;
  int bReplace ;
  int regRowCount ;
  int regOldRowid ;
  int regNewRowid ;
  int regNew ;
  int regOld ;
  int regRowSet ;
  int regKey ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Index *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int rc ;
  char const   *tmp___7 ;
  int reg ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int iCur ;
  char const   *tmp___13 ;
  int addrOnce ;
  int tmp___14 ;
  u32 oldmask ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  int tmp___19 ;

  {
  addrTop = 0;
  aRegIdx = (int *)0;
  aXRef = (int *)0;
  pRowidExpr = (Expr *)0;
  iEph = 0;
  nKey = 0;
  addrOpen = 0;
  iPk = 0;
  nPk = (i16 )0;
  bReplace = 0;
  regRowCount = 0;
  regOldRowid = 0;
  regNewRowid = 0;
  regNew = 0;
  regOld = 0;
  regRowSet = 0;
  regKey = 0;
  memset((void *)(& sContext), 0, sizeof(sContext));
  db = pParse->db;
  if (pParse->nErr) {
    goto update_cleanup;
  } else
  if (db->mallocFailed) {
    goto update_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    goto update_cleanup;
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  pTrigger = sqlite3TriggersExist(pParse, pTab, 125, pChanges, & tmask);
  isView = (unsigned long )pTab->pSelect != (unsigned long )((Select *)0);
  tmp = sqlite3ViewGetColumnNames(pParse, pTab);
  if (tmp) {
    goto update_cleanup;
  }
  tmp___0 = sqlite3IsReadOnly(pParse, pTab, tmask);
  if (tmp___0) {
    goto update_cleanup;
  }
  tmp___1 = pParse->nTab;
  (pParse->nTab) ++;
  iDataCur = tmp___1;
  iBaseCur = iDataCur;
  iIdxCur = iDataCur + 1;
  if ((pTab->tabFlags & 32U) == 0U) {
    pPk = (Index *)0;
  } else {
    tmp___2 = sqlite3PrimaryKeyIndex(pTab);
    pPk = tmp___2;
  }
  nIdx = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if ((unsigned long )pPk == (unsigned long )pIdx) {
      iDataCur = pParse->nTab;
    }
    (pParse->nTab) ++;
    pIdx = pIdx->pNext;
    nIdx ++;
  }
  if (pUpsert) {
    iDataCur = pUpsert->iDataCur;
    iIdxCur = pUpsert->iIdxCur;
    pParse->nTab = iBaseCur;
  }
  pTabList->a[0].iCursor = iDataCur;
  tmp___3 = sqlite3DbMallocRawNN(db, (u64 )((sizeof(int ) * (unsigned long )(((int )pTab->nCol + nIdx) + 1) + (unsigned long )nIdx) + 2UL));
  aXRef = (int *)tmp___3;
  if ((unsigned long )aXRef == (unsigned long )((int *)0)) {
    goto update_cleanup;
  }
  aRegIdx = aXRef + (int )pTab->nCol;
  aToOpen = (u8 *)((aRegIdx + nIdx) + 1);
  memset((void *)aToOpen, 1, (size_t )(nIdx + 1));
  *(aToOpen + (nIdx + 1)) = (u8 )0;
  i = 0;
  while (i < (int )pTab->nCol) {
    *(aXRef + i) = -1;
    i ++;
  }
  memset((void *)(& sNC), 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  sNC.uNC.pUpsert = pUpsert;
  sNC.ncFlags = 512;
  chngPk = (u8 )0;
  chngRowid = chngPk;
  i = 0;
  while (i < pChanges->nExpr) {
    tmp___4 = sqlite3ResolveExprNames(& sNC, pChanges->a[i].pExpr);
    if (tmp___4) {
      goto update_cleanup;
    }
    j = 0;
    while (j < (int )pTab->nCol) {
      tmp___5 = sqlite3StrICmp((char const   *)(pTab->aCol + j)->zName, (char const   *)pChanges->a[i].zName);
      if (tmp___5 == 0) {
        if (j == (int )pTab->iPKey) {
          chngRowid = (u8 )1;
          pRowidExpr = pChanges->a[i].pExpr;
        } else
        if (pPk) {
          if (((int )(pTab->aCol + j)->colFlags & 1) != 0) {
            chngPk = (u8 )1;
          }
        }
        *(aXRef + j) = i;
        break;
      }
      j ++;
    }
    if (j >= (int )pTab->nCol) {
      if ((unsigned long )pPk == (unsigned long )((Index *)0)) {
        tmp___6 = sqlite3IsRowid((char const   *)pChanges->a[i].zName);
        if (tmp___6) {
          j = -1;
          chngRowid = (u8 )1;
          pRowidExpr = pChanges->a[i].pExpr;
        } else {
          sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName);
          pParse->checkSchema = (u8 )1;
          goto update_cleanup;
        }
      } else {
        sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName);
        pParse->checkSchema = (u8 )1;
        goto update_cleanup;
      }
    }
    if (j < 0) {
      tmp___7 = "ROWID";
    } else {
      tmp___7 = (char const   *)(pTab->aCol + j)->zName;
    }
    rc = sqlite3AuthCheck(pParse, 23, (char const   *)pTab->zName, tmp___7, (char const   *)(db->aDb + iDb)->zDbSName);
    if (rc == 1) {
      goto update_cleanup;
    } else
    if (rc == 2) {
      *(aXRef + j) = -1;
    }
    i ++;
  }
  chngKey = (u8 )((int )chngRowid + (int )chngPk);
  if (pTab->nModuleArg) {
    pTabList->a[0].colUsed = (Bitmask )-1;
  } else {
    pTabList->a[0].colUsed = (Bitmask )0;
  }
  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, (int )chngKey);
  if (onError == 5) {
    bReplace = 1;
  }
  nAllIdx = 0;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (chngKey) {
      (pParse->nMem) ++;
      reg = pParse->nMem;
      pParse->nMem += (int )pIdx->nColumn;
    } else
    if (hasFK > 1) {
      (pParse->nMem) ++;
      reg = pParse->nMem;
      pParse->nMem += (int )pIdx->nColumn;
    } else
    if ((unsigned long )pIdx == (unsigned long )pPk) {
      (pParse->nMem) ++;
      reg = pParse->nMem;
      pParse->nMem += (int )pIdx->nColumn;
    } else {
      tmp___9 = indexWhereClauseMightChange(pIdx, aXRef, (int )chngRowid);
      if (tmp___9) {
        (pParse->nMem) ++;
        reg = pParse->nMem;
        pParse->nMem += (int )pIdx->nColumn;
      } else {
        reg = 0;
        i = 0;
        while (i < (int )pIdx->nKeyCol) {
          tmp___8 = indexColumnIsBeingUpdated(pIdx, i, aXRef, (int )chngRowid);
          if (tmp___8) {
            (pParse->nMem) ++;
            reg = pParse->nMem;
            pParse->nMem += (int )pIdx->nColumn;
            if (onError == 11) {
              if ((int )pIdx->onError == 5) {
                bReplace = 1;
              }
            }
            break;
          }
          i ++;
        }
      }
    }
    if (reg == 0) {
      *(aToOpen + (nAllIdx + 1)) = (u8 )0;
    }
    *(aRegIdx + nAllIdx) = reg;
    pIdx = pIdx->pNext;
    nAllIdx ++;
  }
  (pParse->nMem) ++;
  *(aRegIdx + nAllIdx) = pParse->nMem;
  if (bReplace) {
    memset((void *)aToOpen, 1, (size_t )(nIdx + 1));
  }
  v = sqlite3GetVdbe(pParse);
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    goto update_cleanup;
  }
  if ((int )pParse->nested == 0) {
    sqlite3VdbeCountChanges(v);
  }
  if (pTrigger) {
    tmp___10 = 1;
  } else
  if (hasFK) {
    tmp___10 = 1;
  } else {
    tmp___10 = 0;
  }
  sqlite3BeginWriteOperation(pParse, tmp___10, iDb);
  if (! pTab->nModuleArg) {
    regRowSet = *(aRegIdx + nAllIdx);
    (pParse->nMem) ++;
    regNewRowid = pParse->nMem;
    regOldRowid = regNewRowid;
    if (chngPk) {
      regOld = pParse->nMem + 1;
      pParse->nMem += (int )pTab->nCol;
    } else
    if (pTrigger) {
      regOld = pParse->nMem + 1;
      pParse->nMem += (int )pTab->nCol;
    } else
    if (hasFK) {
      regOld = pParse->nMem + 1;
      pParse->nMem += (int )pTab->nCol;
    }
    if (chngKey) {
      (pParse->nMem) ++;
      regNewRowid = pParse->nMem;
    } else
    if (pTrigger) {
      (pParse->nMem) ++;
      regNewRowid = pParse->nMem;
    } else
    if (hasFK) {
      (pParse->nMem) ++;
      regNewRowid = pParse->nMem;
    }
    regNew = pParse->nMem + 1;
    pParse->nMem += (int )pTab->nCol;
  }
  if (isView) {
    sqlite3AuthContextPush(pParse, & sContext, (char const   *)pTab->zName);
  }
  if (isView) {
    sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iDataCur);
    pOrderBy = (ExprList *)0;
    pLimit = (Expr *)0;
  }
  tmp___11 = sqlite3ResolveExprNames(& sNC, pWhere);
  if (tmp___11) {
    goto update_cleanup;
  }
  if (pTab->nModuleArg) {
    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere,
                       onError);
    goto update_cleanup;
  }
  labelBreak = sqlite3VdbeMakeLabel(pParse);
  labelContinue = labelBreak;
  if ((db->flags & 128ULL) != 0ULL) {
    if (! pParse->pTriggerTab) {
      if (! pParse->nested) {
        if ((unsigned long )pUpsert == (unsigned long )((Upsert *)0)) {
          (pParse->nMem) ++;
          regRowCount = pParse->nMem;
          sqlite3VdbeAddOp2(v, 70, 0, regRowCount);
        }
      }
    }
  }
  if ((pTab->tabFlags & 32U) == 0U) {
    sqlite3VdbeAddOp3(v, 73, 0, regRowSet, regOldRowid);
  } else {
    nPk = (i16 )pPk->nKeyCol;
    iPk = pParse->nMem + 1;
    pParse->nMem += (int )nPk;
    (pParse->nMem) ++;
    regKey = pParse->nMem;
    if ((unsigned long )pUpsert == (unsigned long )((Upsert *)0)) {
      tmp___12 = pParse->nTab;
      (pParse->nTab) ++;
      iEph = tmp___12;
      sqlite3VdbeAddOp3(v, 73, 0, iPk, (iPk + (int )nPk) - 1);
      addrOpen = sqlite3VdbeAddOp2(v, 112, iEph, (int )nPk);
      sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
  }
  if (pUpsert) {
    pWInfo = (WhereInfo *)0;
    eOnePass = 1;
    sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 16);
  } else {
    flags___0 = 4100;
    if (! pParse->nested) {
      if (! pTrigger) {
        if (! hasFK) {
          if (! chngKey) {
            if (! bReplace) {
              flags___0 |= 8;
            }
          }
        }
      }
    }
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, (ExprList *)0, (ExprList *)0,
                               (u16 )flags___0, iIdxCur);
    if ((unsigned long )pWInfo == (unsigned long )((WhereInfo *)0)) {
      goto update_cleanup;
    }
    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
    if (eOnePass != 1) {
      sqlite3MultiWrite(pParse);
      if (eOnePass == 2) {
        iCur = aiCurOnePass[1];
        if (iCur >= 0) {
          if (iCur != iDataCur) {
            if (*(aToOpen + (iCur - iBaseCur))) {
              eOnePass = 0;
            }
          }
        }
      }
    }
  }
  if ((pTab->tabFlags & 32U) == 0U) {
    sqlite3VdbeAddOp2(v, 128, iDataCur, regOldRowid);
    if (eOnePass == 0) {
      (pParse->nMem) ++;
      *(aRegIdx + nAllIdx) = pParse->nMem;
      sqlite3VdbeAddOp2(v, 147, regRowSet, regOldRowid);
    }
  } else {
    i = 0;
    while (i < (int )nPk) {
      sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, (int )*(pPk->aiColumn + i),
                                      iPk + i);
      i ++;
    }
    if (eOnePass) {
      if (addrOpen) {
        sqlite3VdbeChangeToNoop(v, addrOpen);
      }
      nKey = (int )nPk;
      regKey = iPk;
    } else {
      tmp___13 = sqlite3IndexAffinityStr(db, pPk);
      sqlite3VdbeAddOp4(v, 92, iPk, (int )nPk, regKey, tmp___13, (int )nPk);
      sqlite3VdbeAddOp4Int(v, 132, iEph, regKey, iPk, (int )nPk);
    }
  }
  if ((unsigned long )pUpsert == (unsigned long )((Upsert *)0)) {
    if (eOnePass != 2) {
      sqlite3WhereEnd(pWInfo);
    }
    if (! isView) {
      addrOnce = 0;
      if (eOnePass != 0) {
        if (aiCurOnePass[0] >= 0) {
          *(aToOpen + (aiCurOnePass[0] - iBaseCur)) = (u8 )0;
        }
        if (aiCurOnePass[1] >= 0) {
          *(aToOpen + (aiCurOnePass[1] - iBaseCur)) = (u8 )0;
        }
      }
      if (eOnePass == 2) {
        if (nIdx - (aiCurOnePass[1] >= 0) > 0) {
          addrOnce = sqlite3VdbeAddOp0(v, 17);
        }
      }
      sqlite3OpenTableAndIndices(pParse, pTab, 98, (u8 )0, iBaseCur, aToOpen, (int *)0,
                                 (int *)0);
      if (addrOnce) {
        sqlite3VdbeJumpHere(v, addrOnce);
      }
    }
    if (eOnePass != 0) {
      if (! isView) {
        if (aiCurOnePass[0] != iDataCur) {
          if (aiCurOnePass[1] != iDataCur) {
            sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelBreak, regKey, nKey);
          }
        }
      }
      if (eOnePass != 1) {
        labelContinue = sqlite3VdbeMakeLabel(pParse);
      }
      if (pPk) {
        tmp___14 = regKey;
      } else {
        tmp___14 = regOldRowid;
      }
      sqlite3VdbeAddOp2(v, 50, tmp___14, labelBreak);
    } else
    if (pPk) {
      labelContinue = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);
      addrTop = sqlite3VdbeAddOp2(v, 127, iEph, regKey);
      sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, 0);
    } else {
      labelContinue = sqlite3VdbeAddOp3(v, 41, regRowSet, labelBreak, regOldRowid);
      sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);
    }
  }
  if (chngRowid) {
    sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
    sqlite3VdbeAddOp1(v, 15, regNewRowid);
  }
  if (chngPk) {
    goto _L___0;
  } else
  if (hasFK) {
    goto _L___0;
  } else
  if (pTrigger) {
    _L___0: /* CIL Label */ 
    if (hasFK) {
      tmp___15 = sqlite3FkOldmask(pParse, pTab);
      tmp___16 = tmp___15;
    } else {
      tmp___16 = (u32 )0;
    }
    oldmask = tmp___16;
    tmp___17 = sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, 3, pTab, onError);
    oldmask |= tmp___17;
    i = 0;
    while (i < (int )pTab->nCol) {
      if (oldmask == 4294967295U) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regOld + i);
      } else
      if (i < 32) {
        if ((oldmask & (1U << i)) != 0U) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regOld + i);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (((int )(pTab->aCol + i)->colFlags & 1) != 0) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regOld + i);
      } else {
        sqlite3VdbeAddOp2(v, 73, 0, regOld + i);
      }
      i ++;
    }
    if ((int )chngRowid == 0) {
      if ((unsigned long )pPk == (unsigned long )((Index *)0)) {
        sqlite3VdbeAddOp2(v, 78, regOldRowid, regNewRowid);
      }
    }
  }
  tmp___18 = sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, pTab, onError);
  newmask = (int )tmp___18;
  i = 0;
  while (i < (int )pTab->nCol) {
    if (i == (int )pTab->iPKey) {
      sqlite3VdbeAddOp2(v, 73, 0, regNew + i);
    } else {
      j = *(aXRef + i);
      if (j >= 0) {
        sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regNew + i);
      } else
      if (0 == (tmask & 1)) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew + i);
      } else
      if (i > 31) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew + i);
      } else
      if ((unsigned int )newmask & (1U << i)) {
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew + i);
      } else {
        sqlite3VdbeAddOp2(v, 73, 0, regNew + i);
      }
    }
    i ++;
  }
  if (tmask & 1) {
    sqlite3TableAffinity(v, pTab, regNew);
    sqlite3CodeRowTrigger(pParse, pTrigger, 125, pChanges, 1, pTab, regOldRowid, onError,
                          labelContinue);
    if (pPk) {
      sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);
    } else {
      sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);
    }
    i = 0;
    while (i < (int )pTab->nCol) {
      if (*(aXRef + i) < 0) {
        if (i != (int )pTab->iPKey) {
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew + i);
        }
      }
      i ++;
    }
  }
  if (! isView) {
    sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regNewRowid,
                                    regOldRowid, chngKey, (u8 )onError, labelContinue,
                                    & bReplace, aXRef, (Upsert *)0);
    if (bReplace) {
      goto _L___1;
    } else
    if (chngKey) {
      _L___1: /* CIL Label */ 
      if (pPk) {
        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);
      } else {
        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);
      }
    }
    if (hasFK) {
      sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, (int )chngKey);
    }
    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);
    if (hasFK > 1) {
      sqlite3VdbeAddOp2(v, 123, iDataCur, 0);
    } else
    if (chngKey) {
      sqlite3VdbeAddOp2(v, 123, iDataCur, 0);
    }
    if (hasFK) {
      sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, (int )chngKey);
    }
    if (eOnePass == 2) {
      tmp___19 = 2;
    } else {
      tmp___19 = 0;
    }
    sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx,
                             4 | tmp___19, 0, 0);
    if (hasFK) {
      sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, (int )chngKey);
    }
  }
  if (regRowCount) {
    sqlite3VdbeAddOp2(v, 83, regRowCount, 1);
  }
  sqlite3CodeRowTrigger(pParse, pTrigger, 125, pChanges, 2, pTab, regOldRowid, onError,
                        labelContinue);
  if (! (eOnePass == 1)) {
    if (eOnePass == 2) {
      sqlite3VdbeResolveLabel(v, labelContinue);
      sqlite3WhereEnd(pWInfo);
    } else
    if (pPk) {
      sqlite3VdbeResolveLabel(v, labelContinue);
      sqlite3VdbeAddOp2(v, 5, iEph, addrTop);
    } else {
      sqlite3VdbeGoto(v, labelContinue);
    }
  }
  sqlite3VdbeResolveLabel(v, labelBreak);
  if ((int )pParse->nested == 0) {
    if ((unsigned long )pParse->pTriggerTab == (unsigned long )((Table *)0)) {
      if ((unsigned long )pUpsert == (unsigned long )((Upsert *)0)) {
        sqlite3AutoincrementEnd(pParse);
      }
    }
  }
  if (regRowCount) {
    sqlite3VdbeAddOp2(v, 81, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows updated", (void (*)(void * ))0);
  }
  update_cleanup: 
  sqlite3AuthContextPop(& sContext);
  sqlite3DbFree(db, (void *)aXRef);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pChanges);
  sqlite3ExprDelete(db, pWhere);
  return;
}
}
static void updateVirtualTable(Parse *pParse , SrcList *pSrc , Table *pTab , ExprList *pChanges ,
                               Expr *pRowid , int *aXRef , Expr *pWhere , int onError ) 
{ 
  Vdbe *v ;
  int ephemTab ;
  int i ;
  sqlite3 *db ;
  char const   *pVTab ;
  VTable *tmp ;
  WhereInfo *pWInfo ;
  int nArg ;
  int regArg ;
  int regRec ;
  int regRowid ;
  int iCsr ;
  int aDummy[2] ;
  int eOnePass ;
  int addr ;
  int tmp___0 ;
  Index *pPk ;
  i16 iPk ;
  int tmp___1 ;

  {
  v = pParse->pVdbe;
  db = pParse->db;
  tmp = sqlite3GetVTable(db, pTab);
  pVTab = (char const   *)tmp;
  nArg = 2 + (int )pTab->nCol;
  iCsr = pSrc->a[0].iCursor;
  tmp___0 = pParse->nTab;
  (pParse->nTab) ++;
  ephemTab = tmp___0;
  addr = sqlite3VdbeAddOp2(v, 112, ephemTab, nArg);
  regArg = pParse->nMem + 1;
  pParse->nMem += nArg;
  (pParse->nMem) ++;
  regRec = pParse->nMem;
  (pParse->nMem) ++;
  regRowid = pParse->nMem;
  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, (ExprList *)0, (ExprList *)0, (u16 )4,
                             0);
  if ((unsigned long )pWInfo == (unsigned long )((WhereInfo *)0)) {
    return;
  }
  i = 0;
  while (i < (int )pTab->nCol) {
    if (*(aXRef + i) >= 0) {
      sqlite3ExprCode(pParse, pChanges->a[*(aXRef + i)].pExpr, (regArg + 2) + i);
    } else {
      sqlite3VdbeAddOp3(v, 164, iCsr, i, (regArg + 2) + i);
      sqlite3VdbeChangeP5(v, (u16 )1);
    }
    i ++;
  }
  if ((pTab->tabFlags & 32U) == 0U) {
    sqlite3VdbeAddOp2(v, 128, iCsr, regArg);
    if (pRowid) {
      sqlite3ExprCode(pParse, pRowid, regArg + 1);
    } else {
      sqlite3VdbeAddOp2(v, 128, iCsr, regArg + 1);
    }
  } else {
    pPk = sqlite3PrimaryKeyIndex(pTab);
    iPk = *(pPk->aiColumn + 0);
    sqlite3VdbeAddOp3(v, 164, iCsr, (int )iPk, regArg);
    sqlite3VdbeAddOp2(v, 79, (regArg + 2) + (int )iPk, regArg + 1);
  }
  eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);
  if (eOnePass) {
    sqlite3VdbeChangeToNoop(v, addr);
    sqlite3VdbeAddOp1(v, 117, iCsr);
  } else {
    sqlite3MultiWrite(pParse);
    sqlite3VdbeAddOp3(v, 92, regArg, nArg, regRec);
    sqlite3VdbeAddOp2(v, 121, ephemTab, regRowid);
    sqlite3VdbeAddOp3(v, 122, ephemTab, regRec, regRowid);
  }
  if (eOnePass == 0) {
    sqlite3WhereEnd(pWInfo);
    addr = sqlite3VdbeAddOp1(v, 36, ephemTab);
    i = 0;
    while (i < nArg) {
      sqlite3VdbeAddOp3(v, 90, ephemTab, i, regArg + i);
      i ++;
    }
  }
  sqlite3VtabMakeWritable(pParse, pTab);
  sqlite3VdbeAddOp4(v, 10, 0, nArg, regArg, pVTab, -12);
  if (onError == 11) {
    tmp___1 = 2;
  } else {
    tmp___1 = onError;
  }
  sqlite3VdbeChangeP5(v, (u16 )tmp___1);
  sqlite3MayAbort(pParse);
  if (eOnePass == 0) {
    sqlite3VdbeAddOp2(v, 5, ephemTab, addr + 1);
    sqlite3VdbeJumpHere(v, addr);
    sqlite3VdbeAddOp2(v, 117, ephemTab, 0);
  } else {
    sqlite3WhereEnd(pWInfo);
  }
  return;
}
}
static void sqlite3UpsertDelete(sqlite3 *db , Upsert *p ) 
{ 


  {
  if (p) {
    sqlite3ExprListDelete(db, p->pUpsertTarget);
    sqlite3ExprDelete(db, p->pUpsertTargetWhere);
    sqlite3ExprListDelete(db, p->pUpsertSet);
    sqlite3ExprDelete(db, p->pUpsertWhere);
    sqlite3DbFree(db, (void *)p);
  }
  return;
}
}
static Upsert *sqlite3UpsertDup(sqlite3 *db , Upsert *p ) 
{ 
  Expr *tmp ;
  ExprList *tmp___0 ;
  Expr *tmp___1 ;
  ExprList *tmp___2 ;
  Upsert *tmp___3 ;

  {
  if ((unsigned long )p == (unsigned long )((Upsert *)0)) {
    return ((Upsert *)0);
  }
  tmp = sqlite3ExprDup(db, p->pUpsertWhere, 0);
  tmp___0 = sqlite3ExprListDup(db, p->pUpsertSet, 0);
  tmp___1 = sqlite3ExprDup(db, p->pUpsertTargetWhere, 0);
  tmp___2 = sqlite3ExprListDup(db, p->pUpsertTarget, 0);
  tmp___3 = sqlite3UpsertNew(db, tmp___2, tmp___1, tmp___0, tmp);
  return (tmp___3);
}
}
static Upsert *sqlite3UpsertNew(sqlite3 *db , ExprList *pTarget , Expr *pTargetWhere ,
                                ExprList *pSet , Expr *pWhere ) 
{ 
  Upsert *pNew ;
  void *tmp ;

  {
  tmp = sqlite3DbMallocRaw(db, (u64 )sizeof(Upsert ));
  pNew = (Upsert *)tmp;
  if ((unsigned long )pNew == (unsigned long )((Upsert *)0)) {
    sqlite3ExprListDelete(db, pTarget);
    sqlite3ExprDelete(db, pTargetWhere);
    sqlite3ExprListDelete(db, pSet);
    sqlite3ExprDelete(db, pWhere);
    return ((Upsert *)0);
  } else {
    pNew->pUpsertTarget = pTarget;
    pNew->pUpsertTargetWhere = pTargetWhere;
    pNew->pUpsertSet = pSet;
    pNew->pUpsertWhere = pWhere;
    pNew->pUpsertIdx = (Index *)0;
  }
  return (pNew);
}
}
static int sqlite3UpsertAnalyzeTarget(Parse *pParse , SrcList *pTabList , Upsert *pUpsert ) 
{ 
  Table *pTab ;
  int rc ;
  int iCursor ;
  Index *pIdx ;
  ExprList *pTarget ;
  Expr *pTerm ;
  NameContext sNC ;
  Expr sCol[2] ;
  int ii ;
  int jj ;
  int nn ;
  int tmp ;
  Expr *pExpr ;
  int tmp___0 ;

  {
  memset((void *)(& sNC), 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  rc = sqlite3ResolveExprListNames(& sNC, pUpsert->pUpsertTarget);
  if (rc) {
    return (rc);
  }
  rc = sqlite3ResolveExprNames(& sNC, pUpsert->pUpsertTargetWhere);
  if (rc) {
    return (rc);
  }
  pTab = pTabList->a[0].pTab;
  pTarget = pUpsert->pUpsertTarget;
  iCursor = pTabList->a[0].iCursor;
  if ((pTab->tabFlags & 32U) == 0U) {
    if (pTarget->nExpr == 1) {
      pTerm = pTarget->a[0].pExpr;
      if ((int )pTerm->op == 162) {
        if ((int )pTerm->iColumn == -1) {
          return (0);
        }
      }
    }
  }
  memset((void *)(sCol), 0, sizeof(sCol));
  sCol[0].op = (u8 )109;
  sCol[0].pLeft = & sCol[1];
  sCol[1].op = (u8 )162;
  sCol[1].iTable = pTabList->a[0].iCursor;
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (! ((int )pIdx->onError != 0)) {
      goto __Cont;
    }
    if (pTarget->nExpr != (int )pIdx->nKeyCol) {
      goto __Cont;
    }
    if (pIdx->pPartIdxWhere) {
      if ((unsigned long )pUpsert->pUpsertTargetWhere == (unsigned long )((Expr *)0)) {
        goto __Cont;
      }
      tmp = sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere, pIdx->pPartIdxWhere,
                               iCursor);
      if (tmp != 0) {
        goto __Cont;
      }
    }
    nn = (int )pIdx->nKeyCol;
    ii = 0;
    while (ii < nn) {
      sCol[0].u.zToken = (char *)*(pIdx->azColl + ii);
      if ((int )*(pIdx->aiColumn + ii) == -2) {
        pExpr = (pIdx->aColExpr)->a[ii].pExpr;
        if ((int )pExpr->op != 109) {
          sCol[0].pLeft = pExpr;
          pExpr = & sCol[0];
        }
      } else {
        sCol[0].pLeft = & sCol[1];
        sCol[1].iColumn = *(pIdx->aiColumn + ii);
        pExpr = & sCol[0];
      }
      jj = 0;
      while (jj < nn) {
        tmp___0 = sqlite3ExprCompare(pParse, pTarget->a[jj].pExpr, pExpr, iCursor);
        if (tmp___0 < 2) {
          break;
        }
        jj ++;
      }
      if (jj >= nn) {
        break;
      }
      ii ++;
    }
    if (ii < nn) {
      goto __Cont;
    }
    pUpsert->pUpsertIdx = pIdx;
    return (0);
    __Cont: /* CIL Label */ 
    pIdx = pIdx->pNext;
  }
  sqlite3ErrorMsg(pParse, "ON CONFLICT clause does not match any PRIMARY KEY or UNIQUE constraint");
  return (1);
}
}
static void sqlite3UpsertDoUpdate(Parse *pParse , Upsert *pUpsert , Table *pTab ,
                                  Index *pIdx , int iCur ) 
{ 
  Vdbe *v ;
  sqlite3 *db ;
  SrcList *pSrc ;
  int iDataCur ;
  int i ;
  int regRowid ;
  int tmp ;
  Index *pPk ;
  Index *tmp___0 ;
  int nPk ;
  int iPk ;
  int k ;
  i16 tmp___1 ;

  {
  v = pParse->pVdbe;
  db = pParse->db;
  iDataCur = pUpsert->iDataCur;
  if (pIdx) {
    if (iCur != iDataCur) {
      if ((pTab->tabFlags & 32U) == 0U) {
        tmp = sqlite3GetTempReg(pParse);
        regRowid = tmp;
        sqlite3VdbeAddOp2(v, 135, iCur, regRowid);
        sqlite3VdbeAddOp3(v, 30, iDataCur, 0, regRowid);
        sqlite3ReleaseTempReg(pParse, regRowid);
      } else {
        tmp___0 = sqlite3PrimaryKeyIndex(pTab);
        pPk = tmp___0;
        nPk = (int )pPk->nKeyCol;
        iPk = pParse->nMem + 1;
        pParse->nMem += nPk;
        i = 0;
        while (i < nPk) {
          tmp___1 = sqlite3ColumnOfIndex(pIdx, *(pPk->aiColumn + i));
          k = (int )tmp___1;
          sqlite3VdbeAddOp3(v, 90, iCur, k, iPk + i);
          i ++;
        }
        i = sqlite3VdbeAddOp4Int(v, 29, iDataCur, 0, iPk, nPk);
        sqlite3VdbeAddOp4(v, 69, 11, 2, 0, "corrupt database", -1);
        sqlite3VdbeJumpHere(v, i);
      }
    }
  }
  pSrc = sqlite3SrcListDup(db, pUpsert->pUpsertSrc, 0);
  i = 0;
  while (i < (int )pTab->nCol) {
    if ((int )(pTab->aCol + i)->affinity == 69) {
      sqlite3VdbeAddOp1(v, 84, pUpsert->regData + i);
    }
    i ++;
  }
  sqlite3Update(pParse, pSrc, pUpsert->pUpsertSet, pUpsert->pUpsertWhere, 2, (ExprList *)0,
                (Expr *)0, pUpsert);
  pUpsert->pUpsertSet = (ExprList *)0;
  pUpsert->pUpsertWhere = (Expr *)0;
  return;
}
}
static int execSql(sqlite3 *db , char **pzErrMsg , char const   *zSql ) 
{ 
  sqlite3_stmt *pStmt ;
  int rc ;
  char const   *zSubSql ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  rc = sqlite3_prepare_v2(db, zSql, -1, & pStmt, (char const   **)0);
  if (rc != 0) {
    return (rc);
  }
  while (1) {
    rc = sqlite3_step(pStmt);
    if (! (100 == rc)) {
      break;
    }
    tmp = sqlite3_column_text(pStmt, 0);
    zSubSql = (char const   *)tmp;
    if (zSubSql) {
      tmp___0 = strncmp(zSubSql, "CRE", (size_t )3);
      if (tmp___0 == 0) {
        goto _L;
      } else {
        tmp___1 = strncmp(zSubSql, "INS", (size_t )3);
        if (tmp___1 == 0) {
          _L: /* CIL Label */ 
          rc = execSql(db, pzErrMsg, zSubSql);
          if (rc != 0) {
            break;
          }
        }
      }
    }
  }
  if (rc == 101) {
    rc = 0;
  }
  if (rc) {
    tmp___2 = sqlite3_errmsg(db);
    sqlite3SetString(pzErrMsg, db, tmp___2);
  }
  sqlite3_finalize(pStmt);
  return (rc);
}
}
static int execSqlF(sqlite3 *db , char **pzErrMsg , char const   *zSql  , ...) 
{ 
  char *z ;
  va_list ap ;
  int rc ;

  {
  __builtin_va_start(ap, zSql);
  z = sqlite3VMPrintf(db, zSql, ap);
  __builtin_va_end(ap);
  if ((unsigned long )z == (unsigned long )((char *)0)) {
    return (7);
  }
  rc = execSql(db, pzErrMsg, (char const   *)z);
  sqlite3DbFree(db, (void *)z);
  return (rc);
}
}
static void sqlite3Vacuum(Parse *pParse , Token *pNm , Expr *pInto ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  int iDb ;
  int iIntoReg ;
  int tmp___0 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  iDb = 0;
  if ((unsigned long )v == (unsigned long )((Vdbe *)0)) {
    goto build_vacuum_end;
  }
  if (pParse->nErr) {
    goto build_vacuum_end;
  }
  if (pNm) {
    iDb = sqlite3TwoPartName(pParse, pNm, pNm, & pNm);
    if (iDb < 0) {
      goto build_vacuum_end;
    }
  }
  if (iDb != 1) {
    iIntoReg = 0;
    if (pInto) {
      tmp___0 = sqlite3ResolveSelfReference(pParse, (Table *)0, 0, pInto, (ExprList *)0);
      if (tmp___0 == 0) {
        (pParse->nMem) ++;
        iIntoReg = pParse->nMem;
        sqlite3ExprCode(pParse, pInto, iIntoReg);
      }
    }
    sqlite3VdbeAddOp2(v, 8, iDb, iIntoReg);
    sqlite3VdbeUsesBtree(v, iDb);
  }
  build_vacuum_end: 
  sqlite3ExprDelete(pParse->db, pInto);
  return;
}
}
static unsigned char const   aCopy[10]  = 
  {      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )6,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )0};
static int ( __attribute__((__noinline__)) sqlite3RunVacuum)(char **pzErrMsg , sqlite3 *db ,
                                                             int iDb , sqlite3_value *pOut ) 
{ 
  int rc ;
  Btree *pMain ;
  Btree *pTemp ;
  u32 saved_mDbFlags ;
  u64 saved_flags ;
  int saved_nChange ;
  int saved_nTotalChange ;
  u32 saved_openFlags ;
  u8 saved_mTrace ;
  Db *pDb ;
  int isMemDb ;
  int nRes ;
  int nDb ;
  char const   *zDbMain ;
  char const   *zOut ;
  int tmp ;
  unsigned char const   *tmp___0 ;
  struct Pager *tmp___1 ;
  sqlite3_file *id ;
  struct Pager *tmp___2 ;
  sqlite3_file *tmp___3 ;
  i64 sz ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct Pager *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  u32 meta ;
  int i ;
  int tmp___14 ;
  int tmp___15 ;

  {
  rc = 0;
  pDb = (Db *)0;
  if (! db->autoCommit) {
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
    return (1);
  }
  if (db->nVdbeActive > 1) {
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
    return (1);
  }
  saved_openFlags = db->openFlags;
  if (pOut) {
    tmp = sqlite3_value_type(pOut);
    if (tmp != 3) {
      sqlite3SetString(pzErrMsg, db, "non-text filename");
      return (1);
    }
    tmp___0 = sqlite3_value_text(pOut);
    zOut = (char const   *)tmp___0;
    db->openFlags &= 4294967294U;
    db->openFlags |= 6U;
  } else {
    zOut = "";
  }
  saved_flags = db->flags;
  saved_mDbFlags = db->mDbFlags;
  saved_nChange = db->nChange;
  saved_nTotalChange = db->nTotalChange;
  saved_mTrace = db->mTrace;
  db->flags |= 513ULL;
  db->mDbFlags |= 6U;
  db->flags &= 0xffffffffefffaf7fULL;
  db->mTrace = (u8 )0;
  zDbMain = (char const   *)(db->aDb + iDb)->zDbSName;
  pMain = (db->aDb + iDb)->pBt;
  tmp___1 = sqlite3BtreePager(pMain);
  isMemDb = sqlite3PagerIsMemdb(tmp___1);
  nDb = db->nDb;
  rc = execSqlF(db, pzErrMsg, "ATTACH %Q AS vacuum_db", zOut);
  db->openFlags = saved_openFlags;
  if (rc != 0) {
    goto end_of_vacuum;
  }
  pDb = db->aDb + nDb;
  pTemp = pDb->pBt;
  if (pOut) {
    tmp___2 = sqlite3BtreePager(pTemp);
    tmp___3 = sqlite3PagerFile(tmp___2);
    id = tmp___3;
    sz = (i64 )0;
    if ((unsigned long )id->pMethods != (unsigned long )((struct sqlite3_io_methods  const  *)0)) {
      tmp___4 = sqlite3OsFileSize(id, & sz);
      if (tmp___4 != 0) {
        rc = 1;
        sqlite3SetString(pzErrMsg, db, "output file already exists");
        goto end_of_vacuum;
      } else
      if (sz > 0LL) {
        rc = 1;
        sqlite3SetString(pzErrMsg, db, "output file already exists");
        goto end_of_vacuum;
      }
    }
    db->mDbFlags |= 8U;
  }
  nRes = sqlite3BtreeGetOptimalReserve(pMain);
  sqlite3BtreeSetCacheSize(pTemp, ((db->aDb + iDb)->pSchema)->cache_size);
  tmp___5 = sqlite3BtreeSetSpillSize(pMain, 0);
  sqlite3BtreeSetSpillSize(pTemp, tmp___5);
  sqlite3BtreeSetPagerFlags(pTemp, 33U);
  rc = execSql(db, pzErrMsg, "BEGIN");
  if (rc != 0) {
    goto end_of_vacuum;
  }
  if ((unsigned long )pOut == (unsigned long )((sqlite3_value *)0)) {
    tmp___6 = 2;
  } else {
    tmp___6 = 0;
  }
  rc = sqlite3BtreeBeginTrans(pMain, tmp___6, (int *)0);
  if (rc != 0) {
    goto end_of_vacuum;
  }
  tmp___7 = sqlite3BtreePager(pMain);
  tmp___8 = sqlite3PagerGetJournalMode(tmp___7);
  if (tmp___8 == 5) {
    db->nextPagesize = 0;
  }
  tmp___9 = sqlite3BtreeGetPageSize(pMain);
  tmp___10 = sqlite3BtreeSetPageSize(pTemp, tmp___9, nRes, 0);
  if (tmp___10) {
    rc = 7;
    goto end_of_vacuum;
  } else
  if (! isMemDb) {
    tmp___11 = sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0);
    if (tmp___11) {
      rc = 7;
      goto end_of_vacuum;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (db->mallocFailed) {
    rc = 7;
    goto end_of_vacuum;
  }
  if ((int )db->nextAutovac >= 0) {
    tmp___13 = (int )db->nextAutovac;
  } else {
    tmp___12 = sqlite3BtreeGetAutoVacuum(pMain);
    tmp___13 = tmp___12;
  }
  sqlite3BtreeSetAutoVacuum(pTemp, tmp___13);
  db->init.iDb = (u8 )nDb;
  rc = execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_master WHERE type=\'table\'AND name<>\'sqlite_sequence\' AND coalesce(rootpage,1)>0",
                zDbMain);
  if (rc != 0) {
    goto end_of_vacuum;
  }
  rc = execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_master WHERE type=\'index\'",
                zDbMain);
  if (rc != 0) {
    goto end_of_vacuum;
  }
  db->init.iDb = (u8 )0;
  rc = execSqlF(db, pzErrMsg, "SELECT\'INSERT INTO vacuum_db.\'||quote(name)||\' SELECT*FROM\"%w\".\'||quote(name)FROM vacuum_db.sqlite_master WHERE type=\'table\'AND coalesce(rootpage,1)>0",
                zDbMain);
  db->mDbFlags &= 4294967291U;
  if (rc != 0) {
    goto end_of_vacuum;
  }
  rc = execSqlF(db, pzErrMsg, "INSERT INTO vacuum_db.sqlite_master SELECT*FROM \"%w\".sqlite_master WHERE type IN(\'view\',\'trigger\') OR(type=\'table\'AND rootpage=0)",
                zDbMain);
  if (rc) {
    goto end_of_vacuum;
  }
  i = 0;
  while (i < (int )(sizeof(aCopy) / sizeof(aCopy[0]))) {
    sqlite3BtreeGetMeta(pMain, (int )aCopy[i], & meta);
    rc = sqlite3BtreeUpdateMeta(pTemp, (int )aCopy[i], meta + (u32 )aCopy[i + 1]);
    if (rc != 0) {
      goto end_of_vacuum;
    }
    i += 2;
  }
  if ((unsigned long )pOut == (unsigned long )((sqlite3_value *)0)) {
    rc = sqlite3BtreeCopyFile(pMain, pTemp);
  }
  if (rc != 0) {
    goto end_of_vacuum;
  }
  rc = sqlite3BtreeCommit(pTemp);
  if (rc != 0) {
    goto end_of_vacuum;
  }
  if ((unsigned long )pOut == (unsigned long )((sqlite3_value *)0)) {
    tmp___14 = sqlite3BtreeGetAutoVacuum(pTemp);
    sqlite3BtreeSetAutoVacuum(pMain, tmp___14);
  }
  if ((unsigned long )pOut == (unsigned long )((sqlite3_value *)0)) {
    tmp___15 = sqlite3BtreeGetPageSize(pTemp);
    rc = sqlite3BtreeSetPageSize(pMain, tmp___15, nRes, 1);
  }
  end_of_vacuum: 
  db->init.iDb = (u8 )0;
  db->mDbFlags = saved_mDbFlags;
  db->flags = saved_flags;
  db->nChange = saved_nChange;
  db->nTotalChange = saved_nTotalChange;
  db->mTrace = saved_mTrace;
  sqlite3BtreeSetPageSize(pMain, -1, -1, 1);
  db->autoCommit = (u8 )1;
  if (pDb) {
    sqlite3BtreeClose(pDb->pBt);
    pDb->pBt = (Btree *)0;
    pDb->pSchema = (Schema *)0;
  }
  sqlite3ResetAllSchemasOfConnection(db);
  return (rc);
}
}
static Module *sqlite3VtabCreateModule(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                                       void *pAux , void (*xDestroy)(void * ) ) 
{ 
  Module *pMod ;
  Module *pDel ;
  char *zCopy ;
  int nName ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )pModule == (unsigned long )((sqlite3_module const   *)0)) {
    zCopy = (char *)zName;
    pMod = (Module *)0;
  } else {
    tmp = sqlite3Strlen30(zName);
    nName = tmp;
    tmp___0 = sqlite3Malloc((u64 )((sizeof(Module ) + (unsigned long )nName) + 1UL));
    pMod = (Module *)tmp___0;
    if ((unsigned long )pMod == (unsigned long )((Module *)0)) {
      sqlite3OomFault(db);
      return ((Module *)0);
    }
    zCopy = (char *)(pMod + 1);
    memcpy((void * __restrict  )zCopy, (void const   * __restrict  )zName, (size_t )(nName + 1));
    pMod->zName = (char const   *)zCopy;
    pMod->pModule = pModule;
    pMod->pAux = pAux;
    pMod->xDestroy = xDestroy;
    pMod->pEpoTab = (Table *)0;
    pMod->nRefModule = 1;
  }
  tmp___1 = sqlite3HashInsert(& db->aModule, (char const   *)zCopy, (void *)pMod);
  pDel = (Module *)tmp___1;
  if (pDel) {
    if ((unsigned long )pDel == (unsigned long )pMod) {
      sqlite3OomFault(db);
      sqlite3DbFree(db, (void *)pDel);
      pMod = (Module *)0;
    } else {
      sqlite3VtabEponymousTableClear(db, pDel);
      sqlite3VtabModuleUnref(db, pDel);
    }
  }
  return (pMod);
}
}
static int createModule(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                        void *pAux , void (*xDestroy)(void * ) ) 
{ 
  int rc ;

  {
  rc = 0;
  sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);
  rc = sqlite3ApiExit(db, rc);
  if (rc != 0) {
    if (xDestroy) {
      (*xDestroy)(pAux);
    }
  }
  return (rc);
}
}
int sqlite3_create_module(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                          void *pAux ) 
{ 
  int tmp ;

  {
  tmp = createModule(db, zName, pModule, pAux, (void (*)(void * ))0);
  return (tmp);
}
}
int sqlite3_create_module_v2(sqlite3 *db , char const   *zName , sqlite3_module const   *pModule ,
                             void *pAux , void (*xDestroy)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = createModule(db, zName, pModule, pAux, xDestroy);
  return (tmp);
}
}
int sqlite3_drop_modules(sqlite3 *db , char const   **azNames ) 
{ 
  HashElem *pThis ;
  HashElem *pNext ;
  Module *pMod ;
  int ii ;
  int tmp ;

  {
  pThis = db->aModule.first;
  while (pThis) {
    pMod = (Module *)pThis->data;
    pNext = pThis->next;
    if (azNames) {
      ii = 0;
      while (1) {
        if ((unsigned long )*(azNames + ii) != (unsigned long )((char const   *)0)) {
          tmp = strcmp(*(azNames + ii), pMod->zName);
          if (! (tmp != 0)) {
            break;
          }
        } else {
          break;
        }
        ii ++;
      }
      if ((unsigned long )*(azNames + ii) != (unsigned long )((char const   *)0)) {
        goto __Cont;
      }
    }
    createModule(db, pMod->zName, (sqlite3_module const   *)0, (void *)0, (void (*)(void * ))0);
    __Cont: /* CIL Label */ 
    pThis = pNext;
  }
  return (0);
}
}
static void sqlite3VtabModuleUnref(sqlite3 *db , Module *pMod ) 
{ 


  {
  (pMod->nRefModule) --;
  if (pMod->nRefModule == 0) {
    if (pMod->xDestroy) {
      (*(pMod->xDestroy))(pMod->pAux);
    }
    sqlite3DbFree(db, (void *)pMod);
  }
  return;
}
}
static void sqlite3VtabLock(VTable *pVTab ) 
{ 


  {
  (pVTab->nRef) ++;
  return;
}
}
static VTable *sqlite3GetVTable(sqlite3 *db , Table *pTab ) 
{ 
  VTable *pVtab ;

  {
  pVtab = pTab->pVTable;
  while (1) {
    if (pVtab) {
      if (! ((unsigned long )pVtab->db != (unsigned long )db)) {
        break;
      }
    } else {
      break;
    }
    pVtab = pVtab->pNext;
  }
  return (pVtab);
}
}
static void sqlite3VtabUnlock(VTable *pVTab ) 
{ 
  sqlite3 *db ;
  sqlite3_vtab *p ;

  {
  db = pVTab->db;
  (pVTab->nRef) --;
  if (pVTab->nRef == 0) {
    p = pVTab->pVtab;
    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);
    if (p) {
      (*((p->pModule)->xDisconnect))(p);
    }
    sqlite3DbFree(db, (void *)pVTab);
  }
  return;
}
}
static VTable *vtabDisconnectAll(sqlite3 *db , Table *p ) 
{ 
  VTable *pRet ;
  VTable *pVTable ;
  sqlite3 *db2 ;
  VTable *pNext ;

  {
  pRet = (VTable *)0;
  pVTable = p->pVTable;
  p->pVTable = (VTable *)0;
  while (pVTable) {
    db2 = pVTable->db;
    pNext = pVTable->pNext;
    if ((unsigned long )db2 == (unsigned long )db) {
      pRet = pVTable;
      p->pVTable = pRet;
      pRet->pNext = (VTable *)0;
    } else {
      pVTable->pNext = db2->pDisconnect;
      db2->pDisconnect = pVTable;
    }
    pVTable = pNext;
  }
  return (pRet);
}
}
static void sqlite3VtabDisconnect(sqlite3 *db , Table *p ) 
{ 
  VTable **ppVTab ;
  VTable *pVTab ;

  {
  ppVTab = & p->pVTable;
  while (*ppVTab) {
    if ((unsigned long )(*ppVTab)->db == (unsigned long )db) {
      pVTab = *ppVTab;
      *ppVTab = pVTab->pNext;
      sqlite3VtabUnlock(pVTab);
      break;
    }
    ppVTab = & (*ppVTab)->pNext;
  }
  return;
}
}
static void sqlite3VtabUnlockList(sqlite3 *db ) 
{ 
  VTable *p ;
  VTable *pNext ;

  {
  p = db->pDisconnect;
  db->pDisconnect = (VTable *)0;
  if (p) {
    sqlite3ExpirePreparedStatements(db, 0);
    while (1) {
      pNext = p->pNext;
      sqlite3VtabUnlock(p);
      p = pNext;
      if (! p) {
        break;
      }
    }
  }
  return;
}
}
static void sqlite3VtabClear(sqlite3 *db , Table *p ) 
{ 
  int i ;

  {
  if (! db) {
    vtabDisconnectAll((sqlite3 *)0, p);
  } else
  if ((unsigned long )db->pnBytesFreed == (unsigned long )((int *)0)) {
    vtabDisconnectAll((sqlite3 *)0, p);
  }
  if (p->azModuleArg) {
    i = 0;
    while (i < p->nModuleArg) {
      if (i != 1) {
        sqlite3DbFree(db, (void *)*(p->azModuleArg + i));
      }
      i ++;
    }
    sqlite3DbFree(db, (void *)p->azModuleArg);
  }
  return;
}
}
static void addModuleArgument(Parse *pParse , Table *pTable , char *zArg ) 
{ 
  sqlite_int64 nBytes ;
  char **azModuleArg ;
  sqlite3 *db ;
  void *tmp ;
  int i ;
  int tmp___0 ;

  {
  nBytes = (sqlite_int64 )(sizeof(char *) * (unsigned long )(2 + pTable->nModuleArg));
  db = pParse->db;
  if (pTable->nModuleArg + 3 >= db->aLimit[2]) {
    sqlite3ErrorMsg(pParse, "too many columns on %s", pTable->zName);
  }
  tmp = sqlite3DbRealloc(db, (void *)pTable->azModuleArg, (u64 )nBytes);
  azModuleArg = (char **)tmp;
  if ((unsigned long )azModuleArg == (unsigned long )((char **)0)) {
    sqlite3DbFree(db, (void *)zArg);
  } else {
    tmp___0 = pTable->nModuleArg;
    (pTable->nModuleArg) ++;
    i = tmp___0;
    *(azModuleArg + i) = zArg;
    *(azModuleArg + (i + 1)) = (char *)0;
    pTable->azModuleArg = azModuleArg;
  }
  return;
}
}
static void sqlite3VtabBeginParse(Parse *pParse , Token *pName1 , Token *pName2 ,
                                  Token *pModuleName , int ifNotExists ) 
{ 
  Table *pTable ;
  sqlite3 *db ;
  char *tmp ;
  char *tmp___0 ;
  int iDb ;
  int tmp___1 ;

  {
  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);
  pTable = pParse->pNewTable;
  if ((unsigned long )pTable == (unsigned long )((Table *)0)) {
    return;
  }
  db = pParse->db;
  tmp = sqlite3NameFromToken(db, pModuleName);
  addModuleArgument(pParse, pTable, tmp);
  addModuleArgument(pParse, pTable, (char *)0);
  tmp___0 = sqlite3DbStrDup(db, (char const   *)pTable->zName);
  addModuleArgument(pParse, pTable, tmp___0);
  pParse->sNameToken.n = (unsigned int )((int )((pModuleName->z + pModuleName->n) - pParse->sNameToken.z));
  if (pTable->azModuleArg) {
    tmp___1 = sqlite3SchemaToIndex(db, pTable->pSchema);
    iDb = tmp___1;
    sqlite3AuthCheck(pParse, 29, (char const   *)pTable->zName, (char const   *)*(pTable->azModuleArg + 0),
                     (char const   *)((pParse->db)->aDb + iDb)->zDbSName);
  }
  return;
}
}
static void addArgumentToVtab(Parse *pParse ) 
{ 
  char const   *z ;
  int n ;
  sqlite3 *db ;
  char *tmp ;

  {
  if (pParse->sArg.z) {
    if (pParse->pNewTable) {
      z = pParse->sArg.z;
      n = (int )pParse->sArg.n;
      db = pParse->db;
      tmp = sqlite3DbStrNDup(db, z, (u64 )n);
      addModuleArgument(pParse, pParse->pNewTable, tmp);
    }
  }
  return;
}
}
static void sqlite3VtabFinishParse(Parse *pParse , Token *pEnd ) 
{ 
  Table *pTab ;
  sqlite3 *db ;
  char *zStmt ;
  char *zWhere ;
  int iDb ;
  int iReg ;
  Vdbe *v ;
  Table *pOld ;
  Schema *pSchema ;
  char const   *zName ;
  void *tmp ;

  {
  pTab = pParse->pNewTable;
  db = pParse->db;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return;
  }
  addArgumentToVtab(pParse);
  pParse->sArg.z = (char const   *)0;
  if (pTab->nModuleArg < 1) {
    return;
  }
  if (! db->init.busy) {
    if (pEnd) {
      pParse->sNameToken.n = (unsigned int )((int )(pEnd->z - pParse->sNameToken.z)) + pEnd->n;
    }
    zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", & pParse->sNameToken);
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    sqlite3NestedParse(pParse, "UPDATE %Q.%s SET type=\'table\', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q WHERE rowid=#%d",
                       (db->aDb + iDb)->zDbSName, "sqlite_master", pTab->zName, pTab->zName,
                       zStmt, pParse->regRowid);
    sqlite3DbFree(db, (void *)zStmt);
    v = sqlite3GetVdbe(pParse);
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp0(v, 158);
    zWhere = sqlite3MPrintf(db, "name=\'%q\' AND type=\'table\'", pTab->zName);
    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);
    (pParse->nMem) ++;
    iReg = pParse->nMem;
    sqlite3VdbeLoadString(v, iReg, (char const   *)pTab->zName);
    sqlite3VdbeAddOp2(v, 161, iDb, iReg);
  } else {
    pSchema = pTab->pSchema;
    zName = (char const   *)pTab->zName;
    tmp = sqlite3HashInsert(& pSchema->tblHash, zName, (void *)pTab);
    pOld = (Table *)tmp;
    if (pOld) {
      sqlite3OomFault(db);
      return;
    }
    pParse->pNewTable = (Table *)0;
  }
  return;
}
}
static void sqlite3VtabArgInit(Parse *pParse ) 
{ 


  {
  addArgumentToVtab(pParse);
  pParse->sArg.z = (char const   *)0;
  pParse->sArg.n = 0U;
  return;
}
}
static void sqlite3VtabArgExtend(Parse *pParse , Token *p ) 
{ 
  Token *pArg ;

  {
  pArg = & pParse->sArg;
  if ((unsigned long )pArg->z == (unsigned long )((char const   *)0)) {
    pArg->z = p->z;
    pArg->n = p->n;
  } else {
    pArg->n = (unsigned int )((int )((p->z + p->n) - pArg->z));
  }
  return;
}
}
static int vtabCallConstructor(sqlite3 *db , Table *pTab , Module *pMod , int (*xConstruct)(sqlite3 * ,
                                                                                            void * ,
                                                                                            int  ,
                                                                                            char const   * const  * ,
                                                                                            sqlite3_vtab ** ,
                                                                                            char ** ) ,
                               char **pzErr ) 
{ 
  VtabCtx sCtx ;
  VTable *pVTable ;
  int rc ;
  char const   * const  *azArg ;
  int nArg ;
  char *zErr ;
  char *zModuleName ;
  int iDb ;
  VtabCtx *pCtx ;
  void *tmp ;
  char const   *zFormat ;
  int iCol ;
  u8 oooHidden ;
  char *zType ;
  char *tmp___0 ;
  int nType ;
  int i ;
  int tmp___1 ;
  int j ;
  int nDel ;
  int tmp___2 ;

  {
  azArg = (char const   * const  *)pTab->azModuleArg;
  nArg = pTab->nModuleArg;
  zErr = (char *)0;
  pCtx = db->pVtabCtx;
  while (pCtx) {
    if ((unsigned long )pCtx->pTab == (unsigned long )pTab) {
      *pzErr = sqlite3MPrintf(db, "vtable constructor called recursively: %s", pTab->zName);
      return (6);
    }
    pCtx = pCtx->pPrior;
  }
  zModuleName = sqlite3DbStrDup(db, (char const   *)pTab->zName);
  if (! zModuleName) {
    return (7);
  }
  tmp = sqlite3MallocZero((u64 )sizeof(VTable ));
  pVTable = (VTable *)tmp;
  if (! pVTable) {
    sqlite3OomFault(db);
    sqlite3DbFree(db, (void *)zModuleName);
    return (7);
  }
  pVTable->db = db;
  pVTable->pMod = pMod;
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  *(pTab->azModuleArg + 1) = (db->aDb + iDb)->zDbSName;
  sCtx.pTab = pTab;
  sCtx.pVTable = pVTable;
  sCtx.pPrior = db->pVtabCtx;
  sCtx.bDeclared = 0;
  db->pVtabCtx = & sCtx;
  rc = (*xConstruct)(db, pMod->pAux, nArg, azArg, & pVTable->pVtab, & zErr);
  db->pVtabCtx = sCtx.pPrior;
  if (rc == 7) {
    sqlite3OomFault(db);
  }
  if (0 != rc) {
    if ((unsigned long )zErr == (unsigned long )((char *)0)) {
      *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
    } else {
      *pzErr = sqlite3MPrintf(db, "%s", zErr);
      sqlite3_free((void *)zErr);
    }
    sqlite3DbFree(db, (void *)pVTable);
  } else
  if (pVTable->pVtab) {
    memset((void *)pVTable->pVtab, 0, sizeof(*(pVTable->pVtab + 0)));
    (pVTable->pVtab)->pModule = pMod->pModule;
    (pMod->nRefModule) ++;
    pVTable->nRef = 1;
    if (sCtx.bDeclared == 0) {
      zFormat = "vtable constructor did not declare schema: %s";
      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
      sqlite3VtabUnlock(pVTable);
      rc = 1;
    } else {
      oooHidden = (u8 )0;
      pVTable->pNext = pTab->pVTable;
      pTab->pVTable = pVTable;
      iCol = 0;
      while (iCol < (int )pTab->nCol) {
        tmp___0 = sqlite3ColumnType(pTab->aCol + iCol, (char *)"");
        zType = tmp___0;
        i = 0;
        nType = sqlite3Strlen30((char const   *)zType);
        i = 0;
        while (i < nType) {
          tmp___1 = sqlite3_strnicmp("hidden", (char const   *)(zType + i), 6);
          if (0 == tmp___1) {
            if (i == 0) {
              goto _L;
            } else
            if ((int )*(zType + (i - 1)) == 32) {
              _L: /* CIL Label */ 
              if ((int )*(zType + (i + 6)) == 0) {
                break;
              } else
              if ((int )*(zType + (i + 6)) == 32) {
                break;
              }
            }
          }
          i ++;
        }
        if (i < nType) {
          if (*(zType + (i + 6))) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
          nDel = 6 + tmp___2;
          j = i;
          while (j + nDel <= nType) {
            *(zType + j) = *(zType + (j + nDel));
            j ++;
          }
          if ((int )*(zType + i) == 0) {
            if (i > 0) {
              *(zType + (i - 1)) = (char )'\000';
            }
          }
          (pTab->aCol + iCol)->colFlags = (u8 )((int )(pTab->aCol + iCol)->colFlags | 2);
          oooHidden = (u8 )128;
        } else {
          pTab->tabFlags |= (unsigned int )oooHidden;
        }
        iCol ++;
      }
    }
  }
  sqlite3DbFree(db, (void *)zModuleName);
  return (rc);
}
}
static int sqlite3VtabCallConnect(Parse *pParse , Table *pTab ) 
{ 
  sqlite3 *db ;
  char const   *zMod ;
  Module *pMod ;
  int rc ;
  VTable *tmp ;
  void *tmp___0 ;
  char const   *zModule ;
  char *zErr ;

  {
  db = pParse->db;
  if (! pTab->nModuleArg) {
    return (0);
  } else {
    tmp = sqlite3GetVTable(db, pTab);
    if (tmp) {
      return (0);
    }
  }
  zMod = (char const   *)*(pTab->azModuleArg + 0);
  tmp___0 = sqlite3HashFind((Hash const   *)(& db->aModule), zMod);
  pMod = (Module *)tmp___0;
  if (! pMod) {
    zModule = (char const   *)*(pTab->azModuleArg + 0);
    sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
    rc = 1;
  } else {
    zErr = (char *)0;
    rc = vtabCallConstructor(db, pTab, pMod, (int (*)(sqlite3 * , void * , int  ,
                                                      char const   * const  * , sqlite3_vtab ** ,
                                                      char ** ))(pMod->pModule)->xConnect,
                             & zErr);
    if (rc != 0) {
      sqlite3ErrorMsg(pParse, "%s", zErr);
      pParse->rc = rc;
    }
    sqlite3DbFree(db, (void *)zErr);
  }
  return (rc);
}
}
static int growVTrans(sqlite3 *db ) 
{ 
  int ARRAY_INCR ;
  VTable **aVTrans ;
  sqlite_int64 nBytes ;
  void *tmp ;

  {
  ARRAY_INCR = 5;
  if (db->nVTrans % ARRAY_INCR == 0) {
    nBytes = (sqlite_int64 )((unsigned long long )sizeof(sqlite3_vtab *) * (unsigned long long )((sqlite_int64 )db->nVTrans + (sqlite_int64 )ARRAY_INCR));
    tmp = sqlite3DbRealloc(db, (void *)db->aVTrans, (u64 )nBytes);
    aVTrans = (VTable **)tmp;
    if (! aVTrans) {
      return (7);
    }
    memset((void *)(aVTrans + db->nVTrans), 0, sizeof(sqlite3_vtab *) * (unsigned long )ARRAY_INCR);
    db->aVTrans = aVTrans;
  }
  return (0);
}
}
static void addToVTrans(sqlite3 *db , VTable *pVTab ) 
{ 
  int tmp ;

  {
  tmp = db->nVTrans;
  (db->nVTrans) ++;
  *(db->aVTrans + tmp) = pVTab;
  sqlite3VtabLock(pVTab);
  return;
}
}
static int sqlite3VtabCallCreate(sqlite3 *db , int iDb , char const   *zTab , char **pzErr ) 
{ 
  int rc ;
  Table *pTab ;
  Module *pMod ;
  char const   *zMod ;
  void *tmp ;
  VTable *tmp___0 ;
  VTable *tmp___1 ;

  {
  rc = 0;
  pTab = sqlite3FindTable(db, zTab, (char const   *)(db->aDb + iDb)->zDbSName);
  zMod = (char const   *)*(pTab->azModuleArg + 0);
  tmp = sqlite3HashFind((Hash const   *)(& db->aModule), zMod);
  pMod = (Module *)tmp;
  if ((unsigned long )pMod == (unsigned long )((Module *)0)) {
    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
    rc = 1;
  } else
  if ((unsigned long )(pMod->pModule)->xCreate == (unsigned long )((int (* const  )(sqlite3 * ,
                                                                                    void *pAux ,
                                                                                    int argc ,
                                                                                    char const   * const  *argv ,
                                                                                    sqlite3_vtab **ppVTab ,
                                                                                    char ** ))0)) {
    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
    rc = 1;
  } else
  if ((unsigned long )(pMod->pModule)->xDestroy == (unsigned long )((int (* const  )(sqlite3_vtab *pVTab ))0)) {
    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
    rc = 1;
  } else {
    rc = vtabCallConstructor(db, pTab, pMod, (int (*)(sqlite3 * , void * , int  ,
                                                      char const   * const  * , sqlite3_vtab ** ,
                                                      char ** ))(pMod->pModule)->xCreate,
                             pzErr);
  }
  if (rc == 0) {
    tmp___1 = sqlite3GetVTable(db, pTab);
    if (tmp___1) {
      rc = growVTrans(db);
      if (rc == 0) {
        tmp___0 = sqlite3GetVTable(db, pTab);
        addToVTrans(db, tmp___0);
      }
    }
  }
  return (rc);
}
}
int sqlite3_declare_vtab(sqlite3 *db , char const   *zCreateTable ) 
{ 
  VtabCtx *pCtx ;
  int rc ;
  Table *pTab ;
  char *zErr ;
  Parse sParse ;
  int tmp ;
  Table *pNew ;
  Index *pIdx ;
  Index *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  rc = 0;
  zErr = (char *)0;
  pCtx = db->pVtabCtx;
  if (! pCtx) {
    sqlite3Error(db, 21);
    tmp = sqlite3MisuseError(136196);
    return (tmp);
  } else
  if (pCtx->bDeclared) {
    sqlite3Error(db, 21);
    tmp = sqlite3MisuseError(136196);
    return (tmp);
  }
  pTab = pCtx->pTab;
  memset((void *)(& sParse), 0, sizeof(sParse));
  sParse.eParseMode = (u8 )1;
  sParse.db = db;
  sParse.nQueryLoop = (u32 )1;
  tmp___2 = sqlite3RunParser(& sParse, zCreateTable, & zErr);
  if (0 == tmp___2) {
    if (sParse.pNewTable) {
      if (! db->mallocFailed) {
        if (! (sParse.pNewTable)->pSelect) {
          if (! (sParse.pNewTable)->nModuleArg) {
            if (! pTab->aCol) {
              pNew = sParse.pNewTable;
              pTab->aCol = pNew->aCol;
              pTab->nCol = pNew->nCol;
              pTab->tabFlags |= pNew->tabFlags & 96U;
              pNew->nCol = (i16 )0;
              pNew->aCol = (Column *)0;
              if (! ((pNew->tabFlags & 32U) == 0U)) {
                if ((unsigned long )(((pCtx->pVTable)->pMod)->pModule)->xUpdate != (unsigned long )((int (* const  )(sqlite3_vtab * ,
                                                                                                                     int  ,
                                                                                                                     sqlite3_value ** ,
                                                                                                                     sqlite_int64 * ))0)) {
                  tmp___0 = sqlite3PrimaryKeyIndex(pNew);
                  if ((int )tmp___0->nKeyCol != 1) {
                    rc = 1;
                  }
                }
              }
              pIdx = pNew->pIndex;
              if (pIdx) {
                pTab->pIndex = pIdx;
                pNew->pIndex = (Index *)0;
                pIdx->pTable = pTab;
              }
            }
            pCtx->bDeclared = 1;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    if (zErr) {
      tmp___1 = "%s";
    } else {
      tmp___1 = (char const   *)0;
    }
    sqlite3ErrorWithMsg(db, 1, tmp___1, zErr);
    sqlite3DbFree(db, (void *)zErr);
    rc = 1;
  }
  sParse.eParseMode = (u8 )0;
  if (sParse.pVdbe) {
    sqlite3VdbeFinalize(sParse.pVdbe);
  }
  sqlite3DeleteTable(db, sParse.pNewTable);
  sqlite3ParserReset(& sParse);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
static int sqlite3VtabCallDestroy(sqlite3 *db , int iDb , char const   *zTab ) 
{ 
  int rc ;
  Table *pTab ;
  VTable *p ;
  int (*xDestroy)(sqlite3_vtab * ) ;

  {
  rc = 0;
  pTab = sqlite3FindTable(db, zTab, (char const   *)(db->aDb + iDb)->zDbSName);
  if ((unsigned long )pTab != (unsigned long )((Table *)0)) {
    if ((unsigned long )pTab->pVTable != (unsigned long )((VTable *)0)) {
      p = pTab->pVTable;
      while (p) {
        if ((p->pVtab)->nRef > 0) {
          return (6);
        }
        p = p->pNext;
      }
      p = vtabDisconnectAll(db, pTab);
      xDestroy = (int (*)(sqlite3_vtab * ))((p->pMod)->pModule)->xDestroy;
      (pTab->nTabRef) ++;
      rc = (*xDestroy)(p->pVtab);
      if (rc == 0) {
        p->pVtab = (sqlite3_vtab *)0;
        pTab->pVTable = (VTable *)0;
        sqlite3VtabUnlock(p);
      }
      sqlite3DeleteTable(db, pTab);
    }
  }
  return (rc);
}
}
static void callFinaliser(sqlite3 *db , int offset ) 
{ 
  int i ;
  VTable **aVTrans ;
  VTable *pVTab ;
  sqlite3_vtab *p ;
  int (*x___0)(sqlite3_vtab * ) ;

  {
  if (db->aVTrans) {
    aVTrans = db->aVTrans;
    db->aVTrans = (VTable **)0;
    i = 0;
    while (i < db->nVTrans) {
      pVTab = *(aVTrans + i);
      p = pVTab->pVtab;
      if (p) {
        x___0 = *((int (**)(sqlite3_vtab * ))((char *)p->pModule + offset));
        if (x___0) {
          (*x___0)(p);
        }
      }
      pVTab->iSavepoint = 0;
      sqlite3VtabUnlock(pVTab);
      i ++;
    }
    sqlite3DbFree(db, (void *)aVTrans);
    db->nVTrans = 0;
  }
  return;
}
}
static int sqlite3VtabSync(sqlite3 *db , Vdbe *p ) 
{ 
  int i ;
  int rc ;
  VTable **aVTrans ;
  int (*x___0)(sqlite3_vtab * ) ;
  sqlite3_vtab *pVtab ;

  {
  rc = 0;
  aVTrans = db->aVTrans;
  db->aVTrans = (VTable **)0;
  i = 0;
  while (1) {
    if (rc == 0) {
      if (! (i < db->nVTrans)) {
        break;
      }
    } else {
      break;
    }
    pVtab = (*(aVTrans + i))->pVtab;
    if (pVtab) {
      x___0 = (int (*)(sqlite3_vtab * ))(pVtab->pModule)->xSync;
      if ((unsigned long )x___0 != (unsigned long )((int (*)(sqlite3_vtab * ))0)) {
        rc = (*x___0)(pVtab);
        sqlite3VtabImportErrmsg(p, pVtab);
      }
    }
    i ++;
  }
  db->aVTrans = aVTrans;
  return (rc);
}
}
static int sqlite3VtabRollback(sqlite3 *db ) 
{ 


  {
  callFinaliser(db, (int )((unsigned long )(& ((sqlite3_module *)0)->xRollback)));
  return (0);
}
}
static int sqlite3VtabCommit(sqlite3 *db ) 
{ 


  {
  callFinaliser(db, (int )((unsigned long )(& ((sqlite3_module *)0)->xCommit)));
  return (0);
}
}
static int sqlite3VtabBegin(sqlite3 *db , VTable *pVTab ) 
{ 
  int rc ;
  sqlite3_module const   *pModule ;
  int i ;
  int iSvpt ;

  {
  rc = 0;
  if (db->nVTrans > 0) {
    if ((unsigned long )db->aVTrans == (unsigned long )((VTable **)0)) {
      return (6);
    }
  }
  if (! pVTab) {
    return (0);
  }
  pModule = (pVTab->pVtab)->pModule;
  if (pModule->xBegin) {
    i = 0;
    while (i < db->nVTrans) {
      if ((unsigned long )*(db->aVTrans + i) == (unsigned long )pVTab) {
        return (0);
      }
      i ++;
    }
    rc = growVTrans(db);
    if (rc == 0) {
      rc = (*(pModule->xBegin))(pVTab->pVtab);
      if (rc == 0) {
        iSvpt = db->nStatement + db->nSavepoint;
        addToVTrans(db, pVTab);
        if (iSvpt) {
          if (pModule->xSavepoint) {
            pVTab->iSavepoint = iSvpt;
            rc = (*(pModule->xSavepoint))(pVTab->pVtab, iSvpt - 1);
          }
        }
      }
    }
  }
  return (rc);
}
}
static int sqlite3VtabSavepoint(sqlite3 *db , int op , int iSavepoint ) 
{ 
  int rc ;
  int i ;
  VTable *pVTab ;
  sqlite3_module const   *pMod ;
  int (*xMethod)(sqlite3_vtab * , int  ) ;

  {
  rc = 0;
  if (db->aVTrans) {
    i = 0;
    while (1) {
      if (rc == 0) {
        if (! (i < db->nVTrans)) {
          break;
        }
      } else {
        break;
      }
      pVTab = *(db->aVTrans + i);
      pMod = (pVTab->pMod)->pModule;
      if (pVTab->pVtab) {
        if (pMod->iVersion >= 2) {
          sqlite3VtabLock(pVTab);
          switch (op) {
          case 0: 
          xMethod = (int (*)(sqlite3_vtab * , int  ))pMod->xSavepoint;
          pVTab->iSavepoint = iSavepoint + 1;
          break;
          case 2: 
          xMethod = (int (*)(sqlite3_vtab * , int  ))pMod->xRollbackTo;
          break;
          default: 
          xMethod = (int (*)(sqlite3_vtab * , int  ))pMod->xRelease;
          break;
          }
          if (xMethod) {
            if (pVTab->iSavepoint > iSavepoint) {
              rc = (*xMethod)(pVTab->pVtab, iSavepoint);
            }
          }
          sqlite3VtabUnlock(pVTab);
        }
      }
      i ++;
    }
  }
  return (rc);
}
}
static FuncDef *sqlite3VtabOverloadFunction(sqlite3 *db , FuncDef *pDef , int nArg ,
                                            Expr *pExpr ) 
{ 
  Table *pTab ;
  sqlite3_vtab *pVtab ;
  sqlite3_module *pMod ;
  void (*xSFunc)(sqlite3_context * , int  , sqlite3_value ** ) ;
  void *pArg ;
  FuncDef *pNew ;
  int rc ;
  VTable *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  xSFunc = (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0;
  pArg = (void *)0;
  rc = 0;
  if ((unsigned long )pExpr == (unsigned long )((Expr *)0)) {
    return (pDef);
  }
  if ((int )pExpr->op != 162) {
    return (pDef);
  }
  pTab = pExpr->y.pTab;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return (pDef);
  }
  if (! pTab->nModuleArg) {
    return (pDef);
  }
  tmp = sqlite3GetVTable(db, pTab);
  pVtab = tmp->pVtab;
  pMod = (sqlite3_module *)pVtab->pModule;
  if ((unsigned long )pMod->xFindFunction == (unsigned long )((int (*)(sqlite3_vtab *pVtab ,
                                                                       int nArg ,
                                                                       char const   *zName ,
                                                                       void (**pxFunc)(sqlite3_context * ,
                                                                                       int  ,
                                                                                       sqlite3_value ** ) ,
                                                                       void **ppArg ))0)) {
    return (pDef);
  }
  rc = (*(pMod->xFindFunction))(pVtab, nArg, pDef->zName, & xSFunc, & pArg);
  if (rc == 0) {
    return (pDef);
  }
  tmp___0 = sqlite3Strlen30(pDef->zName);
  tmp___1 = sqlite3DbMallocZero(db, (u64 )((sizeof(*pNew) + (unsigned long )tmp___0) + 1UL));
  pNew = (FuncDef *)tmp___1;
  if ((unsigned long )pNew == (unsigned long )((FuncDef *)0)) {
    return (pDef);
  }
  *pNew = *pDef;
  pNew->zName = (char const   *)(pNew + 1);
  tmp___2 = sqlite3Strlen30(pDef->zName);
  memcpy((void * __restrict  )((char *)(pNew + 1)), (void const   * __restrict  )pDef->zName,
         (size_t )(tmp___2 + 1));
  pNew->xSFunc = xSFunc;
  pNew->pUserData = pArg;
  pNew->funcFlags |= 16U;
  return (pNew);
}
}
static void sqlite3VtabMakeWritable(Parse *pParse , Table *pTab ) 
{ 
  Parse *pToplevel ;
  Parse *tmp ;
  int i ;
  int n ;
  Table **apVtabLock ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  if (pParse->pToplevel) {
    tmp = pParse->pToplevel;
  } else {
    tmp = pParse;
  }
  pToplevel = tmp;
  i = 0;
  while (i < pToplevel->nVtabLock) {
    if ((unsigned long )pTab == (unsigned long )*(pToplevel->apVtabLock + i)) {
      return;
    }
    i ++;
  }
  n = (int )((unsigned long )(pToplevel->nVtabLock + 1) * sizeof(*(pToplevel->apVtabLock + 0)));
  tmp___0 = sqlite3_realloc64((void *)pToplevel->apVtabLock, (sqlite_uint64 )n);
  apVtabLock = (Table **)tmp___0;
  if (apVtabLock) {
    pToplevel->apVtabLock = apVtabLock;
    tmp___1 = pToplevel->nVtabLock;
    (pToplevel->nVtabLock) ++;
    *(pToplevel->apVtabLock + tmp___1) = pTab;
  } else {
    sqlite3OomFault(pToplevel->db);
  }
  return;
}
}
static int sqlite3VtabEponymousTableInit(Parse *pParse , Module *pMod ) 
{ 
  sqlite3_module const   *pModule ;
  Table *pTab ;
  char *zErr ;
  int rc ;
  sqlite3 *db ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  pModule = pMod->pModule;
  zErr = (char *)0;
  db = pParse->db;
  if (pMod->pEpoTab) {
    return (1);
  }
  if ((unsigned long )pModule->xCreate != (unsigned long )((int (* const  )(sqlite3 * ,
                                                                            void *pAux ,
                                                                            int argc ,
                                                                            char const   * const  *argv ,
                                                                            sqlite3_vtab **ppVTab ,
                                                                            char ** ))0)) {
    if ((unsigned long )pModule->xCreate != (unsigned long )pModule->xConnect) {
      return (0);
    }
  }
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(Table ));
  pTab = (Table *)tmp;
  if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
    return (0);
  }
  pTab->zName = sqlite3DbStrDup(db, pMod->zName);
  if ((unsigned long )pTab->zName == (unsigned long )((char *)0)) {
    sqlite3DbFree(db, (void *)pTab);
    return (0);
  }
  pMod->pEpoTab = pTab;
  pTab->nTabRef = (u32 )1;
  pTab->pSchema = (db->aDb + 0)->pSchema;
  pTab->iPKey = (i16 )-1;
  tmp___0 = sqlite3DbStrDup(db, (char const   *)pTab->zName);
  addModuleArgument(pParse, pTab, tmp___0);
  addModuleArgument(pParse, pTab, (char *)0);
  tmp___1 = sqlite3DbStrDup(db, (char const   *)pTab->zName);
  addModuleArgument(pParse, pTab, tmp___1);
  rc = vtabCallConstructor(db, pTab, pMod, (int (*)(sqlite3 * , void * , int  , char const   * const  * ,
                                                    sqlite3_vtab ** , char ** ))pModule->xConnect,
                           & zErr);
  if (rc) {
    sqlite3ErrorMsg(pParse, "%s", zErr);
    sqlite3DbFree(db, (void *)zErr);
    sqlite3VtabEponymousTableClear(db, pMod);
    return (0);
  }
  return (1);
}
}
static void sqlite3VtabEponymousTableClear(sqlite3 *db , Module *pMod ) 
{ 
  Table *pTab ;

  {
  pTab = pMod->pEpoTab;
  if ((unsigned long )pTab != (unsigned long )((Table *)0)) {
    pTab->tabFlags |= 2U;
    sqlite3DeleteTable(db, pTab);
    pMod->pEpoTab = (Table *)0;
  }
  return;
}
}
static unsigned char const   aMap[5]  = {      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )3,      (unsigned char const   )2, 
        (unsigned char const   )5};
int sqlite3_vtab_on_conflict(sqlite3 *db ) 
{ 


  {
  return ((int )aMap[(int )db->vtabOnConflict - 1]);
}
}
int sqlite3_vtab_config(sqlite3 *db , int op  , ...) 
{ 
  va_list ap ;
  int rc ;
  VtabCtx *p ;
  int tmp___0 ;

  {
  rc = 0;
  __builtin_va_start(ap, op);
  switch (op) {
  case 1: 
  p = db->pVtabCtx;
  if (! p) {
    rc = sqlite3MisuseError(136673);
  } else {
    tmp___0 = __builtin_va_arg(ap, int );
    (p->pVTable)->bConstraint = (u8 )tmp___0;
  }
  break;
  default: 
  rc = sqlite3MisuseError(136681);
  break;
  }
  __builtin_va_end(ap);
  if (rc != 0) {
    sqlite3Error(db, rc);
  }
  return (rc);
}
}
static Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet , int iCursor ) ;
static WhereTerm *sqlite3WhereFindTerm(WhereClause *pWC , int iCur , int iColumn ,
                                       Bitmask notReady , u32 op , Index *pIdx ) ;
static int sqlite3WhereExplainOneScan(Parse *pParse , SrcList *pTabList , WhereLevel *pLevel ,
                                      u16 wctrlFlags ) ;
static Bitmask sqlite3WhereCodeOneLoopStart(Parse *pParse , Vdbe *v , WhereInfo *pWInfo ,
                                            int iLevel , WhereLevel *pLevel , Bitmask notReady ) ;
static void sqlite3WhereClauseInit(WhereClause *pWC , WhereInfo *pWInfo ) ;
static void sqlite3WhereClauseClear(WhereClause *pWC ) ;
static void sqlite3WhereSplit(WhereClause *pWC , Expr *pExpr , u8 op ) ;
static Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet , Expr *p ) ;
static Bitmask sqlite3WhereExprUsageNN(WhereMaskSet *pMaskSet , Expr *p ) ;
static Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet , ExprList *pList ) ;
static void sqlite3WhereExprAnalyze(SrcList *pTabList , WhereClause *pWC ) ;
static void sqlite3WhereTabFuncArgs(Parse *pParse , struct SrcList_item *pItem , WhereClause *pWC ) ;
static char const   *explainIndexColumnName(Index *pIdx , int i ) 
{ 


  {
  i = (int )*(pIdx->aiColumn + i);
  if (i == -2) {
    return ("<expr>");
  }
  if (i == -1) {
    return ("rowid");
  }
  return ((char const   *)((pIdx->pTable)->aCol + i)->zName);
}
}
static void explainAppendTerm(StrAccum *pStr , Index *pIdx , int nTerm , int iTerm ,
                              int bAnd , char const   *zOp ) 
{ 
  int i ;
  char const   *tmp ;

  {
  if (bAnd) {
    sqlite3_str_append(pStr, " AND ", 5);
  }
  if (nTerm > 1) {
    sqlite3_str_append(pStr, "(", 1);
  }
  i = 0;
  while (i < nTerm) {
    if (i) {
      sqlite3_str_append(pStr, ",", 1);
    }
    tmp = explainIndexColumnName(pIdx, iTerm + i);
    sqlite3_str_appendall(pStr, tmp);
    i ++;
  }
  if (nTerm > 1) {
    sqlite3_str_append(pStr, ")", 1);
  }
  sqlite3_str_append(pStr, zOp, 1);
  if (nTerm > 1) {
    sqlite3_str_append(pStr, "(", 1);
  }
  i = 0;
  while (i < nTerm) {
    if (i) {
      sqlite3_str_append(pStr, ",", 1);
    }
    sqlite3_str_append(pStr, "?", 1);
    i ++;
  }
  if (nTerm > 1) {
    sqlite3_str_append(pStr, ")", 1);
  }
  return;
}
}
static void explainIndexRange(StrAccum *pStr , WhereLoop *pLoop ) 
{ 
  Index *pIndex ;
  u16 nEq ;
  u16 nSkip ;
  int i ;
  int j ;
  char const   *z ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  pIndex = pLoop->u.btree.pIndex;
  nEq = pLoop->u.btree.nEq;
  nSkip = pLoop->nSkip;
  if ((int )nEq == 0) {
    if ((pLoop->wsFlags & 48U) == 0U) {
      return;
    }
  }
  sqlite3_str_append(pStr, " (", 2);
  i = 0;
  while (i < (int )nEq) {
    tmp = explainIndexColumnName(pIndex, i);
    z = tmp;
    if (i) {
      sqlite3_str_append(pStr, " AND ", 5);
    }
    if (i >= (int )nSkip) {
      tmp___0 = "%s=?";
    } else {
      tmp___0 = "ANY(%s)";
    }
    sqlite3_str_appendf(pStr, tmp___0, z);
    i ++;
  }
  j = i;
  if (pLoop->wsFlags & 32U) {
    explainAppendTerm(pStr, pIndex, (int )pLoop->u.btree.nBtm, j, i, ">");
    i = 1;
  }
  if (pLoop->wsFlags & 16U) {
    explainAppendTerm(pStr, pIndex, (int )pLoop->u.btree.nTop, j, i, "<");
  }
  sqlite3_str_append(pStr, ")", 1);
  return;
}
}
static int sqlite3WhereExplainOneScan(Parse *pParse , SrcList *pTabList , WhereLevel *pLevel ,
                                      u16 wctrlFlags ) 
{ 
  int ret ;
  struct SrcList_item *pItem ;
  Vdbe *v ;
  sqlite3 *db ;
  int isSearch ;
  WhereLoop *pLoop ;
  u32 flags___0 ;
  char *zMsg ;
  StrAccum str ;
  char zBuf[100] ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *zFmt ;
  Index *pIdx ;
  char const   *zRangeOp ;
  int tmp___1 ;
  Parse *tmp___2 ;

  {
  ret = 0;
  if (pParse->pToplevel) {
    tmp___2 = pParse->pToplevel;
  } else {
    tmp___2 = pParse;
  }
  if ((int )tmp___2->explain == 2) {
    pItem = & pTabList->a[pLevel->iFrom];
    v = pParse->pVdbe;
    db = pParse->db;
    pLoop = pLevel->pWLoop;
    flags___0 = pLoop->wsFlags;
    if (flags___0 & 8192U) {
      return (0);
    } else
    if ((int )wctrlFlags & 32) {
      return (0);
    }
    if ((flags___0 & 48U) != 0U) {
      tmp = 1;
    } else
    if ((flags___0 & 1024U) == 0U) {
      if ((int )pLoop->u.btree.nEq > 0) {
        tmp = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int )wctrlFlags & 3) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    isSearch = tmp;
    sqlite3StrAccumInit(& str, db, zBuf, (int )sizeof(zBuf), 1000000000);
    if (isSearch) {
      tmp___0 = "SEARCH";
    } else {
      tmp___0 = "SCAN";
    }
    sqlite3_str_appendall(& str, tmp___0);
    if (pItem->pSelect) {
      sqlite3_str_appendf(& str, " SUBQUERY %u", (pItem->pSelect)->selId);
    } else {
      sqlite3_str_appendf(& str, " TABLE %s", pItem->zName);
    }
    if (pItem->zAlias) {
      sqlite3_str_appendf(& str, " AS %s", pItem->zAlias);
    }
    if ((flags___0 & 1280U) == 0U) {
      zFmt = (char const   *)0;
      pIdx = pLoop->u.btree.pIndex;
      if (! (((pItem->pTab)->tabFlags & 32U) == 0U)) {
        if (pIdx->idxType == 2U) {
          if (isSearch) {
            zFmt = "PRIMARY KEY";
          }
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (flags___0 & 131072U) {
        zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
      } else
      if (flags___0 & 16384U) {
        zFmt = "AUTOMATIC COVERING INDEX";
      } else
      if (flags___0 & 64U) {
        zFmt = "COVERING INDEX %s";
      } else {
        zFmt = "INDEX %s";
      }
      if (zFmt) {
        sqlite3_str_append(& str, " USING ", 7);
        sqlite3_str_appendf(& str, zFmt, pIdx->zName);
        explainIndexRange(& str, pLoop);
      }
    } else
    if ((flags___0 & 256U) != 0U) {
      if ((flags___0 & 15U) != 0U) {
        if (flags___0 & 5U) {
          zRangeOp = "=";
        } else
        if ((flags___0 & 48U) == 48U) {
          zRangeOp = ">? AND rowid<";
        } else
        if (flags___0 & 32U) {
          zRangeOp = ">";
        } else {
          zRangeOp = "<";
        }
        sqlite3_str_appendf(& str, " USING INTEGER PRIMARY KEY (rowid%s?)", zRangeOp);
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if ((flags___0 & 1024U) != 0U) {
      sqlite3_str_appendf(& str, " VIRTUAL TABLE INDEX %d:%s", pLoop->u.vtab.idxNum,
                          pLoop->u.vtab.idxStr);
    }
    zMsg = sqlite3StrAccumFinish(& str);
    tmp___1 = sqlite3VdbeCurrentAddr(v);
    ret = sqlite3VdbeAddOp4(v, 171, tmp___1, pParse->addrExplain, 0, (char const   *)zMsg,
                            -7);
  }
  return (ret);
}
}
static void disableTerm(WhereLevel *pLevel , WhereTerm *pTerm ) 
{ 
  int nLoop ;

  {
  nLoop = 0;
  while (1) {
    if (((int )pTerm->wtFlags & 4) == 0) {
      if (pLevel->iLeftJoin == 0) {
        goto _L;
      } else
      if (((pTerm->pExpr)->flags & 1U) != 0U) {
        _L: /* CIL Label */ 
        if (! ((pLevel->notReady & pTerm->prereqAll) == 0ULL)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (nLoop) {
      if (((int )pTerm->wtFlags & 1024) != 0) {
        pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 512);
      } else {
        pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
      }
    } else {
      pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
    }
    if (pTerm->iParent < 0) {
      break;
    }
    pTerm = (pTerm->pWC)->a + pTerm->iParent;
    pTerm->nChild = (u8 )((int )pTerm->nChild - 1);
    if ((int )pTerm->nChild != 0) {
      break;
    }
    nLoop ++;
  }
  return;
}
}
static void codeApplyAffinity(Parse *pParse , int base , int n , char *zAff___0 ) 
{ 
  Vdbe *v ;

  {
  v = pParse->pVdbe;
  if ((unsigned long )zAff___0 == (unsigned long )((char *)0)) {
    return;
  }
  while (1) {
    if (n > 0) {
      if (! ((int )*(zAff___0 + 0) <= 65)) {
        break;
      }
    } else {
      break;
    }
    n --;
    base ++;
    zAff___0 ++;
  }
  while (1) {
    if (n > 1) {
      if (! ((int )*(zAff___0 + (n - 1)) <= 65)) {
        break;
      }
    } else {
      break;
    }
    n --;
  }
  if (n > 0) {
    sqlite3VdbeAddOp4(v, 91, base, n, 0, (char const   *)zAff___0, n);
  }
  return;
}
}
static void updateRangeAffinityStr(Expr *pRight , int n , char *zAff___0 ) 
{ 
  int i ;
  Expr *p ;
  Expr *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  i = 0;
  while (i < n) {
    tmp = sqlite3VectorFieldSubexpr(pRight, i);
    p = tmp;
    tmp___0 = sqlite3CompareAffinity(p, *(zAff___0 + i));
    if ((int )tmp___0 == 65) {
      *(zAff___0 + i) = (char)65;
    } else {
      tmp___1 = sqlite3ExprNeedsNoAffinityChange((Expr const   *)p, *(zAff___0 + i));
      if (tmp___1) {
        *(zAff___0 + i) = (char)65;
      }
    }
    i ++;
  }
  return;
}
}
static Expr *removeUnindexableInClauseTerms(Parse *pParse , int iEq , WhereLoop *pLoop ,
                                            Expr *pX ) 
{ 
  sqlite3 *db ;
  Expr *pNew ;
  Expr *tmp ;
  ExprList *pOrigRhs ;
  ExprList *pOrigLhs ;
  ExprList *pRhs ;
  ExprList *pLhs ;
  int i ;
  Select *pSelect ;
  int iField ;
  Expr *p ;
  ExprList *pOrderBy ;

  {
  db = pParse->db;
  tmp = sqlite3ExprDup(db, pX, 0);
  pNew = tmp;
  if ((int )db->mallocFailed == 0) {
    pOrigRhs = (pNew->x.pSelect)->pEList;
    pOrigLhs = (pNew->pLeft)->x.pList;
    pRhs = (ExprList *)0;
    pLhs = (ExprList *)0;
    i = iEq;
    while (i < (int )pLoop->nLTerm) {
      if ((unsigned long )(*(pLoop->aLTerm + i))->pExpr == (unsigned long )pX) {
        iField = (*(pLoop->aLTerm + i))->iField - 1;
        if ((unsigned long )pOrigRhs->a[iField].pExpr == (unsigned long )((Expr *)0)) {
          goto __Cont;
        }
        pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);
        pOrigRhs->a[iField].pExpr = (Expr *)0;
        pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs->a[iField].pExpr);
        pOrigLhs->a[iField].pExpr = (Expr *)0;
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
    sqlite3ExprListDelete(db, pOrigRhs);
    sqlite3ExprListDelete(db, pOrigLhs);
    (pNew->pLeft)->x.pList = pLhs;
    (pNew->x.pSelect)->pEList = pRhs;
    if (pLhs) {
      if (pLhs->nExpr == 1) {
        p = pLhs->a[0].pExpr;
        pLhs->a[0].pExpr = (Expr *)0;
        sqlite3ExprDelete(db, pNew->pLeft);
        pNew->pLeft = p;
      }
    }
    pSelect = pNew->x.pSelect;
    if (pSelect->pOrderBy) {
      pOrderBy = pSelect->pOrderBy;
      i = 0;
      while (i < pOrderBy->nExpr) {
        pOrderBy->a[i].u.x.iOrderByCol = (u16 )0;
        i ++;
      }
    }
  }
  return (pNew);
}
}
static int codeEqualityTerm(Parse *pParse , WhereTerm *pTerm , WhereLevel *pLevel ,
                            int iEq , int bRev , int iTarget ) 
{ 
  Expr *pX ;
  Vdbe *v ;
  int iReg ;
  int eType ;
  int iTab ;
  struct InLoop *pIn ;
  WhereLoop *pLoop ;
  int i ;
  int nEq ;
  int *aiMap ;
  sqlite3 *db ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int iMap ;
  int iOut ;
  int iCol ;
  int tmp___2 ;
  int tmp___3 ;

  {
  pX = pTerm->pExpr;
  v = pParse->pVdbe;
  if ((int )pX->op == 53) {
    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
  } else
  if ((int )pX->op == 45) {
    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
  } else
  if ((int )pX->op == 50) {
    iReg = iTarget;
    sqlite3VdbeAddOp2(v, 73, 0, iReg);
  } else {
    eType = 5;
    pLoop = pLevel->pWLoop;
    nEq = 0;
    aiMap = (int *)0;
    if ((pLoop->wsFlags & 1024U) == 0U) {
      if ((unsigned long )pLoop->u.btree.pIndex != (unsigned long )((Index *)0)) {
        if (*((pLoop->u.btree.pIndex)->aSortOrder + iEq)) {
          bRev = ! bRev;
        }
      }
    }
    iReg = iTarget;
    i = 0;
    while (i < iEq) {
      if (*(pLoop->aLTerm + i)) {
        if ((unsigned long )(*(pLoop->aLTerm + i))->pExpr == (unsigned long )pX) {
          disableTerm(pLevel, pTerm);
          return (iTarget);
        }
      }
      i ++;
    }
    i = iEq;
    while (i < (int )pLoop->nLTerm) {
      if ((unsigned long )(*(pLoop->aLTerm + i))->pExpr == (unsigned long )pX) {
        nEq ++;
      }
      i ++;
    }
    iTab = 0;
    if ((pX->flags & 2048U) == 0U) {
      eType = sqlite3FindInIndex(pParse, pX, (u32 )4, (int *)0, (int *)0, & iTab);
    } else
    if (((pX->x.pSelect)->pEList)->nExpr == 1) {
      eType = sqlite3FindInIndex(pParse, pX, (u32 )4, (int *)0, (int *)0, & iTab);
    } else {
      db = pParse->db;
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
      if (! db->mallocFailed) {
        tmp = sqlite3DbMallocZero(pParse->db, (u64 )(sizeof(int ) * (unsigned long )nEq));
        aiMap = (int *)tmp;
        eType = sqlite3FindInIndex(pParse, pX, (u32 )4, (int *)0, aiMap, & iTab);
        (pTerm->pExpr)->iTable = iTab;
      }
      sqlite3ExprDelete(db, pX);
      pX = pTerm->pExpr;
    }
    if (eType == 4) {
      bRev = ! bRev;
    }
    if (bRev) {
      tmp___0 = 32;
    } else {
      tmp___0 = 36;
    }
    sqlite3VdbeAddOp2(v, tmp___0, iTab, 0);
    pLoop->wsFlags |= 2048U;
    if (pLevel->u.in.nIn == 0) {
      pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);
    }
    i = pLevel->u.in.nIn;
    pLevel->u.in.nIn += nEq;
    tmp___1 = sqlite3DbReallocOrFree(pParse->db, (void *)pLevel->u.in.aInLoop, (u64 )(sizeof(*(pLevel->u.in.aInLoop + 0)) * (unsigned long )pLevel->u.in.nIn));
    pLevel->u.in.aInLoop = (struct InLoop *)tmp___1;
    pIn = pLevel->u.in.aInLoop;
    if (pIn) {
      iMap = 0;
      pIn += i;
      i = iEq;
      while (i < (int )pLoop->nLTerm) {
        if ((unsigned long )(*(pLoop->aLTerm + i))->pExpr == (unsigned long )pX) {
          iOut = (iReg + i) - iEq;
          if (eType == 1) {
            pIn->addrInTop = sqlite3VdbeAddOp2(v, 128, iTab, iOut);
          } else {
            if (aiMap) {
              tmp___2 = iMap;
              iMap ++;
              tmp___3 = *(aiMap + tmp___2);
            } else {
              tmp___3 = 0;
            }
            iCol = tmp___3;
            pIn->addrInTop = sqlite3VdbeAddOp3(v, 90, iTab, iCol, iOut);
          }
          sqlite3VdbeAddOp1(v, 50, iOut);
          if (i == iEq) {
            pIn->iCur = iTab;
            if (bRev) {
              pIn->eEndLoopOp = (u8 )4;
            } else {
              pIn->eEndLoopOp = (u8 )5;
            }
            if (iEq > 0) {
              if ((pLoop->wsFlags & 1024U) == 0U) {
                pIn->iBase = iReg - i;
                pIn->nPrefix = i;
                pLoop->wsFlags |= 262144U;
              } else {
                pIn->nPrefix = 0;
              }
            } else {
              pIn->nPrefix = 0;
            }
          } else {
            pIn->eEndLoopOp = (u8 )170;
          }
          pIn ++;
        }
        i ++;
      }
    } else {
      pLevel->u.in.nIn = 0;
    }
    sqlite3DbFree(pParse->db, (void *)aiMap);
  }
  disableTerm(pLevel, pTerm);
  return (iReg);
}
}
static int codeAllEqualityTerms(Parse *pParse , WhereLevel *pLevel , int bRev , int nExtraReg ,
                                char **pzAff ) 
{ 
  u16 nEq ;
  u16 nSkip ;
  Vdbe *v ;
  Index *pIdx ;
  WhereTerm *pTerm ;
  WhereLoop *pLoop ;
  int j ;
  int regBase ;
  int nReg ;
  char *zAff___0 ;
  char const   *tmp ;
  int iIdxCur ;
  int tmp___0 ;
  int tmp___1 ;
  int r1 ;
  Expr *pRight ;
  int tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;

  {
  v = pParse->pVdbe;
  pLoop = pLevel->pWLoop;
  nEq = pLoop->u.btree.nEq;
  nSkip = pLoop->nSkip;
  pIdx = pLoop->u.btree.pIndex;
  regBase = pParse->nMem + 1;
  nReg = (int )pLoop->u.btree.nEq + nExtraReg;
  pParse->nMem += nReg;
  tmp = sqlite3IndexAffinityStr(pParse->db, pIdx);
  zAff___0 = sqlite3DbStrDup(pParse->db, tmp);
  if (nSkip) {
    iIdxCur = pLevel->iIdxCur;
    if (bRev) {
      tmp___0 = 32;
    } else {
      tmp___0 = 36;
    }
    sqlite3VdbeAddOp1(v, tmp___0, iIdxCur);
    j = sqlite3VdbeAddOp0(v, 11);
    if (bRev) {
      tmp___1 = 22;
    } else {
      tmp___1 = 25;
    }
    pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, tmp___1, iIdxCur, 0, regBase, (int )nSkip);
    sqlite3VdbeJumpHere(v, j);
    j = 0;
    while (j < (int )nSkip) {
      sqlite3VdbeAddOp3(v, 90, iIdxCur, j, regBase + j);
      j ++;
    }
  }
  j = (int )nSkip;
  while (j < (int )nEq) {
    pTerm = *(pLoop->aLTerm + j);
    r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase + j);
    if (r1 != regBase + j) {
      if (nReg == 1) {
        sqlite3ReleaseTempReg(pParse, regBase);
        regBase = r1;
      } else {
        sqlite3VdbeAddOp2(v, 79, r1, regBase + j);
      }
    }
    if ((int )pTerm->eOperator & 1) {
      if ((pTerm->pExpr)->flags & 2048U) {
        if (zAff___0) {
          *(zAff___0 + j) = (char)65;
        }
      }
    } else
    if (((int )pTerm->eOperator & 256) == 0) {
      pRight = (pTerm->pExpr)->pRight;
      if (((int )pTerm->wtFlags & 2048) == 0) {
        tmp___2 = sqlite3ExprCanBeNull((Expr const   *)pRight);
        if (tmp___2) {
          sqlite3VdbeAddOp2(v, 50, regBase + j, pLevel->addrBrk);
        }
      }
      if (zAff___0) {
        tmp___3 = sqlite3CompareAffinity(pRight, *(zAff___0 + j));
        if ((int )tmp___3 == 65) {
          *(zAff___0 + j) = (char)65;
        }
        tmp___4 = sqlite3ExprNeedsNoAffinityChange((Expr const   *)pRight, *(zAff___0 + j));
        if (tmp___4) {
          *(zAff___0 + j) = (char)65;
        }
      }
    }
    j ++;
  }
  *pzAff = zAff___0;
  return (regBase);
}
}
static void whereLikeOptimizationStringFixup(Vdbe *v , WhereLevel *pLevel , WhereTerm *pTerm ) 
{ 
  VdbeOp *pOp ;

  {
  if ((int )pTerm->wtFlags & 256) {
    pOp = sqlite3VdbeGetOp(v, -1);
    pOp->p3 = (int )(pLevel->iLikeRepCntr >> 1);
    pOp->p5 = (u16 )((u8 )(pLevel->iLikeRepCntr & 1U));
  }
  return;
}
}
static void codeDeferredSeek(WhereInfo *pWInfo , Index *pIdx , int iCur , int iIdxCur ) 
{ 
  Parse *pParse ;
  Vdbe *v ;
  int i ;
  Table *pTab ;
  int *ai ;
  void *tmp ;
  Parse *tmp___0 ;

  {
  pParse = pWInfo->pParse;
  v = pParse->pVdbe;
  sqlite3VdbeAddOp3(v, 134, iIdxCur, 0, iCur);
  if ((int )pWInfo->wctrlFlags & 32) {
    if (pParse->pToplevel) {
      tmp___0 = pParse->pToplevel;
    } else {
      tmp___0 = pParse;
    }
    if (tmp___0->writeMask == 0U) {
      pTab = pIdx->pTable;
      tmp = sqlite3DbMallocZero(pParse->db, (u64 )(sizeof(int ) * (unsigned long )((int )pTab->nCol + 1)));
      ai = (int *)tmp;
      if (ai) {
        *(ai + 0) = (int )pTab->nCol;
        i = 0;
        while (i < (int )pIdx->nColumn - 1) {
          if ((int )*(pIdx->aiColumn + i) >= 0) {
            *(ai + ((int )*(pIdx->aiColumn + i) + 1)) = i + 1;
          }
          i ++;
        }
        sqlite3VdbeChangeP4(v, -1, (char const   *)((char *)ai), -15);
      }
    }
  }
  return;
}
}
static void codeExprOrVector(Parse *pParse , Expr *p , int iReg , int nReg ) 
{ 
  Vdbe *v ;
  int iSelect ;
  int i ;
  ExprList *pList ;
  int tmp ;

  {
  if (p) {
    tmp = sqlite3ExprIsVector(p);
    if (tmp) {
      if (p->flags & 2048U) {
        v = pParse->pVdbe;
        iSelect = sqlite3CodeSubselect(pParse, p);
        sqlite3VdbeAddOp3(v, 78, iSelect, iReg, nReg - 1);
      } else {
        pList = p->x.pList;
        i = 0;
        while (i < nReg) {
          sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg + i);
          i ++;
        }
      }
    } else {
      sqlite3ExprCode(pParse, p, iReg);
    }
  } else {
    sqlite3ExprCode(pParse, p, iReg);
  }
  return;
}
}
static int whereIndexExprTransNode(Walker *p , Expr *pExpr ) 
{ 
  IdxExprTrans *pX ;
  int tmp ;

  {
  pX = p->u.pIdxTrans;
  tmp = sqlite3ExprCompare((Parse *)0, pExpr, pX->pIdxExpr, pX->iTabCur);
  if (tmp == 0) {
    pExpr->affExpr = sqlite3ExprAffinity(pExpr);
    pExpr->op = (u8 )162;
    pExpr->iTable = pX->iIdxCur;
    pExpr->iColumn = (ynVar )pX->iIdxCol;
    pExpr->y.pTab = (Table *)0;
    return (1);
  } else {
    return (0);
  }
}
}
static void whereIndexExprTrans(Index *pIdx , int iTabCur , int iIdxCur , WhereInfo *pWInfo ) 
{ 
  int iIdxCol ;
  ExprList *aColExpr ;
  Walker w ;
  IdxExprTrans x___0 ;

  {
  aColExpr = pIdx->aColExpr;
  if ((unsigned long )aColExpr == (unsigned long )((ExprList *)0)) {
    return;
  }
  memset((void *)(& w), 0, sizeof(w));
  w.xExprCallback = & whereIndexExprTransNode;
  w.u.pIdxTrans = & x___0;
  x___0.iTabCur = iTabCur;
  x___0.iIdxCur = iIdxCur;
  iIdxCol = 0;
  while (iIdxCol < aColExpr->nExpr) {
    if ((int )*(pIdx->aiColumn + iIdxCol) != -2) {
      goto __Cont;
    }
    x___0.iIdxCol = iIdxCol;
    x___0.pIdxExpr = aColExpr->a[iIdxCol].pExpr;
    sqlite3WalkExpr(& w, pWInfo->pWhere);
    sqlite3WalkExprList(& w, pWInfo->pOrderBy);
    sqlite3WalkExprList(& w, pWInfo->pResultSet);
    __Cont: /* CIL Label */ 
    iIdxCol ++;
  }
  return;
}
}
static void whereApplyPartialIndexConstraints(Expr *pTruth , int iTabCur , WhereClause *pWC ) 
{ 
  int i ;
  WhereTerm *pTerm ;
  Expr *pExpr ;
  int tmp ;

  {
  while ((int )pTruth->op == 44) {
    whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);
    pTruth = pTruth->pRight;
  }
  i = 0;
  pTerm = pWC->a;
  while (i < pWC->nTerm) {
    if ((int )pTerm->wtFlags & 4) {
      goto __Cont;
    }
    pExpr = pTerm->pExpr;
    tmp = sqlite3ExprCompare((Parse *)0, pExpr, pTruth, iTabCur);
    if (tmp == 0) {
      pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
    }
    __Cont: /* CIL Label */ 
    i ++;
    pTerm ++;
  }
  return;
}
}
static u8 const   aStartOp[8]  = 
  {      (u8 const   )0,      (u8 const   )0,      (u8 const   )36,      (u8 const   )32, 
        (u8 const   )25,      (u8 const   )22,      (u8 const   )24,      (u8 const   )23};
static u8 const   aEndOp[4]  = {      (u8 const   )40,      (u8 const   )38,      (u8 const   )37,      (u8 const   )39};
static u8 const   aStep[2]  = {      (u8 const   )5,      (u8 const   )4};
static u8 const   aStart[2]  = {      (u8 const   )36,      (u8 const   )32};
static Bitmask sqlite3WhereCodeOneLoopStart(Parse *pParse , Vdbe *v , WhereInfo *pWInfo ,
                                            int iLevel , WhereLevel *pLevel , Bitmask notReady ) 
{ 
  int j ;
  int k ;
  int iCur ;
  int addrNxt ;
  int bRev ;
  WhereLoop *pLoop ;
  WhereClause *pWC ;
  WhereTerm *pTerm ;
  sqlite3 *db ;
  struct SrcList_item *pTabItem ;
  int addrBrk ;
  int addrHalt ;
  int addrCont ;
  int iRowidReg ;
  int iReleaseReg ;
  Index *pIdx ;
  int iLoop ;
  Bitmask tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int regYield ;
  int iReg ;
  int addrNotFound ;
  int nConstraint ;
  int iIn ;
  int iTarget ;
  Expr *pRight ;
  int tmp___3 ;
  Expr *pCompare ;
  Expr *pRight___0 ;
  VdbeOp *pOp ;
  int testOp ;
  int start ;
  int memEndValue ;
  WhereTerm *pStart ;
  WhereTerm *pEnd ;
  int tmp___4 ;
  int tmp___5 ;
  Expr *pX ;
  int r1 ;
  int rTemp ;
  int op ;
  u8 aMoveOp[4] ;
  int tmp___6 ;
  int tmp___7 ;
  Expr *pX___0 ;
  int tmp___8 ;
  int tmp___9 ;
  u16 nEq ;
  u16 nBtm ;
  u16 nTop ;
  int regBase ;
  WhereTerm *pRangeStart ;
  WhereTerm *pRangeEnd ;
  int startEq ;
  int endEq ;
  int start_constraints ;
  int nConstraint___0 ;
  int iIdxCur ;
  int nExtraReg ;
  int op___0 ;
  char *zStartAff ;
  char *zEndAff ;
  u8 bSeekPastNull ;
  u8 bStopAtNull ;
  int omitTable ;
  int regBignull ;
  int tmp___10 ;
  int tmp___11 ;
  WhereTerm *t ;
  u8 t___0 ;
  u8 t___1 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  Expr *pRight___1 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  Expr *pRight___2 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  Index *pPk ;
  Index *tmp___23 ;
  i16 tmp___24 ;
  WhereClause *pOrWc ;
  SrcList *pOrTab ;
  Index *pCov ;
  int iCovCur ;
  int tmp___25 ;
  int regReturn ;
  int regRowset ;
  int regRowid ;
  int iLoopBody ;
  int tmp___26 ;
  int iRetInit ;
  int untestedTerms ;
  int ii ;
  u16 wctrlFlags ;
  Expr *pAndExpr ;
  Table *pTab ;
  int nNotReady ;
  struct SrcList_item *origSrc ;
  void *tmp___27 ;
  Index *pPk___0 ;
  Index *tmp___28 ;
  int tmp___29 ;
  int iTerm ;
  Expr *pExpr ;
  WhereTerm *pOrTerm ;
  WhereInfo *pSubWInfo ;
  Expr *pOrExpr ;
  int jmp1 ;
  WhereLoop *pSubLoop ;
  int addrExplain ;
  int tmp___30 ;
  int iSet ;
  int tmp___31 ;
  Index *pPk___1 ;
  Index *tmp___32 ;
  int nPk ;
  int iPk ;
  int r ;
  int iCol ;
  int tmp___33 ;
  int tmp___34 ;
  int iNext ;
  Expr *pE ;
  int skipLikeAddr ;
  int tmp___35 ;
  u32 x___0 ;
  int tmp___36 ;
  Expr *pE___0 ;
  Expr sEAlt ;
  WhereTerm *pAlt ;

  {
  iRowidReg = 0;
  iReleaseReg = 0;
  pIdx = (Index *)0;
  pWC = & pWInfo->sWC;
  db = pParse->db;
  pLoop = pLevel->pWLoop;
  pTabItem = & (pWInfo->pTabList)->a[pLevel->iFrom];
  iCur = pTabItem->iCursor;
  tmp = sqlite3WhereGetMask(& pWInfo->sMaskSet, iCur);
  pLevel->notReady = notReady & ~ tmp;
  bRev = (int )((pWInfo->revMask >> iLevel) & 1ULL);
  tmp___1 = sqlite3VdbeMakeLabel(pParse);
  pLevel->addrNxt = tmp___1;
  tmp___0 = tmp___1;
  pLevel->addrBrk = tmp___0;
  addrBrk = tmp___0;
  tmp___2 = sqlite3VdbeMakeLabel(pParse);
  pLevel->addrCont = tmp___2;
  addrCont = tmp___2;
  if ((int )pLevel->iFrom > 0) {
    if (((int )(pTabItem + 0)->fg.jointype & 8) != 0) {
      (pParse->nMem) ++;
      pLevel->iLeftJoin = pParse->nMem;
      sqlite3VdbeAddOp2(v, 70, 0, pLevel->iLeftJoin);
    }
  }
  j = iLevel;
  while (1) {
    if (j > 0) {
      if (! (pWInfo->a[j].iLeftJoin == 0)) {
        break;
      }
    } else {
      break;
    }
    j --;
  }
  addrHalt = pWInfo->a[j].addrBrk;
  if (pTabItem->fg.viaCoroutine) {
    regYield = pTabItem->regReturn;
    sqlite3VdbeAddOp3(v, 13, regYield, 0, pTabItem->addrFillSub);
    pLevel->p2 = sqlite3VdbeAddOp2(v, 14, regYield, addrBrk);
    pLevel->op = (u8 )11;
  } else
  if ((pLoop->wsFlags & 1024U) != 0U) {
    nConstraint = (int )pLoop->nLTerm;
    iReg = sqlite3GetTempRange(pParse, nConstraint + 2);
    addrNotFound = pLevel->addrBrk;
    j = 0;
    while (j < nConstraint) {
      iTarget = (iReg + j) + 2;
      pTerm = *(pLoop->aLTerm + j);
      if ((unsigned long )pTerm == (unsigned long )((WhereTerm *)0)) {
        goto __Cont;
      }
      if ((int )pTerm->eOperator & 1) {
        codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
        addrNotFound = pLevel->addrNxt;
      } else {
        pRight = (pTerm->pExpr)->pRight;
        codeExprOrVector(pParse, pRight, iTarget, 1);
      }
      __Cont: /* CIL Label */ 
      j ++;
    }
    sqlite3VdbeAddOp2(v, 70, pLoop->u.vtab.idxNum, iReg);
    sqlite3VdbeAddOp2(v, 70, nConstraint, iReg + 1);
    if (pLoop->u.vtab.needFree) {
      tmp___3 = -7;
    } else {
      tmp___3 = -1;
    }
    sqlite3VdbeAddOp4(v, 9, iCur, addrNotFound, iReg, (char const   *)pLoop->u.vtab.idxStr,
                      tmp___3);
    pLoop->u.vtab.needFree = (u8 )0;
    pLevel->p1 = iCur;
    if (pWInfo->eOnePass) {
      pLevel->op = (u8 )170;
    } else {
      pLevel->op = (u8 )60;
    }
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);
    iIn = pLevel->u.in.nIn;
    j = nConstraint - 1;
    while (j >= 0) {
      pTerm = *(pLoop->aLTerm + j);
      if (j < 16) {
        if (((int )pLoop->u.vtab.omitMask >> j) & 1) {
          disableTerm(pLevel, pTerm);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (((int )pTerm->eOperator & 1) != 0) {
        if (! db->mallocFailed) {
          iIn --;
          pOp = sqlite3VdbeGetOp(v, (pLevel->u.in.aInLoop + iIn)->addrInTop);
          sqlite3VdbeAddOp3(v, (int )pOp->opcode, pOp->p1, pOp->p2, pOp->p3);
        }
        pCompare = sqlite3PExpr(pParse, 53, (Expr *)0, (Expr *)0);
        if (pCompare) {
          pCompare->pLeft = (pTerm->pExpr)->pLeft;
          pRight___0 = sqlite3Expr(db, 171, (char const   *)0);
          pCompare->pRight = pRight___0;
          if (pRight___0) {
            pRight___0->iTable = (iReg + j) + 2;
            sqlite3ExprIfFalse(pParse, pCompare, pLevel->addrCont, 0);
          }
          pCompare->pLeft = (Expr *)0;
          sqlite3ExprDelete(db, pCompare);
        }
      }
      j --;
    }
  } else
  if ((pLoop->wsFlags & 256U) != 0U) {
    if ((pLoop->wsFlags & 5U) != 0U) {
      pTerm = *(pLoop->aLTerm + 0);
      (pParse->nMem) ++;
      iReleaseReg = pParse->nMem;
      iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
      if (iRowidReg != iReleaseReg) {
        sqlite3ReleaseTempReg(pParse, iReleaseReg);
      }
      addrNxt = pLevel->addrNxt;
      sqlite3VdbeAddOp3(v, 30, iCur, addrNxt, iRowidReg);
      pLevel->op = (u8 )170;
      if ((pTerm->prereqAll & pLevel->notReady) == 0ULL) {
        pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
      }
    } else {
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
  if ((pLoop->wsFlags & 256U) != 0U) {
    if ((pLoop->wsFlags & 2U) != 0U) {
      testOp = 170;
      memEndValue = 0;
      j = 0;
      pEnd = (WhereTerm *)0;
      pStart = pEnd;
      if (pLoop->wsFlags & 32U) {
        tmp___4 = j;
        j ++;
        pStart = *(pLoop->aLTerm + tmp___4);
      }
      if (pLoop->wsFlags & 16U) {
        tmp___5 = j;
        j ++;
        pEnd = *(pLoop->aLTerm + tmp___5);
      }
      if (bRev) {
        pTerm = pStart;
        pStart = pEnd;
        pEnd = pTerm;
      }
      if (pStart) {
        aMoveOp[0] = (u8 )25;
        aMoveOp[1] = (u8 )23;
        aMoveOp[2] = (u8 )22;
        aMoveOp[3] = (u8 )24;
        pX = pStart->pExpr;
        tmp___6 = sqlite3ExprIsVector(pX->pRight);
        if (tmp___6) {
          rTemp = sqlite3GetTempReg(pParse);
          r1 = rTemp;
          codeExprOrVector(pParse, pX->pRight, r1, 1);
          op = (int )aMoveOp[((((int )pX->op - 54) - 1) & 3) | 1];
        } else {
          r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, & rTemp);
          disableTerm(pLevel, pStart);
          op = (int )aMoveOp[(int )pX->op - 54];
        }
        sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);
        sqlite3ReleaseTempReg(pParse, rTemp);
      } else {
        if (bRev) {
          tmp___7 = 32;
        } else {
          tmp___7 = 36;
        }
        sqlite3VdbeAddOp2(v, tmp___7, iCur, addrHalt);
      }
      if (pEnd) {
        pX___0 = pEnd->pExpr;
        (pParse->nMem) ++;
        memEndValue = pParse->nMem;
        codeExprOrVector(pParse, pX___0->pRight, memEndValue, 1);
        tmp___8 = sqlite3ExprIsVector(pX___0->pRight);
        if (0 == tmp___8) {
          if ((int )pX___0->op == 56) {
            goto _L___1;
          } else
          if ((int )pX___0->op == 54) {
            _L___1: /* CIL Label */ 
            if (bRev) {
              testOp = 55;
            } else {
              testOp = 57;
            }
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (bRev) {
          testOp = 56;
        } else {
          testOp = 54;
        }
        tmp___9 = sqlite3ExprIsVector(pX___0->pRight);
        if (0 == tmp___9) {
          disableTerm(pLevel, pEnd);
        }
      }
      start = sqlite3VdbeCurrentAddr(v);
      if (bRev) {
        pLevel->op = (u8 )4;
      } else {
        pLevel->op = (u8 )5;
      }
      pLevel->p1 = iCur;
      pLevel->p2 = start;
      if (testOp != 170) {
        (pParse->nMem) ++;
        iRowidReg = pParse->nMem;
        sqlite3VdbeAddOp2(v, 128, iCur, iRowidReg);
        sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
        sqlite3VdbeChangeP5(v, (u16 )83);
      }
    } else {
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
  if (pLoop->wsFlags & 512U) {
    nEq = pLoop->u.btree.nEq;
    nBtm = pLoop->u.btree.nBtm;
    nTop = pLoop->u.btree.nTop;
    pRangeStart = (WhereTerm *)0;
    pRangeEnd = (WhereTerm *)0;
    nExtraReg = 0;
    zEndAff = (char *)0;
    bSeekPastNull = (u8 )0;
    bStopAtNull = (u8 )0;
    regBignull = 0;
    pIdx = pLoop->u.btree.pIndex;
    iIdxCur = pLevel->iIdxCur;
    j = (int )nEq;
    if (pLoop->wsFlags & 32U) {
      tmp___10 = j;
      j ++;
      pRangeStart = *(pLoop->aLTerm + tmp___10);
      if (nExtraReg > (int )pLoop->u.btree.nBtm) {
        nExtraReg = nExtraReg;
      } else {
        nExtraReg = (int )pLoop->u.btree.nBtm;
      }
    }
    if (pLoop->wsFlags & 16U) {
      tmp___11 = j;
      j ++;
      pRangeEnd = *(pLoop->aLTerm + tmp___11);
      if (nExtraReg > (int )pLoop->u.btree.nTop) {
        nExtraReg = nExtraReg;
      } else {
        nExtraReg = (int )pLoop->u.btree.nTop;
      }
      if (((int )pRangeEnd->wtFlags & 256) != 0) {
        (pParse->nMem) ++;
        pLevel->iLikeRepCntr = (u32 )pParse->nMem;
        sqlite3VdbeAddOp2(v, 70, 1, (int )pLevel->iLikeRepCntr);
        pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);
        pLevel->iLikeRepCntr <<= 1;
        pLevel->iLikeRepCntr |= (unsigned int )(bRev ^ ((int )*(pIdx->aSortOrder + nEq) == 1));
      }
      if ((unsigned long )pRangeStart == (unsigned long )((WhereTerm *)0)) {
        j = (int )*(pIdx->aiColumn + nEq);
        if (j >= 0) {
          if ((int )((pIdx->pTable)->aCol + j)->notNull == 0) {
            bSeekPastNull = (u8 )1;
          } else {
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
        if (j == -2) {
          bSeekPastNull = (u8 )1;
        }
      }
    }
    if ((pLoop->wsFlags & 48U) == 0U) {
      if ((pLoop->wsFlags & 524288U) != 0U) {
        nExtraReg = 1;
        bSeekPastNull = (u8 )1;
        (pParse->nMem) ++;
        regBignull = pParse->nMem;
        pLevel->regBignull = regBignull;
        pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);
      }
    }
    if ((int )nEq < (int )pIdx->nKeyCol) {
      if (bRev == ((int )*(pIdx->aSortOrder + nEq) == 0)) {
        goto _L___3;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (bRev) {
      if ((int )pIdx->nKeyCol == (int )nEq) {
        _L___3: /* CIL Label */ 
        t = pRangeEnd;
        pRangeEnd = pRangeStart;
        pRangeStart = t;
        t___0 = bSeekPastNull;
        bSeekPastNull = bStopAtNull;
        bStopAtNull = t___0;
        t___1 = (u8 )nBtm;
        nBtm = nTop;
        nTop = (u16 )t___1;
      }
    }
    regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, & zStartAff);
    if (zStartAff) {
      if (nTop) {
        zEndAff = sqlite3DbStrDup(db, (char const   *)(zStartAff + nEq));
      }
    }
    if (regBignull) {
      addrNxt = pLevel->addrBignull;
    } else {
      addrNxt = pLevel->addrNxt;
    }
    if (! pRangeStart) {
      tmp___12 = 1;
    } else
    if ((int )pRangeStart->eOperator & ((2 << 2) | (2 << 4))) {
      tmp___12 = 1;
    } else {
      tmp___12 = 0;
    }
    startEq = tmp___12;
    if (! pRangeEnd) {
      tmp___13 = 1;
    } else
    if ((int )pRangeEnd->eOperator & ((2 << 2) | (2 << 4))) {
      tmp___13 = 1;
    } else {
      tmp___13 = 0;
    }
    endEq = tmp___13;
    if (pRangeStart) {
      tmp___14 = 1;
    } else
    if ((int )nEq > 0) {
      tmp___14 = 1;
    } else {
      tmp___14 = 0;
    }
    start_constraints = tmp___14;
    nConstraint___0 = (int )nEq;
    if (pRangeStart) {
      pRight___1 = (pRangeStart->pExpr)->pRight;
      codeExprOrVector(pParse, pRight___1, regBase + (int )nEq, (int )nBtm);
      whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
      tmp___15 = sqlite3ExprCanBeNull((Expr const   *)pRight___1);
      if (tmp___15) {
        sqlite3VdbeAddOp2(v, 50, regBase + (int )nEq, addrNxt);
      }
      if (zStartAff) {
        updateRangeAffinityStr(pRight___1, (int )nBtm, zStartAff + nEq);
      }
      nConstraint___0 += (int )nBtm;
      tmp___16 = sqlite3ExprIsVector(pRight___1);
      if (tmp___16 == 0) {
        disableTerm(pLevel, pRangeStart);
      } else {
        startEq = 1;
      }
      bSeekPastNull = (u8 )0;
    } else
    if (bSeekPastNull) {
      startEq = 0;
      sqlite3VdbeAddOp2(v, 73, 0, regBase + (int )nEq);
      start_constraints = 1;
      nConstraint___0 ++;
    } else
    if (regBignull) {
      sqlite3VdbeAddOp2(v, 73, 0, regBase + (int )nEq);
      start_constraints = 1;
      nConstraint___0 ++;
    }
    codeApplyAffinity(pParse, regBase, nConstraint___0 - (int )bSeekPastNull, zStartAff);
    if ((int )pLoop->nSkip > 0) {
      if (! (nConstraint___0 == (int )pLoop->nSkip)) {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      if (pLoop->wsFlags & 262144U) {
        sqlite3VdbeAddOp1(v, 119, iIdxCur);
      }
      if (regBignull) {
        sqlite3VdbeAddOp2(v, 70, 1, regBignull);
      }
      op___0 = (int )aStartOp[((start_constraints << 2) + (startEq << 1)) + bRev];
      sqlite3VdbeAddOp4Int(v, op___0, iIdxCur, addrNxt, regBase, nConstraint___0);
      if (regBignull) {
        tmp___17 = sqlite3VdbeCurrentAddr(v);
        sqlite3VdbeAddOp2(v, 11, 0, tmp___17 + 2);
        op___0 = (int )aStartOp[((nConstraint___0 > 1) * 4 + 2) + bRev];
        sqlite3VdbeAddOp4Int(v, op___0, iIdxCur, addrNxt, regBase, nConstraint___0 - startEq);
      }
    }
    nConstraint___0 = (int )nEq;
    if (pRangeEnd) {
      pRight___2 = (pRangeEnd->pExpr)->pRight;
      codeExprOrVector(pParse, pRight___2, regBase + (int )nEq, (int )nTop);
      whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
      tmp___18 = sqlite3ExprCanBeNull((Expr const   *)pRight___2);
      if (tmp___18) {
        sqlite3VdbeAddOp2(v, 50, regBase + (int )nEq, addrNxt);
      }
      if (zEndAff) {
        updateRangeAffinityStr(pRight___2, (int )nTop, zEndAff);
        codeApplyAffinity(pParse, regBase + (int )nEq, (int )nTop, zEndAff);
      }
      nConstraint___0 += (int )nTop;
      tmp___19 = sqlite3ExprIsVector(pRight___2);
      if (tmp___19 == 0) {
        disableTerm(pLevel, pRangeEnd);
      } else {
        endEq = 1;
      }
    } else
    if (bStopAtNull) {
      if (regBignull == 0) {
        sqlite3VdbeAddOp2(v, 73, 0, regBase + (int )nEq);
        endEq = 0;
      }
      nConstraint___0 ++;
    }
    sqlite3DbFree(db, (void *)zStartAff);
    sqlite3DbFree(db, (void *)zEndAff);
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);
    if (nConstraint___0) {
      if (regBignull) {
        tmp___20 = sqlite3VdbeCurrentAddr(v);
        sqlite3VdbeAddOp2(v, 20, regBignull, tmp___20 + 3);
      }
      op___0 = (int )aEndOp[bRev * 2 + endEq];
      sqlite3VdbeAddOp4Int(v, op___0, iIdxCur, addrNxt, regBase, nConstraint___0);
    }
    if (regBignull) {
      tmp___21 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 18, regBignull, tmp___21 + 2);
      op___0 = (int )aEndOp[bRev * 2 + (int )bSeekPastNull];
      sqlite3VdbeAddOp4Int(v, op___0, iIdxCur, addrNxt, regBase, nConstraint___0 + (int )bSeekPastNull);
    }
    if (pLoop->wsFlags & 262144U) {
      sqlite3VdbeAddOp2(v, 119, iIdxCur, 1);
    }
    if ((pLoop->wsFlags & 64U) != 0U) {
      if (((int )pWInfo->wctrlFlags & 32) == 0) {
        tmp___22 = 1;
      } else {
        tmp___22 = 0;
      }
    } else {
      tmp___22 = 0;
    }
    omitTable = tmp___22;
    if (! omitTable) {
      if (((pIdx->pTable)->tabFlags & 32U) == 0U) {
        if ((int )pWInfo->wctrlFlags & 1024) {
          (pParse->nMem) ++;
          iRowidReg = pParse->nMem;
          sqlite3VdbeAddOp2(v, 135, iIdxCur, iRowidReg);
          sqlite3VdbeAddOp3(v, 31, iCur, 0, iRowidReg);
        } else
        if ((int )pWInfo->wctrlFlags & 4096) {
          if ((int )pWInfo->eOnePass == 1) {
            (pParse->nMem) ++;
            iRowidReg = pParse->nMem;
            sqlite3VdbeAddOp2(v, 135, iIdxCur, iRowidReg);
            sqlite3VdbeAddOp3(v, 31, iCur, 0, iRowidReg);
          } else {
            codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);
          }
        } else {
          codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);
        }
      } else
      if (iCur != iIdxCur) {
        tmp___23 = sqlite3PrimaryKeyIndex(pIdx->pTable);
        pPk = tmp___23;
        iRowidReg = sqlite3GetTempRange(pParse, (int )pPk->nKeyCol);
        j = 0;
        while (j < (int )pPk->nKeyCol) {
          tmp___24 = sqlite3ColumnOfIndex(pIdx, *(pPk->aiColumn + j));
          k = (int )tmp___24;
          sqlite3VdbeAddOp3(v, 90, iIdxCur, k, iRowidReg + j);
          j ++;
        }
        sqlite3VdbeAddOp4Int(v, 28, iCur, addrCont, iRowidReg, (int )pPk->nKeyCol);
      }
    }
    if (pLevel->iLeftJoin == 0) {
      if (((int )pWInfo->wctrlFlags & 32) == 0) {
        whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo);
      }
    }
    if (pIdx->pPartIdxWhere) {
      whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);
    }
    if (pLoop->wsFlags & 4096U) {
      pLevel->op = (u8 )170;
    } else
    if (bRev) {
      pLevel->op = (u8 )4;
    } else {
      pLevel->op = (u8 )5;
    }
    pLevel->p1 = iIdxCur;
    if ((pLoop->wsFlags & 65536U) != 0U) {
      pLevel->p3 = (u8 )1;
    } else {
      pLevel->p3 = (u8 )0;
    }
    if ((pLoop->wsFlags & 15U) == 0U) {
      pLevel->p5 = (u8 )1;
    }
    if (omitTable) {
      pIdx = (Index *)0;
    }
  } else
  if (pLoop->wsFlags & 8192U) {
    pCov = (Index *)0;
    tmp___25 = pParse->nTab;
    (pParse->nTab) ++;
    iCovCur = tmp___25;
    (pParse->nMem) ++;
    regReturn = pParse->nMem;
    regRowset = 0;
    regRowid = 0;
    tmp___26 = sqlite3VdbeMakeLabel(pParse);
    iLoopBody = tmp___26;
    untestedTerms = 0;
    pAndExpr = (Expr *)0;
    pTab = pTabItem->pTab;
    pTerm = *(pLoop->aLTerm + 0);
    pOrWc = & (pTerm->u.pOrInfo)->wc;
    pLevel->op = (u8 )66;
    pLevel->p1 = regReturn;
    if ((int )pWInfo->nLevel > 1) {
      nNotReady = ((int )pWInfo->nLevel - iLevel) - 1;
      tmp___27 = sqlite3DbMallocRaw(db, (u64 )(sizeof(*pOrTab) + (unsigned long )nNotReady * sizeof(pOrTab->a[0])));
      pOrTab = (SrcList *)tmp___27;
      if ((unsigned long )pOrTab == (unsigned long )((SrcList *)0)) {
        return (notReady);
      }
      pOrTab->nAlloc = (u32 )((u8 )(nNotReady + 1));
      pOrTab->nSrc = (int )pOrTab->nAlloc;
      memcpy((void * __restrict  )(pOrTab->a), (void const   * __restrict  )pTabItem,
             sizeof(*pTabItem));
      origSrc = (pWInfo->pTabList)->a;
      k = 1;
      while (k <= nNotReady) {
        memcpy((void * __restrict  )(& pOrTab->a[k]), (void const   * __restrict  )(origSrc + (pLevel + k)->iFrom),
               sizeof(pOrTab->a[k]));
        k ++;
      }
    } else {
      pOrTab = pWInfo->pTabList;
    }
    if (((int )pWInfo->wctrlFlags & 16) == 0) {
      if ((pTab->tabFlags & 32U) == 0U) {
        (pParse->nMem) ++;
        regRowset = pParse->nMem;
        sqlite3VdbeAddOp2(v, 73, 0, regRowset);
      } else {
        tmp___28 = sqlite3PrimaryKeyIndex(pTab);
        pPk___0 = tmp___28;
        tmp___29 = pParse->nTab;
        (pParse->nTab) ++;
        regRowset = tmp___29;
        sqlite3VdbeAddOp2(v, 112, regRowset, (int )pPk___0->nKeyCol);
        sqlite3VdbeSetP4KeyInfo(pParse, pPk___0);
      }
      (pParse->nMem) ++;
      regRowid = pParse->nMem;
    }
    iRetInit = sqlite3VdbeAddOp2(v, 70, 0, regReturn);
    if (pWC->nTerm > 1) {
      iTerm = 0;
      while (iTerm < pWC->nTerm) {
        pExpr = (pWC->a + iTerm)->pExpr;
        if ((unsigned long )(pWC->a + iTerm) == (unsigned long )pTerm) {
          goto __Cont___0;
        }
        if (((int )(pWC->a + iTerm)->wtFlags & 6) != 0) {
          goto __Cont___0;
        }
        if (((int )(pWC->a + iTerm)->eOperator & 8191) == 0) {
          goto __Cont___0;
        }
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
        __Cont___0: /* CIL Label */ 
        iTerm ++;
      }
      if (pAndExpr) {
        pAndExpr = sqlite3PExpr(pParse, 65580, (Expr *)0, pAndExpr);
      }
    }
    wctrlFlags = (u16 )(32 | ((int )pWInfo->wctrlFlags & 1024));
    sqlite3VdbeExplain(pParse, (u8 )1, "MULTI-INDEX OR");
    ii = 0;
    while (ii < pOrWc->nTerm) {
      pOrTerm = pOrWc->a + ii;
      if (pOrTerm->leftCursor == iCur) {
        goto _L___7;
      } else
      if (((int )pOrTerm->eOperator & 1024) != 0) {
        _L___7: /* CIL Label */ 
        pOrExpr = pOrTerm->pExpr;
        jmp1 = 0;
        if (pAndExpr) {
          pAndExpr->pLeft = pOrExpr;
          pOrExpr = pAndExpr;
        }
        sqlite3VdbeExplain(pParse, (u8 )1, "INDEX %d", ii + 1);
        pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, (ExprList *)0, (ExprList *)0,
                                      wctrlFlags, iCovCur);
        if (pSubWInfo) {
          tmp___30 = sqlite3WhereExplainOneScan(pParse, pOrTab, & pSubWInfo->a[0],
                                                (u16 )0);
          addrExplain = tmp___30;
          if (((int )pWInfo->wctrlFlags & 16) == 0) {
            if (ii == pOrWc->nTerm - 1) {
              tmp___31 = -1;
            } else {
              tmp___31 = ii;
            }
            iSet = tmp___31;
            if ((pTab->tabFlags & 32U) == 0U) {
              sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);
              jmp1 = sqlite3VdbeAddOp4Int(v, 42, regRowset, 0, regRowid, iSet);
            } else {
              tmp___32 = sqlite3PrimaryKeyIndex(pTab);
              pPk___1 = tmp___32;
              nPk = (int )pPk___1->nKeyCol;
              r = sqlite3GetTempRange(pParse, nPk);
              iPk = 0;
              while (iPk < nPk) {
                iCol = (int )*(pPk___1->aiColumn + iPk);
                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + iPk);
                iPk ++;
              }
              if (iSet) {
                jmp1 = sqlite3VdbeAddOp4Int(v, 29, regRowset, 0, r, nPk);
              }
              if (iSet >= 0) {
                sqlite3VdbeAddOp3(v, 92, r, nPk, regRowid);
                sqlite3VdbeAddOp4Int(v, 132, regRowset, regRowid, r, nPk);
                if (iSet) {
                  sqlite3VdbeChangeP5(v, (u16 )16);
                }
              }
              sqlite3ReleaseTempRange(pParse, r, nPk);
            }
          }
          sqlite3VdbeAddOp2(v, 12, regReturn, iLoopBody);
          if (jmp1) {
            sqlite3VdbeJumpHere(v, jmp1);
          }
          if (pSubWInfo->untestedTerms) {
            untestedTerms = 1;
          }
          pSubLoop = pSubWInfo->a[0].pWLoop;
          if ((pSubLoop->wsFlags & 512U) != 0U) {
            if (ii == 0) {
              goto _L___6;
            } else
            if ((unsigned long )pSubLoop->u.btree.pIndex == (unsigned long )pCov) {
              _L___6: /* CIL Label */ 
              if ((pTab->tabFlags & 32U) == 0U) {
                pCov = pSubLoop->u.btree.pIndex;
              } else
              if (! ((pSubLoop->u.btree.pIndex)->idxType == 2U)) {
                pCov = pSubLoop->u.btree.pIndex;
              } else {
                pCov = (Index *)0;
              }
            } else {
              pCov = (Index *)0;
            }
          } else {
            pCov = (Index *)0;
          }
          sqlite3WhereEnd(pSubWInfo);
          sqlite3VdbeExplainPop(pParse);
        }
      }
      ii ++;
    }
    sqlite3VdbeExplainPop(pParse);
    pLevel->u.pCovidx = pCov;
    if (pCov) {
      pLevel->iIdxCur = iCovCur;
    }
    if (pAndExpr) {
      pAndExpr->pLeft = (Expr *)0;
      sqlite3ExprDelete(db, pAndExpr);
    }
    tmp___33 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeChangeP1(v, iRetInit, tmp___33);
    sqlite3VdbeGoto(v, pLevel->addrBrk);
    sqlite3VdbeResolveLabel(v, iLoopBody);
    if ((int )pWInfo->nLevel > 1) {
      sqlite3DbFree(db, (void *)pOrTab);
    }
    if (! untestedTerms) {
      disableTerm(pLevel, pTerm);
    }
  } else
  if (pTabItem->fg.isRecursive) {
    pLevel->op = (u8 )170;
  } else {
    pLevel->op = (u8 )aStep[bRev];
    pLevel->p1 = iCur;
    tmp___34 = sqlite3VdbeAddOp2(v, (int )aStart[bRev], iCur, addrHalt);
    pLevel->p2 = 1 + tmp___34;
    pLevel->p5 = (u8 )1;
  }
  if (pIdx) {
    iLoop = 1;
  } else {
    iLoop = 2;
  }
  while (1) {
    iNext = 0;
    pTerm = pWC->a;
    j = pWC->nTerm;
    while (j > 0) {
      skipLikeAddr = 0;
      if ((int )pTerm->wtFlags & 6) {
        goto __Cont___1;
      }
      if ((pTerm->prereqAll & pLevel->notReady) != 0ULL) {
        pWInfo->untestedTerms = (u8 )1;
        goto __Cont___1;
      }
      pE = pTerm->pExpr;
      if ((int )pTabItem->fg.jointype & 8) {
        if (! ((pE->flags & 1U) != 0U)) {
          goto __Cont___1;
        }
      }
      if (iLoop == 1) {
        tmp___35 = sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx);
        if (! tmp___35) {
          iNext = 2;
          goto __Cont___1;
        }
      }
      if (iLoop < 3) {
        if ((int )pTerm->wtFlags & 4096) {
          if (iNext == 0) {
            iNext = 3;
          }
          goto __Cont___1;
        }
      }
      if (((int )pTerm->wtFlags & 512) != 0) {
        x___0 = pLevel->iLikeRepCntr;
        if (x___0 > 0U) {
          if (x___0 & 1U) {
            tmp___36 = 20;
          } else {
            tmp___36 = 18;
          }
          skipLikeAddr = sqlite3VdbeAddOp1(v, tmp___36, (int )(x___0 >> 1));
        }
      }
      sqlite3ExprIfFalse(pParse, pE, addrCont, 16);
      if (skipLikeAddr) {
        sqlite3VdbeJumpHere(v, skipLikeAddr);
      }
      pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
      __Cont___1: /* CIL Label */ 
      j --;
      pTerm ++;
    }
    iLoop = iNext;
    if (! (iLoop > 0)) {
      break;
    }
  }
  pTerm = pWC->a;
  j = pWC->nTerm;
  while (j > 0) {
    if ((int )pTerm->wtFlags & 6) {
      goto __Cont___2;
    }
    if (((int )pTerm->eOperator & 130) == 0) {
      goto __Cont___2;
    }
    if (((int )pTerm->eOperator & 2048) == 0) {
      goto __Cont___2;
    }
    if (pTerm->leftCursor != iCur) {
      goto __Cont___2;
    }
    if (pLevel->iLeftJoin) {
      goto __Cont___2;
    }
    pE___0 = pTerm->pExpr;
    pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.leftColumn, notReady, (u32 )131,
                                (Index *)0);
    if ((unsigned long )pAlt == (unsigned long )((WhereTerm *)0)) {
      goto __Cont___2;
    }
    if ((int )pAlt->wtFlags & 4) {
      goto __Cont___2;
    }
    if ((int )pAlt->eOperator & 1) {
      if ((pAlt->pExpr)->flags & 2048U) {
        if ((((pAlt->pExpr)->x.pSelect)->pEList)->nExpr > 1) {
          goto __Cont___2;
        }
      }
    }
    sEAlt = *(pAlt->pExpr);
    sEAlt.pLeft = pE___0->pLeft;
    sqlite3ExprIfFalse(pParse, & sEAlt, addrCont, 16);
    __Cont___2: /* CIL Label */ 
    j --;
    pTerm ++;
  }
  if (pLevel->iLeftJoin) {
    pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 70, 1, pLevel->iLeftJoin);
    pTerm = pWC->a;
    j = 0;
    while (j < pWC->nTerm) {
      if ((int )pTerm->wtFlags & 6) {
        goto __Cont___3;
      }
      if ((pTerm->prereqAll & pLevel->notReady) != 0ULL) {
        goto __Cont___3;
      }
      sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 16);
      pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
      __Cont___3: /* CIL Label */ 
      j ++;
      pTerm ++;
    }
  }
  return (pLevel->notReady);
}
}
static void exprAnalyze(SrcList *pSrc , WhereClause *pWC , int idxTerm ) ;
static void whereOrInfoDelete(sqlite3 *db , WhereOrInfo *p ) 
{ 


  {
  sqlite3WhereClauseClear(& p->wc);
  sqlite3DbFree(db, (void *)p);
  return;
}
}
static void whereAndInfoDelete(sqlite3 *db , WhereAndInfo *p ) 
{ 


  {
  sqlite3WhereClauseClear(& p->wc);
  sqlite3DbFree(db, (void *)p);
  return;
}
}
static int whereClauseInsert(WhereClause *pWC , Expr *p , u16 wtFlags ) 
{ 
  WhereTerm *pTerm ;
  int idx ;
  WhereTerm *pOld ;
  sqlite3 *db ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  LogEst tmp___2 ;

  {
  if (pWC->nTerm >= pWC->nSlot) {
    pOld = pWC->a;
    db = ((pWC->pWInfo)->pParse)->db;
    tmp = sqlite3DbMallocRawNN(db, (u64 )((sizeof(*(pWC->a + 0)) * (unsigned long )pWC->nSlot) * 2UL));
    pWC->a = (WhereTerm *)tmp;
    if ((unsigned long )pWC->a == (unsigned long )((WhereTerm *)0)) {
      if ((int )wtFlags & 1) {
        sqlite3ExprDelete(db, p);
      }
      pWC->a = pOld;
      return (0);
    }
    memcpy((void * __restrict  )pWC->a, (void const   * __restrict  )pOld, sizeof(*(pWC->a + 0)) * (unsigned long )pWC->nTerm);
    if ((unsigned long )pOld != (unsigned long )(pWC->aStatic)) {
      sqlite3DbFree(db, (void *)pOld);
    }
    tmp___0 = sqlite3DbMallocSize(db, (void *)pWC->a);
    pWC->nSlot = (int )((unsigned long )tmp___0 / sizeof(*(pWC->a + 0)));
  }
  tmp___1 = pWC->nTerm;
  (pWC->nTerm) ++;
  idx = tmp___1;
  pTerm = pWC->a + idx;
  if (p) {
    if ((p->flags & 262144U) != 0U) {
      tmp___2 = sqlite3LogEst((u64 )p->iTable);
      pTerm->truthProb = (LogEst )((int )tmp___2 - 270);
    } else {
      pTerm->truthProb = (LogEst )1;
    }
  } else {
    pTerm->truthProb = (LogEst )1;
  }
  pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);
  pTerm->wtFlags = wtFlags;
  pTerm->pWC = pWC;
  pTerm->iParent = -1;
  memset((void *)(& pTerm->eOperator), 0, sizeof(WhereTerm ) - (unsigned long )(& ((WhereTerm *)0)->eOperator));
  return (idx);
}
}
static int allowedOp(int op ) 
{ 
  int tmp ;

  {
  if (op == 49) {
    tmp = 1;
  } else
  if (op >= 53) {
    if (op <= 57) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (op == 50) {
    tmp = 1;
  } else
  if (op == 45) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static u16 exprCommute(Parse *pParse , Expr *pExpr ) 
{ 
  u16 expRight ;
  u16 expLeft ;
  u16 wtFlags ;
  CollSeq *tmp ;
  Expr *t ;

  {
  expRight = (u16 )((pExpr->pRight)->flags & 256U);
  expLeft = (u16 )((pExpr->pLeft)->flags & 256U);
  wtFlags = (u16 )0;
  if ((int )expRight == (int )expLeft) {
    if (expRight) {
      (pExpr->pRight)->flags &= 4294967039U;
      wtFlags = (u16 )((int )wtFlags | 8192);
    } else {
      tmp = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
      if ((unsigned long )tmp != (unsigned long )((CollSeq *)0)) {
        (pExpr->pLeft)->flags |= 256U;
        wtFlags = (u16 )((int )wtFlags | 8192);
      }
    }
  }
  t = pExpr->pRight;
  pExpr->pRight = pExpr->pLeft;
  pExpr->pLeft = t;
  if ((int )pExpr->op >= 54) {
    pExpr->op = (u8 )((((int )pExpr->op - 54) ^ 2) + 54);
  }
  return (wtFlags);
}
}
static u16 operatorMask(int op ) 
{ 
  u16 c ;

  {
  if (op == 49) {
    c = (u16 )1;
  } else
  if (op == 50) {
    c = (u16 )256;
  } else
  if (op == 45) {
    c = (u16 )128;
  } else {
    c = (u16 )(2 << (op - 53));
  }
  return (c);
}
}
static int isLikeOrGlob(Parse *pParse , Expr *pExpr , Expr **ppPrefix , int *pisComplete ,
                        int *pnoCase ) 
{ 
  u8 const   *z ;
  Expr *pRight ;
  Expr *pLeft ;
  ExprList *pList ;
  u8 c ;
  int cnt ;
  u8 wc[4] ;
  sqlite3 *db ;
  sqlite3_value *pVal ;
  int op ;
  int rc ;
  int tmp ;
  Vdbe *pReprepare ;
  int iCol ;
  int tmp___0 ;
  Expr *pPrefix ;
  int tmp___1 ;
  int iFrom ;
  int iTo ;
  char *zNew ;
  int tmp___2 ;
  int isNum ;
  double rDummy ;
  char tmp___3 ;
  Vdbe *v ;
  int r1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  z = (u8 const   *)0;
  db = pParse->db;
  pVal = (sqlite3_value *)0;
  tmp = sqlite3IsLikeFunction(db, pExpr, pnoCase, (char *)(wc));
  if (! tmp) {
    return (0);
  }
  pList = pExpr->x.pList;
  pLeft = pList->a[1].pExpr;
  pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);
  op = (int )pRight->op;
  if (op == 151) {
    if ((db->flags & 8388608ULL) == 0ULL) {
      pReprepare = pParse->pReprepare;
      iCol = (int )pRight->iColumn;
      pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, (u8 )65);
      if (pVal) {
        tmp___0 = sqlite3_value_type(pVal);
        if (tmp___0 == 3) {
          z = sqlite3_value_text(pVal);
        }
      }
      sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (op == 113) {
    z = (u8 const   *)((u8 *)pRight->u.zToken);
  }
  if (z) {
    cnt = 0;
    while (1) {
      c = (u8 )*(z + cnt);
      if ((int )c != 0) {
        if ((int )c != (int )wc[0]) {
          if ((int )c != (int )wc[1]) {
            if (! ((int )c != (int )wc[2])) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      cnt ++;
      if ((int )c == (int )wc[3]) {
        if ((int const   )*(z + cnt) != 0) {
          cnt ++;
        }
      }
    }
    if (cnt != 0) {
      if (255 != (int )((u8 )*(z + (cnt - 1)))) {
        if (cnt > 1) {
          goto _L___1;
        } else
        if ((int const   )*(z + 0) != (int const   )wc[3]) {
          _L___1: /* CIL Label */ 
          if ((int )c == (int )wc[0]) {
            if ((int const   )*(z + (cnt + 1)) == 0) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
          } else {
            tmp___1 = 0;
          }
          *pisComplete = tmp___1;
          pPrefix = sqlite3Expr(db, 113, (char const   *)((char *)z));
          if (pPrefix) {
            zNew = pPrefix->u.zToken;
            *(zNew + cnt) = (char)0;
            iTo = 0;
            iFrom = iTo;
            while (iFrom < cnt) {
              if ((int )*(zNew + iFrom) == (int )wc[3]) {
                iFrom ++;
              }
              tmp___2 = iTo;
              iTo ++;
              *(zNew + tmp___2) = *(zNew + iFrom);
              iFrom ++;
            }
            *(zNew + iTo) = (char)0;
            if ((int )pLeft->op != 162) {
              goto _L___0;
            } else {
              tmp___3 = sqlite3ExprAffinity(pLeft);
              if ((int )tmp___3 != 66) {
                goto _L___0;
              } else
              if ((pLeft->y.pTab)->nModuleArg) {
                _L___0: /* CIL Label */ 
                isNum = sqlite3AtoF((char const   *)zNew, & rDummy, iTo, (u8 )1);
                if (isNum <= 0) {
                  if (iTo == 1) {
                    if ((int )*(zNew + 0) == 45) {
                      isNum = 1;
                    } else {
                      *(zNew + (iTo - 1)) = (char )((int )*(zNew + (iTo - 1)) + 1);
                      isNum = sqlite3AtoF((char const   *)zNew, & rDummy, iTo, (u8 )1);
                      *(zNew + (iTo - 1)) = (char )((int )*(zNew + (iTo - 1)) - 1);
                    }
                  } else {
                    *(zNew + (iTo - 1)) = (char )((int )*(zNew + (iTo - 1)) + 1);
                    isNum = sqlite3AtoF((char const   *)zNew, & rDummy, iTo, (u8 )1);
                    *(zNew + (iTo - 1)) = (char )((int )*(zNew + (iTo - 1)) - 1);
                  }
                }
                if (isNum > 0) {
                  sqlite3ExprDelete(db, pPrefix);
                  sqlite3ValueFree(pVal);
                  return (0);
                }
              }
            }
          }
          *ppPrefix = pPrefix;
          if (op == 151) {
            v = pParse->pVdbe;
            sqlite3VdbeSetVarmask(v, (int )pRight->iColumn);
            if (*pisComplete) {
              if (*(pRight->u.zToken + 1)) {
                tmp___4 = sqlite3GetTempReg(pParse);
                r1 = tmp___4;
                sqlite3ExprCodeTarget(pParse, pRight, r1);
                tmp___5 = sqlite3VdbeCurrentAddr(v);
                sqlite3VdbeChangeP3(v, tmp___5 - 1, 0);
                sqlite3ReleaseTempReg(pParse, r1);
              }
            }
          }
        } else {
          z = (u8 const   *)0;
        }
      } else {
        z = (u8 const   *)0;
      }
    } else {
      z = (u8 const   *)0;
    }
  }
  rc = (unsigned long )z != (unsigned long )((u8 const   *)0);
  sqlite3ValueFree(pVal);
  return (rc);
}
}
static int isAuxiliaryVtabOperator(sqlite3 *db , Expr *pExpr , unsigned char *peOp2 ,
                                   Expr **ppLeft , Expr **ppRight ) ;
static struct Op2  const  aOp[4]  = {      {"match", (unsigned char)64}, 
        {"glob", (unsigned char)66}, 
        {"like", (unsigned char)65}, 
        {"regexp", (unsigned char)67}};
static int isAuxiliaryVtabOperator(sqlite3 *db , Expr *pExpr , unsigned char *peOp2 ,
                                   Expr **ppLeft , Expr **ppRight ) 
{ 
  ExprList *pList ;
  Expr *pCol ;
  int i ;
  int tmp ;
  sqlite3_vtab *pVtab ;
  sqlite3_module *pMod ;
  void (*xNotUsed)(sqlite3_context * , int  , sqlite3_value ** ) ;
  void *pNotUsed ;
  VTable *tmp___0 ;
  int res ;
  Expr *pLeft ;
  Expr *pRight ;
  Expr *t ;

  {
  if ((int )pExpr->op == 167) {
    pList = pExpr->x.pList;
    if ((unsigned long )pList == (unsigned long )((ExprList *)0)) {
      return (0);
    } else
    if (pList->nExpr != 2) {
      return (0);
    }
    pCol = pList->a[1].pExpr;
    if ((int )pCol->op == 162) {
      if ((pCol->y.pTab)->nModuleArg) {
        i = 0;
        while (i < (int )(sizeof(aOp) / sizeof(aOp[0]))) {
          tmp = sqlite3StrICmp((char const   *)pExpr->u.zToken, (char const   *)aOp[i].zOp);
          if (tmp == 0) {
            *peOp2 = (unsigned char )aOp[i].eOp2;
            *ppRight = pList->a[0].pExpr;
            *ppLeft = pCol;
            return (1);
          }
          i ++;
        }
      }
    }
    pCol = pList->a[0].pExpr;
    if ((int )pCol->op == 162) {
      if ((pCol->y.pTab)->nModuleArg) {
        tmp___0 = sqlite3GetVTable(db, pCol->y.pTab);
        pVtab = tmp___0->pVtab;
        pMod = (sqlite3_module *)pVtab->pModule;
        if ((unsigned long )pMod->xFindFunction != (unsigned long )((int (*)(sqlite3_vtab *pVtab ,
                                                                             int nArg ,
                                                                             char const   *zName ,
                                                                             void (**pxFunc)(sqlite3_context * ,
                                                                                             int  ,
                                                                                             sqlite3_value ** ) ,
                                                                             void **ppArg ))0)) {
          i = (*(pMod->xFindFunction))(pVtab, 2, (char const   *)pExpr->u.zToken,
                                       & xNotUsed, & pNotUsed);
          if (i >= 150) {
            *peOp2 = (unsigned char )i;
            *ppRight = pList->a[1].pExpr;
            *ppLeft = pCol;
            return (1);
          }
        }
      }
    }
  } else
  if ((int )pExpr->op == 52) {
    goto _L;
  } else
  if ((int )pExpr->op == 166) {
    goto _L;
  } else
  if ((int )pExpr->op == 51) {
    _L: /* CIL Label */ 
    res = 0;
    pLeft = pExpr->pLeft;
    pRight = pExpr->pRight;
    if ((int )pLeft->op == 162) {
      if ((pLeft->y.pTab)->nModuleArg) {
        res ++;
      }
    }
    if (pRight) {
      if ((int )pRight->op == 162) {
        if ((pRight->y.pTab)->nModuleArg) {
          res ++;
          t = pLeft;
          pLeft = pRight;
          pRight = t;
        }
      }
    }
    *ppLeft = pLeft;
    *ppRight = pRight;
    if ((int )pExpr->op == 52) {
      *peOp2 = (unsigned char)68;
    }
    if ((int )pExpr->op == 166) {
      *peOp2 = (unsigned char)69;
    }
    if ((int )pExpr->op == 51) {
      *peOp2 = (unsigned char)70;
    }
    return (res);
  }
  return (0);
}
}
static void transferJoinMarkings(Expr *pDerived , Expr *pBase ) 
{ 


  {
  if (pDerived) {
    pDerived->flags |= pBase->flags & 1U;
    pDerived->iRightJoinTable = pBase->iRightJoinTable;
  }
  return;
}
}
static void markTermAsChild(WhereClause *pWC , int iChild , int iParent ) 
{ 


  {
  (pWC->a + iChild)->iParent = iParent;
  (pWC->a + iChild)->truthProb = (pWC->a + iParent)->truthProb;
  (pWC->a + iParent)->nChild = (u8 )((int )(pWC->a + iParent)->nChild + 1);
  return;
}
}
static WhereTerm *whereNthSubterm(WhereTerm *pTerm , int N ) 
{ 
  WhereTerm *tmp ;

  {
  if ((int )pTerm->eOperator != 1024) {
    if (N == 0) {
      tmp = pTerm;
    } else {
      tmp = (WhereTerm *)0;
    }
    return (tmp);
  }
  if (N < (pTerm->u.pAndInfo)->wc.nTerm) {
    return ((pTerm->u.pAndInfo)->wc.a + N);
  }
  return ((WhereTerm *)0);
}
}
static void whereCombineDisjuncts(SrcList *pSrc , WhereClause *pWC , WhereTerm *pOne ,
                                  WhereTerm *pTwo ) 
{ 
  u16 eOp ;
  sqlite3 *db ;
  Expr *pNew ;
  int op ;
  int idxNew ;
  int tmp ;
  int tmp___0 ;

  {
  eOp = (u16 )((int )pOne->eOperator | (int )pTwo->eOperator);
  if (((int )pOne->eOperator & ((((2 | (2 << 3)) | (2 << 2)) | (2 << 1)) | (2 << 4))) == 0) {
    return;
  }
  if (((int )pTwo->eOperator & ((((2 | (2 << 3)) | (2 << 2)) | (2 << 1)) | (2 << 4))) == 0) {
    return;
  }
  if (((int )eOp & ((2 | (2 << 3)) | (2 << 2))) != (int )eOp) {
    if (((int )eOp & ((2 | (2 << 1)) | (2 << 4))) != (int )eOp) {
      return;
    }
  }
  tmp = sqlite3ExprCompare((Parse *)0, (pOne->pExpr)->pLeft, (pTwo->pExpr)->pLeft,
                           -1);
  if (tmp) {
    return;
  }
  tmp___0 = sqlite3ExprCompare((Parse *)0, (pOne->pExpr)->pRight, (pTwo->pExpr)->pRight,
                               -1);
  if (tmp___0) {
    return;
  }
  if (((int )eOp & ((int )eOp - 1)) != 0) {
    if ((int )eOp & ((2 << 3) | (2 << 2))) {
      eOp = (u16 )(2 << 2);
    } else {
      eOp = (u16 )(2 << 4);
    }
  }
  db = ((pWC->pWInfo)->pParse)->db;
  pNew = sqlite3ExprDup(db, pOne->pExpr, 0);
  if ((unsigned long )pNew == (unsigned long )((Expr *)0)) {
    return;
  }
  op = 53;
  while ((int )eOp != 2 << (op - 53)) {
    op ++;
  }
  pNew->op = (u8 )op;
  idxNew = whereClauseInsert(pWC, pNew, (u16 )3);
  exprAnalyze(pSrc, pWC, idxNew);
  return;
}
}
static void exprAnalyzeOrTerm(SrcList *pSrc , WhereClause *pWC , int idxTerm ) 
{ 
  WhereInfo *pWInfo ;
  Parse *pParse ;
  sqlite3 *db ;
  WhereTerm *pTerm ;
  Expr *pExpr ;
  int i ;
  WhereClause *pOrWc ;
  WhereTerm *pOrTerm ;
  WhereOrInfo *pOrInfo ;
  Bitmask chngToIN ;
  Bitmask indexable ;
  void *tmp ;
  WhereAndInfo *pAndInfo ;
  void *tmp___0 ;
  WhereClause *pAndWC ;
  WhereTerm *pAndTerm ;
  int j ;
  Bitmask b ;
  Bitmask tmp___1 ;
  int tmp___2 ;
  Bitmask b___0 ;
  WhereTerm *pOther ;
  Bitmask tmp___3 ;
  int iOne ;
  WhereTerm *pOne ;
  int iTwo ;
  WhereTerm *pTwo ;
  int tmp___4 ;
  int tmp___5 ;
  int okToChngToIN ;
  int iColumn ;
  int iCursor ;
  int j___0 ;
  Expr *pLeft ;
  Bitmask tmp___6 ;
  int affLeft ;
  int affRight ;
  char tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;
  Expr *pDup ;
  ExprList *pList ;
  Expr *pLeft___0 ;
  Expr *pNew ;
  int idxNew ;

  {
  pWInfo = pWC->pWInfo;
  pParse = pWInfo->pParse;
  db = pParse->db;
  pTerm = pWC->a + idxTerm;
  pExpr = pTerm->pExpr;
  tmp = sqlite3DbMallocZero(db, (u64 )sizeof(*pOrInfo));
  pOrInfo = (WhereOrInfo *)tmp;
  pTerm->u.pOrInfo = pOrInfo;
  if ((unsigned long )pOrInfo == (unsigned long )((WhereOrInfo *)0)) {
    return;
  }
  pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 16);
  pOrWc = & pOrInfo->wc;
  memset((void *)(pOrWc->aStatic), 0, sizeof(pOrWc->aStatic));
  sqlite3WhereClauseInit(pOrWc, pWInfo);
  sqlite3WhereSplit(pOrWc, pExpr, (u8 )43);
  sqlite3WhereExprAnalyze(pSrc, pOrWc);
  if (db->mallocFailed) {
    return;
  }
  indexable = ~ ((Bitmask )0);
  chngToIN = ~ ((Bitmask )0);
  i = pOrWc->nTerm - 1;
  pOrTerm = pOrWc->a;
  while (1) {
    if (i >= 0) {
      if (! indexable) {
        break;
      }
    } else {
      break;
    }
    if (((int )pOrTerm->eOperator & 511) == 0) {
      chngToIN = (Bitmask )0;
      tmp___0 = sqlite3DbMallocRawNN(db, (u64 )sizeof(*pAndInfo));
      pAndInfo = (WhereAndInfo *)tmp___0;
      if (pAndInfo) {
        b = (Bitmask )0;
        pOrTerm->u.pAndInfo = pAndInfo;
        pOrTerm->wtFlags = (u16 )((int )pOrTerm->wtFlags | 32);
        pOrTerm->eOperator = (u16 )1024;
        pAndWC = & pAndInfo->wc;
        memset((void *)(pAndWC->aStatic), 0, sizeof(pAndWC->aStatic));
        sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);
        sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, (u8 )44);
        sqlite3WhereExprAnalyze(pSrc, pAndWC);
        pAndWC->pOuter = pWC;
        if (! db->mallocFailed) {
          j = 0;
          pAndTerm = pAndWC->a;
          while (j < pAndWC->nTerm) {
            tmp___2 = allowedOp((int )(pAndTerm->pExpr)->op);
            if (tmp___2) {
              tmp___1 = sqlite3WhereGetMask(& pWInfo->sMaskSet, pAndTerm->leftCursor);
              b |= tmp___1;
            } else
            if ((int )pAndTerm->eOperator == 64) {
              tmp___1 = sqlite3WhereGetMask(& pWInfo->sMaskSet, pAndTerm->leftCursor);
              b |= tmp___1;
            }
            j ++;
            pAndTerm ++;
          }
        }
        indexable &= b;
      }
    } else
    if (! ((int )pOrTerm->wtFlags & 8)) {
      b___0 = sqlite3WhereGetMask(& pWInfo->sMaskSet, pOrTerm->leftCursor);
      if ((int )pOrTerm->wtFlags & 2) {
        pOther = pOrWc->a + pOrTerm->iParent;
        tmp___3 = sqlite3WhereGetMask(& pWInfo->sMaskSet, pOther->leftCursor);
        b___0 |= tmp___3;
      }
      indexable &= b___0;
      if (((int )pOrTerm->eOperator & 2) == 0) {
        chngToIN = (Bitmask )0;
      } else {
        chngToIN &= b___0;
      }
    }
    i --;
    pOrTerm ++;
  }
  pOrInfo->indexable = indexable;
  if (indexable) {
    pTerm->eOperator = (u16 )512;
    pWC->hasOr = (u8 )1;
  } else {
    pTerm->eOperator = (u16 )512;
  }
  if (indexable) {
    if (pOrWc->nTerm == 2) {
      iOne = 0;
      while (1) {
        tmp___5 = iOne;
        iOne ++;
        pOne = whereNthSubterm(pOrWc->a + 0, tmp___5);
        if (! ((unsigned long )pOne != (unsigned long )((WhereTerm *)0))) {
          break;
        }
        iTwo = 0;
        while (1) {
          tmp___4 = iTwo;
          iTwo ++;
          pTwo = whereNthSubterm(pOrWc->a + 1, tmp___4);
          if (! ((unsigned long )pTwo != (unsigned long )((WhereTerm *)0))) {
            break;
          }
          whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
        }
      }
    }
  }
  if (chngToIN) {
    okToChngToIN = 0;
    iColumn = -1;
    iCursor = -1;
    j___0 = 0;
    j___0 = 0;
    while (1) {
      if (j___0 < 2) {
        if (! (! okToChngToIN)) {
          break;
        }
      } else {
        break;
      }
      pLeft = (Expr *)0;
      pOrTerm = pOrWc->a;
      i = pOrWc->nTerm - 1;
      while (i >= 0) {
        pOrTerm->wtFlags = (u16 )((int )pOrTerm->wtFlags & -65);
        if (pOrTerm->leftCursor == iCursor) {
          goto __Cont;
        }
        tmp___6 = sqlite3WhereGetMask(& pWInfo->sMaskSet, pOrTerm->leftCursor);
        if ((chngToIN & tmp___6) == 0ULL) {
          goto __Cont;
        }
        iColumn = pOrTerm->u.leftColumn;
        iCursor = pOrTerm->leftCursor;
        pLeft = (pOrTerm->pExpr)->pLeft;
        break;
        __Cont: /* CIL Label */ 
        i --;
        pOrTerm ++;
      }
      if (i < 0) {
        break;
      }
      okToChngToIN = 1;
      while (1) {
        if (i >= 0) {
          if (! okToChngToIN) {
            break;
          }
        } else {
          break;
        }
        if (pOrTerm->leftCursor != iCursor) {
          pOrTerm->wtFlags = (u16 )((int )pOrTerm->wtFlags & -65);
        } else
        if (pOrTerm->u.leftColumn != iColumn) {
          okToChngToIN = 0;
        } else
        if (iColumn == -2) {
          tmp___9 = sqlite3ExprCompare(pParse, (pOrTerm->pExpr)->pLeft, pLeft, -1);
          if (tmp___9) {
            okToChngToIN = 0;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          tmp___7 = sqlite3ExprAffinity((pOrTerm->pExpr)->pRight);
          affRight = (int )tmp___7;
          tmp___8 = sqlite3ExprAffinity((pOrTerm->pExpr)->pLeft);
          affLeft = (int )tmp___8;
          if (affRight != 0) {
            if (affRight != affLeft) {
              okToChngToIN = 0;
            } else {
              pOrTerm->wtFlags = (u16 )((int )pOrTerm->wtFlags | 64);
            }
          } else {
            pOrTerm->wtFlags = (u16 )((int )pOrTerm->wtFlags | 64);
          }
        }
        i --;
        pOrTerm ++;
      }
      j___0 ++;
    }
    if (okToChngToIN) {
      pList = (ExprList *)0;
      pLeft___0 = (Expr *)0;
      i = pOrWc->nTerm - 1;
      pOrTerm = pOrWc->a;
      while (i >= 0) {
        if (((int )pOrTerm->wtFlags & 64) == 0) {
          goto __Cont___0;
        }
        pDup = sqlite3ExprDup(db, (pOrTerm->pExpr)->pRight, 0);
        pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);
        pLeft___0 = (pOrTerm->pExpr)->pLeft;
        __Cont___0: /* CIL Label */ 
        i --;
        pOrTerm ++;
      }
      pDup = sqlite3ExprDup(db, pLeft___0, 0);
      pNew = sqlite3PExpr(pParse, 49, pDup, (Expr *)0);
      if (pNew) {
        transferJoinMarkings(pNew, pExpr);
        pNew->x.pList = pList;
        idxNew = whereClauseInsert(pWC, pNew, (u16 )3);
        exprAnalyze(pSrc, pWC, idxNew);
        markTermAsChild(pWC, idxNew, idxTerm);
      } else {
        sqlite3ExprListDelete(db, pList);
      }
    }
  }
  return;
}
}
static int termIsEquivalence(Parse *pParse , Expr *pExpr ) 
{ 
  char aff1 ;
  char aff2 ;
  CollSeq *pColl ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (((int )(pParse->db)->dbOptFlags & 128) == 0)) {
    return (0);
  }
  if ((int )pExpr->op != 53) {
    if ((int )pExpr->op != 45) {
      return (0);
    }
  }
  if ((pExpr->flags & 1U) != 0U) {
    return (0);
  }
  aff1 = sqlite3ExprAffinity(pExpr->pLeft);
  aff2 = sqlite3ExprAffinity(pExpr->pRight);
  if ((int )aff1 != (int )aff2) {
    if (! ((int )aff1 >= 67)) {
      return (0);
    } else
    if (! ((int )aff2 >= 67)) {
      return (0);
    }
  }
  pColl = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight);
  tmp = sqlite3IsBinary((CollSeq const   *)pColl);
  if (tmp) {
    return (1);
  }
  tmp___0 = sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight);
  return (tmp___0);
}
}
static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet , Select *pS ) 
{ 
  Bitmask mask ;
  SrcList *pSrc ;
  Bitmask tmp ;
  Bitmask tmp___0 ;
  Bitmask tmp___1 ;
  Bitmask tmp___2 ;
  Bitmask tmp___3 ;
  int i ;
  Bitmask tmp___4 ;
  Bitmask tmp___5 ;
  Bitmask tmp___6 ;

  {
  mask = (Bitmask )0;
  while (pS) {
    pSrc = pS->pSrc;
    tmp = sqlite3WhereExprListUsage(pMaskSet, pS->pEList);
    mask |= tmp;
    tmp___0 = sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);
    mask |= tmp___0;
    tmp___1 = sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);
    mask |= tmp___1;
    tmp___2 = sqlite3WhereExprUsage(pMaskSet, pS->pWhere);
    mask |= tmp___2;
    tmp___3 = sqlite3WhereExprUsage(pMaskSet, pS->pHaving);
    mask |= tmp___3;
    if ((unsigned long )pSrc != (unsigned long )((SrcList *)0)) {
      i = 0;
      while (i < pSrc->nSrc) {
        tmp___4 = exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);
        mask |= tmp___4;
        tmp___5 = sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);
        mask |= tmp___5;
        if (pSrc->a[i].fg.isTabFunc) {
          tmp___6 = sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);
          mask |= tmp___6;
        }
        i ++;
      }
    }
    pS = pS->pPrior;
  }
  return (mask);
}
}
static int ( __attribute__((__noinline__)) exprMightBeIndexed2)(SrcList *pFrom , Bitmask mPrereq ,
                                                                int *aiCurCol , Expr *pExpr ) 
{ 
  Index *pIdx ;
  int i ;
  int iCur ;
  int tmp ;

  {
  i = 0;
  while (mPrereq > 1ULL) {
    i ++;
    mPrereq >>= 1;
  }
  iCur = pFrom->a[i].iCursor;
  pIdx = (pFrom->a[i].pTab)->pIndex;
  while (pIdx) {
    if ((unsigned long )pIdx->aColExpr == (unsigned long )((ExprList *)0)) {
      goto __Cont;
    }
    i = 0;
    while (i < (int )pIdx->nKeyCol) {
      if ((int )*(pIdx->aiColumn + i) != -2) {
        goto __Cont___0;
      }
      tmp = sqlite3ExprCompareSkip(pExpr, (pIdx->aColExpr)->a[i].pExpr, iCur);
      if (tmp == 0) {
        *(aiCurCol + 0) = iCur;
        *(aiCurCol + 1) = -2;
        return (1);
      }
      __Cont___0: /* CIL Label */ 
      i ++;
    }
    __Cont: /* CIL Label */ 
    pIdx = pIdx->pNext;
  }
  return (0);
}
}
static int exprMightBeIndexed(SrcList *pFrom , Bitmask mPrereq , int *aiCurCol , Expr *pExpr ,
                              int op ) 
{ 
  int tmp ;

  {
  if ((int )pExpr->op == 172) {
    if (op >= 54) {
      if (op <= 57) {
        pExpr = (pExpr->x.pList)->a[0].pExpr;
      }
    }
  }
  if ((int )pExpr->op == 162) {
    *(aiCurCol + 0) = pExpr->iTable;
    *(aiCurCol + 1) = (int )pExpr->iColumn;
    return (1);
  }
  if (mPrereq == 0ULL) {
    return (0);
  }
  if ((mPrereq & (mPrereq - 1ULL)) != 0ULL) {
    return (0);
  }
  tmp = exprMightBeIndexed2(pFrom, mPrereq, aiCurCol, pExpr);
  return (tmp);
}
}
static u8 const   ops[2]  = {      (u8 const   )57,      (u8 const   )55};
static void exprAnalyze(SrcList *pSrc , WhereClause *pWC , int idxTerm ) 
{ 
  WhereInfo *pWInfo ;
  WhereTerm *pTerm ;
  WhereMaskSet *pMaskSet ;
  Expr *pExpr ;
  Bitmask prereqLeft ;
  Bitmask prereqAll ;
  Bitmask extraRight ;
  Expr *pStr1 ;
  int isComplete ;
  int noCase ;
  int op ;
  Parse *pParse ;
  sqlite3 *db ;
  unsigned char eOp2 ;
  int nLeft ;
  int tmp ;
  Bitmask x___0 ;
  Bitmask tmp___0 ;
  int aiCurCol[2] ;
  Expr *pLeft ;
  Expr *tmp___1 ;
  Expr *pRight ;
  Expr *tmp___2 ;
  u16 opMask ;
  int tmp___3 ;
  u16 tmp___4 ;
  int tmp___5 ;
  WhereTerm *pNew ;
  Expr *pDup ;
  u16 eExtraOp ;
  int idxNew ;
  int tmp___6 ;
  u16 tmp___7 ;
  u16 tmp___8 ;
  int tmp___9 ;
  ExprList *pList ;
  int i ;
  Expr *pNewExpr ;
  int idxNew___0 ;
  Expr *tmp___10 ;
  Expr *tmp___11 ;
  int tmp___12 ;
  Expr *pLeft___0 ;
  Expr *pStr2 ;
  Expr *pNewExpr1 ;
  Expr *pNewExpr2 ;
  int idxNew1 ;
  int idxNew2 ;
  char const   *zCollSeqName ;
  u16 wtFlags ;
  int i___0 ;
  char c ;
  u8 c___0 ;
  u8 *pC ;
  int tmp___13 ;
  Expr *tmp___14 ;
  Expr *tmp___15 ;
  int tmp___16 ;
  Expr *pRight___0 ;
  Expr *pLeft___1 ;
  int res ;
  int tmp___17 ;
  int idxNew___1 ;
  WhereTerm *pNewTerm ;
  Bitmask prereqColumn ;
  Bitmask prereqExpr ;
  Expr *pNewExpr___0 ;
  Expr *tmp___18 ;
  Expr *t ;
  int tmp___19 ;
  int i___1 ;
  int idxNew___2 ;
  Expr *pNew___0 ;
  Expr *pLeft___2 ;
  Expr *tmp___20 ;
  Expr *pRight___1 ;
  Expr *tmp___21 ;
  int tmp___22 ;
  int i___2 ;
  int idxNew___3 ;
  int tmp___23 ;

  {
  pWInfo = pWC->pWInfo;
  extraRight = (Bitmask )0;
  pStr1 = (Expr *)0;
  isComplete = 0;
  noCase = 0;
  pParse = pWInfo->pParse;
  db = pParse->db;
  eOp2 = (unsigned char)0;
  if (db->mallocFailed) {
    return;
  }
  pTerm = pWC->a + idxTerm;
  pMaskSet = & pWInfo->sMaskSet;
  pExpr = pTerm->pExpr;
  prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);
  op = (int )pExpr->op;
  if (op == 49) {
    tmp = sqlite3ExprCheckIN(pParse, pExpr);
    if (tmp) {
      return;
    }
    if ((pExpr->flags & 2048U) != 0U) {
      pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);
    } else {
      pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);
    }
  } else
  if (op == 50) {
    pTerm->prereqRight = (Bitmask )0;
  } else {
    pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);
  }
  pMaskSet->bVarSelect = 0;
  prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr);
  if (pMaskSet->bVarSelect) {
    pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4096);
  }
  if ((pExpr->flags & 1U) != 0U) {
    tmp___0 = sqlite3WhereGetMask(pMaskSet, (int )pExpr->iRightJoinTable);
    x___0 = tmp___0;
    prereqAll |= x___0;
    extraRight = x___0 - 1ULL;
    if (prereqAll >> 1 >= x___0) {
      sqlite3ErrorMsg(pParse, "ON clause references tables to its right");
      return;
    }
  }
  pTerm->prereqAll = prereqAll;
  pTerm->leftCursor = -1;
  pTerm->iParent = -1;
  pTerm->eOperator = (u16 )0;
  tmp___12 = allowedOp(op);
  if (tmp___12) {
    tmp___1 = sqlite3ExprSkipCollate(pExpr->pLeft);
    pLeft = tmp___1;
    tmp___2 = sqlite3ExprSkipCollate(pExpr->pRight);
    pRight = tmp___2;
    if ((pTerm->prereqRight & prereqLeft) == 0ULL) {
      tmp___3 = 8191;
    } else {
      tmp___3 = 2048;
    }
    opMask = (u16 )tmp___3;
    if (pTerm->iField > 0) {
      pLeft = (pLeft->x.pList)->a[pTerm->iField - 1].pExpr;
    }
    tmp___5 = exprMightBeIndexed(pSrc, prereqLeft, aiCurCol, pLeft, op);
    if (tmp___5) {
      pTerm->leftCursor = aiCurCol[0];
      pTerm->u.leftColumn = aiCurCol[1];
      tmp___4 = operatorMask(op);
      pTerm->eOperator = (u16 )((int )tmp___4 & (int )opMask);
    }
    if (op == 45) {
      pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 2048);
    }
    if (pRight) {
      tmp___9 = exprMightBeIndexed(pSrc, pTerm->prereqRight, aiCurCol, pRight, op);
      if (tmp___9) {
        eExtraOp = (u16 )0;
        if (pTerm->leftCursor >= 0) {
          pDup = sqlite3ExprDup(db, pExpr, 0);
          if (db->mallocFailed) {
            sqlite3ExprDelete(db, pDup);
            return;
          }
          idxNew = whereClauseInsert(pWC, pDup, (u16 )3);
          if (idxNew == 0) {
            return;
          }
          pNew = pWC->a + idxNew;
          markTermAsChild(pWC, idxNew, idxTerm);
          if (op == 45) {
            pNew->wtFlags = (u16 )((int )pNew->wtFlags | 2048);
          }
          pTerm = pWC->a + idxTerm;
          pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 8);
          tmp___6 = termIsEquivalence(pParse, pDup);
          if (tmp___6) {
            pTerm->eOperator = (u16 )((int )pTerm->eOperator | 2048);
            eExtraOp = (u16 )2048;
          }
        } else {
          pDup = pExpr;
          pNew = pTerm;
        }
        tmp___7 = exprCommute(pParse, pDup);
        pNew->wtFlags = (u16 )((int )pNew->wtFlags | (int )tmp___7);
        pNew->leftCursor = aiCurCol[0];
        pNew->u.leftColumn = aiCurCol[1];
        pNew->prereqRight = prereqLeft | extraRight;
        pNew->prereqAll = prereqAll;
        tmp___8 = operatorMask((int )pDup->op);
        pNew->eOperator = (u16 )(((int )tmp___8 + (int )eExtraOp) & (int )opMask);
      }
    }
  } else
  if ((int )pExpr->op == 48) {
    if ((int )pWC->op == 44) {
      pList = pExpr->x.pList;
      i = 0;
      while (i < 2) {
        tmp___10 = sqlite3ExprDup(db, pList->a[i].pExpr, 0);
        tmp___11 = sqlite3ExprDup(db, pExpr->pLeft, 0);
        pNewExpr = sqlite3PExpr(pParse, (int )ops[i], tmp___11, tmp___10);
        transferJoinMarkings(pNewExpr, pExpr);
        idxNew___0 = whereClauseInsert(pWC, pNewExpr, (u16 )3);
        exprAnalyze(pSrc, pWC, idxNew___0);
        pTerm = pWC->a + idxTerm;
        markTermAsChild(pWC, idxNew___0, idxTerm);
        i ++;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int )pExpr->op == 43) {
    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
    pTerm = pWC->a + idxTerm;
  }
  if ((int )pWC->op == 44) {
    tmp___16 = isLikeOrGlob(pParse, pExpr, & pStr1, & isComplete, & noCase);
    if (tmp___16) {
      wtFlags = (u16 )259;
      pLeft___0 = (pExpr->x.pList)->a[1].pExpr;
      pStr2 = sqlite3ExprDup(db, pStr1, 0);
      if (noCase) {
        if (! (pParse->db)->mallocFailed) {
          pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 1024);
          i___0 = 0;
          while (1) {
            c = *(pStr1->u.zToken + i___0);
            if (! ((int )c != 0)) {
              break;
            }
            *(pStr1->u.zToken + i___0) = (char )((int )c & (int )(~ ((int const   )sqlite3CtypeMap[(unsigned char )c] & 32)));
            *(pStr2->u.zToken + i___0) = (char )sqlite3UpperToLower[(unsigned char )c];
            i___0 ++;
          }
        }
      }
      if (! db->mallocFailed) {
        tmp___13 = sqlite3Strlen30((char const   *)pStr2->u.zToken);
        pC = (u8 *)(pStr2->u.zToken + (tmp___13 - 1));
        c___0 = *pC;
        if (noCase) {
          if ((int )c___0 == 64) {
            isComplete = 0;
          }
          c___0 = (u8 )sqlite3UpperToLower[c___0];
        }
        *pC = (u8 )((int )c___0 + 1);
      }
      if (noCase) {
        zCollSeqName = "NOCASE";
      } else {
        zCollSeqName = sqlite3StrBINARY;
      }
      pNewExpr1 = sqlite3ExprDup(db, pLeft___0, 0);
      tmp___14 = sqlite3ExprAddCollateString(pParse, pNewExpr1, zCollSeqName);
      pNewExpr1 = sqlite3PExpr(pParse, 57, tmp___14, pStr1);
      transferJoinMarkings(pNewExpr1, pExpr);
      idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);
      exprAnalyze(pSrc, pWC, idxNew1);
      pNewExpr2 = sqlite3ExprDup(db, pLeft___0, 0);
      tmp___15 = sqlite3ExprAddCollateString(pParse, pNewExpr2, zCollSeqName);
      pNewExpr2 = sqlite3PExpr(pParse, 56, tmp___15, pStr2);
      transferJoinMarkings(pNewExpr2, pExpr);
      idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);
      exprAnalyze(pSrc, pWC, idxNew2);
      pTerm = pWC->a + idxTerm;
      if (isComplete) {
        markTermAsChild(pWC, idxNew1, idxTerm);
        markTermAsChild(pWC, idxNew2, idxTerm);
      }
    }
  }
  if ((int )pWC->op == 44) {
    pRight___0 = (Expr *)0;
    pLeft___1 = (Expr *)0;
    tmp___17 = isAuxiliaryVtabOperator(db, pExpr, & eOp2, & pLeft___1, & pRight___0);
    res = tmp___17;
    while (1) {
      tmp___19 = res;
      res --;
      if (! (tmp___19 > 0)) {
        break;
      }
      prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight___0);
      prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft___1);
      if ((prereqExpr & prereqColumn) == 0ULL) {
        tmp___18 = sqlite3ExprDup(db, pRight___0, 0);
        pNewExpr___0 = sqlite3PExpr(pParse, 46, (Expr *)0, tmp___18);
        if ((pExpr->flags & 1U) != 0U) {
          if (pNewExpr___0) {
            pNewExpr___0->flags |= 1U;
          }
        }
        idxNew___1 = whereClauseInsert(pWC, pNewExpr___0, (u16 )3);
        pNewTerm = pWC->a + idxNew___1;
        pNewTerm->prereqRight = prereqExpr;
        pNewTerm->leftCursor = pLeft___1->iTable;
        pNewTerm->u.leftColumn = (int )pLeft___1->iColumn;
        pNewTerm->eOperator = (u16 )64;
        pNewTerm->eMatchOp = eOp2;
        markTermAsChild(pWC, idxNew___1, idxTerm);
        pTerm = pWC->a + idxTerm;
        pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 8);
        pNewTerm->prereqAll = pTerm->prereqAll;
      }
      t = pLeft___1;
      pLeft___1 = pRight___0;
      pRight___0 = t;
    }
  }
  if ((int )pWC->op == 44) {
    if ((int )pExpr->op == 53) {
      goto _L___1;
    } else
    if ((int )pExpr->op == 45) {
      _L___1: /* CIL Label */ 
      nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
      if (nLeft > 1) {
        tmp___22 = sqlite3ExprVectorSize(pExpr->pRight);
        if (tmp___22 == nLeft) {
          if (((pExpr->pLeft)->flags & 2048U) == 0U) {
            goto _L___0;
          } else
          if (((pExpr->pRight)->flags & 2048U) == 0U) {
            _L___0: /* CIL Label */ 
            i___1 = 0;
            while (i___1 < nLeft) {
              tmp___20 = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i___1);
              pLeft___2 = tmp___20;
              tmp___21 = sqlite3ExprForVectorField(pParse, pExpr->pRight, i___1);
              pRight___1 = tmp___21;
              pNew___0 = sqlite3PExpr(pParse, (int )pExpr->op, pLeft___2, pRight___1);
              transferJoinMarkings(pNew___0, pExpr);
              idxNew___2 = whereClauseInsert(pWC, pNew___0, (u16 )1);
              exprAnalyze(pSrc, pWC, idxNew___2);
              i___1 ++;
            }
            pTerm = pWC->a + idxTerm;
            pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 6);
            pTerm->eOperator = (u16 )0;
          }
        }
      }
    }
  }
  if ((int )pWC->op == 44) {
    if ((int )pExpr->op == 49) {
      if (pTerm->iField == 0) {
        if ((int )(pExpr->pLeft)->op == 172) {
          if ((unsigned long )(pExpr->x.pSelect)->pPrior == (unsigned long )((Select *)0)) {
            i___2 = 0;
            while (1) {
              tmp___23 = sqlite3ExprVectorSize(pExpr->pLeft);
              if (! (i___2 < tmp___23)) {
                break;
              }
              idxNew___3 = whereClauseInsert(pWC, pExpr, (u16 )2);
              (pWC->a + idxNew___3)->iField = i___2 + 1;
              exprAnalyze(pSrc, pWC, idxNew___3);
              markTermAsChild(pWC, idxNew___3, idxTerm);
              i___2 ++;
            }
          }
        }
      }
    }
  }
  pTerm = pWC->a + idxTerm;
  pTerm->prereqRight |= extraRight;
  return;
}
}
static void sqlite3WhereSplit(WhereClause *pWC , Expr *pExpr , u8 op ) 
{ 
  Expr *pE2 ;
  Expr *tmp ;

  {
  tmp = sqlite3ExprSkipCollateAndLikely(pExpr);
  pE2 = tmp;
  pWC->op = op;
  if ((unsigned long )pE2 == (unsigned long )((Expr *)0)) {
    return;
  }
  if ((int )pE2->op != (int )op) {
    whereClauseInsert(pWC, pExpr, (u16 )0);
  } else {
    sqlite3WhereSplit(pWC, pE2->pLeft, op);
    sqlite3WhereSplit(pWC, pE2->pRight, op);
  }
  return;
}
}
static void sqlite3WhereClauseInit(WhereClause *pWC , WhereInfo *pWInfo ) 
{ 


  {
  pWC->pWInfo = pWInfo;
  pWC->hasOr = (u8 )0;
  pWC->pOuter = (WhereClause *)0;
  pWC->nTerm = 0;
  pWC->nSlot = (int )(sizeof(pWC->aStatic) / sizeof(pWC->aStatic[0]));
  pWC->a = pWC->aStatic;
  return;
}
}
static void sqlite3WhereClauseClear(WhereClause *pWC ) 
{ 
  int i ;
  WhereTerm *a___0 ;
  sqlite3 *db ;

  {
  db = ((pWC->pWInfo)->pParse)->db;
  i = pWC->nTerm - 1;
  a___0 = pWC->a;
  while (i >= 0) {
    if ((int )a___0->wtFlags & 1) {
      sqlite3ExprDelete(db, a___0->pExpr);
    }
    if ((int )a___0->wtFlags & 16) {
      whereOrInfoDelete(db, a___0->u.pOrInfo);
    } else
    if ((int )a___0->wtFlags & 32) {
      whereAndInfoDelete(db, a___0->u.pAndInfo);
    }
    i --;
    a___0 ++;
  }
  if ((unsigned long )pWC->a != (unsigned long )(pWC->aStatic)) {
    sqlite3DbFree(db, (void *)pWC->a);
  }
  return;
}
}
static Bitmask sqlite3WhereExprUsageNN(WhereMaskSet *pMaskSet , Expr *p ) 
{ 
  Bitmask mask ;
  Bitmask tmp ;
  Bitmask tmp___0 ;
  Bitmask tmp___1 ;
  Bitmask tmp___2 ;
  Bitmask tmp___3 ;
  Bitmask tmp___4 ;
  Bitmask tmp___5 ;
  Bitmask tmp___6 ;

  {
  if ((int )p->op == 162) {
    if (! ((p->flags & 8U) != 0U)) {
      tmp = sqlite3WhereGetMask(pMaskSet, p->iTable);
      return (tmp);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((p->flags & 8404992U) != 0U) {
    return ((Bitmask )0);
  }
  if ((int )p->op == 174) {
    tmp___0 = sqlite3WhereGetMask(pMaskSet, p->iTable);
    mask = tmp___0;
  } else {
    mask = (Bitmask )0;
  }
  if (p->pLeft) {
    tmp___1 = sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);
    mask |= tmp___1;
  }
  if (p->pRight) {
    tmp___2 = sqlite3WhereExprUsageNN(pMaskSet, p->pRight);
    mask |= tmp___2;
  } else
  if ((p->flags & 2048U) != 0U) {
    if ((p->flags & 32U) != 0U) {
      pMaskSet->bVarSelect = 1;
    }
    tmp___3 = exprSelectUsage(pMaskSet, p->x.pSelect);
    mask |= tmp___3;
  } else
  if (p->x.pList) {
    tmp___4 = sqlite3WhereExprListUsage(pMaskSet, p->x.pList);
    mask |= tmp___4;
  }
  if ((int )p->op == 167) {
    if (p->y.pWin) {
      tmp___5 = sqlite3WhereExprListUsage(pMaskSet, (p->y.pWin)->pPartition);
      mask |= tmp___5;
      tmp___6 = sqlite3WhereExprListUsage(pMaskSet, (p->y.pWin)->pOrderBy);
      mask |= tmp___6;
    }
  }
  return (mask);
}
}
static Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet , Expr *p ) 
{ 
  Bitmask tmp ;
  Bitmask tmp___0 ;

  {
  if (p) {
    tmp = sqlite3WhereExprUsageNN(pMaskSet, p);
    tmp___0 = tmp;
  } else {
    tmp___0 = (Bitmask )0;
  }
  return (tmp___0);
}
}
static Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet , ExprList *pList ) 
{ 
  int i ;
  Bitmask mask ;
  Bitmask tmp ;

  {
  mask = (Bitmask )0;
  if (pList) {
    i = 0;
    while (i < pList->nExpr) {
      tmp = sqlite3WhereExprUsage(pMaskSet, pList->a[i].pExpr);
      mask |= tmp;
      i ++;
    }
  }
  return (mask);
}
}
static void sqlite3WhereExprAnalyze(SrcList *pTabList , WhereClause *pWC ) 
{ 
  int i ;

  {
  i = pWC->nTerm - 1;
  while (i >= 0) {
    exprAnalyze(pTabList, pWC, i);
    i --;
  }
  return;
}
}
static void sqlite3WhereTabFuncArgs(Parse *pParse , struct SrcList_item *pItem , WhereClause *pWC ) 
{ 
  Table *pTab ;
  int j ;
  int k ;
  ExprList *pArgs ;
  Expr *pColRef ;
  Expr *pTerm ;
  Expr *pRhs ;
  int tmp ;
  Expr *tmp___0 ;

  {
  if (pItem->fg.isTabFunc == 0U) {
    return;
  }
  pTab = pItem->pTab;
  pArgs = pItem->u1.pFuncArg;
  if ((unsigned long )pArgs == (unsigned long )((ExprList *)0)) {
    return;
  }
  k = 0;
  j = k;
  while (j < pArgs->nExpr) {
    while (1) {
      if (k < (int )pTab->nCol) {
        if (! (((int )(pTab->aCol + k)->colFlags & 2) == 0)) {
          break;
        }
      } else {
        break;
      }
      k ++;
    }
    if (k >= (int )pTab->nCol) {
      sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d", pTab->zName,
                      j);
      return;
    }
    pColRef = sqlite3ExprAlloc(pParse->db, 162, (Token const   *)0, 0);
    if ((unsigned long )pColRef == (unsigned long )((Expr *)0)) {
      return;
    }
    pColRef->iTable = pItem->iCursor;
    tmp = k;
    k ++;
    pColRef->iColumn = (ynVar )tmp;
    pColRef->y.pTab = pTab;
    tmp___0 = sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0);
    pRhs = sqlite3PExpr(pParse, 169, tmp___0, (Expr *)0);
    pTerm = sqlite3PExpr(pParse, 53, pColRef, pRhs);
    whereClauseInsert(pWC, pTerm, (u16 )1);
    j ++;
  }
  return;
}
}
static int whereLoopResize(sqlite3 *db , WhereLoop *p , int n ) ;
static LogEst sqlite3WhereOutputRowCount(WhereInfo *pWInfo ) 
{ 


  {
  return (pWInfo->nRowOut);
}
}
static int sqlite3WhereIsDistinct(WhereInfo *pWInfo ) 
{ 


  {
  return ((int )pWInfo->eDistinct);
}
}
static int sqlite3WhereIsOrdered(WhereInfo *pWInfo ) 
{ 


  {
  return ((int )pWInfo->nOBSat);
}
}
static int sqlite3WhereOrderByLimitOptLabel(WhereInfo *pWInfo ) 
{ 
  WhereLevel *pInner ;

  {
  if (! pWInfo->bOrderedInnerLoop) {
    return (pWInfo->iContinue);
  }
  pInner = & pWInfo->a[(int )pWInfo->nLevel - 1];
  return (pInner->addrNxt);
}
}
static int sqlite3WhereContinueLabel(WhereInfo *pWInfo ) 
{ 


  {
  return (pWInfo->iContinue);
}
}
static int sqlite3WhereBreakLabel(WhereInfo *pWInfo ) 
{ 


  {
  return (pWInfo->iBreak);
}
}
static int sqlite3WhereOkOnePass(WhereInfo *pWInfo , int *aiCur ) 
{ 


  {
  memcpy((void * __restrict  )aiCur, (void const   * __restrict  )(pWInfo->aiCurOnePass),
         sizeof(int ) * 2UL);
  return ((int )pWInfo->eOnePass);
}
}
static void whereOrMove(WhereOrSet *pDest , WhereOrSet *pSrc ) 
{ 


  {
  pDest->n = pSrc->n;
  memcpy((void * __restrict  )(pDest->a), (void const   * __restrict  )(pSrc->a),
         (unsigned long )pDest->n * sizeof(pDest->a[0]));
  return;
}
}
static int whereOrInsert(WhereOrSet *pSet , Bitmask prereq , LogEst rRun , LogEst nOut ) 
{ 
  u16 i ;
  WhereOrCost *p ;
  u16 tmp ;

  {
  i = pSet->n;
  p = pSet->a;
  while ((int )i > 0) {
    if ((int )rRun <= (int )p->rRun) {
      if ((prereq & p->prereq) == prereq) {
        goto whereOrInsert_done;
      }
    }
    if ((int )p->rRun <= (int )rRun) {
      if ((p->prereq & prereq) == p->prereq) {
        return (0);
      }
    }
    i = (u16 )((int )i - 1);
    p ++;
  }
  if ((int )pSet->n < 3) {
    tmp = pSet->n;
    pSet->n = (u16 )((int )pSet->n + 1);
    p = & pSet->a[tmp];
    p->nOut = nOut;
  } else {
    p = pSet->a;
    i = (u16 )1;
    while ((int )i < (int )pSet->n) {
      if ((int )p->rRun > (int )pSet->a[i].rRun) {
        p = pSet->a + (int )i;
      }
      i = (u16 )((int )i + 1);
    }
    if ((int )p->rRun <= (int )rRun) {
      return (0);
    }
  }
  whereOrInsert_done: 
  p->prereq = prereq;
  p->rRun = rRun;
  if ((int )p->nOut > (int )nOut) {
    p->nOut = nOut;
  }
  return (1);
}
}
static Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet , int iCursor ) 
{ 
  int i ;

  {
  i = 0;
  while (i < pMaskSet->n) {
    if (pMaskSet->ix[i] == iCursor) {
      return (1ULL << i);
    }
    i ++;
  }
  return ((Bitmask )0);
}
}
static void createMask(WhereMaskSet *pMaskSet , int iCursor ) 
{ 
  int tmp ;

  {
  tmp = pMaskSet->n;
  (pMaskSet->n) ++;
  pMaskSet->ix[tmp] = iCursor;
  return;
}
}
static WhereTerm *whereScanNext(WhereScan *pScan ) 
{ 
  int iCur ;
  i16 iColumn ;
  Expr *pX ;
  WhereClause *pWC ;
  WhereTerm *pTerm ;
  int k ;
  int j ;
  CollSeq *pColl ;
  Parse *pParse ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  k = pScan->k;
  pWC = pScan->pWC;
  while (1) {
    iColumn = pScan->aiColumn[(int )pScan->iEquiv - 1];
    iCur = pScan->aiCur[(int )pScan->iEquiv - 1];
    while (1) {
      pTerm = pWC->a + k;
      while (k < pWC->nTerm) {
        if (pTerm->leftCursor == iCur) {
          if (pTerm->u.leftColumn == (int )iColumn) {
            if ((int )iColumn != -2) {
              goto _L___0;
            } else {
              tmp___1 = sqlite3ExprCompareSkip((pTerm->pExpr)->pLeft, pScan->pIdxExpr,
                                               iCur);
              if (tmp___1 == 0) {
                _L___0: /* CIL Label */ 
                if ((int )pScan->iEquiv <= 1) {
                  goto _L;
                } else
                if (! (((pTerm->pExpr)->flags & 1U) != 0U)) {
                  _L: /* CIL Label */ 
                  if (((int )pTerm->eOperator & 2048) != 0) {
                    if ((int )pScan->nEquiv < (int )(sizeof(pScan->aiCur) / sizeof(pScan->aiCur[0]))) {
                      pX = sqlite3ExprSkipCollateAndLikely((pTerm->pExpr)->pRight);
                      if ((int )pX->op == 162) {
                        j = 0;
                        while (j < (int )pScan->nEquiv) {
                          if (pScan->aiCur[j] == pX->iTable) {
                            if ((int )pScan->aiColumn[j] == (int )pX->iColumn) {
                              break;
                            }
                          }
                          j ++;
                        }
                        if (j == (int )pScan->nEquiv) {
                          pScan->aiCur[j] = pX->iTable;
                          pScan->aiColumn[j] = pX->iColumn;
                          pScan->nEquiv = (unsigned char )((int )pScan->nEquiv + 1);
                        }
                      }
                    }
                  }
                  if (((unsigned int )pTerm->eOperator & pScan->opMask) != 0U) {
                    if (pScan->zCollName) {
                      if (((int )pTerm->eOperator & 256) == 0) {
                        pParse = (pWC->pWInfo)->pParse;
                        pX = pTerm->pExpr;
                        tmp = sqlite3IndexAffinityOk(pX, pScan->idxaff);
                        if (! tmp) {
                          goto __Cont;
                        }
                        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
                        if ((unsigned long )pColl == (unsigned long )((CollSeq *)0)) {
                          pColl = (pParse->db)->pDfltColl;
                        }
                        tmp___0 = sqlite3StrICmp((char const   *)pColl->zName, pScan->zCollName);
                        if (tmp___0) {
                          goto __Cont;
                        }
                      }
                    }
                    if (((int )pTerm->eOperator & 130) != 0) {
                      pX = (pTerm->pExpr)->pRight;
                      if ((int )pX->op == 162) {
                        if (pX->iTable == pScan->aiCur[0]) {
                          if ((int )pX->iColumn == (int )pScan->aiColumn[0]) {
                            goto __Cont;
                          }
                        }
                      }
                    }
                    pScan->pWC = pWC;
                    pScan->k = k + 1;
                    return (pTerm);
                  }
                }
              }
            }
          }
        }
        __Cont: /* CIL Label */ 
        k ++;
        pTerm ++;
      }
      pWC = pWC->pOuter;
      k = 0;
      if (! ((unsigned long )pWC != (unsigned long )((WhereClause *)0))) {
        break;
      }
    }
    if ((int )pScan->iEquiv >= (int )pScan->nEquiv) {
      break;
    }
    pWC = pScan->pOrigWC;
    k = 0;
    pScan->iEquiv = (unsigned char )((int )pScan->iEquiv + 1);
  }
  return ((WhereTerm *)0);
}
}
static WhereTerm *( __attribute__((__noinline__)) whereScanInitIndexExpr)(WhereScan *pScan ) 
{ 
  WhereTerm *tmp ;

  {
  pScan->idxaff = sqlite3ExprAffinity(pScan->pIdxExpr);
  tmp = whereScanNext(pScan);
  return (tmp);
}
}
static WhereTerm *whereScanInit(WhereScan *pScan , WhereClause *pWC , int iCur , int iColumn ,
                                u32 opMask , Index *pIdx ) 
{ 
  int j ;
  WhereTerm *tmp ;
  WhereTerm *tmp___0 ;

  {
  pScan->pOrigWC = pWC;
  pScan->pWC = pWC;
  pScan->pIdxExpr = (Expr *)0;
  pScan->idxaff = (char)0;
  pScan->zCollName = (char const   *)0;
  pScan->opMask = opMask;
  pScan->k = 0;
  pScan->aiCur[0] = iCur;
  pScan->nEquiv = (unsigned char)1;
  pScan->iEquiv = (unsigned char)1;
  if (pIdx) {
    j = iColumn;
    iColumn = (int )*(pIdx->aiColumn + j);
    if (iColumn == -2) {
      pScan->pIdxExpr = (pIdx->aColExpr)->a[j].pExpr;
      pScan->zCollName = *(pIdx->azColl + j);
      pScan->aiColumn[0] = (i16 )-2;
      tmp = whereScanInitIndexExpr(pScan);
      return (tmp);
    } else
    if (iColumn == (int )(pIdx->pTable)->iPKey) {
      iColumn = -1;
    } else
    if (iColumn >= 0) {
      pScan->idxaff = ((pIdx->pTable)->aCol + iColumn)->affinity;
      pScan->zCollName = *(pIdx->azColl + j);
    }
  } else
  if (iColumn == -2) {
    return ((WhereTerm *)0);
  }
  pScan->aiColumn[0] = (i16 )iColumn;
  tmp___0 = whereScanNext(pScan);
  return (tmp___0);
}
}
static WhereTerm *sqlite3WhereFindTerm(WhereClause *pWC , int iCur , int iColumn ,
                                       Bitmask notReady , u32 op , Index *pIdx ) 
{ 
  WhereTerm *pResult ;
  WhereTerm *p ;
  WhereScan scan ;

  {
  pResult = (WhereTerm *)0;
  p = whereScanInit(& scan, pWC, iCur, iColumn, op, pIdx);
  op &= 130U;
  while (p) {
    if ((p->prereqRight & notReady) == 0ULL) {
      if (p->prereqRight == 0ULL) {
        if (((unsigned int )p->eOperator & op) != 0U) {
          return (p);
        }
      }
      if ((unsigned long )pResult == (unsigned long )((WhereTerm *)0)) {
        pResult = p;
      }
    }
    p = whereScanNext(& scan);
  }
  return (pResult);
}
}
static int findIndexCol(Parse *pParse , ExprList *pList , int iBase , Index *pIdx ,
                        int iCol ) 
{ 
  int i ;
  char const   *zColl ;
  Expr *p ;
  Expr *tmp ;
  CollSeq *pColl ;
  CollSeq *tmp___0 ;
  int tmp___1 ;

  {
  zColl = *(pIdx->azColl + iCol);
  i = 0;
  while (i < pList->nExpr) {
    tmp = sqlite3ExprSkipCollateAndLikely(pList->a[i].pExpr);
    p = tmp;
    if ((int )p->op == 162) {
      if ((int )p->iColumn == (int )*(pIdx->aiColumn + iCol)) {
        if (p->iTable == iBase) {
          tmp___0 = sqlite3ExprNNCollSeq(pParse, pList->a[i].pExpr);
          pColl = tmp___0;
          tmp___1 = sqlite3StrICmp((char const   *)pColl->zName, zColl);
          if (0 == tmp___1) {
            return (i);
          }
        }
      }
    }
    i ++;
  }
  return (-1);
}
}
static int indexColumnNotNull(Index *pIdx , int iCol ) 
{ 
  int j ;

  {
  j = (int )*(pIdx->aiColumn + iCol);
  if (j >= 0) {
    return ((int )((pIdx->pTable)->aCol + j)->notNull);
  } else
  if (j == -1) {
    return (1);
  } else {
    return (0);
  }
}
}
static int isDistinctRedundant(Parse *pParse , SrcList *pTabList , WhereClause *pWC ,
                               ExprList *pDistinct ) 
{ 
  Table *pTab ;
  Index *pIdx ;
  int i ;
  int iBase ;
  Expr *p ;
  Expr *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  WhereTerm *tmp___2 ;

  {
  if (pTabList->nSrc != 1) {
    return (0);
  }
  iBase = pTabList->a[0].iCursor;
  pTab = pTabList->a[0].pTab;
  i = 0;
  while (i < pDistinct->nExpr) {
    tmp = sqlite3ExprSkipCollateAndLikely(pDistinct->a[i].pExpr);
    p = tmp;
    if ((int )p->op == 162) {
      if (p->iTable == iBase) {
        if ((int )p->iColumn < 0) {
          return (1);
        }
      }
    }
    i ++;
  }
  pIdx = pTab->pIndex;
  while (pIdx) {
    if (! ((int )pIdx->onError != 0)) {
      goto __Cont;
    }
    i = 0;
    while (i < (int )pIdx->nKeyCol) {
      tmp___2 = sqlite3WhereFindTerm(pWC, iBase, i, ~ ((Bitmask )0), (u32 )2, pIdx);
      if ((unsigned long )((WhereTerm *)0) == (unsigned long )tmp___2) {
        tmp___0 = findIndexCol(pParse, pDistinct, iBase, pIdx, i);
        if (tmp___0 < 0) {
          break;
        }
        tmp___1 = indexColumnNotNull(pIdx, i);
        if (tmp___1 == 0) {
          break;
        }
      }
      i ++;
    }
    if (i == (int )pIdx->nKeyCol) {
      return (1);
    }
    __Cont: /* CIL Label */ 
    pIdx = pIdx->pNext;
  }
  return (0);
}
}
static LogEst estLog(LogEst N ) 
{ 
  LogEst tmp ;
  int tmp___0 ;

  {
  if ((int )N <= 10) {
    tmp___0 = 0;
  } else {
    tmp = sqlite3LogEst((u64 )N);
    tmp___0 = (int )tmp - 33;
  }
  return ((LogEst )tmp___0);
}
}
static void translateColumnToCopy(Parse *pParse , int iStart , int iTabCur , int iRegister ,
                                  int iAutoidxCur ) 
{ 
  Vdbe *v ;
  VdbeOp *pOp ;
  VdbeOp *tmp ;
  int iEnd ;
  int tmp___0 ;

  {
  v = pParse->pVdbe;
  tmp = sqlite3VdbeGetOp(v, iStart);
  pOp = tmp;
  tmp___0 = sqlite3VdbeCurrentAddr(v);
  iEnd = tmp___0;
  if ((pParse->db)->mallocFailed) {
    return;
  }
  while (iStart < iEnd) {
    if (pOp->p1 != iTabCur) {
      goto __Cont;
    }
    if ((int )pOp->opcode == 90) {
      pOp->opcode = (u8 )78;
      pOp->p1 = pOp->p2 + iRegister;
      pOp->p2 = pOp->p3;
      pOp->p3 = 0;
    } else
    if ((int )pOp->opcode == 128) {
      if (iAutoidxCur) {
        pOp->opcode = (u8 )120;
        pOp->p1 = iAutoidxCur;
      } else {
        pOp->opcode = (u8 )73;
        pOp->p1 = 0;
        pOp->p3 = 0;
      }
    }
    __Cont: /* CIL Label */ 
    iStart ++;
    pOp ++;
  }
  return;
}
}
static int termCanDriveIndex(WhereTerm *pTerm , struct SrcList_item *pSrc , Bitmask notReady ) 
{ 
  char aff ;
  int tmp ;

  {
  if (pTerm->leftCursor != pSrc->iCursor) {
    return (0);
  }
  if (((int )pTerm->eOperator & 130) == 0) {
    return (0);
  }
  if ((int )pSrc->fg.jointype & 8) {
    if (! (((pTerm->pExpr)->flags & 1U) != 0U)) {
      if ((int )pTerm->eOperator & 128) {
        return (0);
      }
    }
  }
  if ((pTerm->prereqRight & notReady) != 0ULL) {
    return (0);
  }
  if (pTerm->u.leftColumn < 0) {
    return (0);
  }
  aff = ((pSrc->pTab)->aCol + pTerm->u.leftColumn)->affinity;
  tmp = sqlite3IndexAffinityOk(pTerm->pExpr, aff);
  if (! tmp) {
    return (0);
  }
  return (1);
}
}
static void constructAutomaticIndex(Parse *pParse , WhereClause *pWC , struct SrcList_item *pSrc ,
                                    Bitmask notReady , WhereLevel *pLevel ) 
{ 
  int nKeyCol ;
  WhereTerm *pTerm ;
  WhereTerm *pWCEnd ;
  Index *pIdx ;
  Vdbe *v ;
  int addrInit ;
  Table *pTable ;
  int addrTop ;
  int regRecord ;
  int n ;
  int i ;
  int mxBitCol ;
  CollSeq *pColl ;
  WhereLoop *pLoop ;
  char *zNotUsed ;
  Bitmask idxCols ;
  Bitmask extraCols ;
  u8 sentWarning ;
  Expr *pPartial ;
  int iContinue ;
  struct SrcList_item *pTabItem ;
  int addrCounter ;
  int regBase ;
  Expr *pExpr ;
  Expr *tmp ;
  int tmp___0 ;
  int iCol ;
  Bitmask cMask ;
  Bitmask tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u16 tmp___5 ;
  int iCol___0 ;
  Bitmask cMask___0 ;
  Bitmask tmp___6 ;
  Expr *pX ;
  int tmp___7 ;
  int tmp___8 ;
  int regYield ;

  {
  sentWarning = (u8 )0;
  pPartial = (Expr *)0;
  iContinue = 0;
  addrCounter = 0;
  v = pParse->pVdbe;
  addrInit = sqlite3VdbeAddOp0(v, 17);
  nKeyCol = 0;
  pTable = pSrc->pTab;
  pWCEnd = pWC->a + pWC->nTerm;
  pLoop = pLevel->pWLoop;
  idxCols = (Bitmask )0;
  pTerm = pWC->a;
  while ((unsigned long )pTerm < (unsigned long )pWCEnd) {
    pExpr = pTerm->pExpr;
    if (pLoop->prereq == 0ULL) {
      if (((int )pTerm->wtFlags & 2) == 0) {
        if (! ((pExpr->flags & 1U) != 0U)) {
          tmp___0 = sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor);
          if (tmp___0) {
            tmp = sqlite3ExprDup(pParse->db, pExpr, 0);
            pPartial = sqlite3ExprAnd(pParse, pPartial, tmp);
          }
        }
      }
    }
    tmp___4 = termCanDriveIndex(pTerm, pSrc, notReady);
    if (tmp___4) {
      iCol = pTerm->u.leftColumn;
      if (iCol >= (int )(sizeof(Bitmask ) * 8UL)) {
        tmp___1 = 1ULL << ((int )(sizeof(Bitmask ) * 8UL) - 1);
      } else {
        tmp___1 = 1ULL << iCol;
      }
      cMask = tmp___1;
      if (! sentWarning) {
        sqlite3_log(28 | (1 << 8), "automatic index on %s(%s)", pTable->zName, (pTable->aCol + iCol)->zName);
        sentWarning = (u8 )1;
      }
      if ((idxCols & cMask) == 0ULL) {
        tmp___2 = whereLoopResize(pParse->db, pLoop, nKeyCol + 1);
        if (tmp___2) {
          goto end_auto_index_create;
        }
        tmp___3 = nKeyCol;
        nKeyCol ++;
        *(pLoop->aLTerm + tmp___3) = pTerm;
        idxCols |= cMask;
      }
    }
    pTerm ++;
  }
  tmp___5 = (u16 )nKeyCol;
  pLoop->nLTerm = tmp___5;
  pLoop->u.btree.nEq = tmp___5;
  pLoop->wsFlags = (u32 )16961;
  extraCols = pSrc->colUsed & (~ idxCols | (1ULL << ((int )(sizeof(Bitmask ) * 8UL) - 1)));
  if ((int )(sizeof(Bitmask ) * 8UL) - 1 < (int )pTable->nCol) {
    mxBitCol = (int )(sizeof(Bitmask ) * 8UL) - 1;
  } else {
    mxBitCol = (int )pTable->nCol;
  }
  i = 0;
  while (i < mxBitCol) {
    if (extraCols & (1ULL << i)) {
      nKeyCol ++;
    }
    i ++;
  }
  if (pSrc->colUsed & (1ULL << ((int )(sizeof(Bitmask ) * 8UL) - 1))) {
    nKeyCol += ((int )pTable->nCol - (int )(sizeof(Bitmask ) * 8UL)) + 1;
  }
  pIdx = sqlite3AllocateIndexObject(pParse->db, (i16 )(nKeyCol + 1), 0, & zNotUsed);
  if ((unsigned long )pIdx == (unsigned long )((Index *)0)) {
    goto end_auto_index_create;
  }
  pLoop->u.btree.pIndex = pIdx;
  pIdx->zName = (char *)"auto-index";
  pIdx->pTable = pTable;
  n = 0;
  idxCols = (Bitmask )0;
  pTerm = pWC->a;
  while ((unsigned long )pTerm < (unsigned long )pWCEnd) {
    tmp___7 = termCanDriveIndex(pTerm, pSrc, notReady);
    if (tmp___7) {
      iCol___0 = pTerm->u.leftColumn;
      if (iCol___0 >= (int )(sizeof(Bitmask ) * 8UL)) {
        tmp___6 = 1ULL << ((int )(sizeof(Bitmask ) * 8UL) - 1);
      } else {
        tmp___6 = 1ULL << iCol___0;
      }
      cMask___0 = tmp___6;
      if ((idxCols & cMask___0) == 0ULL) {
        pX = pTerm->pExpr;
        idxCols |= cMask___0;
        *(pIdx->aiColumn + n) = (i16 )pTerm->u.leftColumn;
        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
        if (pColl) {
          *(pIdx->azColl + n) = (char const   *)pColl->zName;
        } else {
          *(pIdx->azColl + n) = sqlite3StrBINARY;
        }
        n ++;
      }
    }
    pTerm ++;
  }
  i = 0;
  while (i < mxBitCol) {
    if (extraCols & (1ULL << i)) {
      *(pIdx->aiColumn + n) = (i16 )i;
      *(pIdx->azColl + n) = sqlite3StrBINARY;
      n ++;
    }
    i ++;
  }
  if (pSrc->colUsed & (1ULL << ((int )(sizeof(Bitmask ) * 8UL) - 1))) {
    i = (int )(sizeof(Bitmask ) * 8UL) - 1;
    while (i < (int )pTable->nCol) {
      *(pIdx->aiColumn + n) = (i16 )i;
      *(pIdx->azColl + n) = sqlite3StrBINARY;
      n ++;
      i ++;
    }
  }
  *(pIdx->aiColumn + n) = (i16 )-1;
  *(pIdx->azColl + n) = sqlite3StrBINARY;
  tmp___8 = pParse->nTab;
  (pParse->nTab) ++;
  pLevel->iIdxCur = tmp___8;
  sqlite3VdbeAddOp2(v, 111, pLevel->iIdxCur, nKeyCol + 1);
  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
  pTabItem = & ((pWC->pWInfo)->pTabList)->a[pLevel->iFrom];
  if (pTabItem->fg.viaCoroutine) {
    regYield = pTabItem->regReturn;
    addrCounter = sqlite3VdbeAddOp2(v, 70, 0, 0);
    sqlite3VdbeAddOp3(v, 13, regYield, 0, pTabItem->addrFillSub);
    addrTop = sqlite3VdbeAddOp1(v, 14, regYield);
  } else {
    addrTop = sqlite3VdbeAddOp1(v, 36, pLevel->iTabCur);
  }
  if (pPartial) {
    iContinue = sqlite3VdbeMakeLabel(pParse);
    sqlite3ExprIfFalse(pParse, pPartial, iContinue, 16);
    pLoop->wsFlags |= 131072U;
  }
  regRecord = sqlite3GetTempReg(pParse);
  regBase = sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 0, (int *)0,
                                    (Index *)0, 0);
  sqlite3VdbeAddOp2(v, 132, pLevel->iIdxCur, regRecord);
  sqlite3VdbeChangeP5(v, (u16 )16);
  if (pPartial) {
    sqlite3VdbeResolveLabel(v, iContinue);
  }
  if (pTabItem->fg.viaCoroutine) {
    sqlite3VdbeChangeP2(v, addrCounter, regBase + n);
    translateColumnToCopy(pParse, addrTop, pLevel->iTabCur, pTabItem->regResult, pLevel->iIdxCur);
    sqlite3VdbeGoto(v, addrTop);
    pTabItem->fg.viaCoroutine = 0U;
  } else {
    sqlite3VdbeAddOp2(v, 5, pLevel->iTabCur, addrTop + 1);
  }
  sqlite3VdbeChangeP5(v, (u16 )3);
  sqlite3VdbeJumpHere(v, addrTop);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeJumpHere(v, addrInit);
  end_auto_index_create: 
  sqlite3ExprDelete(pParse->db, pPartial);
  return;
}
}
static sqlite3_index_info *allocateIndexInfo(Parse *pParse , WhereClause *pWC , Bitmask mUnusable ,
                                             struct SrcList_item *pSrc , ExprList *pOrderBy ,
                                             u16 *pmNoOmit ) 
{ 
  int i ;
  int j ;
  int nTerm ;
  struct sqlite3_index_constraint *pIdxCons ;
  struct sqlite3_index_orderby *pIdxOrderBy ;
  struct sqlite3_index_constraint_usage *pUsage ;
  struct HiddenIndexInfo *pHidden ;
  WhereTerm *pTerm ;
  int nOrderBy ;
  sqlite3_index_info *pIdxInfo ;
  u16 mNoOmit ;
  int n ;
  Expr *pExpr ;
  void *tmp ;
  u16 op ;
  int tmp___0 ;
  Expr *pExpr___0 ;

  {
  mNoOmit = (u16 )0;
  nTerm = 0;
  i = nTerm;
  pTerm = pWC->a;
  while (i < pWC->nTerm) {
    if (pTerm->leftCursor != pSrc->iCursor) {
      goto __Cont;
    }
    if (pTerm->prereqRight & mUnusable) {
      goto __Cont;
    }
    if (((int )pTerm->eOperator & -2049) == 0) {
      goto __Cont;
    }
    nTerm ++;
    __Cont: /* CIL Label */ 
    i ++;
    pTerm ++;
  }
  nOrderBy = 0;
  if (pOrderBy) {
    n = pOrderBy->nExpr;
    i = 0;
    while (i < n) {
      pExpr = pOrderBy->a[i].pExpr;
      if ((int )pExpr->op != 162) {
        break;
      } else
      if (pExpr->iTable != pSrc->iCursor) {
        break;
      }
      if ((int )pOrderBy->a[i].sortFlags & 2) {
        break;
      }
      i ++;
    }
    if (i == n) {
      nOrderBy = n;
    }
  }
  tmp = sqlite3DbMallocZero(pParse->db, (u64 )(((sizeof(*pIdxInfo) + (sizeof(*pIdxCons) + sizeof(*pUsage)) * (unsigned long )nTerm) + sizeof(*pIdxOrderBy) * (unsigned long )nOrderBy) + sizeof(*pHidden)));
  pIdxInfo = (sqlite3_index_info *)tmp;
  if ((unsigned long )pIdxInfo == (unsigned long )((sqlite3_index_info *)0)) {
    sqlite3ErrorMsg(pParse, "out of memory");
    return ((sqlite3_index_info *)0);
  }
  pHidden = (struct HiddenIndexInfo *)(pIdxInfo + 1);
  pIdxCons = (struct sqlite3_index_constraint *)(pHidden + 1);
  pIdxOrderBy = (struct sqlite3_index_orderby *)(pIdxCons + nTerm);
  pUsage = (struct sqlite3_index_constraint_usage *)(pIdxOrderBy + nOrderBy);
  pIdxInfo->nConstraint = nTerm;
  pIdxInfo->nOrderBy = nOrderBy;
  pIdxInfo->aConstraint = pIdxCons;
  pIdxInfo->aOrderBy = pIdxOrderBy;
  pIdxInfo->aConstraintUsage = pUsage;
  pHidden->pWC = pWC;
  pHidden->pParse = pParse;
  j = 0;
  i = j;
  pTerm = pWC->a;
  while (i < pWC->nTerm) {
    if (pTerm->leftCursor != pSrc->iCursor) {
      goto __Cont___0;
    }
    if (pTerm->prereqRight & mUnusable) {
      goto __Cont___0;
    }
    if (((int )pTerm->eOperator & -2049) == 0) {
      goto __Cont___0;
    }
    if (((int )pSrc->fg.jointype & 8) != 0) {
      if (! (((pTerm->pExpr)->flags & 1U) != 0U)) {
        if ((int )pTerm->eOperator & 384) {
          goto __Cont___0;
        }
      }
    }
    (pIdxCons + j)->iColumn = pTerm->u.leftColumn;
    (pIdxCons + j)->iTermOffset = i;
    op = (u16 )((int )pTerm->eOperator & 8191);
    if ((int )op == 1) {
      op = (u16 )2;
    }
    if ((int )op == 64) {
      (pIdxCons + j)->op = pTerm->eMatchOp;
    } else
    if ((int )op & 384) {
      if ((int )op == 256) {
        (pIdxCons + j)->op = (unsigned char)71;
      } else {
        (pIdxCons + j)->op = (unsigned char)72;
      }
    } else {
      (pIdxCons + j)->op = (u8 )op;
      if ((int )op & ((((2 << 3) | (2 << 2)) | (2 << 1)) | (2 << 4))) {
        tmp___0 = sqlite3ExprIsVector((pTerm->pExpr)->pRight);
        if (tmp___0) {
          if (i < 16) {
            mNoOmit = (u16 )((int )mNoOmit | (1 << i));
          }
          if ((int )op == 2 << 3) {
            (pIdxCons + j)->op = (unsigned char )(2 << 2);
          }
          if ((int )op == 2 << 1) {
            (pIdxCons + j)->op = (unsigned char )(2 << 4);
          }
        }
      }
    }
    j ++;
    __Cont___0: /* CIL Label */ 
    i ++;
    pTerm ++;
  }
  i = 0;
  while (i < nOrderBy) {
    pExpr___0 = pOrderBy->a[i].pExpr;
    (pIdxOrderBy + i)->iColumn = (int )pExpr___0->iColumn;
    (pIdxOrderBy + i)->desc = (unsigned char )((int )pOrderBy->a[i].sortFlags & 1);
    i ++;
  }
  *pmNoOmit = mNoOmit;
  return (pIdxInfo);
}
}
static int vtabBestIndex(Parse *pParse , Table *pTab , sqlite3_index_info *p ) 
{ 
  sqlite3_vtab *pVtab ;
  VTable *tmp ;
  int rc ;
  char const   *tmp___0 ;

  {
  tmp = sqlite3GetVTable(pParse->db, pTab);
  pVtab = tmp->pVtab;
  rc = (*((pVtab->pModule)->xBestIndex))(pVtab, p);
  if (rc != 0) {
    if (rc != 19) {
      if (rc == 7) {
        sqlite3OomFault(pParse->db);
      } else
      if (! pVtab->zErrMsg) {
        tmp___0 = sqlite3ErrStr(rc);
        sqlite3ErrorMsg(pParse, "%s", tmp___0);
      } else {
        sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
      }
    }
  }
  sqlite3_free((void *)pVtab->zErrMsg);
  pVtab->zErrMsg = (char *)0;
  return (rc);
}
}
static LogEst whereRangeAdjust(WhereTerm *pTerm , LogEst nNew ) 
{ 
  LogEst nRet ;

  {
  nRet = nNew;
  if (pTerm) {
    if ((int )pTerm->truthProb <= 0) {
      nRet = (LogEst )((int )nRet + (int )pTerm->truthProb);
    } else {
      nRet = (LogEst )((int )nRet - 20);
    }
  }
  return (nRet);
}
}
static int whereRangeScanEst(Parse *pParse , WhereLoopBuilder *pBuilder , WhereTerm *pLower ,
                             WhereTerm *pUpper , WhereLoop *pLoop ) 
{ 
  int rc ;
  int nOut ;
  LogEst nNew ;

  {
  rc = 0;
  nOut = (int )pLoop->nOut;
  nNew = whereRangeAdjust(pLower, (LogEst )nOut);
  nNew = whereRangeAdjust(pUpper, nNew);
  if (pLower) {
    if ((int )pLower->truthProb > 0) {
      if (pUpper) {
        if ((int )pUpper->truthProb > 0) {
          nNew = (LogEst )((int )nNew - 20);
        }
      }
    }
  }
  nOut -= ((unsigned long )pLower != (unsigned long )((WhereTerm *)0)) + ((unsigned long )pUpper != (unsigned long )((WhereTerm *)0));
  if ((int )nNew < 10) {
    nNew = (LogEst )10;
  }
  if ((int )nNew < nOut) {
    nOut = (int )nNew;
  }
  pLoop->nOut = (LogEst )nOut;
  return (rc);
}
}
static void whereLoopInit(WhereLoop *p ) 
{ 


  {
  p->aLTerm = p->aLTermSpace;
  p->nLTerm = (u16 )0;
  p->nLSlot = (u16 )((int )(sizeof(p->aLTermSpace) / sizeof(p->aLTermSpace[0])));
  p->wsFlags = (u32 )0;
  return;
}
}
static void whereLoopClearUnion(sqlite3 *db , WhereLoop *p ) 
{ 


  {
  if (p->wsFlags & 17408U) {
    if ((p->wsFlags & 1024U) != 0U) {
      if (p->u.vtab.needFree) {
        sqlite3_free((void *)p->u.vtab.idxStr);
        p->u.vtab.needFree = (u8 )0;
        p->u.vtab.idxStr = (char *)0;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((p->wsFlags & 16384U) != 0U) {
      if ((unsigned long )p->u.btree.pIndex != (unsigned long )((Index *)0)) {
        sqlite3DbFree(db, (void *)(p->u.btree.pIndex)->zColAff);
        sqlite3DbFreeNN(db, (void *)p->u.btree.pIndex);
        p->u.btree.pIndex = (Index *)0;
      }
    }
  }
  return;
}
}
static void whereLoopClear(sqlite3 *db , WhereLoop *p ) 
{ 


  {
  if ((unsigned long )p->aLTerm != (unsigned long )(p->aLTermSpace)) {
    sqlite3DbFreeNN(db, (void *)p->aLTerm);
  }
  whereLoopClearUnion(db, p);
  whereLoopInit(p);
  return;
}
}
static int whereLoopResize(sqlite3 *db , WhereLoop *p , int n ) 
{ 
  WhereTerm **paNew ;
  void *tmp ;

  {
  if ((int )p->nLSlot >= n) {
    return (0);
  }
  n = (n + 7) & -8;
  tmp = sqlite3DbMallocRawNN(db, (u64 )(sizeof(*(p->aLTerm + 0)) * (unsigned long )n));
  paNew = (WhereTerm **)tmp;
  if ((unsigned long )paNew == (unsigned long )((WhereTerm **)0)) {
    return (7);
  }
  memcpy((void * __restrict  )paNew, (void const   * __restrict  )p->aLTerm, sizeof(*(p->aLTerm + 0)) * (unsigned long )p->nLSlot);
  if ((unsigned long )p->aLTerm != (unsigned long )(p->aLTermSpace)) {
    sqlite3DbFreeNN(db, (void *)p->aLTerm);
  }
  p->aLTerm = paNew;
  p->nLSlot = (u16 )n;
  return (0);
}
}
static int whereLoopXfer(sqlite3 *db , WhereLoop *pTo , WhereLoop *pFrom ) 
{ 
  int tmp ;

  {
  whereLoopClearUnion(db, pTo);
  tmp = whereLoopResize(db, pTo, (int )pFrom->nLTerm);
  if (tmp) {
    memset((void *)(& pTo->u), 0, sizeof(pTo->u));
    return (7);
  }
  memcpy((void * __restrict  )pTo, (void const   * __restrict  )pFrom, (unsigned long )(& ((WhereLoop *)0)->nLSlot));
  memcpy((void * __restrict  )pTo->aLTerm, (void const   * __restrict  )pFrom->aLTerm,
         (unsigned long )pTo->nLTerm * sizeof(*(pTo->aLTerm + 0)));
  if (pFrom->wsFlags & 1024U) {
    pFrom->u.vtab.needFree = (u8 )0;
  } else
  if ((pFrom->wsFlags & 16384U) != 0U) {
    pFrom->u.btree.pIndex = (Index *)0;
  }
  return (0);
}
}
static void whereLoopDelete(sqlite3 *db , WhereLoop *p ) 
{ 


  {
  whereLoopClear(db, p);
  sqlite3DbFreeNN(db, (void *)p);
  return;
}
}
static void whereInfoFree(sqlite3 *db , WhereInfo *pWInfo ) 
{ 
  int i ;
  WhereLevel *pLevel ;
  WhereLoop *p ;

  {
  i = 0;
  while (i < (int )pWInfo->nLevel) {
    pLevel = & pWInfo->a[i];
    if (pLevel->pWLoop) {
      if ((pLevel->pWLoop)->wsFlags & 2048U) {
        sqlite3DbFree(db, (void *)pLevel->u.in.aInLoop);
      }
    }
    i ++;
  }
  sqlite3WhereClauseClear(& pWInfo->sWC);
  while (pWInfo->pLoops) {
    p = pWInfo->pLoops;
    pWInfo->pLoops = p->pNextLoop;
    whereLoopDelete(db, p);
  }
  sqlite3DbFreeNN(db, (void *)pWInfo);
  return;
}
}
static int whereLoopCheaperProperSubset(WhereLoop const   *pX , WhereLoop const   *pY ) 
{ 
  int i ;
  int j ;

  {
  if ((int const   )pX->nLTerm - (int const   )pX->nSkip >= (int const   )pY->nLTerm - (int const   )pY->nSkip) {
    return (0);
  }
  if ((int const   )pY->nSkip > (int const   )pX->nSkip) {
    return (0);
  }
  if ((int const   )pX->rRun >= (int const   )pY->rRun) {
    if ((int const   )pX->rRun > (int const   )pY->rRun) {
      return (0);
    }
    if ((int const   )pX->nOut > (int const   )pY->nOut) {
      return (0);
    }
  }
  i = (int )((int const   )pX->nLTerm - 1);
  while (i >= 0) {
    if ((unsigned long )*(pX->aLTerm + i) == (unsigned long )((WhereTerm *)0)) {
      goto __Cont;
    }
    j = (int )((int const   )pY->nLTerm - 1);
    while (j >= 0) {
      if ((unsigned long )*(pY->aLTerm + j) == (unsigned long )*(pX->aLTerm + i)) {
        break;
      }
      j --;
    }
    if (j < 0) {
      return (0);
    }
    __Cont: /* CIL Label */ 
    i --;
  }
  if ((pX->wsFlags & 64U) != 0U) {
    if ((pY->wsFlags & 64U) == 0U) {
      return (0);
    }
  }
  return (1);
}
}
static void whereLoopAdjustCost(WhereLoop const   *p , WhereLoop *pTemplate ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((pTemplate->wsFlags & 512U) == 0U) {
    return;
  }
  while (p) {
    if ((int const   )p->iTab != (int const   )pTemplate->iTab) {
      goto __Cont;
    }
    if ((p->wsFlags & 512U) == 0U) {
      goto __Cont;
    }
    tmp___0 = whereLoopCheaperProperSubset(p, (WhereLoop const   *)pTemplate);
    if (tmp___0) {
      pTemplate->rRun = (LogEst )p->rRun;
      pTemplate->nOut = (LogEst )((int const   )p->nOut - 1);
    } else {
      tmp = whereLoopCheaperProperSubset((WhereLoop const   *)pTemplate, p);
      if (tmp) {
        pTemplate->rRun = (LogEst )p->rRun;
        pTemplate->nOut = (LogEst )((int const   )p->nOut + 1);
      }
    }
    __Cont: /* CIL Label */ 
    p = (WhereLoop const   *)p->pNextLoop;
  }
  return;
}
}
static WhereLoop **whereLoopFindLesser(WhereLoop **ppPrev , WhereLoop const   *pTemplate ) 
{ 
  WhereLoop *p ;

  {
  p = *ppPrev;
  while (p) {
    if ((int )p->iTab != (int )pTemplate->iTab) {
      goto __Cont;
    } else
    if ((int )p->iSortIdx != (int )pTemplate->iSortIdx) {
      goto __Cont;
    }
    if ((p->wsFlags & 16384U) != 0U) {
      if ((int const   )pTemplate->nSkip == 0) {
        if ((pTemplate->wsFlags & 512U) != 0U) {
          if ((pTemplate->wsFlags & 1U) != 0U) {
            if ((p->prereq & (unsigned long long )pTemplate->prereq) == (unsigned long long )pTemplate->prereq) {
              break;
            }
          }
        }
      }
    }
    if ((p->prereq & (unsigned long long )pTemplate->prereq) == p->prereq) {
      if ((int )p->rSetup <= (int )pTemplate->rSetup) {
        if ((int )p->rRun <= (int )pTemplate->rRun) {
          if ((int )p->nOut <= (int )pTemplate->nOut) {
            return ((WhereLoop **)0);
          }
        }
      }
    }
    if ((p->prereq & (unsigned long long )pTemplate->prereq) == (unsigned long long )pTemplate->prereq) {
      if ((int )p->rRun >= (int )pTemplate->rRun) {
        if ((int )p->nOut >= (int )pTemplate->nOut) {
          break;
        }
      }
    }
    __Cont: /* CIL Label */ 
    ppPrev = & p->pNextLoop;
    p = *ppPrev;
  }
  return (ppPrev);
}
}
static int whereLoopInsert(WhereLoopBuilder *pBuilder , WhereLoop *pTemplate ) 
{ 
  WhereLoop **ppPrev ;
  WhereLoop *p ;
  WhereInfo *pWInfo ;
  sqlite3 *db ;
  int rc ;
  void *tmp ;
  WhereLoop **ppTail ;
  WhereLoop *pToDel ;
  Index *pIndex ;

  {
  pWInfo = pBuilder->pWInfo;
  db = (pWInfo->pParse)->db;
  if (pBuilder->iPlanLimit == 0U) {
    if (pBuilder->pOrSet) {
      (pBuilder->pOrSet)->n = (u16 )0;
    }
    return (101);
  }
  (pBuilder->iPlanLimit) --;
  if ((unsigned long )pBuilder->pOrSet != (unsigned long )((WhereOrSet *)0)) {
    if (pTemplate->nLTerm) {
      whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun, pTemplate->nOut);
    }
    return (0);
  }
  whereLoopAdjustCost((WhereLoop const   *)pWInfo->pLoops, pTemplate);
  ppPrev = whereLoopFindLesser(& pWInfo->pLoops, (WhereLoop const   *)pTemplate);
  if ((unsigned long )ppPrev == (unsigned long )((WhereLoop **)0)) {
    return (0);
  } else {
    p = *ppPrev;
  }
  if ((unsigned long )p == (unsigned long )((WhereLoop *)0)) {
    tmp = sqlite3DbMallocRawNN(db, (u64 )sizeof(WhereLoop ));
    p = (WhereLoop *)tmp;
    *ppPrev = p;
    if ((unsigned long )p == (unsigned long )((WhereLoop *)0)) {
      return (7);
    }
    whereLoopInit(p);
    p->pNextLoop = (WhereLoop *)0;
  } else {
    ppTail = & p->pNextLoop;
    while (*ppTail) {
      ppTail = whereLoopFindLesser(ppTail, (WhereLoop const   *)pTemplate);
      if ((unsigned long )ppTail == (unsigned long )((WhereLoop **)0)) {
        break;
      }
      pToDel = *ppTail;
      if ((unsigned long )pToDel == (unsigned long )((WhereLoop *)0)) {
        break;
      }
      *ppTail = pToDel->pNextLoop;
      whereLoopDelete(db, pToDel);
    }
  }
  rc = whereLoopXfer(db, p, pTemplate);
  if ((p->wsFlags & 1024U) == 0U) {
    pIndex = p->u.btree.pIndex;
    if (pIndex) {
      if (pIndex->idxType == 3U) {
        p->u.btree.pIndex = (Index *)0;
      }
    }
  }
  return (rc);
}
}
static void whereLoopOutputAdjust(WhereClause *pWC , WhereLoop *pLoop , LogEst nRow ) 
{ 
  WhereTerm *pTerm ;
  WhereTerm *pX ;
  Bitmask notAllowed ;
  int i ;
  int j ;
  LogEst iReduce ;
  Expr *pRight ;
  int k ;
  int tmp ;

  {
  notAllowed = ~ (pLoop->prereq | pLoop->maskSelf);
  iReduce = (LogEst )0;
  i = pWC->nTerm;
  pTerm = pWC->a;
  while (i > 0) {
    if (((int )pTerm->wtFlags & 2) != 0) {
      break;
    }
    if ((pTerm->prereqAll & pLoop->maskSelf) == 0ULL) {
      goto __Cont;
    }
    if ((pTerm->prereqAll & notAllowed) != 0ULL) {
      goto __Cont;
    }
    j = (int )pLoop->nLTerm - 1;
    while (j >= 0) {
      pX = *(pLoop->aLTerm + j);
      if ((unsigned long )pX == (unsigned long )((WhereTerm *)0)) {
        goto __Cont___0;
      }
      if ((unsigned long )pX == (unsigned long )pTerm) {
        break;
      }
      if (pX->iParent >= 0) {
        if ((unsigned long )(pWC->a + pX->iParent) == (unsigned long )pTerm) {
          break;
        }
      }
      __Cont___0: /* CIL Label */ 
      j --;
    }
    if (j < 0) {
      if ((int )pTerm->truthProb <= 0) {
        pLoop->nOut = (LogEst )((int )pLoop->nOut + (int )pTerm->truthProb);
      } else {
        pLoop->nOut = (LogEst )((int )pLoop->nOut - 1);
        if ((int )pTerm->eOperator & 130) {
          pRight = (pTerm->pExpr)->pRight;
          k = 0;
          tmp = sqlite3ExprIsInteger(pRight, & k);
          if (tmp) {
            if (k >= -1) {
              if (k <= 1) {
                k = 10;
              } else {
                k = 20;
              }
            } else {
              k = 20;
            }
          } else {
            k = 20;
          }
          if ((int )iReduce < k) {
            iReduce = (LogEst )k;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    i --;
    pTerm ++;
  }
  if ((int )pLoop->nOut > (int )nRow - (int )iReduce) {
    pLoop->nOut = (LogEst )((int )nRow - (int )iReduce);
  }
  return;
}
}
static int whereRangeVectorLen(Parse *pParse , int iCur , Index *pIdx , int nEq ,
                               WhereTerm *pTerm ) 
{ 
  int nCmp ;
  int tmp ;
  int i ;
  char aff ;
  char idxaff ;
  CollSeq *pColl ;
  Expr *pLhs ;
  Expr *pRhs ;
  char tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3ExprVectorSize((pTerm->pExpr)->pLeft);
  nCmp = tmp;
  if (nCmp < (int )pIdx->nColumn - nEq) {
    nCmp = nCmp;
  } else {
    nCmp = (int )pIdx->nColumn - nEq;
  }
  i = 1;
  while (i < nCmp) {
    idxaff = (char)0;
    pLhs = (((pTerm->pExpr)->pLeft)->x.pList)->a[i].pExpr;
    pRhs = (pTerm->pExpr)->pRight;
    if (pRhs->flags & 2048U) {
      pRhs = ((pRhs->x.pSelect)->pEList)->a[i].pExpr;
    } else {
      pRhs = (pRhs->x.pList)->a[i].pExpr;
    }
    if ((int )pLhs->op != 162) {
      break;
    } else
    if (pLhs->iTable != iCur) {
      break;
    } else
    if ((int )pLhs->iColumn != (int )*(pIdx->aiColumn + (i + nEq))) {
      break;
    } else
    if ((int )*(pIdx->aSortOrder + (i + nEq)) != (int )*(pIdx->aSortOrder + nEq)) {
      break;
    }
    tmp___0 = sqlite3ExprAffinity(pLhs);
    aff = sqlite3CompareAffinity(pRhs, tmp___0);
    idxaff = sqlite3TableColumnAffinity(pIdx->pTable, (int )pLhs->iColumn);
    if ((int )aff != (int )idxaff) {
      break;
    }
    pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
    if ((unsigned long )pColl == (unsigned long )((CollSeq *)0)) {
      break;
    }
    tmp___1 = sqlite3StrICmp((char const   *)pColl->zName, *(pIdx->azColl + (i + nEq)));
    if (tmp___1) {
      break;
    }
    i ++;
  }
  return (i);
}
}
static int whereLoopAddBtreeIndex(WhereLoopBuilder *pBuilder , struct SrcList_item *pSrc ,
                                  Index *pProbe , LogEst nInMul ) 
{ 
  WhereInfo *pWInfo ;
  Parse *pParse ;
  sqlite3 *db ;
  WhereLoop *pNew ;
  WhereTerm *pTerm ;
  int opMask ;
  WhereScan scan ;
  Bitmask saved_prereq ;
  u16 saved_nLTerm ;
  u16 saved_nEq ;
  u16 saved_nBtm ;
  u16 saved_nTop ;
  u16 saved_nSkip ;
  u32 saved_wsFlags ;
  LogEst saved_nOut ;
  int rc ;
  LogEst rSize ;
  LogEst rLogSize ;
  WhereTerm *pTop ;
  WhereTerm *pBtm ;
  u16 eOp ;
  LogEst rCostIdx ;
  LogEst nOutUnadjusted ;
  int nIn ;
  int tmp ;
  int tmp___0 ;
  u16 tmp___1 ;
  Expr *pExpr ;
  int i ;
  LogEst tmp___2 ;
  LogEst M ;
  LogEst logK ;
  LogEst safetyMargin ;
  int iCol ;
  int tmp___3 ;
  int tmp___4 ;
  u16 tmp___5 ;
  int tmp___6 ;
  int nEq ;
  LogEst nIter ;
  u16 tmp___7 ;

  {
  pWInfo = pBuilder->pWInfo;
  pParse = pWInfo->pParse;
  db = pParse->db;
  rc = 0;
  pTop = (WhereTerm *)0;
  pBtm = (WhereTerm *)0;
  pNew = pBuilder->pNew;
  if (db->mallocFailed) {
    return (7);
  }
  if (pNew->wsFlags & 32U) {
    opMask = (2 << 3) | (2 << 2);
  } else {
    opMask = (((((3 | (2 << 1)) | (2 << 4)) | (2 << 3)) | (2 << 2)) | 256) | 128;
  }
  if (pProbe->bUnordered) {
    opMask &= ~ ((((2 << 1) | (2 << 4)) | (2 << 3)) | (2 << 2));
  }
  saved_nEq = pNew->u.btree.nEq;
  saved_nBtm = pNew->u.btree.nBtm;
  saved_nTop = pNew->u.btree.nTop;
  saved_nSkip = pNew->nSkip;
  saved_nLTerm = pNew->nLTerm;
  saved_wsFlags = pNew->wsFlags;
  saved_prereq = pNew->prereq;
  saved_nOut = pNew->nOut;
  pTerm = whereScanInit(& scan, pBuilder->pWC, pSrc->iCursor, (int )saved_nEq, (u32 )opMask,
                        pProbe);
  pNew->rSetup = (LogEst )0;
  rSize = *(pProbe->aiRowLogEst + 0);
  rLogSize = estLog(rSize);
  while (1) {
    if (rc == 0) {
      if (! ((unsigned long )pTerm != (unsigned long )((WhereTerm *)0))) {
        break;
      }
    } else {
      break;
    }
    eOp = pTerm->eOperator;
    nIn = 0;
    if ((int )eOp == 256) {
      goto _L;
    } else
    if (0) {
      _L: /* CIL Label */ 
      tmp = indexColumnNotNull(pProbe, (int )saved_nEq);
      if (tmp) {
        goto __Cont;
      }
    }
    if (pTerm->prereqRight & pNew->maskSelf) {
      goto __Cont;
    }
    if ((int )pTerm->wtFlags & 256) {
      if ((int )pTerm->eOperator == 2 << 3) {
        goto __Cont;
      }
    }
    if (((int )pSrc->fg.jointype & 8) != 0) {
      if (! (((pTerm->pExpr)->flags & 1U) != 0U)) {
        goto __Cont;
      }
    }
    if ((int )pProbe->onError != 0) {
      if ((int )saved_nEq == (int )pProbe->nKeyCol - 1) {
        pBuilder->bldFlags |= 2U;
      } else {
        pBuilder->bldFlags |= 1U;
      }
    } else {
      pBuilder->bldFlags |= 1U;
    }
    pNew->wsFlags = saved_wsFlags;
    pNew->u.btree.nEq = saved_nEq;
    pNew->u.btree.nBtm = saved_nBtm;
    pNew->u.btree.nTop = saved_nTop;
    pNew->nLTerm = saved_nLTerm;
    tmp___0 = whereLoopResize(db, pNew, (int )pNew->nLTerm + 1);
    if (tmp___0) {
      break;
    }
    tmp___1 = pNew->nLTerm;
    pNew->nLTerm = (u16 )((int )pNew->nLTerm + 1);
    *(pNew->aLTerm + tmp___1) = pTerm;
    pNew->prereq = (saved_prereq | pTerm->prereqRight) & ~ pNew->maskSelf;
    if ((int )eOp & 1) {
      pExpr = pTerm->pExpr;
      if ((pExpr->flags & 2048U) != 0U) {
        nIn = 46;
        i = 0;
        while (i < (int )pNew->nLTerm - 1) {
          if (*(pNew->aLTerm + i)) {
            if ((unsigned long )(*(pNew->aLTerm + i))->pExpr == (unsigned long )pExpr) {
              nIn = 0;
            }
          }
          i ++;
        }
      } else
      if (pExpr->x.pList) {
        if ((pExpr->x.pList)->nExpr) {
          tmp___2 = sqlite3LogEst((u64 )(pExpr->x.pList)->nExpr);
          nIn = (int )tmp___2;
        }
      }
      if (pProbe->hasStat1) {
        M = *(pProbe->aiRowLogEst + saved_nEq);
        logK = estLog((LogEst )nIn);
        safetyMargin = (LogEst )10;
        if (((int )M + (int )logK) + (int )safetyMargin < nIn + (int )rLogSize) {
          goto __Cont;
        }
      }
      pNew->wsFlags |= 4U;
    } else
    if ((int )eOp & 130) {
      iCol = (int )*(pProbe->aiColumn + saved_nEq);
      pNew->wsFlags |= 1U;
      if (iCol == -1) {
        goto _L___0;
      } else
      if (iCol >= 0) {
        if ((int )nInMul == 0) {
          if ((int )saved_nEq == (int )pProbe->nKeyCol - 1) {
            _L___0: /* CIL Label */ 
            if (iCol == -1) {
              pNew->wsFlags |= 4096U;
            } else
            if (pProbe->uniqNotNull) {
              pNew->wsFlags |= 4096U;
            } else
            if ((int )pProbe->nKeyCol == 1) {
              if (pProbe->onError) {
                if ((int )eOp == 2) {
                  pNew->wsFlags |= 4096U;
                } else {
                  pNew->wsFlags |= 65536U;
                }
              } else {
                pNew->wsFlags |= 65536U;
              }
            } else {
              pNew->wsFlags |= 65536U;
            }
          }
        }
      }
    } else
    if ((int )eOp & 256) {
      pNew->wsFlags |= 8U;
    } else
    if ((int )eOp & ((2 << 1) | (2 << 4))) {
      pNew->wsFlags |= 34U;
      tmp___3 = whereRangeVectorLen(pParse, pSrc->iCursor, pProbe, (int )saved_nEq,
                                    pTerm);
      pNew->u.btree.nBtm = (u16 )tmp___3;
      pBtm = pTerm;
      pTop = (WhereTerm *)0;
      if ((int )pTerm->wtFlags & 256) {
        pTop = pTerm + 1;
        tmp___4 = whereLoopResize(db, pNew, (int )pNew->nLTerm + 1);
        if (tmp___4) {
          break;
        }
        tmp___5 = pNew->nLTerm;
        pNew->nLTerm = (u16 )((int )pNew->nLTerm + 1);
        *(pNew->aLTerm + tmp___5) = pTop;
        pNew->wsFlags |= 16U;
        pNew->u.btree.nTop = (u16 )1;
      }
    } else {
      pNew->wsFlags |= 18U;
      tmp___6 = whereRangeVectorLen(pParse, pSrc->iCursor, pProbe, (int )saved_nEq,
                                    pTerm);
      pNew->u.btree.nTop = (u16 )tmp___6;
      pTop = pTerm;
      if ((pNew->wsFlags & 32U) != 0U) {
        pBtm = *(pNew->aLTerm + ((int )pNew->nLTerm - 2));
      } else {
        pBtm = (WhereTerm *)0;
      }
    }
    if (pNew->wsFlags & 2U) {
      whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
    } else {
      pNew->u.btree.nEq = (u16 )((int )pNew->u.btree.nEq + 1);
      nEq = (int )pNew->u.btree.nEq;
      if ((int )pTerm->truthProb <= 0) {
        if ((int )*(pProbe->aiColumn + saved_nEq) >= 0) {
          pNew->nOut = (LogEst )((int )pNew->nOut + (int )pTerm->truthProb);
          pNew->nOut = (LogEst )((int )pNew->nOut - nIn);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        pNew->nOut = (LogEst )((int )pNew->nOut + ((int )*(pProbe->aiRowLogEst + nEq) - (int )*(pProbe->aiRowLogEst + (nEq - 1))));
        if ((int )eOp & 256) {
          pNew->nOut = (LogEst )((int )pNew->nOut + 10);
        }
      }
    }
    rCostIdx = (LogEst )(((int )pNew->nOut + 1) + (15 * (int )pProbe->szIdxRow) / (int )(pSrc->pTab)->szTabRow);
    pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);
    if ((pNew->wsFlags & 320U) == 0U) {
      pNew->rRun = sqlite3LogEstAdd(pNew->rRun, (LogEst )((int )pNew->nOut + 16));
    }
    nOutUnadjusted = pNew->nOut;
    pNew->rRun = (LogEst )((int )pNew->rRun + ((int )nInMul + nIn));
    pNew->nOut = (LogEst )((int )pNew->nOut + ((int )nInMul + nIn));
    whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);
    rc = whereLoopInsert(pBuilder, pNew);
    if (pNew->wsFlags & 2U) {
      pNew->nOut = saved_nOut;
    } else {
      pNew->nOut = nOutUnadjusted;
    }
    if ((pNew->wsFlags & 16U) == 0U) {
      if ((int )pNew->u.btree.nEq < (int )pProbe->nColumn) {
        whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (LogEst )((int )nInMul + nIn));
      }
    }
    pNew->nOut = saved_nOut;
    __Cont: /* CIL Label */ 
    pTerm = whereScanNext(& scan);
  }
  pNew->prereq = saved_prereq;
  pNew->u.btree.nEq = saved_nEq;
  pNew->u.btree.nBtm = saved_nBtm;
  pNew->u.btree.nTop = saved_nTop;
  pNew->nSkip = saved_nSkip;
  pNew->wsFlags = saved_wsFlags;
  pNew->nOut = saved_nOut;
  pNew->nLTerm = saved_nLTerm;
  if ((int )saved_nEq == (int )saved_nSkip) {
    if ((int )saved_nEq + 1 < (int )pProbe->nKeyCol) {
      if (pProbe->noSkipScan == 0U) {
        if (((int )db->dbOptFlags & 16384) == 0) {
          if ((int )*(pProbe->aiRowLogEst + ((int )saved_nEq + 1)) >= 42) {
            rc = whereLoopResize(db, pNew, (int )pNew->nLTerm + 1);
            if (rc == 0) {
              pNew->u.btree.nEq = (u16 )((int )pNew->u.btree.nEq + 1);
              pNew->nSkip = (u16 )((int )pNew->nSkip + 1);
              tmp___7 = pNew->nLTerm;
              pNew->nLTerm = (u16 )((int )pNew->nLTerm + 1);
              *(pNew->aLTerm + tmp___7) = (WhereTerm *)0;
              pNew->wsFlags |= 32768U;
              nIter = (LogEst )((int )*(pProbe->aiRowLogEst + saved_nEq) - (int )*(pProbe->aiRowLogEst + ((int )saved_nEq + 1)));
              pNew->nOut = (LogEst )((int )pNew->nOut - (int )nIter);
              nIter = (LogEst )((int )nIter + 5);
              whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (LogEst )((int )nIter + (int )nInMul));
              pNew->nOut = saved_nOut;
              pNew->u.btree.nEq = saved_nEq;
              pNew->nSkip = saved_nSkip;
              pNew->wsFlags = saved_wsFlags;
            }
          }
        }
      }
    }
  }
  return (rc);
}
}
static int indexMightHelpWithOrderBy(WhereLoopBuilder *pBuilder , Index *pIndex ,
                                     int iCursor ) 
{ 
  ExprList *pOB ;
  ExprList *aColExpr ;
  int ii ;
  int jj ;
  Expr *pExpr ;
  Expr *tmp ;
  int tmp___0 ;

  {
  if (pIndex->bUnordered) {
    return (0);
  }
  pOB = (pBuilder->pWInfo)->pOrderBy;
  if ((unsigned long )pOB == (unsigned long )((ExprList *)0)) {
    return (0);
  }
  ii = 0;
  while (ii < pOB->nExpr) {
    tmp = sqlite3ExprSkipCollateAndLikely(pOB->a[ii].pExpr);
    pExpr = tmp;
    if ((int )pExpr->op == 162) {
      if (pExpr->iTable == iCursor) {
        if ((int )pExpr->iColumn < 0) {
          return (1);
        }
        jj = 0;
        while (jj < (int )pIndex->nKeyCol) {
          if ((int )pExpr->iColumn == (int )*(pIndex->aiColumn + jj)) {
            return (1);
          }
          jj ++;
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      aColExpr = pIndex->aColExpr;
      if ((unsigned long )aColExpr != (unsigned long )((ExprList *)0)) {
        jj = 0;
        while (jj < (int )pIndex->nKeyCol) {
          if ((int )*(pIndex->aiColumn + jj) != -2) {
            goto __Cont;
          }
          tmp___0 = sqlite3ExprCompareSkip(pExpr, aColExpr->a[jj].pExpr, iCursor);
          if (tmp___0 == 0) {
            return (1);
          }
          __Cont: /* CIL Label */ 
          jj ++;
        }
      }
    }
    ii ++;
  }
  return (0);
}
}
static int whereUsablePartialIndex(int iTab , WhereClause *pWC , Expr *pWhere ) 
{ 
  int i ;
  WhereTerm *pTerm ;
  Parse *pParse ;
  int tmp ;
  Expr *pExpr ;
  int tmp___0 ;

  {
  pParse = (pWC->pWInfo)->pParse;
  while ((int )pWhere->op == 44) {
    tmp = whereUsablePartialIndex(iTab, pWC, pWhere->pLeft);
    if (! tmp) {
      return (0);
    }
    pWhere = pWhere->pRight;
  }
  if ((pParse->db)->flags & 8388608ULL) {
    pParse = (Parse *)0;
  }
  i = 0;
  pTerm = pWC->a;
  while (i < pWC->nTerm) {
    if ((int )pTerm->wtFlags & 8192) {
      goto __Cont;
    }
    pExpr = pTerm->pExpr;
    if (! ((pExpr->flags & 1U) != 0U)) {
      goto _L;
    } else
    if ((int )pExpr->iRightJoinTable == iTab) {
      _L: /* CIL Label */ 
      tmp___0 = sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab);
      if (tmp___0) {
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
    pTerm ++;
  }
  return (0);
}
}
static int whereLoopAddBtree(WhereLoopBuilder *pBuilder , Bitmask mPrereq ) 
{ 
  WhereInfo *pWInfo ;
  Index *pProbe ;
  Index sPk ;
  LogEst aiRowEstPk[2] ;
  i16 aiColumnPk ;
  SrcList *pTabList ;
  struct SrcList_item *pSrc ;
  WhereLoop *pNew ;
  int rc ;
  int iSortIdx ;
  int b ;
  LogEst rSize ;
  LogEst rLogSize ;
  WhereClause *pWC ;
  Table *pTab ;
  Index *pFirst ;
  WhereTerm *pTerm ;
  WhereTerm *pWCEnd ;
  int tmp ;
  int tmp___0 ;
  Bitmask m ;
  LogEst nLookup ;
  int ii ;
  int iCur ;
  WhereClause *pWC2 ;
  WhereTerm *pTerm___0 ;
  int tmp___1 ;

  {
  aiColumnPk = (i16 )-1;
  rc = 0;
  iSortIdx = 1;
  pNew = pBuilder->pNew;
  pWInfo = pBuilder->pWInfo;
  pTabList = pWInfo->pTabList;
  pSrc = pTabList->a + (int )pNew->iTab;
  pTab = pSrc->pTab;
  pWC = pBuilder->pWC;
  if (pSrc->pIBIndex) {
    pProbe = pSrc->pIBIndex;
  } else
  if (! ((pTab->tabFlags & 32U) == 0U)) {
    pProbe = pTab->pIndex;
  } else {
    memset((void *)(& sPk), 0, sizeof(Index ));
    sPk.nKeyCol = (u16 )1;
    sPk.nColumn = (u16 )1;
    sPk.aiColumn = & aiColumnPk;
    sPk.aiRowLogEst = aiRowEstPk;
    sPk.onError = (u8 )5;
    sPk.pTable = pTab;
    sPk.szIdxRow = pTab->szTabRow;
    sPk.idxType = 3U;
    aiRowEstPk[0] = pTab->nRowLogEst;
    aiRowEstPk[1] = (LogEst )0;
    pFirst = (pSrc->pTab)->pIndex;
    if (pSrc->fg.notIndexed == 0U) {
      sPk.pNext = pFirst;
    }
    pProbe = & sPk;
  }
  rSize = pTab->nRowLogEst;
  rLogSize = estLog(rSize);
  if (! pBuilder->pOrSet) {
    if (((int )pWInfo->wctrlFlags & 32) == 0) {
      if ((((pWInfo->pParse)->db)->flags & 32768ULL) != 0ULL) {
        if ((unsigned long )pSrc->pIBIndex == (unsigned long )((Index *)0)) {
          if (! pSrc->fg.notIndexed) {
            if ((pTab->tabFlags & 32U) == 0U) {
              if (! pSrc->fg.isCorrelated) {
                if (! pSrc->fg.isRecursive) {
                  pWCEnd = pWC->a + pWC->nTerm;
                  pTerm = pWC->a;
                  while (1) {
                    if (rc == 0) {
                      if (! ((unsigned long )pTerm < (unsigned long )pWCEnd)) {
                        break;
                      }
                    } else {
                      break;
                    }
                    if (pTerm->prereqRight & pNew->maskSelf) {
                      goto __Cont;
                    }
                    tmp = termCanDriveIndex(pTerm, pSrc, (Bitmask )0);
                    if (tmp) {
                      pNew->u.btree.nEq = (u16 )1;
                      pNew->nSkip = (u16 )0;
                      pNew->u.btree.pIndex = (Index *)0;
                      pNew->nLTerm = (u16 )1;
                      *(pNew->aLTerm + 0) = pTerm;
                      pNew->rSetup = (LogEst )((int )rLogSize + (int )rSize);
                      if ((unsigned long )pTab->pSelect == (unsigned long )((Select *)0)) {
                        if ((pTab->tabFlags & 2U) == 0U) {
                          pNew->rSetup = (LogEst )((int )pNew->rSetup + 28);
                        } else {
                          pNew->rSetup = (LogEst )((int )pNew->rSetup - 10);
                        }
                      } else {
                        pNew->rSetup = (LogEst )((int )pNew->rSetup - 10);
                      }
                      if ((int )pNew->rSetup < 0) {
                        pNew->rSetup = (LogEst )0;
                      }
                      pNew->nOut = (LogEst )43;
                      pNew->rRun = sqlite3LogEstAdd(rLogSize, pNew->nOut);
                      pNew->wsFlags = (u32 )16384;
                      pNew->prereq = mPrereq | pTerm->prereqRight;
                      rc = whereLoopInsert(pBuilder, pNew);
                    }
                    __Cont: /* CIL Label */ 
                    pTerm ++;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while (1) {
    if (rc == 0) {
      if (! pProbe) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned long )pProbe->pPartIdxWhere != (unsigned long )((Expr *)0)) {
      tmp___0 = whereUsablePartialIndex(pSrc->iCursor, pWC, pProbe->pPartIdxWhere);
      if (! tmp___0) {
        goto __Cont___0;
      }
    }
    if (pProbe->bNoQuery) {
      goto __Cont___0;
    }
    rSize = *(pProbe->aiRowLogEst + 0);
    pNew->u.btree.nEq = (u16 )0;
    pNew->u.btree.nBtm = (u16 )0;
    pNew->u.btree.nTop = (u16 )0;
    pNew->nSkip = (u16 )0;
    pNew->nLTerm = (u16 )0;
    pNew->iSortIdx = (u8 )0;
    pNew->rSetup = (LogEst )0;
    pNew->prereq = mPrereq;
    pNew->nOut = rSize;
    pNew->u.btree.pIndex = pProbe;
    b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);
    if (pProbe->idxType == 3U) {
      pNew->wsFlags = (u32 )256;
      if (b) {
        pNew->iSortIdx = (u8 )iSortIdx;
      } else {
        pNew->iSortIdx = (u8 )0;
      }
      pNew->rRun = (LogEst )((int )rSize + 16);
      whereLoopOutputAdjust(pWC, pNew, rSize);
      rc = whereLoopInsert(pBuilder, pNew);
      pNew->nOut = rSize;
      if (rc) {
        break;
      }
    } else {
      if (pProbe->isCovering) {
        pNew->wsFlags = (u32 )576;
        m = (Bitmask )0;
      } else {
        m = pSrc->colUsed & pProbe->colNotIdxed;
        if (m == 0ULL) {
          pNew->wsFlags = (u32 )576;
        } else {
          pNew->wsFlags = (u32 )512;
        }
      }
      if (b) {
        goto _L;
      } else
      if (! ((pTab->tabFlags & 32U) == 0U)) {
        goto _L;
      } else
      if ((unsigned long )pProbe->pPartIdxWhere != (unsigned long )((Expr *)0)) {
        goto _L;
      } else
      if (m == 0ULL) {
        if (pProbe->bUnordered == 0U) {
          if ((int )pProbe->szIdxRow < (int )pTab->szTabRow) {
            if (((int )pWInfo->wctrlFlags & 4) == 0) {
              if (sqlite3Config.bUseCis) {
                if (((int )((pWInfo->pParse)->db)->dbOptFlags & 32) == 0) {
                  _L: /* CIL Label */ 
                  if (b) {
                    pNew->iSortIdx = (u8 )iSortIdx;
                  } else {
                    pNew->iSortIdx = (u8 )0;
                  }
                  pNew->rRun = (LogEst )(((int )rSize + 1) + (15 * (int )pProbe->szIdxRow) / (int )pTab->szTabRow);
                  if (m != 0ULL) {
                    nLookup = (LogEst )((int )rSize + 16);
                    iCur = pSrc->iCursor;
                    pWC2 = & pWInfo->sWC;
                    ii = 0;
                    while (ii < pWC2->nTerm) {
                      pTerm___0 = pWC2->a + ii;
                      tmp___1 = sqlite3ExprCoveredByIndex(pTerm___0->pExpr, iCur,
                                                          pProbe);
                      if (! tmp___1) {
                        break;
                      }
                      if ((int )pTerm___0->truthProb <= 0) {
                        nLookup = (LogEst )((int )nLookup + (int )pTerm___0->truthProb);
                      } else {
                        nLookup = (LogEst )((int )nLookup - 1);
                        if ((int )pTerm___0->eOperator & 130) {
                          nLookup = (LogEst )((int )nLookup - 19);
                        }
                      }
                      ii ++;
                    }
                    pNew->rRun = sqlite3LogEstAdd(pNew->rRun, nLookup);
                  }
                  whereLoopOutputAdjust(pWC, pNew, rSize);
                  rc = whereLoopInsert(pBuilder, pNew);
                  pNew->nOut = rSize;
                  if (rc) {
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    pBuilder->bldFlags = 0U;
    rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (LogEst )0);
    if (pBuilder->bldFlags == 1U) {
      pTab->tabFlags |= 256U;
    }
    __Cont___0: /* CIL Label */ 
    if (pSrc->pIBIndex) {
      pProbe = (Index *)0;
    } else {
      pProbe = pProbe->pNext;
    }
    iSortIdx ++;
  }
  return (rc);
}
}
static int whereLoopAddVirtualOne(WhereLoopBuilder *pBuilder , Bitmask mPrereq , Bitmask mUsable ,
                                  u16 mExclude , sqlite3_index_info *pIdxInfo , u16 mNoOmit ,
                                  int *pbIn ) 
{ 
  WhereClause *pWC ;
  struct sqlite3_index_constraint *pIdxCons ;
  struct sqlite3_index_constraint_usage *pUsage ;
  int i ;
  int mxTerm ;
  int rc ;
  WhereLoop *pNew ;
  Parse *pParse ;
  struct SrcList_item *pSrc ;
  int nConstraint ;
  WhereTerm *pTerm ;
  int iTerm ;
  WhereTerm *pTerm___0 ;
  int j ;
  int tmp ;

  {
  pWC = pBuilder->pWC;
  pUsage = pIdxInfo->aConstraintUsage;
  rc = 0;
  pNew = pBuilder->pNew;
  pParse = (pBuilder->pWInfo)->pParse;
  pSrc = & ((pBuilder->pWInfo)->pTabList)->a[pNew->iTab];
  nConstraint = pIdxInfo->nConstraint;
  *pbIn = 0;
  pNew->prereq = mPrereq;
  pIdxCons = pIdxInfo->aConstraint;
  i = 0;
  while (i < nConstraint) {
    pTerm = pWC->a + pIdxCons->iTermOffset;
    pIdxCons->usable = (unsigned char)0;
    if ((pTerm->prereqRight & mUsable) == pTerm->prereqRight) {
      if (((int )pTerm->eOperator & (int )mExclude) == 0) {
        pIdxCons->usable = (unsigned char)1;
      }
    }
    i ++;
    pIdxCons ++;
  }
  memset((void *)pUsage, 0, sizeof(*(pUsage + 0)) * (unsigned long )nConstraint);
  pIdxInfo->idxStr = (char *)0;
  pIdxInfo->idxNum = 0;
  pIdxInfo->orderByConsumed = 0;
  pIdxInfo->estimatedCost = 1e99 / (double )2;
  pIdxInfo->estimatedRows = (sqlite_int64 )25;
  pIdxInfo->idxFlags = 0;
  pIdxInfo->colUsed = (sqlite_uint64 )((sqlite_int64 )pSrc->colUsed);
  rc = vtabBestIndex(pParse, pSrc->pTab, pIdxInfo);
  if (rc) {
    if (rc == 19) {
      return (0);
    }
    return (rc);
  }
  mxTerm = -1;
  i = 0;
  while (i < nConstraint) {
    *(pNew->aLTerm + i) = (WhereTerm *)0;
    i ++;
  }
  pNew->u.vtab.omitMask = (u16 )0;
  pIdxCons = pIdxInfo->aConstraint;
  i = 0;
  while (i < nConstraint) {
    iTerm = (pUsage + i)->argvIndex - 1;
    if (iTerm >= 0) {
      j = pIdxCons->iTermOffset;
      if (iTerm >= nConstraint) {
        sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", (pSrc->pTab)->zName);
        return (1);
      } else
      if (j < 0) {
        sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", (pSrc->pTab)->zName);
        return (1);
      } else
      if (j >= pWC->nTerm) {
        sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", (pSrc->pTab)->zName);
        return (1);
      } else
      if ((unsigned long )*(pNew->aLTerm + iTerm) != (unsigned long )((WhereTerm *)0)) {
        sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", (pSrc->pTab)->zName);
        return (1);
      } else
      if ((int )pIdxCons->usable == 0) {
        sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", (pSrc->pTab)->zName);
        return (1);
      }
      pTerm___0 = pWC->a + j;
      pNew->prereq |= pTerm___0->prereqRight;
      *(pNew->aLTerm + iTerm) = pTerm___0;
      if (iTerm > mxTerm) {
        mxTerm = iTerm;
      }
      if (iTerm < 16) {
        if ((pUsage + i)->omit) {
          pNew->u.vtab.omitMask = (u16 )((int )pNew->u.vtab.omitMask | (1 << iTerm));
        }
      }
      if (((int )pTerm___0->eOperator & 1) != 0) {
        pIdxInfo->orderByConsumed = 0;
        pIdxInfo->idxFlags &= -2;
        *pbIn = 1;
      }
    }
    i ++;
    pIdxCons ++;
  }
  pNew->u.vtab.omitMask = (u16 )((int )pNew->u.vtab.omitMask & ~ ((int )mNoOmit));
  pNew->nLTerm = (u16 )(mxTerm + 1);
  i = 0;
  while (i <= mxTerm) {
    if ((unsigned long )*(pNew->aLTerm + i) == (unsigned long )((WhereTerm *)0)) {
      sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", (pSrc->pTab)->zName);
      return (1);
    }
    i ++;
  }
  pNew->u.vtab.idxNum = pIdxInfo->idxNum;
  pNew->u.vtab.needFree = (u8 )pIdxInfo->needToFreeIdxStr;
  pIdxInfo->needToFreeIdxStr = 0;
  pNew->u.vtab.idxStr = pIdxInfo->idxStr;
  if (pIdxInfo->orderByConsumed) {
    tmp = pIdxInfo->nOrderBy;
  } else {
    tmp = 0;
  }
  pNew->u.vtab.isOrdered = (i8 )tmp;
  pNew->rSetup = (LogEst )0;
  pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);
  pNew->nOut = sqlite3LogEst((u64 )pIdxInfo->estimatedRows);
  if (pIdxInfo->idxFlags & 1) {
    pNew->wsFlags |= 4096U;
  } else {
    pNew->wsFlags &= 4294963199U;
  }
  rc = whereLoopInsert(pBuilder, pNew);
  if (pNew->u.vtab.needFree) {
    sqlite3_free((void *)pNew->u.vtab.idxStr);
    pNew->u.vtab.needFree = (u8 )0;
  }
  return (rc);
}
}
char const   *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo , int iCons ) 
{ 
  HiddenIndexInfo *pHidden ;
  char const   *zRet ;
  CollSeq *pC ;
  int iTerm ;
  Expr *pX ;

  {
  pHidden = (HiddenIndexInfo *)(pIdxInfo + 1);
  zRet = (char const   *)0;
  if (iCons >= 0) {
    if (iCons < pIdxInfo->nConstraint) {
      pC = (CollSeq *)0;
      iTerm = (pIdxInfo->aConstraint + iCons)->iTermOffset;
      pX = ((pHidden->pWC)->a + iTerm)->pExpr;
      if (pX->pLeft) {
        pC = sqlite3BinaryCompareCollSeq(pHidden->pParse, pX->pLeft, pX->pRight);
      }
      if (pC) {
        zRet = (char const   *)pC->zName;
      } else {
        zRet = sqlite3StrBINARY;
      }
    }
  }
  return (zRet);
}
}
static int whereLoopAddVirtual(WhereLoopBuilder *pBuilder , Bitmask mPrereq , Bitmask mUnusable ) 
{ 
  int rc ;
  WhereInfo *pWInfo ;
  Parse *pParse ;
  WhereClause *pWC ;
  struct SrcList_item *pSrc ;
  sqlite3_index_info *p ;
  int nConstraint ;
  int bIn ;
  WhereLoop *pNew ;
  Bitmask mBest ;
  u16 mNoOmit ;
  int tmp ;
  int seenZero ;
  int seenZeroNoIN ;
  Bitmask mPrev ;
  Bitmask mBestNoIn ;
  int i ;
  Bitmask mNext ;
  Bitmask mThis ;

  {
  rc = 0;
  pWInfo = pBuilder->pWInfo;
  pParse = pWInfo->pParse;
  pWC = pBuilder->pWC;
  pNew = pBuilder->pNew;
  pSrc = & (pWInfo->pTabList)->a[pNew->iTab];
  p = allocateIndexInfo(pParse, pWC, mUnusable, pSrc, pBuilder->pOrderBy, & mNoOmit);
  if ((unsigned long )p == (unsigned long )((sqlite3_index_info *)0)) {
    return (7);
  }
  pNew->rSetup = (LogEst )0;
  pNew->wsFlags = (u32 )1024;
  pNew->nLTerm = (u16 )0;
  pNew->u.vtab.needFree = (u8 )0;
  nConstraint = p->nConstraint;
  tmp = whereLoopResize(pParse->db, pNew, nConstraint);
  if (tmp) {
    sqlite3DbFree(pParse->db, (void *)p);
    return (7);
  }
  rc = whereLoopAddVirtualOne(pBuilder, mPrereq, (Bitmask )-1, (u16 )0, p, mNoOmit,
                              & bIn);
  if (rc == 0) {
    mBest = pNew->prereq & ~ mPrereq;
    if (mBest != 0ULL) {
      goto _L;
    } else
    if (bIn) {
      _L: /* CIL Label */ 
      seenZero = 0;
      seenZeroNoIN = 0;
      mPrev = (Bitmask )0;
      mBestNoIn = (Bitmask )0;
      if (bIn) {
        rc = whereLoopAddVirtualOne(pBuilder, mPrereq, (Bitmask )-1, (u16 )1, p, mNoOmit,
                                    & bIn);
        mBestNoIn = pNew->prereq & ~ mPrereq;
        if (mBestNoIn == 0ULL) {
          seenZero = 1;
          seenZeroNoIN = 1;
        }
      }
      while (rc == 0) {
        mNext = (Bitmask )-1;
        i = 0;
        while (i < nConstraint) {
          mThis = (pWC->a + (p->aConstraint + i)->iTermOffset)->prereqRight & ~ mPrereq;
          if (mThis > mPrev) {
            if (mThis < mNext) {
              mNext = mThis;
            }
          }
          i ++;
        }
        mPrev = mNext;
        if (mNext == 0xffffffffffffffffULL) {
          break;
        }
        if (mNext == mBest) {
          continue;
        } else
        if (mNext == mBestNoIn) {
          continue;
        }
        rc = whereLoopAddVirtualOne(pBuilder, mPrereq, mNext | mPrereq, (u16 )0, p,
                                    mNoOmit, & bIn);
        if (pNew->prereq == mPrereq) {
          seenZero = 1;
          if (bIn == 0) {
            seenZeroNoIN = 1;
          }
        }
      }
      if (rc == 0) {
        if (seenZero == 0) {
          rc = whereLoopAddVirtualOne(pBuilder, mPrereq, mPrereq, (u16 )0, p, mNoOmit,
                                      & bIn);
          if (bIn == 0) {
            seenZeroNoIN = 1;
          }
        }
      }
      if (rc == 0) {
        if (seenZeroNoIN == 0) {
          rc = whereLoopAddVirtualOne(pBuilder, mPrereq, mPrereq, (u16 )1, p, mNoOmit,
                                      & bIn);
        }
      }
    }
  }
  if (p->needToFreeIdxStr) {
    sqlite3_free((void *)p->idxStr);
  }
  sqlite3DbFreeNN(pParse->db, (void *)p);
  return (rc);
}
}
static int whereLoopAddOr(WhereLoopBuilder *pBuilder , Bitmask mPrereq , Bitmask mUnusable ) 
{ 
  WhereInfo *pWInfo ;
  WhereClause *pWC ;
  WhereLoop *pNew ;
  WhereTerm *pTerm ;
  WhereTerm *pWCEnd ;
  int rc ;
  int iCur ;
  WhereClause tempWC ;
  WhereLoopBuilder sSubBuild ;
  WhereOrSet sSum ;
  WhereOrSet sCur ;
  struct SrcList_item *pItem ;
  WhereClause *pOrWC ;
  WhereTerm *pOrWCEnd ;
  WhereTerm *pOrTerm ;
  int once ;
  int i ;
  int j ;
  WhereOrSet sPrev ;
  LogEst tmp ;
  LogEst tmp___0 ;

  {
  pWInfo = pBuilder->pWInfo;
  rc = 0;
  pWC = pBuilder->pWC;
  pWCEnd = pWC->a + pWC->nTerm;
  pNew = pBuilder->pNew;
  memset((void *)(& sSum), 0, sizeof(sSum));
  pItem = (pWInfo->pTabList)->a + (int )pNew->iTab;
  iCur = pItem->iCursor;
  pTerm = pWC->a;
  while (1) {
    if ((unsigned long )pTerm < (unsigned long )pWCEnd) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    if (((int )pTerm->eOperator & 512) != 0) {
      if (((pTerm->u.pOrInfo)->indexable & pNew->maskSelf) != 0ULL) {
        pOrWC = & (pTerm->u.pOrInfo)->wc;
        pOrWCEnd = pOrWC->a + pOrWC->nTerm;
        once = 1;
        sSubBuild = *pBuilder;
        sSubBuild.pOrderBy = (ExprList *)0;
        sSubBuild.pOrSet = & sCur;
        pOrTerm = pOrWC->a;
        while ((unsigned long )pOrTerm < (unsigned long )pOrWCEnd) {
          if (((int )pOrTerm->eOperator & 1024) != 0) {
            sSubBuild.pWC = & (pOrTerm->u.pAndInfo)->wc;
          } else
          if (pOrTerm->leftCursor == iCur) {
            tempWC.pWInfo = pWC->pWInfo;
            tempWC.pOuter = pWC;
            tempWC.op = (u8 )44;
            tempWC.nTerm = 1;
            tempWC.a = pOrTerm;
            sSubBuild.pWC = & tempWC;
          } else {
            goto __Cont;
          }
          sCur.n = (u16 )0;
          if ((pItem->pTab)->nModuleArg) {
            rc = whereLoopAddVirtual(& sSubBuild, mPrereq, mUnusable);
          } else {
            rc = whereLoopAddBtree(& sSubBuild, mPrereq);
          }
          if (rc == 0) {
            rc = whereLoopAddOr(& sSubBuild, mPrereq, mUnusable);
          }
          if ((int )sCur.n == 0) {
            sSum.n = (u16 )0;
            break;
          } else
          if (once) {
            whereOrMove(& sSum, & sCur);
            once = 0;
          } else {
            whereOrMove(& sPrev, & sSum);
            sSum.n = (u16 )0;
            i = 0;
            while (i < (int )sPrev.n) {
              j = 0;
              while (j < (int )sCur.n) {
                tmp = sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut);
                tmp___0 = sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun);
                whereOrInsert(& sSum, sPrev.a[i].prereq | sCur.a[j].prereq, tmp___0,
                              tmp);
                j ++;
              }
              i ++;
            }
          }
          __Cont: /* CIL Label */ 
          pOrTerm ++;
        }
        pNew->nLTerm = (u16 )1;
        *(pNew->aLTerm + 0) = pTerm;
        pNew->wsFlags = (u32 )8192;
        pNew->rSetup = (LogEst )0;
        pNew->iSortIdx = (u8 )0;
        memset((void *)(& pNew->u), 0, sizeof(pNew->u));
        i = 0;
        while (1) {
          if (rc == 0) {
            if (! (i < (int )sSum.n)) {
              break;
            }
          } else {
            break;
          }
          pNew->rRun = (LogEst )((int )sSum.a[i].rRun + 1);
          pNew->nOut = sSum.a[i].nOut;
          pNew->prereq = sSum.a[i].prereq;
          rc = whereLoopInsert(pBuilder, pNew);
          i ++;
        }
      }
    }
    pTerm ++;
  }
  return (rc);
}
}
static int whereLoopAddAll(WhereLoopBuilder *pBuilder ) 
{ 
  WhereInfo *pWInfo ;
  Bitmask mPrereq ;
  Bitmask mPrior ;
  int iTab ;
  SrcList *pTabList ;
  struct SrcList_item *pItem ;
  struct SrcList_item *pEnd ;
  sqlite3 *db ;
  int rc ;
  WhereLoop *pNew ;
  u8 priorJointype ;
  Bitmask mUnusable ;
  struct SrcList_item *p ;
  Bitmask tmp ;

  {
  pWInfo = pBuilder->pWInfo;
  mPrereq = (Bitmask )0;
  mPrior = (Bitmask )0;
  pTabList = pWInfo->pTabList;
  pEnd = & pTabList->a[pWInfo->nLevel];
  db = (pWInfo->pParse)->db;
  rc = 0;
  priorJointype = (u8 )0;
  pNew = pBuilder->pNew;
  whereLoopInit(pNew);
  pBuilder->iPlanLimit = 20000U;
  iTab = 0;
  pItem = pTabList->a;
  while ((unsigned long )pItem < (unsigned long )pEnd) {
    mUnusable = (Bitmask )0;
    pNew->iTab = (u8 )iTab;
    pBuilder->iPlanLimit += 1000U;
    pNew->maskSelf = sqlite3WhereGetMask(& pWInfo->sMaskSet, pItem->iCursor);
    if ((((int )pItem->fg.jointype | (int )priorJointype) & 10) != 0) {
      mPrereq = mPrior;
    }
    priorJointype = pItem->fg.jointype;
    if ((pItem->pTab)->nModuleArg) {
      p = pItem + 1;
      while ((unsigned long )p < (unsigned long )pEnd) {
        if (mUnusable) {
          tmp = sqlite3WhereGetMask(& pWInfo->sMaskSet, p->iCursor);
          mUnusable |= tmp;
        } else
        if ((int )p->fg.jointype & 10) {
          tmp = sqlite3WhereGetMask(& pWInfo->sMaskSet, p->iCursor);
          mUnusable |= tmp;
        }
        p ++;
      }
      rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable);
    } else {
      rc = whereLoopAddBtree(pBuilder, mPrereq);
    }
    if (rc == 0) {
      if ((pBuilder->pWC)->hasOr) {
        rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable);
      }
    }
    mPrior |= pNew->maskSelf;
    if (rc) {
      goto _L;
    } else
    if (db->mallocFailed) {
      _L: /* CIL Label */ 
      if (rc == 101) {
        sqlite3_log(28, "abbreviated query algorithm search");
        rc = 0;
      } else {
        break;
      }
    }
    iTab ++;
    pItem ++;
  }
  whereLoopClear(db, pNew);
  return (rc);
}
}
static i8 wherePathSatisfiesOrderBy(WhereInfo *pWInfo , ExprList *pOrderBy , WherePath *pPath ,
                                    u16 wctrlFlags , u16 nLoop , WhereLoop *pLast ,
                                    Bitmask *pRevMask ) 
{ 
  u8 revSet ;
  u8 rev ;
  u8 revIdx ;
  u8 isOrderDistinct ;
  u8 distinctColumns ;
  u8 isMatch ;
  u16 eqOpMask ;
  u16 nKeyCol ;
  u16 nColumn ;
  u16 nOrderBy ;
  int iLoop ;
  int i ;
  int j ;
  int iCur ;
  int iColumn ;
  WhereLoop *pLoop ;
  WhereTerm *pTerm ;
  Expr *pOBExpr ;
  CollSeq *pColl ;
  Index *pIndex ;
  sqlite3 *db ;
  Bitmask obSat ;
  Bitmask obDone ;
  Bitmask orderDistinctMask ;
  Bitmask ready ;
  int tmp ;
  int tmp___0 ;
  u8 bOnce ;
  u16 eOp ;
  Expr *pX ;
  Expr *pIdxExpr ;
  int tmp___1 ;
  int tmp___2 ;
  Expr *p ;
  Bitmask mTerm ;
  int tmp___3 ;
  Bitmask m ;

  {
  pLoop = (WhereLoop *)0;
  db = (pWInfo->pParse)->db;
  obSat = (Bitmask )0;
  if (nLoop) {
    if (((int )db->dbOptFlags & 64) != 0) {
      return ((i8 )0);
    }
  }
  nOrderBy = (u16 )pOrderBy->nExpr;
  if ((int )nOrderBy > (int )(sizeof(Bitmask ) * 8UL) - 1) {
    return ((i8 )0);
  }
  isOrderDistinct = (u8 )1;
  obDone = (1ULL << (int )nOrderBy) - 1ULL;
  orderDistinctMask = (Bitmask )0;
  ready = (Bitmask )0;
  eqOpMask = (u16 )386;
  if ((int )wctrlFlags & 2048) {
    eqOpMask = (u16 )((int )eqOpMask | 1);
  }
  iLoop = 0;
  while (1) {
    if (isOrderDistinct) {
      if (obSat < obDone) {
        if (! (iLoop <= (int )nLoop)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (iLoop > 0) {
      ready |= pLoop->maskSelf;
    }
    if (iLoop < (int )nLoop) {
      pLoop = *(pPath->aLoop + iLoop);
      if ((int )wctrlFlags & 2048) {
        goto __Cont;
      }
    } else {
      pLoop = pLast;
    }
    if (pLoop->wsFlags & 1024U) {
      if (pLoop->u.vtab.isOrdered) {
        obSat = obDone;
      }
      break;
    } else
    if ((int )wctrlFlags & 128) {
      pLoop->u.btree.nDistinctCol = (u16 )0;
    }
    iCur = (pWInfo->pTabList)->a[pLoop->iTab].iCursor;
    i = 0;
    while (i < (int )nOrderBy) {
      if ((1ULL << i) & obSat) {
        goto __Cont___0;
      }
      pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
      if ((int )pOBExpr->op != 162) {
        goto __Cont___0;
      }
      if (pOBExpr->iTable != iCur) {
        goto __Cont___0;
      }
      pTerm = sqlite3WhereFindTerm(& pWInfo->sWC, iCur, (int )pOBExpr->iColumn, ~ ready,
                                   (u32 )eqOpMask, (Index *)0);
      if ((unsigned long )pTerm == (unsigned long )((WhereTerm *)0)) {
        goto __Cont___0;
      }
      if ((int )pTerm->eOperator == 1) {
        j = 0;
        while (1) {
          if (j < (int )pLoop->nLTerm) {
            if (! ((unsigned long )pTerm != (unsigned long )*(pLoop->aLTerm + j))) {
              break;
            }
          } else {
            break;
          }
          j ++;
        }
        if (j >= (int )pLoop->nLTerm) {
          goto __Cont___0;
        }
      }
      if (((int )pTerm->eOperator & 130) != 0) {
        if ((int )pOBExpr->iColumn >= 0) {
          tmp = sqlite3ExprCollSeqMatch(pWInfo->pParse, pOrderBy->a[i].pExpr, pTerm->pExpr);
          if (tmp == 0) {
            goto __Cont___0;
          }
        }
      }
      obSat |= 1ULL << i;
      __Cont___0: /* CIL Label */ 
      i ++;
    }
    if ((pLoop->wsFlags & 4096U) == 0U) {
      if (pLoop->wsFlags & 256U) {
        pIndex = (Index *)0;
        nKeyCol = (u16 )0;
        nColumn = (u16 )1;
      } else {
        pIndex = pLoop->u.btree.pIndex;
        if ((unsigned long )pIndex == (unsigned long )((Index *)0)) {
          return ((i8 )0);
        } else
        if (pIndex->bUnordered) {
          return ((i8 )0);
        } else {
          nKeyCol = pIndex->nKeyCol;
          nColumn = pIndex->nColumn;
          if ((int )pIndex->onError != 0) {
            if ((pLoop->wsFlags & 32768U) == 0U) {
              tmp___0 = 1;
            } else {
              tmp___0 = 0;
            }
          } else {
            tmp___0 = 0;
          }
          isOrderDistinct = (u8 )tmp___0;
        }
      }
      revSet = (u8 )0;
      rev = revSet;
      distinctColumns = (u8 )0;
      j = 0;
      while (j < (int )nColumn) {
        bOnce = (u8 )1;
        if (j < (int )pLoop->u.btree.nEq) {
          if (j >= (int )pLoop->nSkip) {
            eOp = (*(pLoop->aLTerm + j))->eOperator;
            if (((int )eOp & (int )eqOpMask) != 0) {
              if ((int )eOp & 384) {
                isOrderDistinct = (u8 )0;
              }
              goto __Cont___1;
            } else
            if ((int )eOp & 1) {
              pX = (*(pLoop->aLTerm + j))->pExpr;
              i = j + 1;
              while (i < (int )pLoop->u.btree.nEq) {
                if ((unsigned long )(*(pLoop->aLTerm + i))->pExpr == (unsigned long )pX) {
                  bOnce = (u8 )0;
                  break;
                }
                i ++;
              }
            }
          }
        }
        if (pIndex) {
          iColumn = (int )*(pIndex->aiColumn + j);
          revIdx = (u8 )((int )*(pIndex->aSortOrder + j) & 1);
          if (iColumn == (int )(pIndex->pTable)->iPKey) {
            iColumn = -1;
          }
        } else {
          iColumn = -1;
          revIdx = (u8 )0;
        }
        if (isOrderDistinct) {
          if (iColumn >= 0) {
            if (j >= (int )pLoop->u.btree.nEq) {
              if ((int )((pIndex->pTable)->aCol + iColumn)->notNull == 0) {
                isOrderDistinct = (u8 )0;
              }
            }
          }
        }
        isMatch = (u8 )0;
        i = 0;
        while (1) {
          if (bOnce) {
            if (! (i < (int )nOrderBy)) {
              break;
            }
          } else {
            break;
          }
          if ((1ULL << i) & obSat) {
            goto __Cont___2;
          }
          pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
          if (((int )wctrlFlags & 192) == 0) {
            bOnce = (u8 )0;
          }
          if (iColumn >= -1) {
            if ((int )pOBExpr->op != 162) {
              goto __Cont___2;
            }
            if (pOBExpr->iTable != iCur) {
              goto __Cont___2;
            }
            if ((int )pOBExpr->iColumn != iColumn) {
              goto __Cont___2;
            }
          } else {
            pIdxExpr = (pIndex->aColExpr)->a[j].pExpr;
            tmp___1 = sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, iCur);
            if (tmp___1) {
              goto __Cont___2;
            }
          }
          if (iColumn != -1) {
            pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
            tmp___2 = sqlite3StrICmp((char const   *)pColl->zName, *(pIndex->azColl + j));
            if (tmp___2 != 0) {
              goto __Cont___2;
            }
          }
          if ((int )wctrlFlags & 128) {
            pLoop->u.btree.nDistinctCol = (u16 )(j + 1);
          }
          isMatch = (u8 )1;
          break;
          __Cont___2: /* CIL Label */ 
          i ++;
        }
        if (isMatch) {
          if (((int )wctrlFlags & 64) == 0) {
            if (revSet) {
              if (((int )rev ^ (int )revIdx) != ((int )pOrderBy->a[i].sortFlags & 1)) {
                isMatch = (u8 )0;
              }
            } else {
              rev = (u8 )((int )revIdx ^ ((int )pOrderBy->a[i].sortFlags & 1));
              if (rev) {
                *pRevMask |= 1ULL << iLoop;
              }
              revSet = (u8 )1;
            }
          }
        }
        if (isMatch) {
          if ((int )pOrderBy->a[i].sortFlags & 2) {
            if (j == (int )pLoop->u.btree.nEq) {
              pLoop->wsFlags |= 524288U;
            } else {
              isMatch = (u8 )0;
            }
          }
        }
        if (isMatch) {
          if (iColumn == -1) {
            distinctColumns = (u8 )1;
          }
          obSat |= 1ULL << i;
        } else {
          if (j == 0) {
            isOrderDistinct = (u8 )0;
          } else
          if (j < (int )nKeyCol) {
            isOrderDistinct = (u8 )0;
          }
          break;
        }
        __Cont___1: /* CIL Label */ 
        j ++;
      }
      if (distinctColumns) {
        isOrderDistinct = (u8 )1;
      }
    }
    if (isOrderDistinct) {
      orderDistinctMask |= pLoop->maskSelf;
      i = 0;
      while (i < (int )nOrderBy) {
        if ((1ULL << i) & obSat) {
          goto __Cont___3;
        }
        p = pOrderBy->a[i].pExpr;
        mTerm = sqlite3WhereExprUsage(& pWInfo->sMaskSet, p);
        if (mTerm == 0ULL) {
          tmp___3 = sqlite3ExprIsConstant(p);
          if (! tmp___3) {
            goto __Cont___3;
          }
        }
        if ((mTerm & ~ orderDistinctMask) == 0ULL) {
          obSat |= 1ULL << i;
        }
        __Cont___3: /* CIL Label */ 
        i ++;
      }
    }
    __Cont: /* CIL Label */ 
    iLoop ++;
  }
  if (obSat == obDone) {
    return ((i8 )nOrderBy);
  }
  if (! isOrderDistinct) {
    i = (int )nOrderBy - 1;
    while (i > 0) {
      m = (1ULL << i) - 1ULL;
      if ((obSat & m) == m) {
        return ((i8 )i);
      }
      i --;
    }
    return ((i8 )0);
  }
  return ((i8 )-1);
}
}
static int sqlite3WhereIsSorted(WhereInfo *pWInfo ) 
{ 


  {
  return ((int )pWInfo->sorted);
}
}
static LogEst whereSortingCost(WhereInfo *pWInfo , LogEst nRow , int nOrderBy , int nSorted ) 
{ 
  LogEst rScale ;
  LogEst rSortCost ;
  LogEst tmp ;
  LogEst tmp___0 ;

  {
  tmp = sqlite3LogEst((u64 )(((nOrderBy - nSorted) * 100) / nOrderBy));
  rScale = (LogEst )((int )tmp - 66);
  rSortCost = (LogEst )(((int )nRow + (int )rScale) + 16);
  if (((int )pWInfo->wctrlFlags & 16384) != 0) {
    if ((int )pWInfo->iLimit < (int )nRow) {
      nRow = pWInfo->iLimit;
    }
  }
  tmp___0 = estLog(nRow);
  rSortCost = (LogEst )((int )rSortCost + (int )tmp___0);
  return (rSortCost);
}
}
static int wherePathSolver(WhereInfo *pWInfo , LogEst nRowEst ) 
{ 
  int mxChoice ;
  int nLoop ;
  Parse *pParse ;
  sqlite3 *db ;
  int iLoop ;
  int ii ;
  int jj ;
  int mxI ;
  int nOrderBy ;
  LogEst mxCost ;
  LogEst mxUnsorted ;
  int nTo ;
  int nFrom ;
  WherePath *aFrom ;
  WherePath *aTo ;
  WherePath *pFrom ;
  WherePath *pTo ;
  WhereLoop *pWLoop ;
  WhereLoop **pX ;
  LogEst *aSortCost ;
  char *pSpace ;
  int nSpace ;
  int tmp ;
  void *tmp___0 ;
  LogEst nOut ;
  LogEst rCost ;
  LogEst rUnsorted ;
  i8 isOrdered ;
  Bitmask maskNew ;
  Bitmask revMask ;
  LogEst tmp___1 ;
  int tmp___2 ;
  WhereLevel *pLevel ;
  Bitmask notUsed ;
  int rc ;
  i8 tmp___3 ;
  u32 wsFlags ;
  Bitmask m ;
  int rc___0 ;
  i8 tmp___4 ;
  Bitmask revMask___0 ;
  int nOrder ;
  i8 tmp___5 ;

  {
  mxI = 0;
  mxCost = (LogEst )0;
  mxUnsorted = (LogEst )0;
  aSortCost = (LogEst *)0;
  pParse = pWInfo->pParse;
  db = pParse->db;
  nLoop = (int )pWInfo->nLevel;
  if (nLoop <= 1) {
    mxChoice = 1;
  } else {
    if (nLoop == 2) {
      tmp = 5;
    } else {
      tmp = 10;
    }
    mxChoice = tmp;
  }
  if ((unsigned long )pWInfo->pOrderBy == (unsigned long )((ExprList *)0)) {
    nOrderBy = 0;
  } else
  if ((int )nRowEst == 0) {
    nOrderBy = 0;
  } else {
    nOrderBy = (pWInfo->pOrderBy)->nExpr;
  }
  nSpace = (int )(((sizeof(WherePath ) + sizeof(WhereLoop *) * (unsigned long )nLoop) * (unsigned long )mxChoice) * 2UL);
  nSpace = (int )((unsigned long )nSpace + sizeof(LogEst ) * (unsigned long )nOrderBy);
  tmp___0 = sqlite3DbMallocRawNN(db, (u64 )nSpace);
  pSpace = (char *)tmp___0;
  if ((unsigned long )pSpace == (unsigned long )((char *)0)) {
    return (7);
  }
  aTo = (WherePath *)pSpace;
  aFrom = aTo + mxChoice;
  memset((void *)aFrom, 0, sizeof(*(aFrom + 0)));
  pX = (WhereLoop **)(aFrom + mxChoice);
  ii = mxChoice * 2;
  pFrom = aTo;
  while (ii > 0) {
    pFrom->aLoop = pX;
    ii --;
    pFrom ++;
    pX += nLoop;
  }
  if (nOrderBy) {
    aSortCost = (LogEst *)pX;
    memset((void *)aSortCost, 0, sizeof(LogEst ) * (unsigned long )nOrderBy);
  }
  if (pParse->nQueryLoop < 48U) {
    (aFrom + 0)->nRow = (LogEst )pParse->nQueryLoop;
  } else {
    (aFrom + 0)->nRow = (LogEst )48;
  }
  nFrom = 1;
  if (nOrderBy) {
    if (nLoop > 0) {
      (aFrom + 0)->isOrdered = (i8 )-1;
    } else {
      (aFrom + 0)->isOrdered = (i8 )nOrderBy;
    }
  }
  iLoop = 0;
  while (iLoop < nLoop) {
    nTo = 0;
    ii = 0;
    pFrom = aFrom;
    while (ii < nFrom) {
      pWLoop = pWInfo->pLoops;
      while (pWLoop) {
        isOrdered = pFrom->isOrdered;
        revMask = (Bitmask )0;
        if ((pWLoop->prereq & ~ pFrom->maskLoop) != 0ULL) {
          goto __Cont;
        }
        if ((pWLoop->maskSelf & pFrom->maskLoop) != 0ULL) {
          goto __Cont;
        }
        if ((pWLoop->wsFlags & 16384U) != 0U) {
          if ((int )pFrom->nRow < 3) {
            goto __Cont;
          }
        }
        rUnsorted = sqlite3LogEstAdd(pWLoop->rSetup, (LogEst )((int )pWLoop->rRun + (int )pFrom->nRow));
        rUnsorted = sqlite3LogEstAdd(rUnsorted, pFrom->rUnsorted);
        nOut = (LogEst )((int )pFrom->nRow + (int )pWLoop->nOut);
        maskNew = pFrom->maskLoop | pWLoop->maskSelf;
        if ((int )isOrdered < 0) {
          isOrdered = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags,
                                                (u16 )iLoop, pWLoop, & revMask);
        } else {
          revMask = pFrom->revLoop;
        }
        if ((int )isOrdered >= 0) {
          if ((int )isOrdered < nOrderBy) {
            if ((int )*(aSortCost + isOrdered) == 0) {
              *(aSortCost + isOrdered) = whereSortingCost(pWInfo, nRowEst, nOrderBy,
                                                          (int )isOrdered);
            }
            tmp___1 = sqlite3LogEstAdd(rUnsorted, *(aSortCost + isOrdered));
            rCost = (LogEst )((int )tmp___1 + 5);
          } else {
            rCost = rUnsorted;
            rUnsorted = (LogEst )((int )rUnsorted - 2);
          }
        } else {
          rCost = rUnsorted;
          rUnsorted = (LogEst )((int )rUnsorted - 2);
        }
        jj = 0;
        pTo = aTo;
        while (jj < nTo) {
          if (pTo->maskLoop == maskNew) {
            if ((((int )pTo->isOrdered ^ (int )isOrdered) & 128) == 0) {
              break;
            }
          }
          jj ++;
          pTo ++;
        }
        if (jj >= nTo) {
          if (nTo >= mxChoice) {
            if ((int )rCost > (int )mxCost) {
              goto __Cont;
            } else
            if ((int )rCost == (int )mxCost) {
              if ((int )rUnsorted >= (int )mxUnsorted) {
                goto __Cont;
              }
            }
          }
          if (nTo < mxChoice) {
            tmp___2 = nTo;
            nTo ++;
            jj = tmp___2;
          } else {
            jj = mxI;
          }
          pTo = aTo + jj;
        } else
        if ((int )pTo->rCost < (int )rCost) {
          goto __Cont;
        } else
        if ((int )pTo->rCost == (int )rCost) {
          if ((int )pTo->nRow < (int )nOut) {
            goto __Cont;
          } else
          if ((int )pTo->nRow == (int )nOut) {
            if ((int )pTo->rUnsorted <= (int )rUnsorted) {
              goto __Cont;
            }
          }
        }
        pTo->maskLoop = pFrom->maskLoop | pWLoop->maskSelf;
        pTo->revLoop = revMask;
        pTo->nRow = nOut;
        pTo->rCost = rCost;
        pTo->rUnsorted = rUnsorted;
        pTo->isOrdered = isOrdered;
        memcpy((void * __restrict  )pTo->aLoop, (void const   * __restrict  )pFrom->aLoop,
               sizeof(WhereLoop *) * (unsigned long )iLoop);
        *(pTo->aLoop + iLoop) = pWLoop;
        if (nTo >= mxChoice) {
          mxI = 0;
          mxCost = (aTo + 0)->rCost;
          mxUnsorted = (aTo + 0)->nRow;
          jj = 1;
          pTo = aTo + 1;
          while (jj < mxChoice) {
            if ((int )pTo->rCost > (int )mxCost) {
              mxCost = pTo->rCost;
              mxUnsorted = pTo->rUnsorted;
              mxI = jj;
            } else
            if ((int )pTo->rCost == (int )mxCost) {
              if ((int )pTo->rUnsorted > (int )mxUnsorted) {
                mxCost = pTo->rCost;
                mxUnsorted = pTo->rUnsorted;
                mxI = jj;
              }
            }
            jj ++;
            pTo ++;
          }
        }
        __Cont: /* CIL Label */ 
        pWLoop = pWLoop->pNextLoop;
      }
      ii ++;
      pFrom ++;
    }
    pFrom = aTo;
    aTo = aFrom;
    aFrom = pFrom;
    nFrom = nTo;
    iLoop ++;
  }
  if (nFrom == 0) {
    sqlite3ErrorMsg(pParse, "no query solution");
    sqlite3DbFreeNN(db, (void *)pSpace);
    return (1);
  }
  pFrom = aFrom;
  ii = 1;
  while (ii < nFrom) {
    if ((int )pFrom->rCost > (int )(aFrom + ii)->rCost) {
      pFrom = aFrom + ii;
    }
    ii ++;
  }
  iLoop = 0;
  while (iLoop < nLoop) {
    pLevel = pWInfo->a + iLoop;
    pWLoop = *(pFrom->aLoop + iLoop);
    pLevel->pWLoop = pWLoop;
    pLevel->iFrom = pWLoop->iTab;
    pLevel->iTabCur = (pWInfo->pTabList)->a[pLevel->iFrom].iCursor;
    iLoop ++;
  }
  if (((int )pWInfo->wctrlFlags & 256) != 0) {
    if (((int )pWInfo->wctrlFlags & 128) == 0) {
      if ((int )pWInfo->eDistinct == 0) {
        if (nRowEst) {
          tmp___3 = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom, (u16 )128,
                                              (u16 )(nLoop - 1), *(pFrom->aLoop + (nLoop - 1)),
                                              & notUsed);
          rc = (int )tmp___3;
          if (rc == (pWInfo->pResultSet)->nExpr) {
            pWInfo->eDistinct = (u8 )2;
          }
        }
      }
    }
  }
  pWInfo->bOrderedInnerLoop = (u8 )0;
  if (pWInfo->pOrderBy) {
    if ((int )pWInfo->wctrlFlags & 128) {
      if ((int )pFrom->isOrdered == (pWInfo->pOrderBy)->nExpr) {
        pWInfo->eDistinct = (u8 )2;
      }
    } else {
      pWInfo->nOBSat = pFrom->isOrdered;
      pWInfo->revMask = pFrom->revLoop;
      if ((int )pWInfo->nOBSat <= 0) {
        pWInfo->nOBSat = (i8 )0;
        if (nLoop > 0) {
          wsFlags = (*(pFrom->aLoop + (nLoop - 1)))->wsFlags;
          if ((wsFlags & 4096U) == 0U) {
            if ((wsFlags & 260U) != 260U) {
              m = (Bitmask )0;
              tmp___4 = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom,
                                                  (u16 )2048, (u16 )(nLoop - 1), *(pFrom->aLoop + (nLoop - 1)),
                                                  & m);
              rc___0 = (int )tmp___4;
              if (rc___0 == (pWInfo->pOrderBy)->nExpr) {
                pWInfo->bOrderedInnerLoop = (u8 )1;
                pWInfo->revMask = m;
              }
            }
          }
        }
      }
    }
    if ((int )pWInfo->wctrlFlags & 512) {
      if ((int )pWInfo->nOBSat == (pWInfo->pOrderBy)->nExpr) {
        if (nLoop > 0) {
          revMask___0 = (Bitmask )0;
          tmp___5 = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom, (u16 )0,
                                              (u16 )(nLoop - 1), *(pFrom->aLoop + (nLoop - 1)),
                                              & revMask___0);
          nOrder = (int )tmp___5;
          if (nOrder == (pWInfo->pOrderBy)->nExpr) {
            pWInfo->sorted = (u8 )1;
            pWInfo->revMask = revMask___0;
          }
        }
      }
    }
  }
  pWInfo->nRowOut = pFrom->nRow;
  sqlite3DbFreeNN(db, (void *)pSpace);
  return (0);
}
}
static int whereShortCut(WhereLoopBuilder *pBuilder ) 
{ 
  WhereInfo *pWInfo ;
  struct SrcList_item *pItem ;
  WhereClause *pWC ;
  WhereTerm *pTerm ;
  WhereLoop *pLoop ;
  int iCur ;
  int j ;
  Table *pTab ;
  Index *pIdx ;
  int opMask ;

  {
  pWInfo = pBuilder->pWInfo;
  if ((int )pWInfo->wctrlFlags & 32) {
    return (0);
  }
  pItem = (pWInfo->pTabList)->a;
  pTab = pItem->pTab;
  if (pTab->nModuleArg) {
    return (0);
  }
  if (pItem->fg.isIndexedBy) {
    return (0);
  }
  iCur = pItem->iCursor;
  pWC = & pWInfo->sWC;
  pLoop = pBuilder->pNew;
  pLoop->wsFlags = (u32 )0;
  pLoop->nSkip = (u16 )0;
  pTerm = sqlite3WhereFindTerm(pWC, iCur, -1, (Bitmask )0, (u32 )130, (Index *)0);
  if (pTerm) {
    pLoop->wsFlags = (u32 )4353;
    *(pLoop->aLTerm + 0) = pTerm;
    pLoop->nLTerm = (u16 )1;
    pLoop->u.btree.nEq = (u16 )1;
    pLoop->rRun = (LogEst )33;
  } else {
    pIdx = pTab->pIndex;
    while (pIdx) {
      if (! ((int )pIdx->onError != 0)) {
        goto __Cont;
      } else
      if ((unsigned long )pIdx->pPartIdxWhere != (unsigned long )((Expr *)0)) {
        goto __Cont;
      } else
      if ((int )pIdx->nKeyCol > (int )(sizeof(pLoop->aLTermSpace) / sizeof(pLoop->aLTermSpace[0]))) {
        goto __Cont;
      }
      if (pIdx->uniqNotNull) {
        opMask = 130;
      } else {
        opMask = 2;
      }
      j = 0;
      while (j < (int )pIdx->nKeyCol) {
        pTerm = sqlite3WhereFindTerm(pWC, iCur, j, (Bitmask )0, (u32 )opMask, pIdx);
        if ((unsigned long )pTerm == (unsigned long )((WhereTerm *)0)) {
          break;
        }
        *(pLoop->aLTerm + j) = pTerm;
        j ++;
      }
      if (j != (int )pIdx->nKeyCol) {
        goto __Cont;
      }
      pLoop->wsFlags = (u32 )4609;
      if (pIdx->isCovering) {
        pLoop->wsFlags |= 64U;
      } else
      if ((pItem->colUsed & pIdx->colNotIdxed) == 0ULL) {
        pLoop->wsFlags |= 64U;
      }
      pLoop->nLTerm = (u16 )j;
      pLoop->u.btree.nEq = (u16 )j;
      pLoop->u.btree.pIndex = pIdx;
      pLoop->rRun = (LogEst )39;
      break;
      __Cont: /* CIL Label */ 
      pIdx = pIdx->pNext;
    }
  }
  if (pLoop->wsFlags) {
    pLoop->nOut = (LogEst )1;
    pWInfo->a[0].pWLoop = pLoop;
    pLoop->maskSelf = (Bitmask )1;
    pWInfo->a[0].iTabCur = iCur;
    pWInfo->nRowOut = (LogEst )1;
    if (pWInfo->pOrderBy) {
      pWInfo->nOBSat = (i8 )(pWInfo->pOrderBy)->nExpr;
    }
    if ((int )pWInfo->wctrlFlags & 256) {
      pWInfo->eDistinct = (u8 )1;
    }
    return (1);
  }
  return (0);
}
}
static int exprNodeIsDeterministic(Walker *pWalker , Expr *pExpr ) 
{ 


  {
  if ((int )pExpr->op == 167) {
    if (((pExpr->flags & 524288U) != 0U) == 0) {
      pWalker->eCode = (u8 )0;
      return (2);
    }
  }
  return (0);
}
}
static int exprIsDeterministic(Expr *p ) 
{ 
  Walker w ;

  {
  memset((void *)(& w), 0, sizeof(w));
  w.eCode = (u8 )1;
  w.xExprCallback = & exprNodeIsDeterministic;
  w.xSelectCallback = & sqlite3SelectWalkFail;
  sqlite3WalkExpr(& w, p);
  return ((int )w.eCode);
}
}
static WhereInfo *sqlite3WhereBegin(Parse *pParse , SrcList *pTabList , Expr *pWhere ,
                                    ExprList *pOrderBy , ExprList *pResultSet , u16 wctrlFlags ,
                                    int iAuxArg ) 
{ 
  int nByteWInfo ;
  int nTabList ;
  WhereInfo *pWInfo ;
  Vdbe *v ;
  Bitmask notReady ;
  WhereLoopBuilder sWLB ;
  WhereMaskSet *pMaskSet ;
  WhereLevel *pLevel ;
  WhereLoop *pLoop ;
  int ii ;
  sqlite3 *db ;
  int rc ;
  u8 bFordelete ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  WhereTerm *pT ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int i ;
  Bitmask tabUsed ;
  Bitmask tmp___5 ;
  Bitmask tmp___6 ;
  WhereTerm *pTerm ;
  WhereTerm *pEnd ;
  struct SrcList_item *pItem ;
  int nByte ;
  int wsFlags ;
  int bOnerow ;
  Table *pTab ;
  int iDb ;
  struct SrcList_item *pTabItem ;
  char const   *pVTab ;
  VTable *tmp___7 ;
  int iCur ;
  int op ;
  Bitmask b ;
  int n ;
  Index *pIx ;
  int iIndexCur ;
  int op___0 ;
  Index *pJ ;
  int tmp___8 ;
  int addrExplain ;
  int wsFlags___0 ;
  int tmp___9 ;

  {
  v = pParse->pVdbe;
  bFordelete = (u8 )0;
  db = pParse->db;
  memset((void *)(& sWLB), 0, sizeof(sWLB));
  if (pOrderBy) {
    if (pOrderBy->nExpr >= (int )(sizeof(Bitmask ) * 8UL)) {
      pOrderBy = (ExprList *)0;
    }
  }
  sWLB.pOrderBy = pOrderBy;
  if (((int )db->dbOptFlags & 16) != 0) {
    wctrlFlags = (u16 )((int )wctrlFlags & -257);
  }
  if (pTabList->nSrc > (int )(sizeof(Bitmask ) * 8UL)) {
    sqlite3ErrorMsg(pParse, "at most %d tables in a join", (int )(sizeof(Bitmask ) * 8UL));
    return ((WhereInfo *)0);
  }
  if ((int )wctrlFlags & 32) {
    nTabList = 1;
  } else {
    nTabList = pTabList->nSrc;
  }
  nByteWInfo = (int )(((sizeof(WhereInfo ) + (unsigned long )(nTabList - 1) * sizeof(WhereLevel )) + 7UL) & 0xfffffffffffffff8UL);
  tmp = sqlite3DbMallocRawNN(db, (u64 )((unsigned long )nByteWInfo + sizeof(WhereLoop )));
  pWInfo = (WhereInfo *)tmp;
  if (db->mallocFailed) {
    sqlite3DbFree(db, (void *)pWInfo);
    pWInfo = (WhereInfo *)0;
    goto whereBeginError;
  }
  pWInfo->pParse = pParse;
  pWInfo->pTabList = pTabList;
  pWInfo->pOrderBy = pOrderBy;
  pWInfo->pWhere = pWhere;
  pWInfo->pResultSet = pResultSet;
  tmp___0 = -1;
  pWInfo->aiCurOnePass[1] = tmp___0;
  pWInfo->aiCurOnePass[0] = tmp___0;
  pWInfo->nLevel = (u8 )nTabList;
  tmp___1 = sqlite3VdbeMakeLabel(pParse);
  pWInfo->iContinue = tmp___1;
  pWInfo->iBreak = tmp___1;
  pWInfo->wctrlFlags = wctrlFlags;
  pWInfo->iLimit = (LogEst )iAuxArg;
  pWInfo->savedNQueryLoop = (int )pParse->nQueryLoop;
  memset((void *)(& pWInfo->nOBSat), 0, (unsigned long )(& ((WhereInfo *)0)->sWC) - (unsigned long )(& ((WhereInfo *)0)->nOBSat));
  memset((void *)(& pWInfo->a[0]), 0, sizeof(WhereLoop ) + (unsigned long )nTabList * sizeof(WhereLevel ));
  pMaskSet = & pWInfo->sMaskSet;
  sWLB.pWInfo = pWInfo;
  sWLB.pWC = & pWInfo->sWC;
  sWLB.pNew = (WhereLoop *)((char *)pWInfo + nByteWInfo);
  whereLoopInit(sWLB.pNew);
  pMaskSet->n = 0;
  sqlite3WhereClauseInit(& pWInfo->sWC, pWInfo);
  sqlite3WhereSplit(& pWInfo->sWC, pWhere, (u8 )44);
  if (nTabList == 0) {
    if (pOrderBy) {
      pWInfo->nOBSat = (i8 )pOrderBy->nExpr;
    }
    if ((int )wctrlFlags & 256) {
      pWInfo->eDistinct = (u8 )1;
    }
    sqlite3VdbeExplain(pParse, (u8 )0, "SCAN CONSTANT ROW");
  } else {
    ii = 0;
    while (1) {
      createMask(pMaskSet, pTabList->a[ii].iCursor);
      sqlite3WhereTabFuncArgs(pParse, & pTabList->a[ii], & pWInfo->sWC);
      ii ++;
      if (! (ii < pTabList->nSrc)) {
        break;
      }
    }
  }
  sqlite3WhereExprAnalyze(pTabList, & pWInfo->sWC);
  if (db->mallocFailed) {
    goto whereBeginError;
  }
  ii = 0;
  while (ii < (sWLB.pWC)->nTerm) {
    pT = (sWLB.pWC)->a + ii;
    if ((int )pT->wtFlags & 2) {
      goto __Cont;
    }
    if (pT->prereqAll == 0ULL) {
      if (nTabList == 0) {
        sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, 16);
        pT->wtFlags = (u16 )((int )pT->wtFlags | 4);
      } else {
        tmp___2 = exprIsDeterministic(pT->pExpr);
        if (tmp___2) {
          sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, 16);
          pT->wtFlags = (u16 )((int )pT->wtFlags | 4);
        }
      }
    }
    __Cont: /* CIL Label */ 
    ii ++;
  }
  if ((int )wctrlFlags & 256) {
    tmp___3 = isDistinctRedundant(pParse, pTabList, & pWInfo->sWC, pResultSet);
    if (tmp___3) {
      pWInfo->eDistinct = (u8 )1;
    } else
    if ((unsigned long )pOrderBy == (unsigned long )((ExprList *)0)) {
      pWInfo->wctrlFlags = (u16 )((int )pWInfo->wctrlFlags | 128);
      pWInfo->pOrderBy = pResultSet;
    }
  }
  if (nTabList != 1) {
    goto _L;
  } else {
    tmp___4 = whereShortCut(& sWLB);
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
      rc = whereLoopAddAll(& sWLB);
      if (rc) {
        goto whereBeginError;
      }
      wherePathSolver(pWInfo, (LogEst )0);
      if (db->mallocFailed) {
        goto whereBeginError;
      }
      if (pWInfo->pOrderBy) {
        wherePathSolver(pWInfo, (LogEst )((int )pWInfo->nRowOut + 1));
        if (db->mallocFailed) {
          goto whereBeginError;
        }
      }
    }
  }
  if ((unsigned long )pWInfo->pOrderBy == (unsigned long )((ExprList *)0)) {
    if ((db->flags & 4096ULL) != 0ULL) {
      pWInfo->revMask = (Bitmask )-1;
    }
  }
  if (pParse->nErr) {
    goto whereBeginError;
  } else
  if (db->mallocFailed) {
    goto whereBeginError;
  }
  notReady = ~ ((Bitmask )0);
  if ((int )pWInfo->nLevel >= 2) {
    if ((unsigned long )pResultSet != (unsigned long )((ExprList *)0)) {
      if (((int )db->dbOptFlags & 256) == 0) {
        tmp___5 = sqlite3WhereExprListUsage(pMaskSet, pResultSet);
        tabUsed = tmp___5;
        if (sWLB.pOrderBy) {
          tmp___6 = sqlite3WhereExprListUsage(pMaskSet, sWLB.pOrderBy);
          tabUsed |= tmp___6;
        }
        i = (int )pWInfo->nLevel - 1;
        while (i >= 1) {
          pLoop = pWInfo->a[i].pWLoop;
          pItem = & (pWInfo->pTabList)->a[pLoop->iTab];
          if (((int )pItem->fg.jointype & 8) == 0) {
            goto __Cont___0;
          }
          if (((int )wctrlFlags & 256) == 0) {
            if ((pLoop->wsFlags & 4096U) == 0U) {
              goto __Cont___0;
            }
          }
          if ((tabUsed & pLoop->maskSelf) != 0ULL) {
            goto __Cont___0;
          }
          pEnd = (sWLB.pWC)->a + (sWLB.pWC)->nTerm;
          pTerm = (sWLB.pWC)->a;
          while ((unsigned long )pTerm < (unsigned long )pEnd) {
            if ((pTerm->prereqAll & pLoop->maskSelf) != 0ULL) {
              if (! (((pTerm->pExpr)->flags & 1U) != 0U)) {
                break;
              } else
              if ((int )(pTerm->pExpr)->iRightJoinTable != pItem->iCursor) {
                break;
              }
            }
            pTerm ++;
          }
          if ((unsigned long )pTerm < (unsigned long )pEnd) {
            goto __Cont___0;
          }
          notReady &= ~ pLoop->maskSelf;
          pTerm = (sWLB.pWC)->a;
          while ((unsigned long )pTerm < (unsigned long )pEnd) {
            if ((pTerm->prereqAll & pLoop->maskSelf) != 0ULL) {
              pTerm->wtFlags = (u16 )((int )pTerm->wtFlags | 4);
            }
            pTerm ++;
          }
          if (i != (int )pWInfo->nLevel - 1) {
            nByte = (int )((unsigned long )(((int )pWInfo->nLevel - 1) - i) * sizeof(WhereLevel ));
            memmove((void *)(& pWInfo->a[i]), (void const   *)(& pWInfo->a[i + 1]),
                    (size_t )nByte);
          }
          pWInfo->nLevel = (u8 )((int )pWInfo->nLevel - 1);
          nTabList --;
          __Cont___0: /* CIL Label */ 
          i --;
        }
      }
    }
  }
  (pWInfo->pParse)->nQueryLoop += (u32 )pWInfo->nRowOut;
  if (((int )wctrlFlags & 4) != 0) {
    wsFlags = (int )(pWInfo->a[0].pWLoop)->wsFlags;
    bOnerow = (wsFlags & 4096) != 0;
    if (bOnerow) {
      goto _L___1;
    } else
    if (0 != ((int )wctrlFlags & 8)) {
      if (! (pTabList->a[0].pTab)->nModuleArg) {
        if (0 == (wsFlags & 8192)) {
          goto _L___1;
        } else
        if ((int )wctrlFlags & 16) {
          _L___1: /* CIL Label */ 
          if (bOnerow) {
            pWInfo->eOnePass = (u8 )1;
          } else {
            pWInfo->eOnePass = (u8 )2;
          }
          if (((pTabList->a[0].pTab)->tabFlags & 32U) == 0U) {
            if (wsFlags & 64) {
              if ((int )wctrlFlags & 8) {
                bFordelete = (u8 )8;
              }
              (pWInfo->a[0].pWLoop)->wsFlags = (u32 )(wsFlags & -65);
            }
          }
        }
      }
    }
  }
  ii = 0;
  pLevel = pWInfo->a;
  while (ii < nTabList) {
    pTabItem = & pTabList->a[pLevel->iFrom];
    pTab = pTabItem->pTab;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    pLoop = pLevel->pWLoop;
    if (! ((pTab->tabFlags & 2U) != 0U)) {
      if (! pTab->pSelect) {
        if ((pLoop->wsFlags & 1024U) != 0U) {
          tmp___7 = sqlite3GetVTable(db, pTab);
          pVTab = (char const   *)tmp___7;
          iCur = pTabItem->iCursor;
          sqlite3VdbeAddOp4(v, 163, iCur, 0, 0, pVTab, -12);
        } else
        if (! pTab->nModuleArg) {
          if ((pLoop->wsFlags & 64U) == 0U) {
            if (((int )wctrlFlags & 32) == 0) {
              op = 97;
              if ((int )pWInfo->eOnePass != 0) {
                op = 98;
                pWInfo->aiCurOnePass[0] = pTabItem->iCursor;
              }
              sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
              if ((int )pWInfo->eOnePass == 0) {
                if ((int )pTab->nCol < (int )(sizeof(Bitmask ) * 8UL)) {
                  if ((pTab->tabFlags & 32U) == 0U) {
                    b = pTabItem->colUsed;
                    n = 0;
                    while (b) {
                      b >>= 1;
                      n ++;
                    }
                    sqlite3VdbeChangeP4(v, -1, (char const   *)((void *)((long )n)),
                                        -3);
                  }
                }
              }
              sqlite3VdbeChangeP5(v, (u16 )bFordelete);
            } else {
              sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )0, (char const   *)pTab->zName);
            }
          } else {
            sqlite3TableLock(pParse, iDb, pTab->tnum, (u8 )0, (char const   *)pTab->zName);
          }
        }
      }
    }
    if (pLoop->wsFlags & 512U) {
      pIx = pLoop->u.btree.pIndex;
      op___0 = 97;
      if (! ((pTab->tabFlags & 32U) == 0U)) {
        if (pIx->idxType == 2U) {
          if (((int )wctrlFlags & 32) != 0) {
            iIndexCur = pLevel->iTabCur;
            op___0 = 0;
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
      if ((int )pWInfo->eOnePass != 0) {
        pJ = (pTabItem->pTab)->pIndex;
        iIndexCur = iAuxArg;
        while (1) {
          if (pJ) {
            if (! ((unsigned long )pJ != (unsigned long )pIx)) {
              break;
            }
          } else {
            break;
          }
          iIndexCur ++;
          pJ = pJ->pNext;
        }
        op___0 = 98;
        pWInfo->aiCurOnePass[1] = iIndexCur;
      } else
      if (iAuxArg) {
        if (((int )wctrlFlags & 32) != 0) {
          iIndexCur = iAuxArg;
          op___0 = 96;
        } else {
          tmp___8 = pParse->nTab;
          (pParse->nTab) ++;
          iIndexCur = tmp___8;
        }
      } else {
        tmp___8 = pParse->nTab;
        (pParse->nTab) ++;
        iIndexCur = tmp___8;
      }
      pLevel->iIdxCur = iIndexCur;
      if (op___0) {
        sqlite3VdbeAddOp3(v, op___0, iIndexCur, pIx->tnum, iDb);
        sqlite3VdbeSetP4KeyInfo(pParse, pIx);
        if ((pLoop->wsFlags & 15U) != 0U) {
          if ((pLoop->wsFlags & 32770U) == 0U) {
            if ((pLoop->wsFlags & 524288U) == 0U) {
              if (((int )pWInfo->wctrlFlags & 1) == 0) {
                if ((int )pWInfo->eDistinct != 2) {
                  sqlite3VdbeChangeP5(v, (u16 )2);
                }
              }
            }
          }
        }
      }
    }
    if (iDb >= 0) {
      sqlite3CodeVerifySchema(pParse, iDb);
    }
    ii ++;
    pLevel ++;
  }
  pWInfo->iTop = sqlite3VdbeCurrentAddr(v);
  if (db->mallocFailed) {
    goto whereBeginError;
  }
  ii = 0;
  while (ii < nTabList) {
    pLevel = & pWInfo->a[ii];
    wsFlags___0 = (int )(pLevel->pWLoop)->wsFlags;
    if (((pLevel->pWLoop)->wsFlags & 16384U) != 0U) {
      constructAutomaticIndex(pParse, & pWInfo->sWC, & pTabList->a[pLevel->iFrom],
                              notReady, pLevel);
      if (db->mallocFailed) {
        goto whereBeginError;
      }
    }
    addrExplain = sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, wctrlFlags);
    pLevel->addrBody = sqlite3VdbeCurrentAddr(v);
    notReady = sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, ii, pLevel, notReady);
    pWInfo->iContinue = pLevel->addrCont;
    if ((wsFlags___0 & 8192) == 0) {
      if (((int )wctrlFlags & 32) == 0) {
        tmp___9 = 1;
      } else {
        tmp___9 = 0;
      }
    } else {
      tmp___9 = 0;
    }
    ii ++;
  }
  return (pWInfo);
  whereBeginError: 
  if (pWInfo) {
    pParse->nQueryLoop = (u32 )pWInfo->savedNQueryLoop;
    whereInfoFree(db, pWInfo);
  }
  return ((WhereInfo *)0);
}
}
static void sqlite3WhereEnd(WhereInfo *pWInfo ) 
{ 
  Parse *pParse ;
  Vdbe *v ;
  int i ;
  WhereLevel *pLevel ;
  WhereLoop *pLoop ;
  SrcList *pTabList ;
  sqlite3 *db ;
  int addr ;
  int addrSeek ;
  Index *pIdx ;
  int n ;
  int r1 ;
  int j ;
  int op ;
  struct InLoop *pIn ;
  int j___0 ;
  int tmp ;
  int ws ;
  int k ;
  int last ;
  VdbeOp *pOp ;
  Index *pIdx___0 ;
  struct SrcList_item *pTabItem ;
  Table *pTab ;
  int x___0 ;
  Index *pPk ;
  Index *tmp___0 ;
  i16 tmp___1 ;

  {
  pParse = pWInfo->pParse;
  v = pParse->pVdbe;
  pTabList = pWInfo->pTabList;
  db = pParse->db;
  i = (int )pWInfo->nLevel - 1;
  while (i >= 0) {
    pLevel = & pWInfo->a[i];
    pLoop = pLevel->pWLoop;
    if ((int )pLevel->op != 170) {
      addrSeek = 0;
      if ((int )pWInfo->eDistinct == 2) {
        if (i == (int )pWInfo->nLevel - 1) {
          if ((pLoop->wsFlags & 512U) != 0U) {
            pIdx = pLoop->u.btree.pIndex;
            if (pIdx->hasStat1) {
              n = (int )pLoop->u.btree.nDistinctCol;
              if (n > 0) {
                if ((int )*(pIdx->aiRowLogEst + n) >= 36) {
                  r1 = pParse->nMem + 1;
                  j = 0;
                  while (j < n) {
                    sqlite3VdbeAddOp3(v, 90, pLevel->iIdxCur, j, r1 + j);
                    j ++;
                  }
                  pParse->nMem += n + 1;
                  if ((int )pLevel->op == 4) {
                    op = 22;
                  } else {
                    op = 25;
                  }
                  addrSeek = sqlite3VdbeAddOp4Int(v, op, pLevel->iIdxCur, 0, r1, n);
                  sqlite3VdbeAddOp2(v, 11, 1, pLevel->p2);
                }
              }
            }
          }
        }
      }
      sqlite3VdbeResolveLabel(v, pLevel->addrCont);
      sqlite3VdbeAddOp3(v, (int )pLevel->op, pLevel->p1, pLevel->p2, (int )pLevel->p3);
      sqlite3VdbeChangeP5(v, (u16 )pLevel->p5);
      if (pLevel->regBignull) {
        sqlite3VdbeResolveLabel(v, pLevel->addrBignull);
        sqlite3VdbeAddOp2(v, 49, pLevel->regBignull, pLevel->p2 - 1);
      }
      if (addrSeek) {
        sqlite3VdbeJumpHere(v, addrSeek);
      }
    } else {
      sqlite3VdbeResolveLabel(v, pLevel->addrCont);
    }
    if (pLoop->wsFlags & 2048U) {
      if (pLevel->u.in.nIn > 0) {
        sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
        j___0 = pLevel->u.in.nIn;
        pIn = pLevel->u.in.aInLoop + (j___0 - 1);
        while (j___0 > 0) {
          sqlite3VdbeJumpHere(v, pIn->addrInTop + 1);
          if ((int )pIn->eEndLoopOp != 170) {
            if (pIn->nPrefix) {
              tmp = sqlite3VdbeCurrentAddr(v);
              sqlite3VdbeAddOp4Int(v, 26, pLevel->iIdxCur, tmp + 2, pIn->iBase, pIn->nPrefix);
            }
            sqlite3VdbeAddOp2(v, (int )pIn->eEndLoopOp, pIn->iCur, pIn->addrInTop);
          }
          sqlite3VdbeJumpHere(v, pIn->addrInTop - 1);
          j___0 --;
          pIn --;
        }
      }
    }
    sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
    if (pLevel->addrSkip) {
      sqlite3VdbeGoto(v, pLevel->addrSkip);
      sqlite3VdbeJumpHere(v, pLevel->addrSkip);
      sqlite3VdbeJumpHere(v, pLevel->addrSkip - 2);
    }
    if (pLevel->addrLikeRep) {
      sqlite3VdbeAddOp2(v, 49, (int )(pLevel->iLikeRepCntr >> 1), pLevel->addrLikeRep);
    }
    if (pLevel->iLeftJoin) {
      ws = (int )pLoop->wsFlags;
      addr = sqlite3VdbeAddOp1(v, 47, pLevel->iLeftJoin);
      if ((ws & 64) == 0) {
        sqlite3VdbeAddOp1(v, 129, pLevel->iTabCur);
      }
      if (ws & 512) {
        sqlite3VdbeAddOp1(v, 129, pLevel->iIdxCur);
      } else
      if (ws & 8192) {
        if (pLevel->u.pCovidx) {
          sqlite3VdbeAddOp1(v, 129, pLevel->iIdxCur);
        }
      }
      if ((int )pLevel->op == 66) {
        sqlite3VdbeAddOp2(v, 12, pLevel->p1, pLevel->addrFirst);
      } else {
        sqlite3VdbeGoto(v, pLevel->addrFirst);
      }
      sqlite3VdbeJumpHere(v, addr);
    }
    i --;
  }
  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);
  i = 0;
  pLevel = pWInfo->a;
  while (i < (int )pWInfo->nLevel) {
    pIdx___0 = (Index *)0;
    pTabItem = & pTabList->a[pLevel->iFrom];
    pTab = pTabItem->pTab;
    pLoop = pLevel->pWLoop;
    if (pTabItem->fg.viaCoroutine) {
      translateColumnToCopy(pParse, pLevel->addrBody, pLevel->iTabCur, pTabItem->regResult,
                            0);
      goto __Cont;
    }
    if (pLoop->wsFlags & 576U) {
      pIdx___0 = pLoop->u.btree.pIndex;
    } else
    if (pLoop->wsFlags & 8192U) {
      pIdx___0 = pLevel->u.pCovidx;
    }
    if (pIdx___0) {
      if ((int )pWInfo->eOnePass == 0) {
        goto _L;
      } else
      if (! (((pIdx___0->pTable)->tabFlags & 32U) == 0U)) {
        _L: /* CIL Label */ 
        if (! db->mallocFailed) {
          last = sqlite3VdbeCurrentAddr(v);
          k = pLevel->addrBody;
          pOp = sqlite3VdbeGetOp(v, k);
          while (k < last) {
            if (pOp->p1 != pLevel->iTabCur) {
              goto __Cont___0;
            }
            if ((int )pOp->opcode == 90) {
              x___0 = pOp->p2;
              if (! ((pTab->tabFlags & 32U) == 0U)) {
                tmp___0 = sqlite3PrimaryKeyIndex(pTab);
                pPk = tmp___0;
                x___0 = (int )*(pPk->aiColumn + x___0);
              }
              tmp___1 = sqlite3ColumnOfIndex(pIdx___0, (i16 )x___0);
              x___0 = (int )tmp___1;
              if (x___0 >= 0) {
                pOp->p2 = x___0;
                pOp->p1 = pLevel->iIdxCur;
              }
            } else
            if ((int )pOp->opcode == 128) {
              pOp->p1 = pLevel->iIdxCur;
              pOp->opcode = (u8 )135;
            } else
            if ((int )pOp->opcode == 21) {
              pOp->p1 = pLevel->iIdxCur;
            }
            __Cont___0: /* CIL Label */ 
            k ++;
            pOp ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
    pLevel ++;
  }
  pParse->nQueryLoop = (u32 )pWInfo->savedNQueryLoop;
  whereInfoFree(db, pWInfo);
  return;
}
}
static void row_numberStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  i64 *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (i64 *)tmp;
  if (p) {
    (*p) ++;
  }
  return;
}
}
static void row_numberValueFunc(sqlite3_context *pCtx ) 
{ 
  i64 *p ;
  void *tmp ;
  i64 tmp___0 ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (i64 *)tmp;
  if (p) {
    tmp___0 = *p;
  } else {
    tmp___0 = (i64 )0;
  }
  sqlite3_result_int64(pCtx, tmp___0);
  return;
}
}
static void dense_rankStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    p->nStep = (i64 )1;
  }
  return;
}
}
static void dense_rankValueFunc(sqlite3_context *pCtx ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    if (p->nStep) {
      (p->nValue) ++;
      p->nStep = (i64 )0;
    }
    sqlite3_result_int64(pCtx, p->nValue);
  }
  return;
}
}
static void nth_valueStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct NthValueCtx *p ;
  void *tmp ;
  i64 iVal ;
  int tmp___0 ;
  double fVal ;
  double tmp___1 ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct NthValueCtx *)tmp;
  if (p) {
    tmp___0 = sqlite3_value_numeric_type(*(apArg + 1));
    switch (tmp___0) {
    case 1: 
    iVal = sqlite3_value_int64(*(apArg + 1));
    break;
    case 2: 
    tmp___1 = sqlite3_value_double(*(apArg + 1));
    fVal = tmp___1;
    if ((double )((i64 )fVal) != fVal) {
      goto error_out;
    }
    iVal = (i64 )fVal;
    break;
    default: 
    goto error_out;
    }
    if (iVal <= 0LL) {
      goto error_out;
    }
    (p->nStep) ++;
    if (iVal == p->nStep) {
      p->pValue = sqlite3_value_dup((sqlite3_value const   *)*(apArg + 0));
      if (! p->pValue) {
        sqlite3_result_error_nomem(pCtx);
      }
    }
  }
  return;
  error_out: 
  sqlite3_result_error(pCtx, "second argument to nth_value must be a positive integer",
                       -1);
  return;
}
}
static void nth_valueFinalizeFunc(sqlite3_context *pCtx ) 
{ 
  struct NthValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, 0);
  p = (struct NthValueCtx *)tmp;
  if (p) {
    if (p->pValue) {
      sqlite3_result_value(pCtx, p->pValue);
      sqlite3_value_free(p->pValue);
      p->pValue = (sqlite3_value *)0;
    }
  }
  return;
}
}
static void first_valueStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct NthValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct NthValueCtx *)tmp;
  if (p) {
    if ((unsigned long )p->pValue == (unsigned long )((sqlite3_value *)0)) {
      p->pValue = sqlite3_value_dup((sqlite3_value const   *)*(apArg + 0));
      if (! p->pValue) {
        sqlite3_result_error_nomem(pCtx);
      }
    }
  }
  return;
}
}
static void first_valueFinalizeFunc(sqlite3_context *pCtx ) 
{ 
  struct NthValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct NthValueCtx *)tmp;
  if (p) {
    if (p->pValue) {
      sqlite3_result_value(pCtx, p->pValue);
      sqlite3_value_free(p->pValue);
      p->pValue = (sqlite3_value *)0;
    }
  }
  return;
}
}
static void rankStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    (p->nStep) ++;
    if (p->nValue == 0LL) {
      p->nValue = p->nStep;
    }
  }
  return;
}
}
static void rankValueFunc(sqlite3_context *pCtx ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    sqlite3_result_int64(pCtx, p->nValue);
    p->nValue = (i64 )0;
  }
  return;
}
}
static void percent_rankStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    (p->nTotal) ++;
  }
  return;
}
}
static void percent_rankInvFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  (p->nStep) ++;
  return;
}
}
static void percent_rankValueFunc(sqlite3_context *pCtx ) 
{ 
  struct CallCount *p ;
  void *tmp ;
  double r ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    p->nValue = p->nStep;
    if (p->nTotal > 1LL) {
      r = (double )p->nValue / (double )(p->nTotal - 1LL);
      sqlite3_result_double(pCtx, r);
    } else {
      sqlite3_result_double(pCtx, 0.0);
    }
  }
  return;
}
}
static void cume_distStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  if (p) {
    (p->nTotal) ++;
  }
  return;
}
}
static void cume_distInvFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct CallCount *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct CallCount *)tmp;
  (p->nStep) ++;
  return;
}
}
static void cume_distValueFunc(sqlite3_context *pCtx ) 
{ 
  struct CallCount *p ;
  void *tmp ;
  double r ;

  {
  tmp = sqlite3_aggregate_context(pCtx, 0);
  p = (struct CallCount *)tmp;
  if (p) {
    r = (double )p->nStep / (double )p->nTotal;
    sqlite3_result_double(pCtx, r);
  }
  return;
}
}
static void ntileStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct NtileCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct NtileCtx *)tmp;
  if (p) {
    if (p->nTotal == 0LL) {
      p->nParam = sqlite3_value_int64(*(apArg + 0));
      if (p->nParam <= 0LL) {
        sqlite3_result_error(pCtx, "argument of ntile must be a positive integer",
                             -1);
      }
    }
    (p->nTotal) ++;
  }
  return;
}
}
static void ntileInvFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct NtileCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct NtileCtx *)tmp;
  (p->iRow) ++;
  return;
}
}
static void ntileValueFunc(sqlite3_context *pCtx ) 
{ 
  struct NtileCtx *p ;
  void *tmp ;
  int nSize ;
  i64 nLarge ;
  i64 iSmall ;
  i64 iRow ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct NtileCtx *)tmp;
  if (p) {
    if (p->nParam > 0LL) {
      nSize = (int )(p->nTotal / p->nParam);
      if (nSize == 0) {
        sqlite3_result_int64(pCtx, p->iRow + 1LL);
      } else {
        nLarge = p->nTotal - p->nParam * (i64 )nSize;
        iSmall = nLarge * (i64 )(nSize + 1);
        iRow = p->iRow;
        if (iRow < iSmall) {
          sqlite3_result_int64(pCtx, 1LL + iRow / (i64 )(nSize + 1));
        } else {
          sqlite3_result_int64(pCtx, (1LL + nLarge) + (iRow - iSmall) / (i64 )nSize);
        }
      }
    }
  }
  return;
}
}
static void last_valueStepFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct LastValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct LastValueCtx *)tmp;
  if (p) {
    sqlite3_value_free(p->pVal);
    p->pVal = sqlite3_value_dup((sqlite3_value const   *)*(apArg + 0));
    if ((unsigned long )p->pVal == (unsigned long )((sqlite3_value *)0)) {
      sqlite3_result_error_nomem(pCtx);
    } else {
      (p->nVal) ++;
    }
  }
  return;
}
}
static void last_valueInvFunc(sqlite3_context *pCtx , int nArg , sqlite3_value **apArg ) 
{ 
  struct LastValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct LastValueCtx *)tmp;
  if (p) {
    (p->nVal) --;
    if (p->nVal == 0) {
      sqlite3_value_free(p->pVal);
      p->pVal = (sqlite3_value *)0;
    }
  }
  return;
}
}
static void last_valueValueFunc(sqlite3_context *pCtx ) 
{ 
  struct LastValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, 0);
  p = (struct LastValueCtx *)tmp;
  if (p) {
    if (p->pVal) {
      sqlite3_result_value(pCtx, p->pVal);
    }
  }
  return;
}
}
static void last_valueFinalizeFunc(sqlite3_context *pCtx ) 
{ 
  struct LastValueCtx *p ;
  void *tmp ;

  {
  tmp = sqlite3_aggregate_context(pCtx, (int )sizeof(*p));
  p = (struct LastValueCtx *)tmp;
  if (p) {
    if (p->pVal) {
      sqlite3_result_value(pCtx, p->pVal);
      sqlite3_value_free(p->pVal);
      p->pVal = (sqlite3_value *)0;
    }
  }
  return;
}
}
static char const   row_numberName[11]  = 
  {      (char const   )'r',      (char const   )'o',      (char const   )'w',      (char const   )'_', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )'b', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static char const   dense_rankName[11]  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )'_',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'k',      (char const   )'\000'};
static char const   rankName[5]  = {      (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'k', 
        (char const   )'\000'};
static char const   percent_rankName[13]  = 
  {      (char const   )'p',      (char const   )'e',      (char const   )'r',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'_', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'k', 
        (char const   )'\000'};
static char const   cume_distName[10]  = 
  {      (char const   )'c',      (char const   )'u',      (char const   )'m',      (char const   )'e', 
        (char const   )'_',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'\000'};
static char const   ntileName[6]  = {      (char const   )'n',      (char const   )'t',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'\000'};
static char const   last_valueName[11]  = 
  {      (char const   )'l',      (char const   )'a',      (char const   )'s',      (char const   )'t', 
        (char const   )'_',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )'\000'};
static char const   nth_valueName[10]  = 
  {      (char const   )'n',      (char const   )'t',      (char const   )'h',      (char const   )'_', 
        (char const   )'v',      (char const   )'a',      (char const   )'l',      (char const   )'u', 
        (char const   )'e',      (char const   )'\000'};
static char const   first_valueName[12]  = 
  {      (char const   )'f',      (char const   )'i',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'_',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'u',      (char const   )'e',      (char const   )'\000'};
static char const   leadName[5]  = {      (char const   )'l',      (char const   )'e',      (char const   )'a',      (char const   )'d', 
        (char const   )'\000'};
static char const   lagName[4]  = {      (char const   )'l',      (char const   )'a',      (char const   )'g',      (char const   )'\000'};
static void noopStepFunc(sqlite3_context *p , int n , sqlite3_value **a___0 ) 
{ 


  {
  return;
}
}
static void noopValueFunc(sqlite3_context *p ) 
{ 


  {
  return;
}
}
static FuncDef aWindowFuncs[15]  = 
  {      {(i8 )0, (u32 )65537, (void *)0, (FuncDef *)0, & row_numberStepFunc, & row_numberValueFunc,
      & row_numberValueFunc, & noopStepFunc, row_numberName, {(FuncDef *)0}}, 
        {(i8 )0, (u32 )65537, (void *)0, (FuncDef *)0, & dense_rankStepFunc, & dense_rankValueFunc,
      & dense_rankValueFunc, & noopStepFunc, dense_rankName, {(FuncDef *)0}}, 
        {(i8 )0, (u32 )65537, (void *)0, (FuncDef *)0, & rankStepFunc, & rankValueFunc,
      & rankValueFunc, & noopStepFunc, rankName, {(FuncDef *)0}}, 
        {(i8 )0, (u32 )65537, (void *)0, (FuncDef *)0, & percent_rankStepFunc, & percent_rankValueFunc,
      & percent_rankValueFunc, & percent_rankInvFunc, percent_rankName, {(FuncDef *)0}}, 
        {(i8 )0,
      (u32 )65537, (void *)0, (FuncDef *)0, & cume_distStepFunc, & cume_distValueFunc,
      & cume_distValueFunc, & cume_distInvFunc, cume_distName, {(FuncDef *)0}}, 
        {(i8 )1, (u32 )65537, (void *)0, (FuncDef *)0, & ntileStepFunc, & ntileValueFunc,
      & ntileValueFunc, & ntileInvFunc, ntileName, {(FuncDef *)0}}, 
        {(i8 )1, (u32 )65537, (void *)0, (FuncDef *)0, & last_valueStepFunc, & last_valueFinalizeFunc,
      & last_valueValueFunc, & last_valueInvFunc, last_valueName, {(FuncDef *)0}}, 
        {(i8 )2,
      (u32 )65537, (void *)0, (FuncDef *)0, & nth_valueStepFunc, & nth_valueFinalizeFunc,
      & noopValueFunc, & noopStepFunc, nth_valueName, {(FuncDef *)0}}, 
        {(i8 )1, (u32 )65537, (void *)0, (FuncDef *)0, & first_valueStepFunc, & first_valueFinalizeFunc,
      & noopValueFunc, & noopStepFunc, first_valueName, {(FuncDef *)0}}, 
        {(i8 )1, (u32 )65537, (void *)0, (FuncDef *)0, & noopStepFunc, & noopValueFunc,
      & noopValueFunc, & noopStepFunc, leadName, {(FuncDef *)0}}, 
        {(i8 )2, (u32 )65537, (void *)0, (FuncDef *)0, & noopStepFunc, & noopValueFunc,
      & noopValueFunc, & noopStepFunc, leadName, {(FuncDef *)0}}, 
        {(i8 )3, (u32 )65537, (void *)0, (FuncDef *)0, & noopStepFunc, & noopValueFunc,
      & noopValueFunc, & noopStepFunc, leadName, {(FuncDef *)0}}, 
        {(i8 )1, (u32 )65537, (void *)0, (FuncDef *)0, & noopStepFunc, & noopValueFunc,
      & noopValueFunc, & noopStepFunc, lagName, {(FuncDef *)0}}, 
        {(i8 )2, (u32 )65537, (void *)0, (FuncDef *)0, & noopStepFunc, & noopValueFunc,
      & noopValueFunc, & noopStepFunc, lagName, {(FuncDef *)0}}, 
        {(i8 )3, (u32 )65537, (void *)0, (FuncDef *)0, & noopStepFunc, & noopValueFunc,
      & noopValueFunc, & noopStepFunc, lagName, {(FuncDef *)0}}};
static void sqlite3WindowFunctions(void) 
{ 


  {
  sqlite3InsertBuiltinFuncs(aWindowFuncs, (int )(sizeof(aWindowFuncs) / sizeof(aWindowFuncs[0])));
  return;
}
}
static Window *windowFind(Parse *pParse , Window *pList , char const   *zName ) 
{ 
  Window *p ;
  int tmp ;

  {
  p = pList;
  while (p) {
    tmp = sqlite3StrICmp((char const   *)p->zName, zName);
    if (tmp == 0) {
      break;
    }
    p = p->pNextWin;
  }
  if ((unsigned long )p == (unsigned long )((Window *)0)) {
    sqlite3ErrorMsg(pParse, "no such window: %s", zName);
  }
  return (p);
}
}
static void sqlite3WindowUpdate(Parse *pParse , Window *pList , Window *pWin , FuncDef *pFunc ) 
{ 
  Window *p ;
  Window *tmp ;
  sqlite3 *db ;
  struct WindowUpdate aUp[8] ;
  int i ;
  Expr *tmp___0 ;

  {
  if (pWin->zName) {
    if ((int )pWin->eFrmType == 0) {
      tmp = windowFind(pParse, pList, (char const   *)pWin->zName);
      p = tmp;
      if ((unsigned long )p == (unsigned long )((Window *)0)) {
        return;
      }
      pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);
      pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);
      pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);
      pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);
      pWin->eStart = p->eStart;
      pWin->eEnd = p->eEnd;
      pWin->eFrmType = p->eFrmType;
      pWin->eExclude = p->eExclude;
    } else {
      sqlite3WindowChain(pParse, pWin, pList);
    }
  } else {
    sqlite3WindowChain(pParse, pWin, pList);
  }
  if ((int )pWin->eFrmType == 89) {
    if (pWin->pStart) {
      goto _L___1;
    } else
    if (pWin->pEnd) {
      _L___1: /* CIL Label */ 
      if ((unsigned long )pWin->pOrderBy == (unsigned long )((ExprList *)0)) {
        sqlite3ErrorMsg(pParse, "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression");
      } else
      if ((pWin->pOrderBy)->nExpr != 1) {
        sqlite3ErrorMsg(pParse, "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression");
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (pFunc->funcFlags & 65536U) {
    db = pParse->db;
    if (pWin->pFilter) {
      sqlite3ErrorMsg(pParse, "FILTER clause may only be used with aggregate window functions");
    } else {
      aUp[0].zFunc = row_numberName;
      aUp[0].eFrmType = 76;
      aUp[0].eStart = 90;
      aUp[0].eEnd = 85;
      aUp[1].zFunc = dense_rankName;
      aUp[1].eFrmType = 89;
      aUp[1].eStart = 90;
      aUp[1].eEnd = 85;
      aUp[2].zFunc = rankName;
      aUp[2].eFrmType = 89;
      aUp[2].eStart = 90;
      aUp[2].eEnd = 85;
      aUp[3].zFunc = percent_rankName;
      aUp[3].eFrmType = 92;
      aUp[3].eStart = 85;
      aUp[3].eEnd = 90;
      aUp[4].zFunc = cume_distName;
      aUp[4].eFrmType = 92;
      aUp[4].eStart = 86;
      aUp[4].eEnd = 90;
      aUp[5].zFunc = ntileName;
      aUp[5].eFrmType = 76;
      aUp[5].eStart = 85;
      aUp[5].eEnd = 90;
      aUp[6].zFunc = leadName;
      aUp[6].eFrmType = 76;
      aUp[6].eStart = 90;
      aUp[6].eEnd = 90;
      aUp[7].zFunc = lagName;
      aUp[7].eFrmType = 76;
      aUp[7].eStart = 90;
      aUp[7].eEnd = 85;
      i = 0;
      while (i < (int )(sizeof(aUp) / sizeof(aUp[0]))) {
        if ((unsigned long )pFunc->zName == (unsigned long )aUp[i].zFunc) {
          sqlite3ExprDelete(db, pWin->pStart);
          sqlite3ExprDelete(db, pWin->pEnd);
          tmp___0 = (Expr *)0;
          pWin->pStart = tmp___0;
          pWin->pEnd = tmp___0;
          pWin->eFrmType = (u8 )aUp[i].eFrmType;
          pWin->eStart = (u8 )aUp[i].eStart;
          pWin->eEnd = (u8 )aUp[i].eEnd;
          pWin->eExclude = (u8 )0;
          if ((int )pWin->eStart == 86) {
            pWin->pStart = sqlite3Expr(db, 150, "1");
          }
          break;
        }
        i ++;
      }
    }
  }
  pWin->pFunc = pFunc;
  return;
}
}
static int selectWindowRewriteExprCb(Walker *pWalker , Expr *pExpr ) 
{ 
  struct WindowRewrite *p ;
  Parse *pParse ;
  int nSrc ;
  int i ;
  Window *pWin ;
  Expr *pDup ;
  Expr *tmp ;

  {
  p = pWalker->u.pRewrite;
  pParse = pWalker->pParse;
  if (p->pSubSelect) {
    if ((int )pExpr->op != 162) {
      return (0);
    } else {
      nSrc = (p->pSrc)->nSrc;
      i = 0;
      while (i < nSrc) {
        if (pExpr->iTable == (p->pSrc)->a[i].iCursor) {
          break;
        }
        i ++;
      }
      if (i == nSrc) {
        return (0);
      }
    }
  }
  switch ((int )pExpr->op) {
  case 167: 
  if (! ((pExpr->flags & 16777216U) != 0U)) {
    break;
  } else {
    pWin = p->pWin;
    while (pWin) {
      if ((unsigned long )pExpr->y.pWin == (unsigned long )pWin) {
        return (1);
      }
      pWin = pWin->pNextWin;
    }
  }
  case 162: 
  case 163: 
  tmp = sqlite3ExprDup(pParse->db, pExpr, 0);
  pDup = tmp;
  p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);
  if (p->pSub) {
    pExpr->flags |= 134217728U;
    sqlite3ExprDelete(pParse->db, pExpr);
    pExpr->flags &= 4160749567U;
    memset((void *)pExpr, 0, sizeof(Expr ));
    pExpr->op = (u8 )162;
    pExpr->iColumn = (ynVar )((p->pSub)->nExpr - 1);
    pExpr->iTable = (p->pWin)->iEphCsr;
    pExpr->y.pTab = p->pTab;
  }
  break;
  default: 
  break;
  }
  return (0);
}
}
static int selectWindowRewriteSelectCb(Walker *pWalker , Select *pSelect ) 
{ 
  struct WindowRewrite *p ;
  Select *pSave ;

  {
  p = pWalker->u.pRewrite;
  pSave = p->pSubSelect;
  if ((unsigned long )pSave == (unsigned long )pSelect) {
    return (0);
  } else {
    p->pSubSelect = pSelect;
    sqlite3WalkSelect(pWalker, pSelect);
    p->pSubSelect = pSave;
  }
  return (1);
}
}
static void selectWindowRewriteEList(Parse *pParse , Window *pWin , SrcList *pSrc ,
                                     ExprList *pEList , Table *pTab , ExprList **ppSub ) 
{ 
  Walker sWalker ;
  WindowRewrite sRewrite ;

  {
  memset((void *)(& sWalker), 0, sizeof(Walker ));
  memset((void *)(& sRewrite), 0, sizeof(WindowRewrite ));
  sRewrite.pSub = *ppSub;
  sRewrite.pWin = pWin;
  sRewrite.pSrc = pSrc;
  sRewrite.pTab = pTab;
  sWalker.pParse = pParse;
  sWalker.xExprCallback = & selectWindowRewriteExprCb;
  sWalker.xSelectCallback = & selectWindowRewriteSelectCb;
  sWalker.u.pRewrite = & sRewrite;
  sqlite3WalkExprList(& sWalker, pEList);
  *ppSub = sRewrite.pSub;
  return;
}
}
static ExprList *exprListAppendList(Parse *pParse , ExprList *pList , ExprList *pAppend ,
                                    int bIntToNull ) 
{ 
  int i ;
  int nInit ;
  int tmp ;
  Expr *pDup ;
  Expr *tmp___0 ;

  {
  if (pAppend) {
    if (pList) {
      tmp = pList->nExpr;
    } else {
      tmp = 0;
    }
    nInit = tmp;
    i = 0;
    while (i < pAppend->nExpr) {
      tmp___0 = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
      pDup = tmp___0;
      if (bIntToNull) {
        if (pDup) {
          if ((int )pDup->op == 150) {
            pDup->op = (u8 )117;
            pDup->flags &= 3489659903U;
          }
        }
      }
      pList = sqlite3ExprListAppend(pParse, pList, pDup);
      if (pList) {
        pList->a[nInit + i].sortFlags = pAppend->a[i].sortFlags;
      }
      i ++;
    }
  }
  return (pList);
}
}
static int sqlite3WindowRewrite(Parse *pParse , Select *p ) 
{ 
  int rc ;
  Vdbe *v ;
  Vdbe *tmp ;
  sqlite3 *db ;
  Select *pSub ;
  SrcList *pSrc ;
  Expr *pWhere ;
  ExprList *pGroupBy ;
  Expr *pHaving ;
  ExprList *pSort ;
  ExprList *pSublist ;
  Window *pMWin ;
  Window *pWin ;
  Table *pTab ;
  void *tmp___0 ;
  int nSave ;
  int tmp___1 ;
  int tmp___2 ;
  ExprList *pArgs ;
  Expr *pFilter ;
  Expr *tmp___3 ;
  Expr *tmp___4 ;
  Table *pTab2 ;

  {
  rc = 0;
  if (p->pWin) {
    if ((unsigned long )p->pPrior == (unsigned long )((Select *)0)) {
      tmp = sqlite3GetVdbe(pParse);
      v = tmp;
      db = pParse->db;
      pSub = (Select *)0;
      pSrc = p->pSrc;
      pWhere = p->pWhere;
      pGroupBy = p->pGroupBy;
      pHaving = p->pHaving;
      pSort = (ExprList *)0;
      pSublist = (ExprList *)0;
      pMWin = p->pWin;
      tmp___0 = sqlite3DbMallocZero(db, (u64 )sizeof(Table ));
      pTab = (Table *)tmp___0;
      if ((unsigned long )pTab == (unsigned long )((Table *)0)) {
        return (7);
      }
      p->pSrc = (SrcList *)0;
      p->pWhere = (Expr *)0;
      p->pGroupBy = (ExprList *)0;
      p->pHaving = (Expr *)0;
      p->selFlags &= 4294967287U;
      pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);
      pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
      if (pSort) {
        if (p->pOrderBy) {
          if ((p->pOrderBy)->nExpr <= pSort->nExpr) {
            nSave = pSort->nExpr;
            pSort->nExpr = (p->pOrderBy)->nExpr;
            tmp___1 = sqlite3ExprListCompare(pSort, p->pOrderBy, -1);
            if (tmp___1 == 0) {
              sqlite3ExprListDelete(db, p->pOrderBy);
              p->pOrderBy = (ExprList *)0;
            }
            pSort->nExpr = nSave;
          }
        }
      }
      tmp___2 = pParse->nTab;
      (pParse->nTab) ++;
      pMWin->iEphCsr = tmp___2;
      pParse->nTab += 3;
      selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, & pSublist);
      selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, & pSublist);
      if (pSublist) {
        pMWin->nBufferCol = pSublist->nExpr;
      } else {
        pMWin->nBufferCol = 0;
      }
      pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
      pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);
      pWin = pMWin;
      while (pWin) {
        pArgs = (pWin->pOwner)->x.pList;
        if ((pWin->pFunc)->funcFlags & 1048576U) {
          selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, & pSublist);
          if (pSublist) {
            pWin->iArgCol = pSublist->nExpr;
          } else {
            pWin->iArgCol = 0;
          }
          pWin->bExprArgs = (u8 )1;
        } else {
          if (pSublist) {
            pWin->iArgCol = pSublist->nExpr;
          } else {
            pWin->iArgCol = 0;
          }
          pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
        }
        if (pWin->pFilter) {
          tmp___3 = sqlite3ExprDup(db, pWin->pFilter, 0);
          pFilter = tmp___3;
          pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
        }
        (pParse->nMem) ++;
        pWin->regAccum = pParse->nMem;
        (pParse->nMem) ++;
        pWin->regResult = pParse->nMem;
        sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
        pWin = pWin->pNextWin;
      }
      if ((unsigned long )pSublist == (unsigned long )((ExprList *)0)) {
        tmp___4 = sqlite3Expr(db, 150, "0");
        pSublist = sqlite3ExprListAppend(pParse, (ExprList *)0, tmp___4);
      }
      pSub = sqlite3SelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort,
                              (u32 )0, (Expr *)0);
      p->pSrc = sqlite3SrcListAppend(pParse, (SrcList *)0, (Token *)0, (Token *)0);
      if (p->pSrc) {
        (p->pSrc)->a[0].pSelect = pSub;
        sqlite3SrcListAssignCursors(pParse, p->pSrc);
        pSub->selFlags |= 64U;
        pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, (char)64);
        if ((unsigned long )pTab2 == (unsigned long )((Table *)0)) {
          rc = 7;
        } else {
          memcpy((void * __restrict  )pTab, (void const   * __restrict  )pTab2, sizeof(Table ));
          pTab->tabFlags |= 2U;
          (p->pSrc)->a[0].pTab = pTab;
          pTab = pTab2;
        }
        sqlite3VdbeAddOp2(v, 112, pMWin->iEphCsr, pSublist->nExpr);
        sqlite3VdbeAddOp2(v, 109, pMWin->iEphCsr + 1, pMWin->iEphCsr);
        sqlite3VdbeAddOp2(v, 109, pMWin->iEphCsr + 2, pMWin->iEphCsr);
        sqlite3VdbeAddOp2(v, 109, pMWin->iEphCsr + 3, pMWin->iEphCsr);
      } else {
        sqlite3SelectDelete(db, pSub);
      }
      if (db->mallocFailed) {
        rc = 7;
      }
      sqlite3DbFree(db, (void *)pTab);
    }
  }
  return (rc);
}
}
static void sqlite3WindowUnlinkFromSelect(Window *p ) 
{ 


  {
  if (p->ppThis) {
    *(p->ppThis) = p->pNextWin;
    if (p->pNextWin) {
      (p->pNextWin)->ppThis = p->ppThis;
    }
    p->ppThis = (Window **)0;
  }
  return;
}
}
static void sqlite3WindowDelete(sqlite3 *db , Window *p ) 
{ 


  {
  if (p) {
    sqlite3WindowUnlinkFromSelect(p);
    sqlite3ExprDelete(db, p->pFilter);
    sqlite3ExprListDelete(db, p->pPartition);
    sqlite3ExprListDelete(db, p->pOrderBy);
    sqlite3ExprDelete(db, p->pEnd);
    sqlite3ExprDelete(db, p->pStart);
    sqlite3DbFree(db, (void *)p->zName);
    sqlite3DbFree(db, (void *)p->zBase);
    sqlite3DbFree(db, (void *)p);
  }
  return;
}
}
static void sqlite3WindowListDelete(sqlite3 *db , Window *p ) 
{ 
  Window *pNext ;

  {
  while (p) {
    pNext = p->pNextWin;
    sqlite3WindowDelete(db, p);
    p = pNext;
  }
  return;
}
}
static Expr *sqlite3WindowOffsetExpr(Parse *pParse , Expr *pExpr ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ExprIsConstant(pExpr);
  if (0 == tmp) {
    if ((int )pParse->eParseMode >= 2) {
      sqlite3RenameExprUnmap(pParse, pExpr);
    }
    sqlite3ExprDelete(pParse->db, pExpr);
    pExpr = sqlite3ExprAlloc(pParse->db, 117, (Token const   *)0, 0);
  }
  return (pExpr);
}
}
static Window *sqlite3WindowAlloc(Parse *pParse , int eType , int eStart , Expr *pStart ,
                                  int eEnd , Expr *pEnd , u8 eExclude ) 
{ 
  Window *pWin ;
  int bImplicitFrame ;
  void *tmp ;

  {
  pWin = (Window *)0;
  bImplicitFrame = 0;
  if (eType == 0) {
    bImplicitFrame = 1;
    eType = 89;
  }
  if (eStart == 85) {
    if (eEnd == 88) {
      sqlite3ErrorMsg(pParse, "unsupported frame specification");
      goto windowAllocErr;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (eStart == 86) {
    if (eEnd == 88) {
      sqlite3ErrorMsg(pParse, "unsupported frame specification");
      goto windowAllocErr;
    } else
    if (eEnd == 85) {
      sqlite3ErrorMsg(pParse, "unsupported frame specification");
      goto windowAllocErr;
    }
  }
  tmp = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(Window ));
  pWin = (Window *)tmp;
  if ((unsigned long )pWin == (unsigned long )((Window *)0)) {
    goto windowAllocErr;
  }
  pWin->eFrmType = (u8 )eType;
  pWin->eStart = (u8 )eStart;
  pWin->eEnd = (u8 )eEnd;
  if ((int )eExclude == 0) {
    if (((int )(pParse->db)->dbOptFlags & 2) != 0) {
      eExclude = (u8 )66;
    }
  }
  pWin->eExclude = eExclude;
  pWin->bImplicitFrame = (u8 )bImplicitFrame;
  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);
  return (pWin);
  windowAllocErr: 
  sqlite3ExprDelete(pParse->db, pEnd);
  sqlite3ExprDelete(pParse->db, pStart);
  return ((Window *)0);
}
}
static Window *sqlite3WindowAssemble(Parse *pParse , Window *pWin , ExprList *pPartition ,
                                     ExprList *pOrderBy , Token *pBase ) 
{ 


  {
  if (pWin) {
    pWin->pPartition = pPartition;
    pWin->pOrderBy = pOrderBy;
    if (pBase) {
      pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, (u64 )pBase->n);
    }
  } else {
    sqlite3ExprListDelete(pParse->db, pPartition);
    sqlite3ExprListDelete(pParse->db, pOrderBy);
  }
  return (pWin);
}
}
static void sqlite3WindowChain(Parse *pParse , Window *pWin , Window *pList ) 
{ 
  sqlite3 *db ;
  Window *pExist ;
  Window *tmp ;
  char const   *zErr ;

  {
  if (pWin->zBase) {
    db = pParse->db;
    tmp = windowFind(pParse, pList, (char const   *)pWin->zBase);
    pExist = tmp;
    if (pExist) {
      zErr = (char const   *)0;
      if (pWin->pPartition) {
        zErr = "PARTITION clause";
      } else
      if (pExist->pOrderBy) {
        if (pWin->pOrderBy) {
          zErr = "ORDER BY clause";
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((int )pExist->bImplicitFrame == 0) {
        zErr = "frame specification";
      }
      if (zErr) {
        sqlite3ErrorMsg(pParse, "cannot override %s of window: %s", zErr, pWin->zBase);
      } else {
        pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);
        if (pExist->pOrderBy) {
          pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);
        }
        sqlite3DbFree(db, (void *)pWin->zBase);
        pWin->zBase = (char *)0;
      }
    }
  }
  return;
}
}
static void sqlite3WindowAttach(Parse *pParse , Expr *p , Window *pWin ) 
{ 


  {
  if (p) {
    p->y.pWin = pWin;
    p->flags |= 16777216U;
    pWin->pOwner = p;
    if (p->flags & 2U) {
      if ((int )pWin->eFrmType != 161) {
        sqlite3ErrorMsg(pParse, "DISTINCT is not supported for window functions");
      }
    }
  } else {
    sqlite3WindowDelete(pParse->db, pWin);
  }
  return;
}
}
static void sqlite3WindowLink(Select *pSel , Window *pWin ) 
{ 
  int tmp ;

  {
  if ((unsigned long )((Window *)0) == (unsigned long )pSel->pWin) {
    goto _L;
  } else {
    tmp = sqlite3WindowCompare((Parse *)0, pSel->pWin, pWin, 0);
    if (0 == tmp) {
      _L: /* CIL Label */ 
      pWin->pNextWin = pSel->pWin;
      if (pSel->pWin) {
        (pSel->pWin)->ppThis = & pWin->pNextWin;
      }
      pSel->pWin = pWin;
      pWin->ppThis = & pSel->pWin;
    }
  }
  return;
}
}
static int sqlite3WindowCompare(Parse *pParse , Window *p1 , Window *p2 , int bFilter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((int )p1->eFrmType != (int )p2->eFrmType) {
    return (1);
  }
  if ((int )p1->eStart != (int )p2->eStart) {
    return (1);
  }
  if ((int )p1->eEnd != (int )p2->eEnd) {
    return (1);
  }
  if ((int )p1->eExclude != (int )p2->eExclude) {
    return (1);
  }
  tmp = sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1);
  if (tmp) {
    return (1);
  }
  tmp___0 = sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1);
  if (tmp___0) {
    return (1);
  }
  tmp___1 = sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1);
  if (tmp___1) {
    return (1);
  }
  tmp___2 = sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1);
  if (tmp___2) {
    return (1);
  }
  if (bFilter) {
    tmp___3 = sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1);
    if (tmp___3) {
      return (1);
    }
  }
  return (0);
}
}
static void sqlite3WindowCodeInit(Parse *pParse , Window *pMWin ) 
{ 
  Window *pWin ;
  Vdbe *v ;
  Vdbe *tmp ;
  int nExpr ;
  int tmp___0 ;
  FuncDef *p ;
  ExprList *pList ;
  KeyInfo *pKeyInfo ;
  KeyInfo *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if (pMWin->pPartition) {
    nExpr = (pMWin->pPartition)->nExpr;
    pMWin->regPart = pParse->nMem + 1;
    pParse->nMem += nExpr;
    sqlite3VdbeAddOp3(v, 73, 0, pMWin->regPart, (pMWin->regPart + nExpr) - 1);
  }
  (pParse->nMem) ++;
  pMWin->regOne = pParse->nMem;
  sqlite3VdbeAddOp2(v, 70, 1, pMWin->regOne);
  if (pMWin->eExclude) {
    (pParse->nMem) ++;
    pMWin->regStartRowid = pParse->nMem;
    (pParse->nMem) ++;
    pMWin->regEndRowid = pParse->nMem;
    tmp___0 = pParse->nTab;
    (pParse->nTab) ++;
    pMWin->csrApp = tmp___0;
    sqlite3VdbeAddOp2(v, 70, 1, pMWin->regStartRowid);
    sqlite3VdbeAddOp2(v, 70, 0, pMWin->regEndRowid);
    sqlite3VdbeAddOp2(v, 109, pMWin->csrApp, pMWin->iEphCsr);
    return;
  }
  pWin = pMWin;
  while (pWin) {
    p = pWin->pFunc;
    if (p->funcFlags & 4096U) {
      if ((int )pWin->eStart != 90) {
        pList = (pWin->pOwner)->x.pList;
        tmp___1 = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);
        pKeyInfo = tmp___1;
        tmp___2 = pParse->nTab;
        (pParse->nTab) ++;
        pWin->csrApp = tmp___2;
        pWin->regApp = pParse->nMem + 1;
        pParse->nMem += 3;
        if (pKeyInfo) {
          if ((int const   )*((pWin->pFunc)->zName + 1) == 105) {
            *(pKeyInfo->aSortFlags + 0) = (u8 )1;
          }
        }
        sqlite3VdbeAddOp2(v, 112, pWin->csrApp, 2);
        sqlite3VdbeAppendP4(v, (void *)pKeyInfo, -9);
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp + 1);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if ((unsigned long )p->zName == (unsigned long )(nth_valueName)) {
      goto _L;
    } else
    if ((unsigned long )p->zName == (unsigned long )(first_valueName)) {
      _L: /* CIL Label */ 
      pWin->regApp = pParse->nMem + 1;
      tmp___3 = pParse->nTab;
      (pParse->nTab) ++;
      pWin->csrApp = tmp___3;
      pParse->nMem += 2;
      sqlite3VdbeAddOp2(v, 109, pWin->csrApp, pMWin->iEphCsr);
    } else
    if ((unsigned long )p->zName == (unsigned long )(leadName)) {
      tmp___4 = pParse->nTab;
      (pParse->nTab) ++;
      pWin->csrApp = tmp___4;
      sqlite3VdbeAddOp2(v, 109, pWin->csrApp, pMWin->iEphCsr);
    } else
    if ((unsigned long )p->zName == (unsigned long )(lagName)) {
      tmp___4 = pParse->nTab;
      (pParse->nTab) ++;
      pWin->csrApp = tmp___4;
      sqlite3VdbeAddOp2(v, 109, pWin->csrApp, pMWin->iEphCsr);
    }
    pWin = pWin->pNextWin;
  }
  return;
}
}
static void windowCheckValue(Parse *pParse , int reg , int eCond ) ;
static char const   *azErr[5]  = {      "frame starting offset must be a non-negative integer",      "frame ending offset must be a non-negative integer",      "second argument to nth_value must be a positive integer",      "frame starting offset must be a non-negative number", 
        "frame ending offset must be a non-negative number"};
static int aOp___0[5]  = {      57,      57,      54,      57, 
        57};
static void windowCheckValue(Parse *pParse , int reg , int eCond ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  int regZero ;
  int tmp___0 ;
  int regString ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  tmp___0 = sqlite3GetTempReg(pParse);
  regZero = tmp___0;
  sqlite3VdbeAddOp2(v, 70, 0, regZero);
  if (eCond >= 3) {
    tmp___1 = sqlite3GetTempReg(pParse);
    regString = tmp___1;
    sqlite3VdbeAddOp4(v, 113, 0, regString, 0, "", -1);
    tmp___2 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp3(v, 57, regString, tmp___2 + 2, reg);
    sqlite3VdbeChangeP5(v, (u16 )83);
  } else {
    tmp___3 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 15, reg, tmp___3 + 2);
  }
  tmp___4 = sqlite3VdbeCurrentAddr(v);
  sqlite3VdbeAddOp3(v, aOp___0[eCond], regZero, tmp___4 + 2, reg);
  sqlite3MayAbort(pParse);
  sqlite3VdbeAddOp2(v, 69, 1, 2);
  sqlite3VdbeAppendP4(v, (void *)azErr[eCond], -1);
  sqlite3ReleaseTempReg(pParse, regZero);
  return;
}
}
static int windowArgCount(Window *pWin ) 
{ 
  ExprList *pList ;
  int tmp ;

  {
  pList = (pWin->pOwner)->x.pList;
  if (pList) {
    tmp = pList->nExpr;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static void windowReadPeerValues(WindowCodeArg *p , int csr , int reg ) 
{ 
  Window *pMWin ;
  ExprList *pOrderBy ;
  Vdbe *v ;
  Vdbe *tmp ;
  ExprList *pPart ;
  int iColOff ;
  int tmp___0 ;
  int i ;

  {
  pMWin = p->pMWin;
  pOrderBy = pMWin->pOrderBy;
  if (pOrderBy) {
    tmp = sqlite3GetVdbe(p->pParse);
    v = tmp;
    pPart = pMWin->pPartition;
    if (pPart) {
      tmp___0 = pPart->nExpr;
    } else {
      tmp___0 = 0;
    }
    iColOff = pMWin->nBufferCol + tmp___0;
    i = 0;
    while (i < pOrderBy->nExpr) {
      sqlite3VdbeAddOp3(v, 90, csr, iColOff + i, reg + i);
      i ++;
    }
  }
  return;
}
}
static void windowAggStep(WindowCodeArg *p , Window *pMWin , int csr , int bInverse ,
                          int reg ) 
{ 
  Parse *pParse ;
  Vdbe *v ;
  Vdbe *tmp ;
  Window *pWin ;
  FuncDef *pFunc ;
  int regArg ;
  int nArg ;
  int tmp___0 ;
  int tmp___1 ;
  int i ;
  int addrIsNull ;
  int tmp___2 ;
  int tmp___3 ;
  int addrIf ;
  int regTmp ;
  int iStart ;
  int tmp___4 ;
  VdbeOp *pOp ;
  VdbeOp *pEnd ;
  CollSeq *pColl ;
  int tmp___5 ;

  {
  pParse = p->pParse;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  pWin = pMWin;
  while (pWin) {
    pFunc = pWin->pFunc;
    if (pWin->bExprArgs) {
      tmp___1 = 0;
    } else {
      tmp___0 = windowArgCount(pWin);
      tmp___1 = tmp___0;
    }
    nArg = tmp___1;
    i = 0;
    while (i < nArg) {
      if (i != 1) {
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol + i, reg + i);
      } else
      if ((unsigned long )pFunc->zName != (unsigned long )(nth_valueName)) {
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol + i, reg + i);
      } else {
        sqlite3VdbeAddOp3(v, 90, pMWin->iEphCsr, pWin->iArgCol + i, reg + i);
      }
      i ++;
    }
    regArg = reg;
    if (pMWin->regStartRowid == 0) {
      if (pFunc->funcFlags & 4096U) {
        if ((int )pWin->eStart != 90) {
          tmp___2 = sqlite3VdbeAddOp1(v, 50, regArg);
          addrIsNull = tmp___2;
          if (bInverse == 0) {
            sqlite3VdbeAddOp2(v, 83, pWin->regApp + 1, 1);
            sqlite3VdbeAddOp2(v, 79, regArg, pWin->regApp);
            sqlite3VdbeAddOp3(v, 92, pWin->regApp, 2, pWin->regApp + 2);
            sqlite3VdbeAddOp2(v, 132, pWin->csrApp, pWin->regApp + 2);
          } else {
            sqlite3VdbeAddOp4Int(v, 24, pWin->csrApp, 0, regArg, 1);
            sqlite3VdbeAddOp1(v, 123, pWin->csrApp);
            tmp___3 = sqlite3VdbeCurrentAddr(v);
            sqlite3VdbeJumpHere(v, tmp___3 - 2);
          }
          sqlite3VdbeJumpHere(v, addrIsNull);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (pWin->regApp) {
      sqlite3VdbeAddOp2(v, 83, (pWin->regApp + 1) - bInverse, 1);
    } else
    if ((unsigned long )pFunc->xSFunc != (unsigned long )(& noopStepFunc)) {
      addrIf = 0;
      if (pWin->pFilter) {
        regTmp = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol + nArg, regTmp);
        addrIf = sqlite3VdbeAddOp3(v, 20, regTmp, 0, 1);
        sqlite3ReleaseTempReg(pParse, regTmp);
      }
      if (pWin->bExprArgs) {
        tmp___4 = sqlite3VdbeCurrentAddr(v);
        iStart = tmp___4;
        nArg = ((pWin->pOwner)->x.pList)->nExpr;
        regArg = sqlite3GetTempRange(pParse, nArg);
        sqlite3ExprCodeExprList(pParse, (pWin->pOwner)->x.pList, regArg, 0, (u8 )0);
        pEnd = sqlite3VdbeGetOp(v, -1);
        pOp = sqlite3VdbeGetOp(v, iStart);
        while ((unsigned long )pOp <= (unsigned long )pEnd) {
          if ((int )pOp->opcode == 90) {
            if (pOp->p1 == pWin->iEphCsr) {
              pOp->p1 = csr;
            }
          }
          pOp ++;
        }
      }
      if (pFunc->funcFlags & 32U) {
        pColl = sqlite3ExprNNCollSeq(pParse, ((pWin->pOwner)->x.pList)->a[0].pExpr);
        sqlite3VdbeAddOp4(v, 82, 0, 0, 0, (char const   *)pColl, -2);
      }
      if (bInverse) {
        tmp___5 = 153;
      } else {
        tmp___5 = 154;
      }
      sqlite3VdbeAddOp3(v, tmp___5, bInverse, regArg, pWin->regAccum);
      sqlite3VdbeAppendP4(v, (void *)pFunc, -8);
      sqlite3VdbeChangeP5(v, (u16 )((u8 )nArg));
      if (pWin->bExprArgs) {
        sqlite3ReleaseTempRange(pParse, regArg, nArg);
      }
      if (addrIf) {
        sqlite3VdbeJumpHere(v, addrIf);
      }
    }
    pWin = pWin->pNextWin;
  }
  return;
}
}
static void windowAggFinal(WindowCodeArg *p , int bFin ) 
{ 
  Parse *pParse ;
  Window *pMWin ;
  Vdbe *v ;
  Vdbe *tmp ;
  Window *pWin ;
  int tmp___0 ;
  int nArg ;
  int tmp___1 ;

  {
  pParse = p->pParse;
  pMWin = p->pMWin;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  pWin = pMWin;
  while (pWin) {
    if (pMWin->regStartRowid == 0) {
      if ((pWin->pFunc)->funcFlags & 4096U) {
        if ((int )pWin->eStart != 90) {
          sqlite3VdbeAddOp2(v, 73, 0, pWin->regResult);
          sqlite3VdbeAddOp1(v, 32, pWin->csrApp);
          sqlite3VdbeAddOp3(v, 90, pWin->csrApp, 0, pWin->regResult);
          tmp___0 = sqlite3VdbeCurrentAddr(v);
          sqlite3VdbeJumpHere(v, tmp___0 - 2);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! pWin->regApp) {
      tmp___1 = windowArgCount(pWin);
      nArg = tmp___1;
      if (bFin) {
        sqlite3VdbeAddOp2(v, 157, pWin->regAccum, nArg);
        sqlite3VdbeAppendP4(v, (void *)pWin->pFunc, -8);
        sqlite3VdbeAddOp2(v, 78, pWin->regAccum, pWin->regResult);
        sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
      } else {
        sqlite3VdbeAddOp3(v, 156, pWin->regAccum, nArg, pWin->regResult);
        sqlite3VdbeAppendP4(v, (void *)pWin->pFunc, -8);
      }
    }
    pWin = pWin->pNextWin;
  }
  return;
}
}
static void windowFullScan(WindowCodeArg *p ) 
{ 
  Window *pWin ;
  Parse *pParse ;
  Window *pMWin ;
  Vdbe *v ;
  int regCRowid ;
  int regCPeer ;
  int regRowid ;
  int regPeer ;
  int nPeer ;
  int lblNext ;
  int lblBrk ;
  int addrNext ;
  int csr ;
  int addr ;
  int addrEq ;
  KeyInfo *pKeyInfo ;
  int tmp ;

  {
  pParse = p->pParse;
  pMWin = p->pMWin;
  v = p->pVdbe;
  regCRowid = 0;
  regCPeer = 0;
  regRowid = 0;
  regPeer = 0;
  csr = pMWin->csrApp;
  if (pMWin->pOrderBy) {
    nPeer = (pMWin->pOrderBy)->nExpr;
  } else {
    nPeer = 0;
  }
  lblNext = sqlite3VdbeMakeLabel(pParse);
  lblBrk = sqlite3VdbeMakeLabel(pParse);
  regCRowid = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  if (nPeer) {
    regCPeer = sqlite3GetTempRange(pParse, nPeer);
    regPeer = sqlite3GetTempRange(pParse, nPeer);
  }
  sqlite3VdbeAddOp2(v, 128, pMWin->iEphCsr, regCRowid);
  windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);
  pWin = pMWin;
  while (pWin) {
    sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
    pWin = pWin->pNextWin;
  }
  sqlite3VdbeAddOp3(v, 24, csr, lblBrk, pMWin->regStartRowid);
  addrNext = sqlite3VdbeCurrentAddr(v);
  sqlite3VdbeAddOp2(v, 128, csr, regRowid);
  sqlite3VdbeAddOp3(v, 54, pMWin->regEndRowid, lblBrk, regRowid);
  if ((int )pMWin->eExclude == 85) {
    sqlite3VdbeAddOp3(v, 53, regCRowid, lblNext, regRowid);
  } else
  if ((int )pMWin->eExclude != 66) {
    addrEq = 0;
    pKeyInfo = (KeyInfo *)0;
    if (pMWin->pOrderBy) {
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);
    }
    if ((int )pMWin->eExclude == 94) {
      addrEq = sqlite3VdbeAddOp3(v, 53, regCRowid, 0, regRowid);
    }
    if (pKeyInfo) {
      windowReadPeerValues(p, csr, regPeer);
      sqlite3VdbeAddOp3(v, 87, regPeer, regCPeer, nPeer);
      sqlite3VdbeAppendP4(v, (void *)pKeyInfo, -9);
      tmp = sqlite3VdbeCurrentAddr(v);
      addr = tmp + 1;
      sqlite3VdbeAddOp3(v, 16, addr, lblNext, addr);
    } else {
      sqlite3VdbeAddOp2(v, 11, 0, lblNext);
    }
    if (addrEq) {
      sqlite3VdbeJumpHere(v, addrEq);
    }
  }
  windowAggStep(p, pMWin, csr, 0, p->regArg);
  sqlite3VdbeResolveLabel(v, lblNext);
  sqlite3VdbeAddOp2(v, 5, csr, addrNext);
  sqlite3VdbeJumpHere(v, addrNext - 1);
  sqlite3VdbeJumpHere(v, addrNext + 1);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regCRowid);
  if (nPeer) {
    sqlite3ReleaseTempRange(pParse, regPeer, nPeer);
    sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);
  }
  windowAggFinal(p, 1);
  return;
}
}
static void windowReturnOneRow(WindowCodeArg *p ) 
{ 
  Window *pMWin ;
  Vdbe *v ;
  Parse *pParse ;
  Window *pWin ;
  FuncDef *pFunc ;
  int csr ;
  int lbl ;
  int tmp ;
  int tmpReg ;
  int tmp___0 ;
  int nArg ;
  int csr___0 ;
  int lbl___0 ;
  int tmp___1 ;
  int tmpReg___0 ;
  int tmp___2 ;
  int iEph ;
  int val ;
  int tmp___3 ;
  int op ;
  int tmp___4 ;
  int tmpReg2 ;
  int tmp___5 ;

  {
  pMWin = p->pMWin;
  v = p->pVdbe;
  if (pMWin->regStartRowid) {
    windowFullScan(p);
  } else {
    pParse = p->pParse;
    pWin = pMWin;
    while (pWin) {
      pFunc = pWin->pFunc;
      if ((unsigned long )pFunc->zName == (unsigned long )(nth_valueName)) {
        goto _L___0;
      } else
      if ((unsigned long )pFunc->zName == (unsigned long )(first_valueName)) {
        _L___0: /* CIL Label */ 
        csr = pWin->csrApp;
        tmp = sqlite3VdbeMakeLabel(pParse);
        lbl = tmp;
        tmp___0 = sqlite3GetTempReg(pParse);
        tmpReg = tmp___0;
        sqlite3VdbeAddOp2(v, 73, 0, pWin->regResult);
        if ((unsigned long )pFunc->zName == (unsigned long )(nth_valueName)) {
          sqlite3VdbeAddOp3(v, 90, pMWin->iEphCsr, pWin->iArgCol + 1, tmpReg);
          windowCheckValue(pParse, tmpReg, 2);
        } else {
          sqlite3VdbeAddOp2(v, 70, 1, tmpReg);
        }
        sqlite3VdbeAddOp3(v, 103, tmpReg, pWin->regApp, tmpReg);
        sqlite3VdbeAddOp3(v, 54, pWin->regApp + 1, lbl, tmpReg);
        sqlite3VdbeAddOp3(v, 30, csr, 0, tmpReg);
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol, pWin->regResult);
        sqlite3VdbeResolveLabel(v, lbl);
        sqlite3ReleaseTempReg(pParse, tmpReg);
      } else
      if ((unsigned long )pFunc->zName == (unsigned long )(leadName)) {
        goto _L;
      } else
      if ((unsigned long )pFunc->zName == (unsigned long )(lagName)) {
        _L: /* CIL Label */ 
        nArg = ((pWin->pOwner)->x.pList)->nExpr;
        csr___0 = pWin->csrApp;
        tmp___1 = sqlite3VdbeMakeLabel(pParse);
        lbl___0 = tmp___1;
        tmp___2 = sqlite3GetTempReg(pParse);
        tmpReg___0 = tmp___2;
        iEph = pMWin->iEphCsr;
        if (nArg < 3) {
          sqlite3VdbeAddOp2(v, 73, 0, pWin->regResult);
        } else {
          sqlite3VdbeAddOp3(v, 90, iEph, pWin->iArgCol + 2, pWin->regResult);
        }
        sqlite3VdbeAddOp2(v, 128, iEph, tmpReg___0);
        if (nArg < 2) {
          if ((unsigned long )pFunc->zName == (unsigned long )(leadName)) {
            tmp___3 = 1;
          } else {
            tmp___3 = -1;
          }
          val = tmp___3;
          sqlite3VdbeAddOp2(v, 83, tmpReg___0, val);
        } else {
          if ((unsigned long )pFunc->zName == (unsigned long )(leadName)) {
            tmp___4 = 103;
          } else {
            tmp___4 = 104;
          }
          op = tmp___4;
          tmp___5 = sqlite3GetTempReg(pParse);
          tmpReg2 = tmp___5;
          sqlite3VdbeAddOp3(v, 90, iEph, pWin->iArgCol + 1, tmpReg2);
          sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg___0, tmpReg___0);
          sqlite3ReleaseTempReg(pParse, tmpReg2);
        }
        sqlite3VdbeAddOp3(v, 30, csr___0, lbl___0, tmpReg___0);
        sqlite3VdbeAddOp3(v, 90, csr___0, pWin->iArgCol, pWin->regResult);
        sqlite3VdbeResolveLabel(v, lbl___0);
        sqlite3ReleaseTempReg(pParse, tmpReg___0);
      }
      pWin = pWin->pNextWin;
    }
  }
  sqlite3VdbeAddOp2(v, 12, p->regGosub, p->addrGosub);
  return;
}
}
static int windowInitAccum(Parse *pParse , Window *pMWin ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  int regArg ;
  int nArg ;
  Window *pWin ;
  FuncDef *pFunc ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  nArg = 0;
  pWin = pMWin;
  while (pWin) {
    pFunc = pWin->pFunc;
    sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
    tmp___2 = windowArgCount(pWin);
    if (nArg > tmp___2) {
      nArg = nArg;
    } else {
      tmp___1 = windowArgCount(pWin);
      nArg = tmp___1;
    }
    if (pMWin->regStartRowid == 0) {
      if ((unsigned long )pFunc->zName == (unsigned long )(nth_valueName)) {
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp);
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp + 1);
      } else
      if ((unsigned long )pFunc->zName == (unsigned long )(first_valueName)) {
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp);
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp + 1);
      }
      if (pFunc->funcFlags & 4096U) {
        if (pWin->csrApp) {
          sqlite3VdbeAddOp1(v, 138, pWin->csrApp);
          sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp + 1);
        }
      }
    }
    pWin = pWin->pNextWin;
  }
  regArg = pParse->nMem + 1;
  pParse->nMem += nArg;
  return (regArg);
}
}
static int windowCacheFrame(Window *pMWin ) 
{ 
  Window *pWin ;
  FuncDef *pFunc ;

  {
  if (pMWin->regStartRowid) {
    return (1);
  }
  pWin = pMWin;
  while (pWin) {
    pFunc = pWin->pFunc;
    if ((unsigned long )pFunc->zName == (unsigned long )(nth_valueName)) {
      return (1);
    } else
    if ((unsigned long )pFunc->zName == (unsigned long )(first_valueName)) {
      return (1);
    } else
    if ((unsigned long )pFunc->zName == (unsigned long )(leadName)) {
      return (1);
    } else
    if ((unsigned long )pFunc->zName == (unsigned long )(lagName)) {
      return (1);
    }
    pWin = pWin->pNextWin;
  }
  return (0);
}
}
static void windowIfNewPeer(Parse *pParse , ExprList *pOrderBy , int regNew , int regOld ,
                            int addr ) 
{ 
  Vdbe *v ;
  Vdbe *tmp ;
  int nVal ;
  KeyInfo *pKeyInfo ;
  KeyInfo *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  if (pOrderBy) {
    nVal = pOrderBy->nExpr;
    tmp___0 = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);
    pKeyInfo = tmp___0;
    sqlite3VdbeAddOp3(v, 87, regOld, regNew, nVal);
    sqlite3VdbeAppendP4(v, (void *)pKeyInfo, -9);
    tmp___1 = sqlite3VdbeCurrentAddr(v);
    tmp___2 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp3(v, 16, tmp___2 + 1, addr, tmp___1 + 1);
    sqlite3VdbeAddOp3(v, 78, regNew, regOld, nVal - 1);
  } else {
    sqlite3VdbeAddOp2(v, 11, 0, addr);
  }
  return;
}
}
static void windowCodeRangeTest(WindowCodeArg *p , int op , int csr1 , int regVal ,
                                int csr2 , int lbl ) 
{ 
  Parse *pParse ;
  Vdbe *v ;
  Vdbe *tmp ;
  ExprList *pOrderBy ;
  int reg1 ;
  int tmp___0 ;
  int reg2 ;
  int tmp___1 ;
  int regString ;
  int arith ;
  int addrGe ;
  int addr ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  pParse = p->pParse;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  pOrderBy = (p->pMWin)->pOrderBy;
  tmp___0 = sqlite3GetTempReg(pParse);
  reg1 = tmp___0;
  tmp___1 = sqlite3GetTempReg(pParse);
  reg2 = tmp___1;
  (pParse->nMem) ++;
  regString = pParse->nMem;
  arith = 103;
  if ((int )pOrderBy->a[0].sortFlags & 1) {
    switch (op) {
    case 57: 
    op = 55;
    break;
    case 54: 
    op = 56;
    break;
    default: 
    op = 57;
    break;
    }
    arith = 104;
  }
  windowReadPeerValues(p, csr1, reg1);
  windowReadPeerValues(p, csr2, reg2);
  sqlite3VdbeAddOp4(v, 113, 0, regString, 0, "", -1);
  addrGe = sqlite3VdbeAddOp3(v, 57, regString, 0, reg1);
  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);
  sqlite3VdbeJumpHere(v, addrGe);
  if ((int )pOrderBy->a[0].sortFlags & 2) {
    tmp___2 = sqlite3VdbeAddOp1(v, 51, reg1);
    addr = tmp___2;
    switch (op) {
    case 57: 
    sqlite3VdbeAddOp2(v, 11, 0, lbl);
    break;
    case 54: 
    sqlite3VdbeAddOp2(v, 51, reg2, lbl);
    break;
    case 55: 
    sqlite3VdbeAddOp2(v, 50, reg2, lbl);
    break;
    default: ;
    break;
    }
    tmp___3 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 11, 0, tmp___3 + 3);
    sqlite3VdbeJumpHere(v, addr);
    sqlite3VdbeAddOp2(v, 50, reg2, lbl);
    if (op == 54) {
      tmp___4 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeChangeP2(v, -1, tmp___4 + 1);
    } else
    if (op == 57) {
      tmp___4 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeChangeP2(v, -1, tmp___4 + 1);
    }
  }
  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1);
  sqlite3VdbeChangeP5(v, (u16 )128);
  sqlite3ReleaseTempReg(pParse, reg1);
  sqlite3ReleaseTempReg(pParse, reg2);
  return;
}
}
static int windowCodeOp(WindowCodeArg *p , int op , int regCountdown , int jumpOnEof ) 
{ 
  int csr ;
  int reg ;
  Parse *pParse ;
  Window *pMWin ;
  int ret ;
  Vdbe *v ;
  int addrContinue ;
  int bPeer ;
  int lblDone ;
  int tmp ;
  int addrNextRange ;
  int regRowid1 ;
  int tmp___0 ;
  int regRowid2 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int nReg ;
  int tmp___4 ;
  int regTmp ;
  int tmp___5 ;
  int tmp___6 ;

  {
  pParse = p->pParse;
  pMWin = p->pMWin;
  ret = 0;
  v = p->pVdbe;
  addrContinue = 0;
  bPeer = (int )pMWin->eFrmType != 76;
  tmp = sqlite3VdbeMakeLabel(pParse);
  lblDone = tmp;
  addrNextRange = 0;
  if (op == 2) {
    if ((int )pMWin->eStart == 90) {
      return (0);
    }
  }
  if (regCountdown > 0) {
    if ((int )pMWin->eFrmType == 89) {
      addrNextRange = sqlite3VdbeCurrentAddr(v);
      if (op == 2) {
        if ((int )pMWin->eStart == 86) {
          windowCodeRangeTest(p, 55, p->current.csr, regCountdown, p->start.csr, lblDone);
        } else {
          windowCodeRangeTest(p, 57, p->start.csr, regCountdown, p->current.csr, lblDone);
        }
      } else {
        windowCodeRangeTest(p, 54, p->end.csr, regCountdown, p->current.csr, lblDone);
      }
    } else {
      sqlite3VdbeAddOp3(v, 47, regCountdown, lblDone, 1);
    }
  }
  if (op == 1) {
    if (pMWin->regStartRowid == 0) {
      windowAggFinal(p, 0);
    }
  }
  addrContinue = sqlite3VdbeCurrentAddr(v);
  if ((int )pMWin->eStart == (int )pMWin->eEnd) {
    if (regCountdown) {
      if ((int )pMWin->eFrmType == 89) {
        if (op == 2) {
          tmp___0 = sqlite3GetTempReg(pParse);
          regRowid1 = tmp___0;
          tmp___1 = sqlite3GetTempReg(pParse);
          regRowid2 = tmp___1;
          sqlite3VdbeAddOp2(v, 128, p->start.csr, regRowid1);
          sqlite3VdbeAddOp2(v, 128, p->end.csr, regRowid2);
          sqlite3VdbeAddOp3(v, 57, regRowid2, lblDone, regRowid1);
          sqlite3ReleaseTempReg(pParse, regRowid1);
          sqlite3ReleaseTempReg(pParse, regRowid2);
        }
      }
    }
  }
  switch (op) {
  case 1: 
  csr = p->current.csr;
  reg = p->current.reg;
  windowReturnOneRow(p);
  break;
  case 2: 
  csr = p->start.csr;
  reg = p->start.reg;
  if (pMWin->regStartRowid) {
    sqlite3VdbeAddOp2(v, 83, pMWin->regStartRowid, 1);
  } else {
    windowAggStep(p, pMWin, csr, 1, p->regArg);
  }
  break;
  default: 
  csr = p->end.csr;
  reg = p->end.reg;
  if (pMWin->regStartRowid) {
    sqlite3VdbeAddOp2(v, 83, pMWin->regEndRowid, 1);
  } else {
    windowAggStep(p, pMWin, csr, 0, p->regArg);
  }
  break;
  }
  if (op == p->eDelete) {
    sqlite3VdbeAddOp1(v, 123, csr);
    sqlite3VdbeChangeP5(v, (u16 )2);
  }
  if (jumpOnEof) {
    tmp___2 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 5, csr, tmp___2 + 2);
    ret = sqlite3VdbeAddOp0(v, 11);
  } else {
    tmp___3 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 5, csr, (tmp___3 + 1) + bPeer);
    if (bPeer) {
      sqlite3VdbeAddOp2(v, 11, 0, lblDone);
    }
  }
  if (bPeer) {
    if (pMWin->pOrderBy) {
      tmp___4 = (pMWin->pOrderBy)->nExpr;
    } else {
      tmp___4 = 0;
    }
    nReg = tmp___4;
    if (nReg) {
      tmp___5 = sqlite3GetTempRange(pParse, nReg);
      tmp___6 = tmp___5;
    } else {
      tmp___6 = 0;
    }
    regTmp = tmp___6;
    windowReadPeerValues(p, csr, regTmp);
    windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);
    sqlite3ReleaseTempRange(pParse, regTmp, nReg);
  }
  if (addrNextRange) {
    sqlite3VdbeAddOp2(v, 11, 0, addrNextRange);
  }
  sqlite3VdbeResolveLabel(v, lblDone);
  return (ret);
}
}
static Window *sqlite3WindowDup(sqlite3 *db , Expr *pOwner , Window *p ) 
{ 
  Window *pNew ;
  void *tmp ;

  {
  pNew = (Window *)0;
  if (p) {
    tmp = sqlite3DbMallocZero(db, (u64 )sizeof(Window ));
    pNew = (Window *)tmp;
    if (pNew) {
      pNew->zName = sqlite3DbStrDup(db, (char const   *)p->zName);
      pNew->zBase = sqlite3DbStrDup(db, (char const   *)p->zBase);
      pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);
      pNew->pFunc = p->pFunc;
      pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);
      pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);
      pNew->eFrmType = p->eFrmType;
      pNew->eEnd = p->eEnd;
      pNew->eStart = p->eStart;
      pNew->eExclude = p->eExclude;
      pNew->regResult = p->regResult;
      pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);
      pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);
      pNew->pOwner = pOwner;
      pNew->bImplicitFrame = p->bImplicitFrame;
    }
  }
  return (pNew);
}
}
static Window *sqlite3WindowListDup(sqlite3 *db , Window *p ) 
{ 
  Window *pWin ;
  Window *pRet ;
  Window **pp ;

  {
  pRet = (Window *)0;
  pp = & pRet;
  pWin = p;
  while (pWin) {
    *pp = sqlite3WindowDup(db, (Expr *)0, pWin);
    if ((unsigned long )*pp == (unsigned long )((Window *)0)) {
      break;
    }
    pp = & (*pp)->pNextWin;
    pWin = pWin->pNextWin;
  }
  return (pRet);
}
}
static int windowExprGtZero(Parse *pParse , Expr *pExpr ) 
{ 
  int ret ;
  sqlite3 *db ;
  sqlite3_value *pVal ;
  int tmp ;

  {
  ret = 0;
  db = pParse->db;
  pVal = (sqlite3_value *)0;
  sqlite3ValueFromExpr(db, pExpr, db->enc, (u8 )67, & pVal);
  if (pVal) {
    tmp = sqlite3_value_int(pVal);
    if (tmp > 0) {
      ret = 1;
    }
  }
  sqlite3ValueFree(pVal);
  return (ret);
}
}
static void sqlite3WindowCodeStep(Parse *pParse , Select *p , WhereInfo *pWInfo ,
                                  int regGosub , int addrGosub ) 
{ 
  Window *pMWin ;
  ExprList *pOrderBy ;
  Vdbe *v ;
  Vdbe *tmp ;
  int csrWrite ;
  int csrInput ;
  int nInput ;
  int iInput ;
  int addrNe ;
  int addrGosubFlush ;
  int addrInteger ;
  int addrEmpty ;
  int regNew ;
  int regRecord ;
  int regRowid ;
  int regNewPeer ;
  int regPeer ;
  int regFlushPart ;
  WindowCodeArg s ;
  int lblWhereEnd ;
  int regStart ;
  int regEnd ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int nPeer ;
  int tmp___3 ;
  int addr ;
  ExprList *pPart ;
  int nPart ;
  int regNewPart ;
  KeyInfo *pKeyInfo ;
  KeyInfo *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int op ;
  int tmp___7 ;
  int addrGe ;
  int tmp___8 ;
  int lbl ;
  int tmp___9 ;
  int addrNext ;
  int tmp___10 ;
  int bRPS ;
  int tmp___11 ;
  int addr___0 ;
  int lbl___0 ;
  int bRPS___0 ;
  int tmp___12 ;
  int addrStart ;
  int addrBreak1 ;
  int addrBreak2 ;
  int addrBreak3 ;
  int addrBreak ;
  int addrStart___0 ;
  int tmp___13 ;

  {
  pMWin = p->pWin;
  pOrderBy = pMWin->pOrderBy;
  tmp = sqlite3GetVdbe(pParse);
  v = tmp;
  csrInput = (p->pSrc)->a[0].iCursor;
  nInput = (int )((p->pSrc)->a[0].pTab)->nCol;
  addrGosubFlush = 0;
  addrInteger = 0;
  regNewPeer = 0;
  regPeer = 0;
  regFlushPart = 0;
  regStart = 0;
  regEnd = 0;
  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);
  memset((void *)(& s), 0, sizeof(WindowCodeArg ));
  s.pParse = pParse;
  s.pMWin = pMWin;
  s.pVdbe = v;
  s.regGosub = regGosub;
  s.addrGosub = addrGosub;
  s.current.csr = pMWin->iEphCsr;
  csrWrite = s.current.csr + 1;
  s.start.csr = s.current.csr + 2;
  s.end.csr = s.current.csr + 3;
  switch ((int )pMWin->eStart) {
  case 86: 
  if ((int )pMWin->eFrmType != 89) {
    tmp___0 = windowExprGtZero(pParse, pMWin->pStart);
    if (tmp___0) {
      s.eDelete = 1;
    }
  }
  break;
  case 90: 
  tmp___2 = windowCacheFrame(pMWin);
  if (tmp___2 == 0) {
    if ((int )pMWin->eEnd == 88) {
      if ((int )pMWin->eFrmType != 89) {
        tmp___1 = windowExprGtZero(pParse, pMWin->pEnd);
        if (tmp___1) {
          s.eDelete = 3;
        }
      }
    } else {
      s.eDelete = 1;
    }
  }
  break;
  default: 
  s.eDelete = 2;
  break;
  }
  regNew = pParse->nMem + 1;
  pParse->nMem += nInput;
  (pParse->nMem) ++;
  regRecord = pParse->nMem;
  (pParse->nMem) ++;
  regRowid = pParse->nMem;
  if ((int )pMWin->eStart == 88) {
    (pParse->nMem) ++;
    regStart = pParse->nMem;
  } else
  if ((int )pMWin->eStart == 86) {
    (pParse->nMem) ++;
    regStart = pParse->nMem;
  }
  if ((int )pMWin->eEnd == 88) {
    (pParse->nMem) ++;
    regEnd = pParse->nMem;
  } else
  if ((int )pMWin->eEnd == 86) {
    (pParse->nMem) ++;
    regEnd = pParse->nMem;
  }
  if ((int )pMWin->eFrmType != 76) {
    if (pOrderBy) {
      tmp___3 = pOrderBy->nExpr;
    } else {
      tmp___3 = 0;
    }
    nPeer = tmp___3;
    regNewPeer = regNew + pMWin->nBufferCol;
    if (pMWin->pPartition) {
      regNewPeer += (pMWin->pPartition)->nExpr;
    }
    regPeer = pParse->nMem + 1;
    pParse->nMem += nPeer;
    s.start.reg = pParse->nMem + 1;
    pParse->nMem += nPeer;
    s.current.reg = pParse->nMem + 1;
    pParse->nMem += nPeer;
    s.end.reg = pParse->nMem + 1;
    pParse->nMem += nPeer;
  }
  iInput = 0;
  while (iInput < nInput) {
    sqlite3VdbeAddOp3(v, 90, csrInput, iInput, regNew + iInput);
    iInput ++;
  }
  sqlite3VdbeAddOp3(v, 92, regNew, nInput, regRecord);
  if (pMWin->pPartition) {
    pPart = pMWin->pPartition;
    nPart = pPart->nExpr;
    regNewPart = regNew + pMWin->nBufferCol;
    tmp___4 = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);
    pKeyInfo = tmp___4;
    (pParse->nMem) ++;
    regFlushPart = pParse->nMem;
    addr = sqlite3VdbeAddOp3(v, 87, regNewPart, pMWin->regPart, nPart);
    sqlite3VdbeAppendP4(v, (void *)pKeyInfo, -9);
    sqlite3VdbeAddOp3(v, 16, addr + 2, addr + 4, addr + 2);
    addrGosubFlush = sqlite3VdbeAddOp1(v, 12, regFlushPart);
    sqlite3VdbeAddOp3(v, 78, regNewPart, pMWin->regPart, nPart - 1);
  }
  sqlite3VdbeAddOp2(v, 121, csrWrite, regRowid);
  sqlite3VdbeAddOp3(v, 122, csrWrite, regRecord, regRowid);
  addrNe = sqlite3VdbeAddOp3(v, 52, pMWin->regOne, 0, regRowid);
  s.regArg = windowInitAccum(pParse, pMWin);
  if (regStart) {
    sqlite3ExprCode(pParse, pMWin->pStart, regStart);
    if ((int )pMWin->eFrmType == 89) {
      tmp___5 = 3;
    } else {
      tmp___5 = 0;
    }
    windowCheckValue(pParse, regStart, tmp___5);
  }
  if (regEnd) {
    sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);
    if ((int )pMWin->eFrmType == 89) {
      tmp___6 = 3;
    } else {
      tmp___6 = 0;
    }
    windowCheckValue(pParse, regEnd, 1 + tmp___6);
  }
  if ((int )pMWin->eFrmType != 89) {
    if ((int )pMWin->eStart == (int )pMWin->eEnd) {
      if (regStart) {
        if ((int )pMWin->eStart == 86) {
          tmp___7 = 57;
        } else {
          tmp___7 = 55;
        }
        op = tmp___7;
        tmp___8 = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);
        addrGe = tmp___8;
        windowAggFinal(& s, 0);
        sqlite3VdbeAddOp2(v, 36, s.current.csr, 1);
        windowReturnOneRow(& s);
        sqlite3VdbeAddOp1(v, 138, s.current.csr);
        sqlite3VdbeAddOp2(v, 11, 0, lblWhereEnd);
        sqlite3VdbeJumpHere(v, addrGe);
      }
    }
  }
  if ((int )pMWin->eStart == 86) {
    if ((int )pMWin->eFrmType != 89) {
      if (regEnd) {
        sqlite3VdbeAddOp3(v, 104, regStart, regEnd, regStart);
      }
    }
  }
  if ((int )pMWin->eStart != 90) {
    sqlite3VdbeAddOp2(v, 36, s.start.csr, 1);
  }
  sqlite3VdbeAddOp2(v, 36, s.current.csr, 1);
  sqlite3VdbeAddOp2(v, 36, s.end.csr, 1);
  if (regPeer) {
    if (pOrderBy) {
      sqlite3VdbeAddOp3(v, 78, regNewPeer, regPeer, pOrderBy->nExpr - 1);
      sqlite3VdbeAddOp3(v, 78, regPeer, s.start.reg, pOrderBy->nExpr - 1);
      sqlite3VdbeAddOp3(v, 78, regPeer, s.current.reg, pOrderBy->nExpr - 1);
      sqlite3VdbeAddOp3(v, 78, regPeer, s.end.reg, pOrderBy->nExpr - 1);
    }
  }
  sqlite3VdbeAddOp2(v, 11, 0, lblWhereEnd);
  sqlite3VdbeJumpHere(v, addrNe);
  if (regPeer) {
    windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);
  }
  if ((int )pMWin->eStart == 86) {
    windowCodeOp(& s, 3, 0, 0);
    if ((int )pMWin->eEnd != 90) {
      if ((int )pMWin->eFrmType == 89) {
        tmp___9 = sqlite3VdbeMakeLabel(pParse);
        lbl = tmp___9;
        tmp___10 = sqlite3VdbeCurrentAddr(v);
        addrNext = tmp___10;
        windowCodeRangeTest(& s, 57, s.current.csr, regEnd, s.end.csr, lbl);
        windowCodeOp(& s, 2, regStart, 0);
        windowCodeOp(& s, 1, 0, 0);
        sqlite3VdbeAddOp2(v, 11, 0, addrNext);
        sqlite3VdbeResolveLabel(v, lbl);
      } else {
        windowCodeOp(& s, 1, regEnd, 0);
        windowCodeOp(& s, 2, regStart, 0);
      }
    }
  } else
  if ((int )pMWin->eEnd == 88) {
    if ((int )pMWin->eStart == 88) {
      if ((int )pMWin->eFrmType == 89) {
        tmp___11 = 1;
      } else {
        tmp___11 = 0;
      }
    } else {
      tmp___11 = 0;
    }
    bRPS = tmp___11;
    windowCodeOp(& s, 3, regEnd, 0);
    if (bRPS) {
      windowCodeOp(& s, 2, regStart, 0);
    }
    windowCodeOp(& s, 1, 0, 0);
    if (! bRPS) {
      windowCodeOp(& s, 2, regStart, 0);
    }
  } else {
    addr___0 = 0;
    windowCodeOp(& s, 3, 0, 0);
    if ((int )pMWin->eEnd != 90) {
      if ((int )pMWin->eFrmType == 89) {
        lbl___0 = 0;
        addr___0 = sqlite3VdbeCurrentAddr(v);
        if (regEnd) {
          lbl___0 = sqlite3VdbeMakeLabel(pParse);
          windowCodeRangeTest(& s, 57, s.current.csr, regEnd, s.end.csr, lbl___0);
        }
        windowCodeOp(& s, 1, 0, 0);
        windowCodeOp(& s, 2, regStart, 0);
        if (regEnd) {
          sqlite3VdbeAddOp2(v, 11, 0, addr___0);
          sqlite3VdbeResolveLabel(v, lbl___0);
        }
      } else {
        if (regEnd) {
          addr___0 = sqlite3VdbeAddOp3(v, 47, regEnd, 0, 1);
        }
        windowCodeOp(& s, 1, 0, 0);
        windowCodeOp(& s, 2, regStart, 0);
        if (regEnd) {
          sqlite3VdbeJumpHere(v, addr___0);
        }
      }
    }
  }
  sqlite3VdbeResolveLabel(v, lblWhereEnd);
  sqlite3WhereEnd(pWInfo);
  if (pMWin->pPartition) {
    addrInteger = sqlite3VdbeAddOp2(v, 70, 0, regFlushPart);
    sqlite3VdbeJumpHere(v, addrGosubFlush);
  }
  addrEmpty = sqlite3VdbeAddOp1(v, 36, csrWrite);
  if ((int )pMWin->eEnd == 88) {
    if ((int )pMWin->eStart == 88) {
      if ((int )pMWin->eFrmType == 89) {
        tmp___12 = 1;
      } else {
        tmp___12 = 0;
      }
    } else {
      tmp___12 = 0;
    }
    bRPS___0 = tmp___12;
    windowCodeOp(& s, 3, regEnd, 0);
    if (bRPS___0) {
      windowCodeOp(& s, 2, regStart, 0);
    }
    windowCodeOp(& s, 1, 0, 0);
  } else
  if ((int )pMWin->eStart == 86) {
    windowCodeOp(& s, 3, 0, 0);
    if ((int )pMWin->eFrmType == 89) {
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak2 = windowCodeOp(& s, 2, regStart, 1);
      addrBreak1 = windowCodeOp(& s, 1, 0, 1);
    } else
    if ((int )pMWin->eEnd == 90) {
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(& s, 1, regStart, 1);
      addrBreak2 = windowCodeOp(& s, 2, 0, 1);
    } else {
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(& s, 1, regEnd, 1);
      addrBreak2 = windowCodeOp(& s, 2, regStart, 1);
    }
    sqlite3VdbeAddOp2(v, 11, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak2);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak3 = windowCodeOp(& s, 1, 0, 1);
    sqlite3VdbeAddOp2(v, 11, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak1);
    sqlite3VdbeJumpHere(v, addrBreak3);
  } else {
    windowCodeOp(& s, 3, 0, 0);
    addrStart___0 = sqlite3VdbeCurrentAddr(v);
    addrBreak = windowCodeOp(& s, 1, 0, 1);
    windowCodeOp(& s, 2, regStart, 0);
    sqlite3VdbeAddOp2(v, 11, 0, addrStart___0);
    sqlite3VdbeJumpHere(v, addrBreak);
  }
  sqlite3VdbeJumpHere(v, addrEmpty);
  sqlite3VdbeAddOp1(v, 138, s.current.csr);
  if (pMWin->pPartition) {
    if (pMWin->regStartRowid) {
      sqlite3VdbeAddOp2(v, 70, 1, pMWin->regStartRowid);
      sqlite3VdbeAddOp2(v, 70, 0, pMWin->regEndRowid);
    }
    tmp___13 = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeChangeP1(v, addrInteger, tmp___13);
    sqlite3VdbeAddOp1(v, 66, regFlushPart);
  }
  return;
}
}
static void disableLookaside(Parse *pParse ) 
{ 


  {
  pParse->disableLookaside = (u8 )((int )pParse->disableLookaside + 1);
  ((pParse->db)->lookaside.bDisable) ++;
  return;
}
}
static void parserDoubleLinkSelect(Parse *pParse , Select *p ) 
{ 
  Select *pNext ;
  Select *pLoop ;
  int mxSelect ;
  int cnt ;

  {
  if (p->pPrior) {
    pNext = (Select *)0;
    cnt = 0;
    pLoop = p;
    while (pLoop) {
      pLoop->pNext = pNext;
      pLoop->selFlags |= 256U;
      pNext = pLoop;
      pLoop = pLoop->pPrior;
      cnt ++;
    }
    if ((p->selFlags & 1024U) == 0U) {
      mxSelect = (pParse->db)->aLimit[4];
      if (mxSelect > 0) {
        if (cnt > mxSelect) {
          sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
        }
      }
    }
  }
  return;
}
}
static Expr *tokenExpr(Parse *pParse , int op , Token t ) 
{ 
  Expr *p ;
  void *tmp ;
  Expr *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = sqlite3DbMallocRawNN(pParse->db, (u64 )((sizeof(Expr ) + (unsigned long )t.n) + 1UL));
  p = (Expr *)tmp;
  if (p) {
    p->op = (u8 )op;
    p->affExpr = (char)0;
    p->flags = (u32 )8388608;
    p->iAgg = (i16 )-1;
    tmp___0 = (Expr *)0;
    p->pRight = tmp___0;
    p->pLeft = tmp___0;
    p->x.pList = (ExprList *)0;
    p->pAggInfo = (AggInfo *)0;
    p->y.pTab = (Table *)0;
    p->op2 = (u8 )0;
    p->iTable = 0;
    p->iColumn = (ynVar )0;
    p->u.zToken = (char *)(p + 1);
    memcpy((void * __restrict  )p->u.zToken, (void const   * __restrict  )t.z, (size_t )t.n);
    *(p->u.zToken + t.n) = (char)0;
    if ((int const   )sqlite3CtypeMap[(unsigned char )*(p->u.zToken + 0)] & 128) {
      sqlite3DequoteExpr(p);
    }
    p->nHeight = 1;
    if ((int )pParse->eParseMode >= 2) {
      tmp___1 = sqlite3RenameTokenMap(pParse, (void *)p, & t);
      return ((Expr *)tmp___1);
    }
  }
  return (p);
}
}
static void binaryToUnaryIfNull(Parse *pParse , Expr *pY , Expr *pA , int op ) 
{ 
  sqlite3 *db ;

  {
  db = pParse->db;
  if (pA) {
    if (pY) {
      if ((int )pY->op == 117) {
        if (! ((int )pParse->eParseMode >= 2)) {
          pA->op = (u8 )op;
          sqlite3ExprDelete(db, pA->pRight);
          pA->pRight = (Expr *)0;
        }
      }
    }
  }
  return;
}
}
static ExprList *parserAddExprIdListTerm(Parse *pParse , ExprList *pPrior , Token *pIdToken ,
                                         int hasCollate , int sortOrder ) 
{ 
  ExprList *p ;
  ExprList *tmp ;

  {
  tmp = sqlite3ExprListAppend(pParse, pPrior, (Expr *)0);
  p = tmp;
  if (hasCollate) {
    goto _L;
  } else
  if (sortOrder != -1) {
    _L: /* CIL Label */ 
    if ((int )(pParse->db)->init.busy == 0) {
      sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"", pIdToken->n,
                      pIdToken->z);
    }
  }
  sqlite3ExprListSetName(pParse, p, pIdToken, 1);
  return (p);
}
}
static unsigned short const   yy_action[1913]  = 
  {      (unsigned short const   )537,      (unsigned short const   )339,      (unsigned short const   )537,      (unsigned short const   )1241, 
        (unsigned short const   )1220,      (unsigned short const   )537,      (unsigned short const   )12,      (unsigned short const   )537, 
        (unsigned short const   )112,      (unsigned short const   )109,      (unsigned short const   )209,      (unsigned short const   )537, 
        (unsigned short const   )1241,      (unsigned short const   )537,      (unsigned short const   )1205,      (unsigned short const   )462, 
        (unsigned short const   )112,      (unsigned short const   )109,      (unsigned short const   )209,      (unsigned short const   )386, 
        (unsigned short const   )338,      (unsigned short const   )462,      (unsigned short const   )42,      (unsigned short const   )42, 
        (unsigned short const   )42,      (unsigned short const   )42,      (unsigned short const   )445,      (unsigned short const   )42, 
        (unsigned short const   )42,      (unsigned short const   )70,      (unsigned short const   )70,      (unsigned short const   )922, 
        (unsigned short const   )1208,      (unsigned short const   )70,      (unsigned short const   )70,      (unsigned short const   )70, 
        (unsigned short const   )70,      (unsigned short const   )1443,      (unsigned short const   )403,      (unsigned short const   )923, 
        (unsigned short const   )531,      (unsigned short const   )531,      (unsigned short const   )531,      (unsigned short const   )119, 
        (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )425,      (unsigned short const   )386, 
        (unsigned short const   )1498,      (unsigned short const   )542,      (unsigned short const   )2,      (unsigned short const   )1176, 
        (unsigned short const   )1442,      (unsigned short const   )519,      (unsigned short const   )141,      (unsigned short const   )1518, 
        (unsigned short const   )289,      (unsigned short const   )519,      (unsigned short const   )134,      (unsigned short const   )519, 
        (unsigned short const   )95,      (unsigned short const   )259,      (unsigned short const   )495,      (unsigned short const   )1215, 
        (unsigned short const   )189,      (unsigned short const   )1254,      (unsigned short const   )518,      (unsigned short const   )494, 
        (unsigned short const   )484,      (unsigned short const   )437,      (unsigned short const   )296,      (unsigned short const   )119, 
        (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )270,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )264,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )264,      (unsigned short const   )423,      (unsigned short const   )1479, 
        (unsigned short const   )352,      (unsigned short const   )1481,      (unsigned short const   )123,      (unsigned short const   )351, 
        (unsigned short const   )1479,      (unsigned short const   )508,      (unsigned short const   )1094,      (unsigned short const   )534, 
        (unsigned short const   )1034,      (unsigned short const   )534,      (unsigned short const   )1099,      (unsigned short const   )386, 
        (unsigned short const   )1099,      (unsigned short const   )239,      (unsigned short const   )206,      (unsigned short const   )112, 
        (unsigned short const   )109,      (unsigned short const   )209,      (unsigned short const   )96,      (unsigned short const   )1094, 
        (unsigned short const   )376,      (unsigned short const   )219,      (unsigned short const   )1094,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )480,      (unsigned short const   )119, 
        (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )353,      (unsigned short const   )422, 
        (unsigned short const   )1407,      (unsigned short const   )264,      (unsigned short const   )264,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418, 
        (unsigned short const   )883,      (unsigned short const   )121,      (unsigned short const   )416,      (unsigned short const   )416, 
        (unsigned short const   )416,      (unsigned short const   )882,      (unsigned short const   )534,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )212,      (unsigned short const   )415, 
        (unsigned short const   )414,      (unsigned short const   )386,      (unsigned short const   )443,      (unsigned short const   )383, 
        (unsigned short const   )382,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )111,      (unsigned short const   )177,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )112,      (unsigned short const   )109, 
        (unsigned short const   )209,      (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110, 
        (unsigned short const   )1148,      (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994, 
        (unsigned short const   )984,      (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )386,      (unsigned short const   )438,      (unsigned short const   )312,      (unsigned short const   )1163, 
        (unsigned short const   )1155,      (unsigned short const   )80,      (unsigned short const   )1155,      (unsigned short const   )1127, 
        (unsigned short const   )514,      (unsigned short const   )79,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113, 
        (unsigned short const   )418,      (unsigned short const   )514,      (unsigned short const   )428,      (unsigned short const   )418, 
        (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148, 
        (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984, 
        (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )428, 
        (unsigned short const   )427,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418, 
        (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )1127, 
        (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129,      (unsigned short const   )1094, 
        (unsigned short const   )258,      (unsigned short const   )258,      (unsigned short const   )192,      (unsigned short const   )386, 
        (unsigned short const   )408,      (unsigned short const   )371,      (unsigned short const   )1168,      (unsigned short const   )326, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )1094,      (unsigned short const   )534,      (unsigned short const   )374,      (unsigned short const   )1094, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )119, 
        (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )386,      (unsigned short const   )354, 
        (unsigned short const   )445,      (unsigned short const   )428,      (unsigned short const   )829,      (unsigned short const   )238, 
        (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129,      (unsigned short const   )515, 
        (unsigned short const   )1466,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418, 
        (unsigned short const   )1127,      (unsigned short const   )1467,      (unsigned short const   )119,      (unsigned short const   )120, 
        (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148,      (unsigned short const   )991, 
        (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984,      (unsigned short const   )117, 
        (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )1169,      (unsigned short const   )82,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )405,      (unsigned short const   )112, 
        (unsigned short const   )109,      (unsigned short const   )209,      (unsigned short const   )161,      (unsigned short const   )445, 
        (unsigned short const   )250,      (unsigned short const   )267,      (unsigned short const   )336,      (unsigned short const   )478, 
        (unsigned short const   )331,      (unsigned short const   )477,      (unsigned short const   )236,      (unsigned short const   )951, 
        (unsigned short const   )1127,      (unsigned short const   )386,      (unsigned short const   )888,      (unsigned short const   )1521, 
        (unsigned short const   )329,      (unsigned short const   )822,      (unsigned short const   )852,      (unsigned short const   )162, 
        (unsigned short const   )274,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )338,      (unsigned short const   )169,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113, 
        (unsigned short const   )418,      (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110, 
        (unsigned short const   )1148,      (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994, 
        (unsigned short const   )984,      (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )386,      (unsigned short const   )438,      (unsigned short const   )312,      (unsigned short const   )1502, 
        (unsigned short const   )1112,      (unsigned short const   )1176,      (unsigned short const   )161,      (unsigned short const   )288, 
        (unsigned short const   )528,      (unsigned short const   )311,      (unsigned short const   )289,      (unsigned short const   )883, 
        (unsigned short const   )134,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )882,      (unsigned short const   )537,      (unsigned short const   )143,      (unsigned short const   )1254, 
        (unsigned short const   )288,      (unsigned short const   )528,      (unsigned short const   )297,      (unsigned short const   )275, 
        (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148, 
        (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984, 
        (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )70, 
        (unsigned short const   )70,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418, 
        (unsigned short const   )264,      (unsigned short const   )264,      (unsigned short const   )12,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )395,      (unsigned short const   )1127,      (unsigned short const   )483, 
        (unsigned short const   )1473,      (unsigned short const   )1094,      (unsigned short const   )204,      (unsigned short const   )482, 
        (unsigned short const   )6,      (unsigned short const   )534,      (unsigned short const   )1258,      (unsigned short const   )386, 
        (unsigned short const   )534,      (unsigned short const   )1474,      (unsigned short const   )825,      (unsigned short const   )972, 
        (unsigned short const   )504,      (unsigned short const   )6,      (unsigned short const   )1094,      (unsigned short const   )500, 
        (unsigned short const   )95,      (unsigned short const   )1094,      (unsigned short const   )534,      (unsigned short const   )219, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )119, 
        (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )386,      (unsigned short const   )1339, 
        (unsigned short const   )971,      (unsigned short const   )422,      (unsigned short const   )956,      (unsigned short const   )1127, 
        (unsigned short const   )1128,      (unsigned short const   )1129,      (unsigned short const   )231,      (unsigned short const   )512, 
        (unsigned short const   )1473,      (unsigned short const   )475,      (unsigned short const   )472,      (unsigned short const   )471, 
        (unsigned short const   )6,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )825, 
        (unsigned short const   )962,      (unsigned short const   )298,      (unsigned short const   )503,      (unsigned short const   )470, 
        (unsigned short const   )961,      (unsigned short const   )452,      (unsigned short const   )119,      (unsigned short const   )120, 
        (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148,      (unsigned short const   )991, 
        (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984,      (unsigned short const   )117, 
        (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )395,      (unsigned short const   )537,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )202,      (unsigned short const   )961, 
        (unsigned short const   )961,      (unsigned short const   )963,      (unsigned short const   )231,      (unsigned short const   )971, 
        (unsigned short const   )1127,      (unsigned short const   )475,      (unsigned short const   )472,      (unsigned short const   )471, 
        (unsigned short const   )13,      (unsigned short const   )13,      (unsigned short const   )951,      (unsigned short const   )1127, 
        (unsigned short const   )834,      (unsigned short const   )386,      (unsigned short const   )1207,      (unsigned short const   )470, 
        (unsigned short const   )399,      (unsigned short const   )183,      (unsigned short const   )447,      (unsigned short const   )962, 
        (unsigned short const   )462,      (unsigned short const   )162,      (unsigned short const   )397,      (unsigned short const   )961, 
        (unsigned short const   )1246,      (unsigned short const   )1246,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113, 
        (unsigned short const   )418,      (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110, 
        (unsigned short const   )1148,      (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994, 
        (unsigned short const   )984,      (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )386,      (unsigned short const   )271,      (unsigned short const   )961,      (unsigned short const   )961, 
        (unsigned short const   )963,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )311,      (unsigned short const   )433,      (unsigned short const   )299,      (unsigned short const   )1406, 
        (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129,      (unsigned short const   )178, 
        (unsigned short const   )1471,      (unsigned short const   )138,      (unsigned short const   )162,      (unsigned short const   )32, 
        (unsigned short const   )6,      (unsigned short const   )1127,      (unsigned short const   )288,      (unsigned short const   )528, 
        (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148, 
        (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984, 
        (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )909, 
        (unsigned short const   )390,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418, 
        (unsigned short const   )1127,      (unsigned short const   )429,      (unsigned short const   )817,      (unsigned short const   )537, 
        (unsigned short const   )1127,      (unsigned short const   )265,      (unsigned short const   )265,      (unsigned short const   )981, 
        (unsigned short const   )981,      (unsigned short const   )992,      (unsigned short const   )995,      (unsigned short const   )324, 
        (unsigned short const   )1055,      (unsigned short const   )93,      (unsigned short const   )520,      (unsigned short const   )5, 
        (unsigned short const   )338,      (unsigned short const   )537,      (unsigned short const   )534,      (unsigned short const   )288, 
        (unsigned short const   )528,      (unsigned short const   )1522,      (unsigned short const   )1127,      (unsigned short const   )1128, 
        (unsigned short const   )1129,      (unsigned short const   )70,      (unsigned short const   )70,      (unsigned short const   )1056, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )70, 
        (unsigned short const   )70,      (unsigned short const   )1495,      (unsigned short const   )1057,      (unsigned short const   )537, 
        (unsigned short const   )98,      (unsigned short const   )1244,      (unsigned short const   )1244,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )908,      (unsigned short const   )371,      (unsigned short const   )1076, 
        (unsigned short const   )1127,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )817,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )534,      (unsigned short const   )519,      (unsigned short const   )140,      (unsigned short const   )863, 
        (unsigned short const   )386,      (unsigned short const   )13,      (unsigned short const   )13,      (unsigned short const   )456, 
        (unsigned short const   )192,      (unsigned short const   )193,      (unsigned short const   )521,      (unsigned short const   )453, 
        (unsigned short const   )319,      (unsigned short const   )864,      (unsigned short const   )322,      (unsigned short const   )284, 
        (unsigned short const   )365,      (unsigned short const   )430,      (unsigned short const   )985,      (unsigned short const   )402, 
        (unsigned short const   )379,      (unsigned short const   )1077,      (unsigned short const   )1548,      (unsigned short const   )101, 
        (unsigned short const   )386,      (unsigned short const   )1548,      (unsigned short const   )3,      (unsigned short const   )395, 
        (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148, 
        (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984, 
        (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )386, 
        (unsigned short const   )451,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )110,      (unsigned short const   )1148, 
        (unsigned short const   )1148,      (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984, 
        (unsigned short const   )984,      (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )1127, 
        (unsigned short const   )1354,      (unsigned short const   )1412,      (unsigned short const   )1169,      (unsigned short const   )119, 
        (unsigned short const   )108,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )1412,      (unsigned short const   )1414, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )272, 
        (unsigned short const   )535,      (unsigned short const   )1075,      (unsigned short const   )877,      (unsigned short const   )877, 
        (unsigned short const   )337,      (unsigned short const   )1492,      (unsigned short const   )309,      (unsigned short const   )462, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )115,      (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )114,      (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )537, 
        (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129,      (unsigned short const   )537, 
        (unsigned short const   )360,      (unsigned short const   )537,      (unsigned short const   )356,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )386,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )13,      (unsigned short const   )13,      (unsigned short const   )273, 
        (unsigned short const   )1127,      (unsigned short const   )13,      (unsigned short const   )13,      (unsigned short const   )13, 
        (unsigned short const   )13,      (unsigned short const   )304,      (unsigned short const   )1253,      (unsigned short const   )386, 
        (unsigned short const   )534,      (unsigned short const   )1077,      (unsigned short const   )1549,      (unsigned short const   )404, 
        (unsigned short const   )1412,      (unsigned short const   )1549,      (unsigned short const   )496,      (unsigned short const   )277, 
        (unsigned short const   )451,      (unsigned short const   )186,      (unsigned short const   )1252,      (unsigned short const   )120, 
        (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148,      (unsigned short const   )991, 
        (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984,      (unsigned short const   )117, 
        (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )110,      (unsigned short const   )1148,      (unsigned short const   )1148, 
        (unsigned short const   )991,      (unsigned short const   )994,      (unsigned short const   )984,      (unsigned short const   )984, 
        (unsigned short const   )117,      (unsigned short const   )117,      (unsigned short const   )118,      (unsigned short const   )118, 
        (unsigned short const   )118,      (unsigned short const   )118,      (unsigned short const   )105,      (unsigned short const   )529, 
        (unsigned short const   )537,      (unsigned short const   )4,      (unsigned short const   )1339,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )1039,      (unsigned short const   )1039,      (unsigned short const   )459,      (unsigned short const   )795, 
        (unsigned short const   )796,      (unsigned short const   )797,      (unsigned short const   )536,      (unsigned short const   )532, 
        (unsigned short const   )534,      (unsigned short const   )242,      (unsigned short const   )301,      (unsigned short const   )807, 
        (unsigned short const   )303,      (unsigned short const   )462,      (unsigned short const   )69,      (unsigned short const   )69, 
        (unsigned short const   )451,      (unsigned short const   )1353,      (unsigned short const   )116,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115,      (unsigned short const   )115, 
        (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )113, 
        (unsigned short const   )418,      (unsigned short const   )1075,      (unsigned short const   )419,      (unsigned short const   )116, 
        (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )116,      (unsigned short const   )115, 
        (unsigned short const   )115,      (unsigned short const   )114,      (unsigned short const   )114,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )418,      (unsigned short const   )526,      (unsigned short const   )537, 
        (unsigned short const   )1146,      (unsigned short const   )192,      (unsigned short const   )350,      (unsigned short const   )105, 
        (unsigned short const   )529,      (unsigned short const   )537,      (unsigned short const   )4,      (unsigned short const   )497, 
        (unsigned short const   )162,      (unsigned short const   )337,      (unsigned short const   )1492,      (unsigned short const   )310, 
        (unsigned short const   )1249,      (unsigned short const   )385,      (unsigned short const   )1550,      (unsigned short const   )372, 
        (unsigned short const   )9,      (unsigned short const   )462,      (unsigned short const   )242,      (unsigned short const   )400, 
        (unsigned short const   )532,      (unsigned short const   )13,      (unsigned short const   )13,      (unsigned short const   )499, 
        (unsigned short const   )971,      (unsigned short const   )843,      (unsigned short const   )436,      (unsigned short const   )70, 
        (unsigned short const   )70,      (unsigned short const   )359,      (unsigned short const   )103,      (unsigned short const   )103, 
        (unsigned short const   )8,      (unsigned short const   )339,      (unsigned short const   )278,      (unsigned short const   )187, 
        (unsigned short const   )278,      (unsigned short const   )104,      (unsigned short const   )1127,      (unsigned short const   )419, 
        (unsigned short const   )539,      (unsigned short const   )538,      (unsigned short const   )1339,      (unsigned short const   )419, 
        (unsigned short const   )961,      (unsigned short const   )302,      (unsigned short const   )1339,      (unsigned short const   )1172, 
        (unsigned short const   )1,      (unsigned short const   )1,      (unsigned short const   )542,      (unsigned short const   )2, 
        (unsigned short const   )1176,      (unsigned short const   )1146,      (unsigned short const   )1146,      (unsigned short const   )526, 
        (unsigned short const   )476,      (unsigned short const   )289,      (unsigned short const   )30,      (unsigned short const   )134, 
        (unsigned short const   )317,      (unsigned short const   )288,      (unsigned short const   )528,      (unsigned short const   )285, 
        (unsigned short const   )844,      (unsigned short const   )1014,      (unsigned short const   )1254,      (unsigned short const   )276, 
        (unsigned short const   )1472,      (unsigned short const   )506,      (unsigned short const   )410,      (unsigned short const   )1194, 
        (unsigned short const   )6,      (unsigned short const   )207,      (unsigned short const   )505,      (unsigned short const   )961, 
        (unsigned short const   )961,      (unsigned short const   )963,      (unsigned short const   )964,      (unsigned short const   )27, 
        (unsigned short const   )449,      (unsigned short const   )971,      (unsigned short const   )415,      (unsigned short const   )414, 
        (unsigned short const   )234,      (unsigned short const   )233,      (unsigned short const   )232,      (unsigned short const   )103, 
        (unsigned short const   )103,      (unsigned short const   )31,      (unsigned short const   )1152,      (unsigned short const   )1127, 
        (unsigned short const   )1128,      (unsigned short const   )1129,      (unsigned short const   )104,      (unsigned short const   )1154, 
        (unsigned short const   )419,      (unsigned short const   )539,      (unsigned short const   )538,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )961,      (unsigned short const   )1399,      (unsigned short const   )1153, 
        (unsigned short const   )264,      (unsigned short const   )264,      (unsigned short const   )1470,      (unsigned short const   )1146, 
        (unsigned short const   )537,      (unsigned short const   )216,      (unsigned short const   )6,      (unsigned short const   )401, 
        (unsigned short const   )534,      (unsigned short const   )1197,      (unsigned short const   )392,      (unsigned short const   )458, 
        (unsigned short const   )406,      (unsigned short const   )534,      (unsigned short const   )537,      (unsigned short const   )485, 
        (unsigned short const   )358,      (unsigned short const   )537,      (unsigned short const   )261,      (unsigned short const   )537, 
        (unsigned short const   )1339,      (unsigned short const   )907,      (unsigned short const   )219,      (unsigned short const   )1155, 
        (unsigned short const   )467,      (unsigned short const   )1155,      (unsigned short const   )50,      (unsigned short const   )50, 
        (unsigned short const   )961,      (unsigned short const   )961,      (unsigned short const   )963,      (unsigned short const   )964, 
        (unsigned short const   )27,      (unsigned short const   )1497,      (unsigned short const   )1116,      (unsigned short const   )421, 
        (unsigned short const   )70,      (unsigned short const   )70,      (unsigned short const   )268,      (unsigned short const   )70, 
        (unsigned short const   )70,      (unsigned short const   )13,      (unsigned short const   )13,      (unsigned short const   )369, 
        (unsigned short const   )369,      (unsigned short const   )368,      (unsigned short const   )253,      (unsigned short const   )366, 
        (unsigned short const   )264,      (unsigned short const   )264,      (unsigned short const   )804,      (unsigned short const   )235, 
        (unsigned short const   )422,      (unsigned short const   )105,      (unsigned short const   )529,      (unsigned short const   )516, 
        (unsigned short const   )4,      (unsigned short const   )287,      (unsigned short const   )487,      (unsigned short const   )510, 
        (unsigned short const   )493,      (unsigned short const   )534,      (unsigned short const   )486,      (unsigned short const   )213, 
        (unsigned short const   )1055,      (unsigned short const   )294,      (unsigned short const   )490,      (unsigned short const   )384, 
        (unsigned short const   )1127,      (unsigned short const   )450,      (unsigned short const   )532,      (unsigned short const   )338, 
        (unsigned short const   )413,      (unsigned short const   )293,      (unsigned short const   )522,      (unsigned short const   )417, 
        (unsigned short const   )335,      (unsigned short const   )1036,      (unsigned short const   )509,      (unsigned short const   )1056, 
        (unsigned short const   )107,      (unsigned short const   )1036,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )1469,      (unsigned short const   )1094,      (unsigned short const   )334,      (unsigned short const   )1105, 
        (unsigned short const   )6,      (unsigned short const   )411,      (unsigned short const   )1145,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )419,      (unsigned short const   )1057,      (unsigned short const   )102, 
        (unsigned short const   )511,      (unsigned short const   )100,      (unsigned short const   )1094,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )1094,      (unsigned short const   )922,      (unsigned short const   )215, 
        (unsigned short const   )534,      (unsigned short const   )526,      (unsigned short const   )907,      (unsigned short const   )264, 
        (unsigned short const   )264,      (unsigned short const   )208,      (unsigned short const   )923,      (unsigned short const   )154, 
        (unsigned short const   )534,      (unsigned short const   )457,      (unsigned short const   )156,      (unsigned short const   )525, 
        (unsigned short const   )391,      (unsigned short const   )142,      (unsigned short const   )218,      (unsigned short const   )506, 
        (unsigned short const   )534,      (unsigned short const   )1127,      (unsigned short const   )1128,      (unsigned short const   )1129, 
        (unsigned short const   )507,      (unsigned short const   )139,      (unsigned short const   )1131,      (unsigned short const   )38, 
        (unsigned short const   )214,      (unsigned short const   )530,      (unsigned short const   )392,      (unsigned short const   )971, 
        (unsigned short const   )329,      (unsigned short const   )1454,      (unsigned short const   )907,      (unsigned short const   )1105, 
        (unsigned short const   )537,      (unsigned short const   )103,      (unsigned short const   )103,      (unsigned short const   )105, 
        (unsigned short const   )529,      (unsigned short const   )537,      (unsigned short const   )4,      (unsigned short const   )537, 
        (unsigned short const   )104,      (unsigned short const   )424,      (unsigned short const   )419,      (unsigned short const   )539, 
        (unsigned short const   )538,      (unsigned short const   )537,      (unsigned short const   )502,      (unsigned short const   )961, 
        (unsigned short const   )517,      (unsigned short const   )537,      (unsigned short const   )1072,      (unsigned short const   )537, 
        (unsigned short const   )532,      (unsigned short const   )373,      (unsigned short const   )54,      (unsigned short const   )54, 
        (unsigned short const   )288,      (unsigned short const   )528,      (unsigned short const   )387,      (unsigned short const   )55, 
        (unsigned short const   )55,      (unsigned short const   )15,      (unsigned short const   )15,      (unsigned short const   )288, 
        (unsigned short const   )528,      (unsigned short const   )17,      (unsigned short const   )136,      (unsigned short const   )44, 
        (unsigned short const   )44,      (unsigned short const   )1451,      (unsigned short const   )537,      (unsigned short const   )56, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )57,      (unsigned short const   )419, 
        (unsigned short const   )1131,      (unsigned short const   )291,      (unsigned short const   )961,      (unsigned short const   )961, 
        (unsigned short const   )963,      (unsigned short const   )964,      (unsigned short const   )27,      (unsigned short const   )393, 
        (unsigned short const   )163,      (unsigned short const   )537,      (unsigned short const   )426,      (unsigned short const   )526, 
        (unsigned short const   )263,      (unsigned short const   )206,      (unsigned short const   )208,      (unsigned short const   )517, 
        (unsigned short const   )58,      (unsigned short const   )58,      (unsigned short const   )235,      (unsigned short const   )440, 
        (unsigned short const   )842,      (unsigned short const   )841,      (unsigned short const   )197,      (unsigned short const   )105, 
        (unsigned short const   )529,      (unsigned short const   )506,      (unsigned short const   )4,      (unsigned short const   )1033, 
        (unsigned short const   )439,      (unsigned short const   )1033,      (unsigned short const   )505,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )308,      (unsigned short const   )849,      (unsigned short const   )850, 
        (unsigned short const   )95,      (unsigned short const   )971,      (unsigned short const   )537,      (unsigned short const   )907, 
        (unsigned short const   )532,      (unsigned short const   )948,      (unsigned short const   )832,      (unsigned short const   )103, 
        (unsigned short const   )103,      (unsigned short const   )105,      (unsigned short const   )529,      (unsigned short const   )537, 
        (unsigned short const   )4,      (unsigned short const   )1021,      (unsigned short const   )104,      (unsigned short const   )537, 
        (unsigned short const   )419,      (unsigned short const   )539,      (unsigned short const   )538,      (unsigned short const   )1116, 
        (unsigned short const   )421,      (unsigned short const   )961,      (unsigned short const   )537,      (unsigned short const   )268, 
        (unsigned short const   )60,      (unsigned short const   )60,      (unsigned short const   )532,      (unsigned short const   )419, 
        (unsigned short const   )369,      (unsigned short const   )369,      (unsigned short const   )368,      (unsigned short const   )253, 
        (unsigned short const   )366,      (unsigned short const   )61,      (unsigned short const   )61,      (unsigned short const   )804, 
        (unsigned short const   )965,      (unsigned short const   )45,      (unsigned short const   )45,      (unsigned short const   )526, 
        (unsigned short const   )537,      (unsigned short const   )1032,      (unsigned short const   )1277,      (unsigned short const   )1032, 
        (unsigned short const   )46,      (unsigned short const   )46,      (unsigned short const   )537,      (unsigned short const   )391, 
        (unsigned short const   )213,      (unsigned short const   )419,      (unsigned short const   )294,      (unsigned short const   )266, 
        (unsigned short const   )961,      (unsigned short const   )961,      (unsigned short const   )963,      (unsigned short const   )964, 
        (unsigned short const   )27,      (unsigned short const   )292,      (unsigned short const   )293,      (unsigned short const   )295, 
        (unsigned short const   )832,      (unsigned short const   )526,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )1290,      (unsigned short const   )971,      (unsigned short const   )1289,      (unsigned short const   )1021, 
        (unsigned short const   )49,      (unsigned short const   )49,      (unsigned short const   )432,      (unsigned short const   )103, 
        (unsigned short const   )103,      (unsigned short const   )887,      (unsigned short const   )953,      (unsigned short const   )537, 
        (unsigned short const   )1457,      (unsigned short const   )241,      (unsigned short const   )104,      (unsigned short const   )305, 
        (unsigned short const   )419,      (unsigned short const   )539,      (unsigned short const   )538,      (unsigned short const   )925, 
        (unsigned short const   )926,      (unsigned short const   )961,      (unsigned short const   )444,      (unsigned short const   )971, 
        (unsigned short const   )215,      (unsigned short const   )241,      (unsigned short const   )965,      (unsigned short const   )1224, 
        (unsigned short const   )537,      (unsigned short const   )103,      (unsigned short const   )103,      (unsigned short const   )1431, 
        (unsigned short const   )154,      (unsigned short const   )62,      (unsigned short const   )62,      (unsigned short const   )156, 
        (unsigned short const   )104,      (unsigned short const   )1430,      (unsigned short const   )419,      (unsigned short const   )539, 
        (unsigned short const   )538,      (unsigned short const   )97,      (unsigned short const   )529,      (unsigned short const   )961, 
        (unsigned short const   )4,      (unsigned short const   )537,      (unsigned short const   )454,      (unsigned short const   )537, 
        (unsigned short const   )314,      (unsigned short const   )214,      (unsigned short const   )63,      (unsigned short const   )63, 
        (unsigned short const   )961,      (unsigned short const   )961,      (unsigned short const   )963,      (unsigned short const   )964, 
        (unsigned short const   )27,      (unsigned short const   )537,      (unsigned short const   )532,      (unsigned short const   )446, 
        (unsigned short const   )1286,      (unsigned short const   )318,      (unsigned short const   )241,      (unsigned short const   )537, 
        (unsigned short const   )321,      (unsigned short const   )323,      (unsigned short const   )325,      (unsigned short const   )64, 
        (unsigned short const   )64,      (unsigned short const   )14,      (unsigned short const   )14,      (unsigned short const   )1237, 
        (unsigned short const   )537,      (unsigned short const   )1223,      (unsigned short const   )961,      (unsigned short const   )961, 
        (unsigned short const   )963,      (unsigned short const   )964,      (unsigned short const   )27,      (unsigned short const   )65, 
        (unsigned short const   )65,      (unsigned short const   )419,      (unsigned short const   )537,      (unsigned short const   )387, 
        (unsigned short const   )537,      (unsigned short const   )125,      (unsigned short const   )125,      (unsigned short const   )537, 
        (unsigned short const   )288,      (unsigned short const   )528,      (unsigned short const   )537,      (unsigned short const   )1486, 
        (unsigned short const   )537,      (unsigned short const   )526,      (unsigned short const   )66,      (unsigned short const   )66, 
        (unsigned short const   )313,      (unsigned short const   )524,      (unsigned short const   )537,      (unsigned short const   )95, 
        (unsigned short const   )468,      (unsigned short const   )1221,      (unsigned short const   )1511,      (unsigned short const   )237, 
        (unsigned short const   )51,      (unsigned short const   )51,      (unsigned short const   )67,      (unsigned short const   )67, 
        (unsigned short const   )330,      (unsigned short const   )68,      (unsigned short const   )68,      (unsigned short const   )426, 
        (unsigned short const   )52,      (unsigned short const   )52,      (unsigned short const   )149,      (unsigned short const   )149, 
        (unsigned short const   )1222,      (unsigned short const   )340,      (unsigned short const   )341,      (unsigned short const   )971, 
        (unsigned short const   )150,      (unsigned short const   )150,      (unsigned short const   )1298,      (unsigned short const   )463, 
        (unsigned short const   )327,      (unsigned short const   )103,      (unsigned short const   )103,      (unsigned short const   )95, 
        (unsigned short const   )537,      (unsigned short const   )1338,      (unsigned short const   )1273,      (unsigned short const   )537, 
        (unsigned short const   )104,      (unsigned short const   )537,      (unsigned short const   )419,      (unsigned short const   )539, 
        (unsigned short const   )538,      (unsigned short const   )1284,      (unsigned short const   )537,      (unsigned short const   )961, 
        (unsigned short const   )268,      (unsigned short const   )283,      (unsigned short const   )523,      (unsigned short const   )1344, 
        (unsigned short const   )1204,      (unsigned short const   )369,      (unsigned short const   )369,      (unsigned short const   )368, 
        (unsigned short const   )253,      (unsigned short const   )366,      (unsigned short const   )75,      (unsigned short const   )75, 
        (unsigned short const   )804,      (unsigned short const   )53,      (unsigned short const   )53,      (unsigned short const   )71, 
        (unsigned short const   )71,      (unsigned short const   )537,      (unsigned short const   )1196,      (unsigned short const   )537, 
        (unsigned short const   )126,      (unsigned short const   )126,      (unsigned short const   )537,      (unsigned short const   )1017, 
        (unsigned short const   )537,      (unsigned short const   )213,      (unsigned short const   )237,      (unsigned short const   )294, 
        (unsigned short const   )537,      (unsigned short const   )1185,      (unsigned short const   )961,      (unsigned short const   )961, 
        (unsigned short const   )963,      (unsigned short const   )964,      (unsigned short const   )27,      (unsigned short const   )293, 
        (unsigned short const   )537,      (unsigned short const   )1184,      (unsigned short const   )537,      (unsigned short const   )72, 
        (unsigned short const   )72,      (unsigned short const   )127,      (unsigned short const   )127,      (unsigned short const   )1186, 
        (unsigned short const   )128,      (unsigned short const   )128,      (unsigned short const   )124,      (unsigned short const   )124, 
        (unsigned short const   )1505,      (unsigned short const   )537,      (unsigned short const   )148,      (unsigned short const   )148, 
        (unsigned short const   )537,      (unsigned short const   )256,      (unsigned short const   )195,      (unsigned short const   )537, 
        (unsigned short const   )1270,      (unsigned short const   )537,      (unsigned short const   )147,      (unsigned short const   )147, 
        (unsigned short const   )132,      (unsigned short const   )132,      (unsigned short const   )537,      (unsigned short const   )11, 
        (unsigned short const   )537,      (unsigned short const   )215,      (unsigned short const   )537,      (unsigned short const   )199, 
        (unsigned short const   )343,      (unsigned short const   )345,      (unsigned short const   )347,      (unsigned short const   )131, 
        (unsigned short const   )131,      (unsigned short const   )154,      (unsigned short const   )129,      (unsigned short const   )129, 
        (unsigned short const   )156,      (unsigned short const   )130,      (unsigned short const   )130,      (unsigned short const   )74, 
        (unsigned short const   )74,      (unsigned short const   )537,      (unsigned short const   )370,      (unsigned short const   )1323, 
        (unsigned short const   )76,      (unsigned short const   )76,      (unsigned short const   )73,      (unsigned short const   )73, 
        (unsigned short const   )43,      (unsigned short const   )43,      (unsigned short const   )214,      (unsigned short const   )431, 
        (unsigned short const   )211,      (unsigned short const   )1331,      (unsigned short const   )300,      (unsigned short const   )916, 
        (unsigned short const   )880,      (unsigned short const   )815,      (unsigned short const   )241,      (unsigned short const   )107, 
        (unsigned short const   )137,      (unsigned short const   )307,      (unsigned short const   )881,      (unsigned short const   )47, 
        (unsigned short const   )47,      (unsigned short const   )107,      (unsigned short const   )473,      (unsigned short const   )378, 
        (unsigned short const   )203,      (unsigned short const   )448,      (unsigned short const   )333,      (unsigned short const   )1403, 
        (unsigned short const   )1220,      (unsigned short const   )1402,      (unsigned short const   )349,      (unsigned short const   )190, 
        (unsigned short const   )527,      (unsigned short const   )191,      (unsigned short const   )363,      (unsigned short const   )198, 
        (unsigned short const   )1508,      (unsigned short const   )1163,      (unsigned short const   )245,      (unsigned short const   )165, 
        (unsigned short const   )387,      (unsigned short const   )1450,      (unsigned short const   )1448,      (unsigned short const   )1160, 
        (unsigned short const   )78,      (unsigned short const   )288,      (unsigned short const   )528,      (unsigned short const   )1408, 
        (unsigned short const   )81,      (unsigned short const   )394,      (unsigned short const   )82,      (unsigned short const   )442, 
        (unsigned short const   )175,      (unsigned short const   )159,      (unsigned short const   )167,      (unsigned short const   )93, 
        (unsigned short const   )1328,      (unsigned short const   )35,      (unsigned short const   )1320,      (unsigned short const   )434, 
        (unsigned short const   )170,      (unsigned short const   )171,      (unsigned short const   )172,      (unsigned short const   )173, 
        (unsigned short const   )435,      (unsigned short const   )466,      (unsigned short const   )221,      (unsigned short const   )375, 
        (unsigned short const   )426,      (unsigned short const   )377,      (unsigned short const   )1334,      (unsigned short const   )179, 
        (unsigned short const   )455,      (unsigned short const   )441,      (unsigned short const   )1397,      (unsigned short const   )225, 
        (unsigned short const   )87,      (unsigned short const   )36,      (unsigned short const   )461,      (unsigned short const   )1419, 
        (unsigned short const   )316,      (unsigned short const   )257,      (unsigned short const   )227,      (unsigned short const   )184, 
        (unsigned short const   )320,      (unsigned short const   )464,      (unsigned short const   )228,      (unsigned short const   )479, 
        (unsigned short const   )1187,      (unsigned short const   )229,      (unsigned short const   )380,      (unsigned short const   )1240, 
        (unsigned short const   )1239,      (unsigned short const   )407,      (unsigned short const   )1238,      (unsigned short const   )1212, 
        (unsigned short const   )834,      (unsigned short const   )332,      (unsigned short const   )1231,      (unsigned short const   )381, 
        (unsigned short const   )409,      (unsigned short const   )1211,      (unsigned short const   )204,      (unsigned short const   )1210, 
        (unsigned short const   )1491,      (unsigned short const   )498,      (unsigned short const   )1520,      (unsigned short const   )1281, 
        (unsigned short const   )92,      (unsigned short const   )281,      (unsigned short const   )1230,      (unsigned short const   )489, 
        (unsigned short const   )282,      (unsigned short const   )492,      (unsigned short const   )342,      (unsigned short const   )243, 
        (unsigned short const   )1282,      (unsigned short const   )344,      (unsigned short const   )244,      (unsigned short const   )1280, 
        (unsigned short const   )346,      (unsigned short const   )412,      (unsigned short const   )1279,      (unsigned short const   )1477, 
        (unsigned short const   )348,      (unsigned short const   )122,      (unsigned short const   )1476,      (unsigned short const   )517, 
        (unsigned short const   )10,      (unsigned short const   )357,      (unsigned short const   )286,      (unsigned short const   )1305, 
        (unsigned short const   )1304,      (unsigned short const   )99,      (unsigned short const   )1383,      (unsigned short const   )94, 
        (unsigned short const   )501,      (unsigned short const   )251,      (unsigned short const   )1193,      (unsigned short const   )34, 
        (unsigned short const   )1263,      (unsigned short const   )355,      (unsigned short const   )540,      (unsigned short const   )194, 
        (unsigned short const   )1262,      (unsigned short const   )361,      (unsigned short const   )362,      (unsigned short const   )1122, 
        (unsigned short const   )252,      (unsigned short const   )254,      (unsigned short const   )255,      (unsigned short const   )388, 
        (unsigned short const   )541,      (unsigned short const   )1182,      (unsigned short const   )1177,      (unsigned short const   )151, 
        (unsigned short const   )1435,      (unsigned short const   )389,      (unsigned short const   )1436,      (unsigned short const   )1434, 
        (unsigned short const   )1433,      (unsigned short const   )791,      (unsigned short const   )152,      (unsigned short const   )135, 
        (unsigned short const   )279,      (unsigned short const   )200,      (unsigned short const   )201,      (unsigned short const   )420, 
        (unsigned short const   )196,      (unsigned short const   )77,      (unsigned short const   )153,      (unsigned short const   )290, 
        (unsigned short const   )269,      (unsigned short const   )210,      (unsigned short const   )1031,      (unsigned short const   )133, 
        (unsigned short const   )1029,      (unsigned short const   )945,      (unsigned short const   )166,      (unsigned short const   )155, 
        (unsigned short const   )217,      (unsigned short const   )168,      (unsigned short const   )866,      (unsigned short const   )306, 
        (unsigned short const   )220,      (unsigned short const   )1045,      (unsigned short const   )174,      (unsigned short const   )949, 
        (unsigned short const   )157,      (unsigned short const   )396,      (unsigned short const   )83,      (unsigned short const   )398, 
        (unsigned short const   )176,      (unsigned short const   )84,      (unsigned short const   )85,      (unsigned short const   )164, 
        (unsigned short const   )86,      (unsigned short const   )158,      (unsigned short const   )1048,      (unsigned short const   )222, 
        (unsigned short const   )223,      (unsigned short const   )1044,      (unsigned short const   )144,      (unsigned short const   )18, 
        (unsigned short const   )224,      (unsigned short const   )315,      (unsigned short const   )1037,      (unsigned short const   )180, 
        (unsigned short const   )241,      (unsigned short const   )460,      (unsigned short const   )1157,      (unsigned short const   )226, 
        (unsigned short const   )181,      (unsigned short const   )37,      (unsigned short const   )806,      (unsigned short const   )465, 
        (unsigned short const   )334,      (unsigned short const   )230,      (unsigned short const   )328,      (unsigned short const   )469, 
        (unsigned short const   )182,      (unsigned short const   )88,      (unsigned short const   )474,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )160,      (unsigned short const   )89,      (unsigned short const   )280, 
        (unsigned short const   )145,      (unsigned short const   )90,      (unsigned short const   )481,      (unsigned short const   )845, 
        (unsigned short const   )1110,      (unsigned short const   )146,      (unsigned short const   )997,      (unsigned short const   )205, 
        (unsigned short const   )1080,      (unsigned short const   )39,      (unsigned short const   )91,      (unsigned short const   )40, 
        (unsigned short const   )488,      (unsigned short const   )1081,      (unsigned short const   )915,      (unsigned short const   )491, 
        (unsigned short const   )260,      (unsigned short const   )262,      (unsigned short const   )185,      (unsigned short const   )910, 
        (unsigned short const   )240,      (unsigned short const   )107,      (unsigned short const   )1100,      (unsigned short const   )1096, 
        (unsigned short const   )1098,      (unsigned short const   )1104,      (unsigned short const   )21,      (unsigned short const   )1084, 
        (unsigned short const   )33,      (unsigned short const   )513,      (unsigned short const   )247,      (unsigned short const   )22, 
        (unsigned short const   )23,      (unsigned short const   )24,      (unsigned short const   )1103,      (unsigned short const   )25, 
        (unsigned short const   )188,      (unsigned short const   )95,      (unsigned short const   )1012,      (unsigned short const   )998, 
        (unsigned short const   )996,      (unsigned short const   )26,      (unsigned short const   )1000,      (unsigned short const   )1054, 
        (unsigned short const   )7,      (unsigned short const   )1053,      (unsigned short const   )1001,      (unsigned short const   )246, 
        (unsigned short const   )28,      (unsigned short const   )41,      (unsigned short const   )533,      (unsigned short const   )966, 
        (unsigned short const   )816,      (unsigned short const   )106,      (unsigned short const   )29,      (unsigned short const   )367, 
        (unsigned short const   )248,      (unsigned short const   )249,      (unsigned short const   )1513,      (unsigned short const   )1512, 
        (unsigned short const   )364,      (unsigned short const   )1117,      (unsigned short const   )1173,      (unsigned short const   )1173, 
        (unsigned short const   )876};
static unsigned short const   yy_lookahead[2092]  = 
  {      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )216, 
        (unsigned short const   )217,      (unsigned short const   )187,      (unsigned short const   )206,      (unsigned short const   )187, 
        (unsigned short const   )264,      (unsigned short const   )265,      (unsigned short const   )266,      (unsigned short const   )187, 
        (unsigned short const   )225,      (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )187, 
        (unsigned short const   )264,      (unsigned short const   )265,      (unsigned short const   )266,      (unsigned short const   )19, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )31, 
        (unsigned short const   )209,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )285,      (unsigned short const   )224,      (unsigned short const   )39, 
        (unsigned short const   )203,      (unsigned short const   )204,      (unsigned short const   )205,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )230,      (unsigned short const   )19, 
        (unsigned short const   )181,      (unsigned short const   )182,      (unsigned short const   )183,      (unsigned short const   )184, 
        (unsigned short const   )230,      (unsigned short const   )245,      (unsigned short const   )233,      (unsigned short const   )208, 
        (unsigned short const   )189,      (unsigned short const   )245,      (unsigned short const   )191,      (unsigned short const   )245, 
        (unsigned short const   )26,      (unsigned short const   )206,      (unsigned short const   )254,      (unsigned short const   )216, 
        (unsigned short const   )276,      (unsigned short const   )198,      (unsigned short const   )254,      (unsigned short const   )198, 
        (unsigned short const   )254,      (unsigned short const   )281,      (unsigned short const   )187,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )259,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )231,      (unsigned short const   )232, 
        (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )286,      (unsigned short const   )302, 
        (unsigned short const   )303,      (unsigned short const   )302,      (unsigned short const   )22,      (unsigned short const   )304, 
        (unsigned short const   )302,      (unsigned short const   )303,      (unsigned short const   )76,      (unsigned short const   )244, 
        (unsigned short const   )11,      (unsigned short const   )244,      (unsigned short const   )86,      (unsigned short const   )19, 
        (unsigned short const   )88,      (unsigned short const   )248,      (unsigned short const   )249,      (unsigned short const   )264, 
        (unsigned short const   )265,      (unsigned short const   )266,      (unsigned short const   )26,      (unsigned short const   )89, 
        (unsigned short const   )198,      (unsigned short const   )258,      (unsigned short const   )92,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )105,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )212,      (unsigned short const   )288, 
        (unsigned short const   )273,      (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )105, 
        (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109, 
        (unsigned short const   )131,      (unsigned short const   )69,      (unsigned short const   )203,      (unsigned short const   )204, 
        (unsigned short const   )205,      (unsigned short const   )136,      (unsigned short const   )244,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )15,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )19,      (unsigned short const   )260,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56, 
        (unsigned short const   )57,      (unsigned short const   )58,      (unsigned short const   )22,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )264,      (unsigned short const   )265, 
        (unsigned short const   )266,      (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45, 
        (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49, 
        (unsigned short const   )50,      (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53, 
        (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57, 
        (unsigned short const   )19,      (unsigned short const   )124,      (unsigned short const   )125,      (unsigned short const   )60, 
        (unsigned short const   )148,      (unsigned short const   )24,      (unsigned short const   )150,      (unsigned short const   )59, 
        (unsigned short const   )187,      (unsigned short const   )67,      (unsigned short const   )99,      (unsigned short const   )100, 
        (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104, 
        (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108, 
        (unsigned short const   )109,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )109, 
        (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46, 
        (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50, 
        (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54, 
        (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )204, 
        (unsigned short const   )205,      (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101, 
        (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105, 
        (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109, 
        (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106, 
        (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )59, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )76, 
        (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )187,      (unsigned short const   )19, 
        (unsigned short const   )19,      (unsigned short const   )22,      (unsigned short const   )23,      (unsigned short const   )23, 
        (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57, 
        (unsigned short const   )89,      (unsigned short const   )244,      (unsigned short const   )199,      (unsigned short const   )92, 
        (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102, 
        (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106, 
        (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )19,      (unsigned short const   )212, 
        (unsigned short const   )187,      (unsigned short const   )274,      (unsigned short const   )23,      (unsigned short const   )26, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )294, 
        (unsigned short const   )295,      (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101, 
        (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105, 
        (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109, 
        (unsigned short const   )59,      (unsigned short const   )295,      (unsigned short const   )43,      (unsigned short const   )44, 
        (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48, 
        (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51,      (unsigned short const   )52, 
        (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56, 
        (unsigned short const   )57,      (unsigned short const   )98,      (unsigned short const   )146,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )109,      (unsigned short const   )264, 
        (unsigned short const   )265,      (unsigned short const   )266,      (unsigned short const   )187,      (unsigned short const   )187, 
        (unsigned short const   )115,      (unsigned short const   )116,      (unsigned short const   )117,      (unsigned short const   )118, 
        (unsigned short const   )119,      (unsigned short const   )120,      (unsigned short const   )121,      (unsigned short const   )73, 
        (unsigned short const   )59,      (unsigned short const   )19,      (unsigned short const   )105,      (unsigned short const   )23, 
        (unsigned short const   )127,      (unsigned short const   )23,      (unsigned short const   )26,      (unsigned short const   )81, 
        (unsigned short const   )259,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )187,      (unsigned short const   )72,      (unsigned short const   )99,      (unsigned short const   )100, 
        (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104, 
        (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108, 
        (unsigned short const   )109,      (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45, 
        (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49, 
        (unsigned short const   )50,      (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53, 
        (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57, 
        (unsigned short const   )19,      (unsigned short const   )124,      (unsigned short const   )125,      (unsigned short const   )182, 
        (unsigned short const   )23,      (unsigned short const   )184,      (unsigned short const   )187,      (unsigned short const   )134, 
        (unsigned short const   )135,      (unsigned short const   )123,      (unsigned short const   )189,      (unsigned short const   )131, 
        (unsigned short const   )191,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )136,      (unsigned short const   )187,      (unsigned short const   )233,      (unsigned short const   )198, 
        (unsigned short const   )134,      (unsigned short const   )135,      (unsigned short const   )198,      (unsigned short const   )259, 
        (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46, 
        (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50, 
        (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54, 
        (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101, 
        (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105, 
        (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109, 
        (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )206,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )187,      (unsigned short const   )59,      (unsigned short const   )296, 
        (unsigned short const   )297,      (unsigned short const   )76,      (unsigned short const   )160,      (unsigned short const   )161, 
        (unsigned short const   )301,      (unsigned short const   )244,      (unsigned short const   )232,      (unsigned short const   )19, 
        (unsigned short const   )244,      (unsigned short const   )297,      (unsigned short const   )59,      (unsigned short const   )23, 
        (unsigned short const   )87,      (unsigned short const   )301,      (unsigned short const   )89,      (unsigned short const   )245, 
        (unsigned short const   )26,      (unsigned short const   )92,      (unsigned short const   )244,      (unsigned short const   )258, 
        (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102, 
        (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106, 
        (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )19,      (unsigned short const   )187, 
        (unsigned short const   )97,      (unsigned short const   )288,      (unsigned short const   )23,      (unsigned short const   )112, 
        (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )115,      (unsigned short const   )296, 
        (unsigned short const   )297,      (unsigned short const   )118,      (unsigned short const   )119,      (unsigned short const   )120, 
        (unsigned short const   )301,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )112, 
        (unsigned short const   )113,      (unsigned short const   )255,      (unsigned short const   )141,      (unsigned short const   )128, 
        (unsigned short const   )117,      (unsigned short const   )281,      (unsigned short const   )43,      (unsigned short const   )44, 
        (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48, 
        (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51,      (unsigned short const   )52, 
        (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56, 
        (unsigned short const   )57,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )26,      (unsigned short const   )148, 
        (unsigned short const   )149,      (unsigned short const   )150,      (unsigned short const   )115,      (unsigned short const   )97, 
        (unsigned short const   )59,      (unsigned short const   )118,      (unsigned short const   )119,      (unsigned short const   )120, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )73,      (unsigned short const   )59, 
        (unsigned short const   )122,      (unsigned short const   )19,      (unsigned short const   )209,      (unsigned short const   )128, 
        (unsigned short const   )256,      (unsigned short const   )72,      (unsigned short const   )187,      (unsigned short const   )113, 
        (unsigned short const   )187,      (unsigned short const   )81,      (unsigned short const   )223,      (unsigned short const   )117, 
        (unsigned short const   )227,      (unsigned short const   )228,      (unsigned short const   )99,      (unsigned short const   )100, 
        (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104, 
        (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108, 
        (unsigned short const   )109,      (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45, 
        (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49, 
        (unsigned short const   )50,      (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53, 
        (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57, 
        (unsigned short const   )19,      (unsigned short const   )255,      (unsigned short const   )148,      (unsigned short const   )149, 
        (unsigned short const   )150,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )123,      (unsigned short const   )124,      (unsigned short const   )125,      (unsigned short const   )230, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )22, 
        (unsigned short const   )297,      (unsigned short const   )22,      (unsigned short const   )81,      (unsigned short const   )22, 
        (unsigned short const   )301,      (unsigned short const   )59,      (unsigned short const   )134,      (unsigned short const   )135, 
        (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46, 
        (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50, 
        (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54, 
        (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )139, 
        (unsigned short const   )192,      (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101, 
        (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105, 
        (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109, 
        (unsigned short const   )59,      (unsigned short const   )116,      (unsigned short const   )59,      (unsigned short const   )187, 
        (unsigned short const   )59,      (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )46, 
        (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )16, 
        (unsigned short const   )12,      (unsigned short const   )145,      (unsigned short const   )198,      (unsigned short const   )22, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )244,      (unsigned short const   )134, 
        (unsigned short const   )135,      (unsigned short const   )222,      (unsigned short const   )112,      (unsigned short const   )113, 
        (unsigned short const   )114,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )27, 
        (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102, 
        (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106, 
        (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )42,      (unsigned short const   )187, 
        (unsigned short const   )154,      (unsigned short const   )227,      (unsigned short const   )228,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )139,      (unsigned short const   )22,      (unsigned short const   )23, 
        (unsigned short const   )59,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )113,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )244,      (unsigned short const   )245,      (unsigned short const   )233,      (unsigned short const   )63, 
        (unsigned short const   )19,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )271, 
        (unsigned short const   )187,      (unsigned short const   )24,      (unsigned short const   )254,      (unsigned short const   )275, 
        (unsigned short const   )77,      (unsigned short const   )73,      (unsigned short const   )79,      (unsigned short const   )245, 
        (unsigned short const   )195,      (unsigned short const   )260,      (unsigned short const   )117,      (unsigned short const   )223, 
        (unsigned short const   )199,      (unsigned short const   )22,      (unsigned short const   )23,      (unsigned short const   )154, 
        (unsigned short const   )19,      (unsigned short const   )26,      (unsigned short const   )22,      (unsigned short const   )187, 
        (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46, 
        (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50, 
        (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54, 
        (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )19, 
        (unsigned short const   )187,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )43,      (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46, 
        (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50, 
        (unsigned short const   )51,      (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54, 
        (unsigned short const   )55,      (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )59, 
        (unsigned short const   )263,      (unsigned short const   )187,      (unsigned short const   )98,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )204,      (unsigned short const   )205, 
        (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102, 
        (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106, 
        (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )255, 
        (unsigned short const   )130,      (unsigned short const   )98,      (unsigned short const   )132,      (unsigned short const   )133, 
        (unsigned short const   )299,      (unsigned short const   )300,      (unsigned short const   )198,      (unsigned short const   )187, 
        (unsigned short const   )99,      (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102, 
        (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106, 
        (unsigned short const   )107,      (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )187, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )187, 
        (unsigned short const   )241,      (unsigned short const   )187,      (unsigned short const   )243,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )19,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )282, 
        (unsigned short const   )59,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )16,      (unsigned short const   )230,      (unsigned short const   )19, 
        (unsigned short const   )244,      (unsigned short const   )22,      (unsigned short const   )23,      (unsigned short const   )223, 
        (unsigned short const   )274,      (unsigned short const   )26,      (unsigned short const   )19,      (unsigned short const   )223, 
        (unsigned short const   )187,      (unsigned short const   )223,      (unsigned short const   )198,      (unsigned short const   )44, 
        (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48, 
        (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51,      (unsigned short const   )52, 
        (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55,      (unsigned short const   )56, 
        (unsigned short const   )57,      (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47, 
        (unsigned short const   )48,      (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51, 
        (unsigned short const   )52,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )55, 
        (unsigned short const   )56,      (unsigned short const   )57,      (unsigned short const   )19,      (unsigned short const   )20, 
        (unsigned short const   )187,      (unsigned short const   )22,      (unsigned short const   )187,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )123,      (unsigned short const   )124,      (unsigned short const   )125,      (unsigned short const   )7, 
        (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )187,      (unsigned short const   )36, 
        (unsigned short const   )244,      (unsigned short const   )24,      (unsigned short const   )77,      (unsigned short const   )21, 
        (unsigned short const   )79,      (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )187,      (unsigned short const   )263,      (unsigned short const   )99,      (unsigned short const   )100, 
        (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103,      (unsigned short const   )104, 
        (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107,      (unsigned short const   )108, 
        (unsigned short const   )109,      (unsigned short const   )98,      (unsigned short const   )59,      (unsigned short const   )99, 
        (unsigned short const   )100,      (unsigned short const   )101,      (unsigned short const   )102,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )106,      (unsigned short const   )107, 
        (unsigned short const   )108,      (unsigned short const   )109,      (unsigned short const   )71,      (unsigned short const   )187, 
        (unsigned short const   )59,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )187,      (unsigned short const   )22,      (unsigned short const   )112, 
        (unsigned short const   )81,      (unsigned short const   )299,      (unsigned short const   )300,      (unsigned short const   )282, 
        (unsigned short const   )230,      (unsigned short const   )199,      (unsigned short const   )291,      (unsigned short const   )292, 
        (unsigned short const   )22,      (unsigned short const   )187,      (unsigned short const   )24,      (unsigned short const   )256, 
        (unsigned short const   )36,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187, 
        (unsigned short const   )97,      (unsigned short const   )35,      (unsigned short const   )80,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )268,      (unsigned short const   )103,      (unsigned short const   )104, 
        (unsigned short const   )48,      (unsigned short const   )187,      (unsigned short const   )220,      (unsigned short const   )223, 
        (unsigned short const   )222,      (unsigned short const   )110,      (unsigned short const   )59,      (unsigned short const   )112, 
        (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )187,      (unsigned short const   )59, 
        (unsigned short const   )117,      (unsigned short const   )156,      (unsigned short const   )187,      (unsigned short const   )179, 
        (unsigned short const   )180,      (unsigned short const   )181,      (unsigned short const   )182,      (unsigned short const   )183, 
        (unsigned short const   )184,      (unsigned short const   )59,      (unsigned short const   )113,      (unsigned short const   )71, 
        (unsigned short const   )66,      (unsigned short const   )189,      (unsigned short const   )22,      (unsigned short const   )191, 
        (unsigned short const   )230,      (unsigned short const   )134,      (unsigned short const   )135,      (unsigned short const   )245, 
        (unsigned short const   )74,      (unsigned short const   )119,      (unsigned short const   )198,      (unsigned short const   )282, 
        (unsigned short const   )297,      (unsigned short const   )85,      (unsigned short const   )224,      (unsigned short const   )198, 
        (unsigned short const   )301,      (unsigned short const   )187,      (unsigned short const   )90,      (unsigned short const   )148, 
        (unsigned short const   )149,      (unsigned short const   )150,      (unsigned short const   )151,      (unsigned short const   )152, 
        (unsigned short const   )19,      (unsigned short const   )97,      (unsigned short const   )103,      (unsigned short const   )104, 
        (unsigned short const   )123,      (unsigned short const   )124,      (unsigned short const   )125,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )53,      (unsigned short const   )111,      (unsigned short const   )112, 
        (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )110,      (unsigned short const   )116, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )117,      (unsigned short const   )156,      (unsigned short const   )124, 
        (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )297,      (unsigned short const   )113, 
        (unsigned short const   )187,      (unsigned short const   )24,      (unsigned short const   )301,      (unsigned short const   )256, 
        (unsigned short const   )244,      (unsigned short const   )201,      (unsigned short const   )202,      (unsigned short const   )256, 
        (unsigned short const   )126,      (unsigned short const   )244,      (unsigned short const   )187,      (unsigned short const   )198, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )23,      (unsigned short const   )187, 
        (unsigned short const   )187,      (unsigned short const   )26,      (unsigned short const   )258,      (unsigned short const   )148, 
        (unsigned short const   )19,      (unsigned short const   )150,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )148,      (unsigned short const   )149,      (unsigned short const   )150,      (unsigned short const   )151, 
        (unsigned short const   )152,      (unsigned short const   )0,      (unsigned short const   )1,      (unsigned short const   )2, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )5,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )10, 
        (unsigned short const   )11,      (unsigned short const   )12,      (unsigned short const   )13,      (unsigned short const   )14, 
        (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )17,      (unsigned short const   )46, 
        (unsigned short const   )288,      (unsigned short const   )19,      (unsigned short const   )20,      (unsigned short const   )223, 
        (unsigned short const   )22,      (unsigned short const   )236,      (unsigned short const   )198,      (unsigned short const   )66, 
        (unsigned short const   )187,      (unsigned short const   )244,      (unsigned short const   )245,      (unsigned short const   )30, 
        (unsigned short const   )12,      (unsigned short const   )32,      (unsigned short const   )198,      (unsigned short const   )246, 
        (unsigned short const   )59,      (unsigned short const   )112,      (unsigned short const   )36,      (unsigned short const   )187, 
        (unsigned short const   )245,      (unsigned short const   )40,      (unsigned short const   )198,      (unsigned short const   )245, 
        (unsigned short const   )117,      (unsigned short const   )29,      (unsigned short const   )85,      (unsigned short const   )27, 
        (unsigned short const   )26,      (unsigned short const   )33,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )297,      (unsigned short const   )76,      (unsigned short const   )127,      (unsigned short const   )94, 
        (unsigned short const   )301,      (unsigned short const   )256,      (unsigned short const   )26,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )59,      (unsigned short const   )42,      (unsigned short const   )153, 
        (unsigned short const   )87,      (unsigned short const   )155,      (unsigned short const   )89,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )92,      (unsigned short const   )31,      (unsigned short const   )70, 
        (unsigned short const   )244,      (unsigned short const   )71,      (unsigned short const   )26,      (unsigned short const   )231, 
        (unsigned short const   )232,      (unsigned short const   )114,      (unsigned short const   )39,      (unsigned short const   )78, 
        (unsigned short const   )244,      (unsigned short const   )65,      (unsigned short const   )81,      (unsigned short const   )63, 
        (unsigned short const   )111,      (unsigned short const   )233,      (unsigned short const   )137,      (unsigned short const   )85, 
        (unsigned short const   )244,      (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114, 
        (unsigned short const   )90,      (unsigned short const   )22,      (unsigned short const   )59,      (unsigned short const   )24, 
        (unsigned short const   )95,      (unsigned short const   )201,      (unsigned short const   )202,      (unsigned short const   )97, 
        (unsigned short const   )127,      (unsigned short const   )187,      (unsigned short const   )139,      (unsigned short const   )142, 
        (unsigned short const   )187,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )187,      (unsigned short const   )22,      (unsigned short const   )187, 
        (unsigned short const   )110,      (unsigned short const   )187,      (unsigned short const   )112,      (unsigned short const   )113, 
        (unsigned short const   )114,      (unsigned short const   )187,      (unsigned short const   )141,      (unsigned short const   )117, 
        (unsigned short const   )141,      (unsigned short const   )187,      (unsigned short const   )23,      (unsigned short const   )187, 
        (unsigned short const   )36,      (unsigned short const   )26,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )134,      (unsigned short const   )135,      (unsigned short const   )129,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )134, 
        (unsigned short const   )135,      (unsigned short const   )22,      (unsigned short const   )159,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )59, 
        (unsigned short const   )113,      (unsigned short const   )187,      (unsigned short const   )148,      (unsigned short const   )149, 
        (unsigned short const   )150,      (unsigned short const   )151,      (unsigned short const   )152,      (unsigned short const   )289, 
        (unsigned short const   )290,      (unsigned short const   )187,      (unsigned short const   )157,      (unsigned short const   )71, 
        (unsigned short const   )248,      (unsigned short const   )249,      (unsigned short const   )114,      (unsigned short const   )141, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )46,      (unsigned short const   )125, 
        (unsigned short const   )116,      (unsigned short const   )117,      (unsigned short const   )138,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )85,      (unsigned short const   )22,      (unsigned short const   )148, 
        (unsigned short const   )61,      (unsigned short const   )150,      (unsigned short const   )90,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )23,      (unsigned short const   )7,      (unsigned short const   )8, 
        (unsigned short const   )26,      (unsigned short const   )97,      (unsigned short const   )187,      (unsigned short const   )139, 
        (unsigned short const   )36,      (unsigned short const   )147,      (unsigned short const   )59,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )19,      (unsigned short const   )20,      (unsigned short const   )187, 
        (unsigned short const   )22,      (unsigned short const   )59,      (unsigned short const   )110,      (unsigned short const   )187, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )1, 
        (unsigned short const   )2,      (unsigned short const   )117,      (unsigned short const   )187,      (unsigned short const   )5, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )36,      (unsigned short const   )59, 
        (unsigned short const   )10,      (unsigned short const   )11,      (unsigned short const   )12,      (unsigned short const   )13, 
        (unsigned short const   )14,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )17, 
        (unsigned short const   )59,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )71, 
        (unsigned short const   )187,      (unsigned short const   )148,      (unsigned short const   )250,      (unsigned short const   )150, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )111, 
        (unsigned short const   )30,      (unsigned short const   )59,      (unsigned short const   )32,      (unsigned short const   )22, 
        (unsigned short const   )148,      (unsigned short const   )149,      (unsigned short const   )150,      (unsigned short const   )151, 
        (unsigned short const   )152,      (unsigned short const   )187,      (unsigned short const   )40,      (unsigned short const   )187, 
        (unsigned short const   )113,      (unsigned short const   )71,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )187,      (unsigned short const   )97,      (unsigned short const   )187,      (unsigned short const   )113, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )103, 
        (unsigned short const   )104,      (unsigned short const   )105,      (unsigned short const   )23,      (unsigned short const   )187, 
        (unsigned short const   )187,      (unsigned short const   )26,      (unsigned short const   )110,      (unsigned short const   )187, 
        (unsigned short const   )112,      (unsigned short const   )113,      (unsigned short const   )114,      (unsigned short const   )83, 
        (unsigned short const   )84,      (unsigned short const   )117,      (unsigned short const   )23,      (unsigned short const   )97, 
        (unsigned short const   )70,      (unsigned short const   )26,      (unsigned short const   )113,      (unsigned short const   )218, 
        (unsigned short const   )187,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )187, 
        (unsigned short const   )78,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )81, 
        (unsigned short const   )110,      (unsigned short const   )187,      (unsigned short const   )112,      (unsigned short const   )113, 
        (unsigned short const   )114,      (unsigned short const   )19,      (unsigned short const   )20,      (unsigned short const   )117, 
        (unsigned short const   )22,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187, 
        (unsigned short const   )187,      (unsigned short const   )95,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )148,      (unsigned short const   )149,      (unsigned short const   )150,      (unsigned short const   )151, 
        (unsigned short const   )152,      (unsigned short const   )187,      (unsigned short const   )36,      (unsigned short const   )23, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )26,      (unsigned short const   )187, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187, 
        (unsigned short const   )187,      (unsigned short const   )218,      (unsigned short const   )148,      (unsigned short const   )149, 
        (unsigned short const   )150,      (unsigned short const   )151,      (unsigned short const   )152,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )59,      (unsigned short const   )187,      (unsigned short const   )129, 
        (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187, 
        (unsigned short const   )134,      (unsigned short const   )135,      (unsigned short const   )187,      (unsigned short const   )306, 
        (unsigned short const   )187,      (unsigned short const   )71,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )23,      (unsigned short const   )228,      (unsigned short const   )187,      (unsigned short const   )26, 
        (unsigned short const   )23,      (unsigned short const   )187,      (unsigned short const   )137,      (unsigned short const   )26, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )157, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )218,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )97, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )278, 
        (unsigned short const   )23,      (unsigned short const   )103,      (unsigned short const   )104,      (unsigned short const   )26, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187, 
        (unsigned short const   )110,      (unsigned short const   )187,      (unsigned short const   )112,      (unsigned short const   )113, 
        (unsigned short const   )114,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )117, 
        (unsigned short const   )5,      (unsigned short const   )247,      (unsigned short const   )187,      (unsigned short const   )187, 
        (unsigned short const   )187,      (unsigned short const   )10,      (unsigned short const   )11,      (unsigned short const   )12, 
        (unsigned short const   )13,      (unsigned short const   )14,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )17,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )23, 
        (unsigned short const   )187,      (unsigned short const   )30,      (unsigned short const   )26,      (unsigned short const   )32, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )148,      (unsigned short const   )149, 
        (unsigned short const   )150,      (unsigned short const   )151,      (unsigned short const   )152,      (unsigned short const   )40, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )187,      (unsigned short const   )277,      (unsigned short const   )234,      (unsigned short const   )187, 
        (unsigned short const   )247,      (unsigned short const   )187,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )235, 
        (unsigned short const   )187,      (unsigned short const   )70,      (unsigned short const   )187,      (unsigned short const   )207, 
        (unsigned short const   )247,      (unsigned short const   )247,      (unsigned short const   )247,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )78,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )81,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )187,      (unsigned short const   )185,      (unsigned short const   )238, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210, 
        (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )95,      (unsigned short const   )251, 
        (unsigned short const   )287,      (unsigned short const   )238,      (unsigned short const   )251,      (unsigned short const   )23, 
        (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )26,      (unsigned short const   )26, 
        (unsigned short const   )26,      (unsigned short const   )283,      (unsigned short const   )23,      (unsigned short const   )209, 
        (unsigned short const   )210,      (unsigned short const   )26,      (unsigned short const   )213,      (unsigned short const   )238, 
        (unsigned short const   )221,      (unsigned short const   )283,      (unsigned short const   )212,      (unsigned short const   )212, 
        (unsigned short const   )217,      (unsigned short const   )212,      (unsigned short const   )251,      (unsigned short const   )241, 
        (unsigned short const   )270,      (unsigned short const   )241,      (unsigned short const   )237,      (unsigned short const   )235, 
        (unsigned short const   )190,      (unsigned short const   )60,      (unsigned short const   )137,      (unsigned short const   )287, 
        (unsigned short const   )129,      (unsigned short const   )194,      (unsigned short const   )194,      (unsigned short const   )38, 
        (unsigned short const   )284,      (unsigned short const   )134,      (unsigned short const   )135,      (unsigned short const   )273, 
        (unsigned short const   )284,      (unsigned short const   )194,      (unsigned short const   )146,      (unsigned short const   )111, 
        (unsigned short const   )22,      (unsigned short const   )43,      (unsigned short const   )226,      (unsigned short const   )145, 
        (unsigned short const   )262,      (unsigned short const   )261,      (unsigned short const   )238,      (unsigned short const   )18, 
        (unsigned short const   )229,      (unsigned short const   )229,      (unsigned short const   )229,      (unsigned short const   )229, 
        (unsigned short const   )194,      (unsigned short const   )18,      (unsigned short const   )193,      (unsigned short const   )238, 
        (unsigned short const   )157,      (unsigned short const   )262,      (unsigned short const   )226,      (unsigned short const   )226, 
        (unsigned short const   )194,      (unsigned short const   )238,      (unsigned short const   )238,      (unsigned short const   )193, 
        (unsigned short const   )153,      (unsigned short const   )261,      (unsigned short const   )62,      (unsigned short const   )280, 
        (unsigned short const   )279,      (unsigned short const   )194,      (unsigned short const   )193,      (unsigned short const   )22, 
        (unsigned short const   )194,      (unsigned short const   )214,      (unsigned short const   )193,      (unsigned short const   )111, 
        (unsigned short const   )194,      (unsigned short const   )193,      (unsigned short const   )214,      (unsigned short const   )211, 
        (unsigned short const   )211,      (unsigned short const   )64,      (unsigned short const   )211,      (unsigned short const   )211, 
        (unsigned short const   )122,      (unsigned short const   )211,      (unsigned short const   )219,      (unsigned short const   )214, 
        (unsigned short const   )109,      (unsigned short const   )213,      (unsigned short const   )160,      (unsigned short const   )211, 
        (unsigned short const   )300,      (unsigned short const   )140,      (unsigned short const   )211,      (unsigned short const   )253, 
        (unsigned short const   )111,      (unsigned short const   )272,      (unsigned short const   )219,      (unsigned short const   )214, 
        (unsigned short const   )272,      (unsigned short const   )214,      (unsigned short const   )252,      (unsigned short const   )194, 
        (unsigned short const   )253,      (unsigned short const   )252,      (unsigned short const   )91,      (unsigned short const   )253, 
        (unsigned short const   )252,      (unsigned short const   )82,      (unsigned short const   )253,      (unsigned short const   )305, 
        (unsigned short const   )252,      (unsigned short const   )144,      (unsigned short const   )305,      (unsigned short const   )141, 
        (unsigned short const   )22,      (unsigned short const   )194,      (unsigned short const   )269,      (unsigned short const   )257, 
        (unsigned short const   )257,      (unsigned short const   )153,      (unsigned short const   )267,      (unsigned short const   )143, 
        (unsigned short const   )142,      (unsigned short const   )25,      (unsigned short const   )197,      (unsigned short const   )26, 
        (unsigned short const   )242,      (unsigned short const   )241,      (unsigned short const   )196,      (unsigned short const   )240, 
        (unsigned short const   )242,      (unsigned short const   )239,      (unsigned short const   )238,      (unsigned short const   )13, 
        (unsigned short const   )188,      (unsigned short const   )188,      (unsigned short const   )6,      (unsigned short const   )293, 
        (unsigned short const   )186,      (unsigned short const   )186,      (unsigned short const   )186,      (unsigned short const   )200, 
        (unsigned short const   )206,      (unsigned short const   )293,      (unsigned short const   )206,      (unsigned short const   )206, 
        (unsigned short const   )206,      (unsigned short const   )4,      (unsigned short const   )200,      (unsigned short const   )215, 
        (unsigned short const   )215,      (unsigned short const   )207,      (unsigned short const   )207,      (unsigned short const   )3, 
        (unsigned short const   )22,      (unsigned short const   )206,      (unsigned short const   )200,      (unsigned short const   )158, 
        (unsigned short const   )96,      (unsigned short const   )15,      (unsigned short const   )23,      (unsigned short const   )16, 
        (unsigned short const   )23,      (unsigned short const   )135,      (unsigned short const   )146,      (unsigned short const   )126, 
        (unsigned short const   )24,      (unsigned short const   )138,      (unsigned short const   )20,      (unsigned short const   )16, 
        (unsigned short const   )140,      (unsigned short const   )1,      (unsigned short const   )138,      (unsigned short const   )147, 
        (unsigned short const   )126,      (unsigned short const   )61,      (unsigned short const   )53,      (unsigned short const   )37, 
        (unsigned short const   )146,      (unsigned short const   )53,      (unsigned short const   )53,      (unsigned short const   )290, 
        (unsigned short const   )53,      (unsigned short const   )126,      (unsigned short const   )112,      (unsigned short const   )34, 
        (unsigned short const   )137,      (unsigned short const   )1,      (unsigned short const   )5,      (unsigned short const   )22, 
        (unsigned short const   )111,      (unsigned short const   )156,      (unsigned short const   )68,      (unsigned short const   )68, 
        (unsigned short const   )26,      (unsigned short const   )41,      (unsigned short const   )75,      (unsigned short const   )137, 
        (unsigned short const   )111,      (unsigned short const   )24,      (unsigned short const   )20,      (unsigned short const   )19, 
        (unsigned short const   )127,      (unsigned short const   )121,      (unsigned short const   )23,      (unsigned short const   )67, 
        (unsigned short const   )22,      (unsigned short const   )22,      (unsigned short const   )67,      (unsigned short const   )22, 
        (unsigned short const   )22,      (unsigned short const   )37,      (unsigned short const   )22,      (unsigned short const   )67, 
        (unsigned short const   )23,      (unsigned short const   )145,      (unsigned short const   )22,      (unsigned short const   )28, 
        (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )137, 
        (unsigned short const   )23,      (unsigned short const   )22,      (unsigned short const   )26,      (unsigned short const   )22, 
        (unsigned short const   )24,      (unsigned short const   )23,      (unsigned short const   )112,      (unsigned short const   )24, 
        (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )22,      (unsigned short const   )139, 
        (unsigned short const   )34,      (unsigned short const   )26,      (unsigned short const   )75,      (unsigned short const   )88, 
        (unsigned short const   )86,      (unsigned short const   )75,      (unsigned short const   )34,      (unsigned short const   )23, 
        (unsigned short const   )22,      (unsigned short const   )24,      (unsigned short const   )22,      (unsigned short const   )34, 
        (unsigned short const   )34,      (unsigned short const   )34,      (unsigned short const   )93,      (unsigned short const   )34, 
        (unsigned short const   )26,      (unsigned short const   )26,      (unsigned short const   )23,      (unsigned short const   )23, 
        (unsigned short const   )23,      (unsigned short const   )34,      (unsigned short const   )23,      (unsigned short const   )23, 
        (unsigned short const   )44,      (unsigned short const   )23,      (unsigned short const   )11,      (unsigned short const   )26, 
        (unsigned short const   )22,      (unsigned short const   )22,      (unsigned short const   )26,      (unsigned short const   )23, 
        (unsigned short const   )23,      (unsigned short const   )22,      (unsigned short const   )22,      (unsigned short const   )15, 
        (unsigned short const   )137,      (unsigned short const   )137,      (unsigned short const   )137,      (unsigned short const   )137, 
        (unsigned short const   )23,      (unsigned short const   )1,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )131,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307, 
        (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307,      (unsigned short const   )307};
static unsigned short const   yy_shift_ofst[543]  = 
  {      (unsigned short const   )1350,      (unsigned short const   )1149,      (unsigned short const   )1531,      (unsigned short const   )939, 
        (unsigned short const   )939,      (unsigned short const   )548,      (unsigned short const   )996,      (unsigned short const   )1150, 
        (unsigned short const   )1236,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )334,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )178, 
        (unsigned short const   )777,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )991,      (unsigned short const   )991, 
        (unsigned short const   )1125,      (unsigned short const   )1125,      (unsigned short const   )447,      (unsigned short const   )597, 
        (unsigned short const   )548,      (unsigned short const   )548,      (unsigned short const   )548,      (unsigned short const   )548, 
        (unsigned short const   )548,      (unsigned short const   )548,      (unsigned short const   )40,      (unsigned short const   )108, 
        (unsigned short const   )217,      (unsigned short const   )284,      (unsigned short const   )323,      (unsigned short const   )390, 
        (unsigned short const   )429,      (unsigned short const   )496,      (unsigned short const   )535,      (unsigned short const   )602, 
        (unsigned short const   )641,      (unsigned short const   )757,      (unsigned short const   )777,      (unsigned short const   )777, 
        (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777, 
        (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777, 
        (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777, 
        (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777,      (unsigned short const   )777, 
        (unsigned short const   )796,      (unsigned short const   )777,      (unsigned short const   )887,      (unsigned short const   )900, 
        (unsigned short const   )900,      (unsigned short const   )1300,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1418,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322,      (unsigned short const   )1322, 
        (unsigned short const   )147,      (unsigned short const   )254,      (unsigned short const   )254,      (unsigned short const   )254, 
        (unsigned short const   )254,      (unsigned short const   )254,      (unsigned short const   )84,      (unsigned short const   )185, 
        (unsigned short const   )66,      (unsigned short const   )853,      (unsigned short const   )958,      (unsigned short const   )1121, 
        (unsigned short const   )853,      (unsigned short const   )92,      (unsigned short const   )92,      (unsigned short const   )853, 
        (unsigned short const   )321,      (unsigned short const   )321,      (unsigned short const   )321,      (unsigned short const   )321, 
        (unsigned short const   )325,      (unsigned short const   )350,      (unsigned short const   )350,      (unsigned short const   )461, 
        (unsigned short const   )150,      (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )285, 
        (unsigned short const   )285,      (unsigned short const   )285,      (unsigned short const   )236,      (unsigned short const   )184, 
        (unsigned short const   )349,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )712, 
        (unsigned short const   )712,      (unsigned short const   )433,      (unsigned short const   )553,      (unsigned short const   )771, 
        (unsigned short const   )899,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )46,      (unsigned short const   )46, 
        (unsigned short const   )853,      (unsigned short const   )113,      (unsigned short const   )223,      (unsigned short const   )223, 
        (unsigned short const   )1183,      (unsigned short const   )1183,      (unsigned short const   )1127,      (unsigned short const   )1142, 
        (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )459, 
        (unsigned short const   )514,      (unsigned short const   )514,      (unsigned short const   )653,      (unsigned short const   )495, 
        (unsigned short const   )657,      (unsigned short const   )305,      (unsigned short const   )705,      (unsigned short const   )560, 
        (unsigned short const   )622,      (unsigned short const   )776,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )545, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )1002,      (unsigned short const   )1002,      (unsigned short const   )1002,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )1111, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )1006, 
        (unsigned short const   )1109,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )1168, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853,      (unsigned short const   )853, 
        (unsigned short const   )845,      (unsigned short const   )1164,      (unsigned short const   )738,      (unsigned short const   )953, 
        (unsigned short const   )953,      (unsigned short const   )953,      (unsigned short const   )953,      (unsigned short const   )1196, 
        (unsigned short const   )738,      (unsigned short const   )738,      (unsigned short const   )45,      (unsigned short const   )96, 
        (unsigned short const   )964,      (unsigned short const   )179,      (unsigned short const   )580,      (unsigned short const   )907, 
        (unsigned short const   )907,      (unsigned short const   )1073,      (unsigned short const   )580,      (unsigned short const   )580, 
        (unsigned short const   )1073,      (unsigned short const   )498,      (unsigned short const   )388,      (unsigned short const   )1268, 
        (unsigned short const   )1187,      (unsigned short const   )1187,      (unsigned short const   )1187,      (unsigned short const   )907, 
        (unsigned short const   )1170,      (unsigned short const   )1170,      (unsigned short const   )1058,      (unsigned short const   )1180, 
        (unsigned short const   )328,      (unsigned short const   )1219,      (unsigned short const   )1597,      (unsigned short const   )1521, 
        (unsigned short const   )1521,      (unsigned short const   )1625,      (unsigned short const   )1625,      (unsigned short const   )1521, 
        (unsigned short const   )1524,      (unsigned short const   )1560,      (unsigned short const   )1650,      (unsigned short const   )1630, 
        (unsigned short const   )1530,      (unsigned short const   )1661,      (unsigned short const   )1661,      (unsigned short const   )1661, 
        (unsigned short const   )1661,      (unsigned short const   )1521,      (unsigned short const   )1667,      (unsigned short const   )1530, 
        (unsigned short const   )1530,      (unsigned short const   )1560,      (unsigned short const   )1650,      (unsigned short const   )1630, 
        (unsigned short const   )1630,      (unsigned short const   )1530,      (unsigned short const   )1521,      (unsigned short const   )1667, 
        (unsigned short const   )1543,      (unsigned short const   )1636,      (unsigned short const   )1521,      (unsigned short const   )1667, 
        (unsigned short const   )1681,      (unsigned short const   )1521,      (unsigned short const   )1667,      (unsigned short const   )1521, 
        (unsigned short const   )1667,      (unsigned short const   )1681,      (unsigned short const   )1596,      (unsigned short const   )1596, 
        (unsigned short const   )1596,      (unsigned short const   )1649,      (unsigned short const   )1681,      (unsigned short const   )1596, 
        (unsigned short const   )1594,      (unsigned short const   )1596,      (unsigned short const   )1649,      (unsigned short const   )1596, 
        (unsigned short const   )1596,      (unsigned short const   )1562,      (unsigned short const   )1681,      (unsigned short const   )1611, 
        (unsigned short const   )1611,      (unsigned short const   )1681,      (unsigned short const   )1585,      (unsigned short const   )1617, 
        (unsigned short const   )1585,      (unsigned short const   )1617,      (unsigned short const   )1585,      (unsigned short const   )1617, 
        (unsigned short const   )1585,      (unsigned short const   )1617,      (unsigned short const   )1521,      (unsigned short const   )1647, 
        (unsigned short const   )1647,      (unsigned short const   )1659,      (unsigned short const   )1659,      (unsigned short const   )1601, 
        (unsigned short const   )1606,      (unsigned short const   )1726,      (unsigned short const   )1521,      (unsigned short const   )1600, 
        (unsigned short const   )1601,      (unsigned short const   )1612,      (unsigned short const   )1614,      (unsigned short const   )1530, 
        (unsigned short const   )1732,      (unsigned short const   )1733,      (unsigned short const   )1754,      (unsigned short const   )1754, 
        (unsigned short const   )1764,      (unsigned short const   )1764,      (unsigned short const   )1764,      (unsigned short const   )1913, 
        (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913, 
        (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913, 
        (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )1913, 
        (unsigned short const   )1913,      (unsigned short const   )1913,      (unsigned short const   )673,      (unsigned short const   )901, 
        (unsigned short const   )283,      (unsigned short const   )740,      (unsigned short const   )707,      (unsigned short const   )973, 
        (unsigned short const   )655,      (unsigned short const   )1247,      (unsigned short const   )1048,      (unsigned short const   )1097, 
        (unsigned short const   )1190,      (unsigned short const   )1306,      (unsigned short const   )1263,      (unsigned short const   )1383, 
        (unsigned short const   )1395,      (unsigned short const   )1432,      (unsigned short const   )1469,      (unsigned short const   )1473, 
        (unsigned short const   )1497,      (unsigned short const   )1279,      (unsigned short const   )1200,      (unsigned short const   )1323, 
        (unsigned short const   )1075,      (unsigned short const   )1286,      (unsigned short const   )1536,      (unsigned short const   )1608, 
        (unsigned short const   )1332,      (unsigned short const   )1609,      (unsigned short const   )1175,      (unsigned short const   )1225, 
        (unsigned short const   )1610,      (unsigned short const   )1615,      (unsigned short const   )1309,      (unsigned short const   )1361, 
        (unsigned short const   )1777,      (unsigned short const   )1784,      (unsigned short const   )1766,      (unsigned short const   )1633, 
        (unsigned short const   )1778,      (unsigned short const   )1696,      (unsigned short const   )1779,      (unsigned short const   )1771, 
        (unsigned short const   )1773,      (unsigned short const   )1662,      (unsigned short const   )1652,      (unsigned short const   )1673, 
        (unsigned short const   )1776,      (unsigned short const   )1663,      (unsigned short const   )1782,      (unsigned short const   )1664, 
        (unsigned short const   )1787,      (unsigned short const   )1804,      (unsigned short const   )1668,      (unsigned short const   )1660, 
        (unsigned short const   )1682,      (unsigned short const   )1748,      (unsigned short const   )1774,      (unsigned short const   )1666, 
        (unsigned short const   )1757,      (unsigned short const   )1760,      (unsigned short const   )1761,      (unsigned short const   )1763, 
        (unsigned short const   )1691,      (unsigned short const   )1706,      (unsigned short const   )1785,      (unsigned short const   )1683, 
        (unsigned short const   )1820,      (unsigned short const   )1817,      (unsigned short const   )1801,      (unsigned short const   )1713, 
        (unsigned short const   )1669,      (unsigned short const   )1758,      (unsigned short const   )1802,      (unsigned short const   )1759, 
        (unsigned short const   )1755,      (unsigned short const   )1788,      (unsigned short const   )1694,      (unsigned short const   )1721, 
        (unsigned short const   )1809,      (unsigned short const   )1814,      (unsigned short const   )1816,      (unsigned short const   )1709, 
        (unsigned short const   )1716,      (unsigned short const   )1818,      (unsigned short const   )1772,      (unsigned short const   )1819, 
        (unsigned short const   )1821,      (unsigned short const   )1815,      (unsigned short const   )1822,      (unsigned short const   )1775, 
        (unsigned short const   )1823,      (unsigned short const   )1824,      (unsigned short const   )1780,      (unsigned short const   )1808, 
        (unsigned short const   )1825,      (unsigned short const   )1704,      (unsigned short const   )1828,      (unsigned short const   )1829, 
        (unsigned short const   )1830,      (unsigned short const   )1831,      (unsigned short const   )1832,      (unsigned short const   )1833, 
        (unsigned short const   )1835,      (unsigned short const   )1836,      (unsigned short const   )1838,      (unsigned short const   )1837, 
        (unsigned short const   )1839,      (unsigned short const   )1718,      (unsigned short const   )1841,      (unsigned short const   )1842, 
        (unsigned short const   )1750,      (unsigned short const   )1834,      (unsigned short const   )1844,      (unsigned short const   )1728, 
        (unsigned short const   )1843,      (unsigned short const   )1840,      (unsigned short const   )1845,      (unsigned short const   )1846, 
        (unsigned short const   )1847,      (unsigned short const   )1783,      (unsigned short const   )1795,      (unsigned short const   )1786, 
        (unsigned short const   )1848,      (unsigned short const   )1798,      (unsigned short const   )1789,      (unsigned short const   )1849, 
        (unsigned short const   )1852,      (unsigned short const   )1854,      (unsigned short const   )1853,      (unsigned short const   )1858, 
        (unsigned short const   )1859,      (unsigned short const   )1855,      (unsigned short const   )1863,      (unsigned short const   )1843, 
        (unsigned short const   )1864,      (unsigned short const   )1865,      (unsigned short const   )1867,      (unsigned short const   )1868, 
        (unsigned short const   )1869,      (unsigned short const   )1870,      (unsigned short const   )1856,      (unsigned short const   )1883, 
        (unsigned short const   )1874,      (unsigned short const   )1875,      (unsigned short const   )1876,      (unsigned short const   )1877, 
        (unsigned short const   )1879,      (unsigned short const   )1880,      (unsigned short const   )1872,      (unsigned short const   )1781, 
        (unsigned short const   )1767,      (unsigned short const   )1768,      (unsigned short const   )1769,      (unsigned short const   )1770, 
        (unsigned short const   )1885,      (unsigned short const   )1888,      (unsigned short const   )1908};
static short const   yy_reduce_ofst[386]  = 
  {      (short const   )880,      (short const   )-121,      (short const   )269,      (short const   )528, 
        (short const   )933,      (short const   )-119,      (short const   )-187,      (short const   )-185, 
        (short const   )-182,      (short const   )-180,      (short const   )-176,      (short const   )-174, 
        (short const   )-62,      (short const   )-46,      (short const   )131,      (short const   )-248, 
        (short const   )-133,      (short const   )407,      (short const   )568,      (short const   )700, 
        (short const   )704,      (short const   )278,      (short const   )706,      (short const   )824, 
        (short const   )542,      (short const   )830,      (short const   )948,      (short const   )773, 
        (short const   )943,      (short const   )946,      (short const   )71,      (short const   )650, 
        (short const   )211,      (short const   )267,      (short const   )826,      (short const   )272, 
        (short const   )676,      (short const   )732,      (short const   )885,      (short const   )976, 
        (short const   )984,      (short const   )992,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )989,      (short const   )1065,      (short const   )1070, 
        (short const   )1072,      (short const   )1078,      (short const   )1082,      (short const   )1084, 
        (short const   )1103,      (short const   )1118,      (short const   )1147,      (short const   )1156, 
        (short const   )1160,      (short const   )1167,      (short const   )1185,      (short const   )1191, 
        (short const   )1220,      (short const   )1237,      (short const   )1254,      (short const   )1256, 
        (short const   )1266,      (short const   )1272,      (short const   )1281,      (short const   )1291, 
        (short const   )1293,      (short const   )1296,      (short const   )1299,      (short const   )1301, 
        (short const   )1307,      (short const   )1337,      (short const   )1340,      (short const   )1342, 
        (short const   )1347,      (short const   )1366,      (short const   )1368,      (short const   )1371, 
        (short const   )1373,      (short const   )1377,      (short const   )1385,      (short const   )1387, 
        (short const   )1398,      (short const   )1401,      (short const   )1404,      (short const   )1406, 
        (short const   )1411,      (short const   )1413,      (short const   )1415,      (short const   )1430, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-256, 
        (short const   )-256,      (short const   )-172,      (short const   )508,      (short const   )-213, 
        (short const   )57,      (short const   )-163,      (short const   )-25,      (short const   )593, 
        (short const   )69,      (short const   )486,      (short const   )69,      (short const   )486, 
        (short const   )-200,      (short const   )573,      (short const   )722,      (short const   )-256, 
        (short const   )-256,      (short const   )-256,      (short const   )-256,      (short const   )-141, 
        (short const   )-141,      (short const   )-141,      (short const   )-105,      (short const   )-161, 
        (short const   )-167,      (short const   )157,      (short const   )212,      (short const   )405, 
        (short const   )530,      (short const   )220,      (short const   )233,      (short const   )735, 
        (short const   )735,      (short const   )115,      (short const   )318,      (short const   )406, 
        (short const   )612,      (short const   )541,      (short const   )-166,      (short const   )441, 
        (short const   )688,      (short const   )794,      (short const   )629,      (short const   )368, 
        (short const   )741,      (short const   )775,      (short const   )867,      (short const   )797, 
        (short const   )871,      (short const   )842,      (short const   )-186,      (short const   )1000, 
        (short const   )858,      (short const   )949,      (short const   )379,      (short const   )783, 
        (short const   )70,      (short const   )296,      (short const   )821,      (short const   )903, 
        (short const   )924,      (short const   )1044,      (short const   )651,      (short const   )282, 
        (short const   )1014,      (short const   )1060,      (short const   )937,      (short const   )-195, 
        (short const   )-177,      (short const   )413,      (short const   )439,      (short const   )511, 
        (short const   )566,      (short const   )787,      (short const   )827,      (short const   )848, 
        (short const   )898,      (short const   )945,      (short const   )1062,      (short const   )1074, 
        (short const   )1102,      (short const   )1110,      (short const   )1202,      (short const   )1204, 
        (short const   )1209,      (short const   )1211,      (short const   )1215,      (short const   )529, 
        (short const   )1221,      (short const   )1224,      (short const   )1240,      (short const   )1246, 
        (short const   )1255,      (short const   )1257,      (short const   )1269,      (short const   )1270, 
        (short const   )1273,      (short const   )1274,      (short const   )1275,      (short const   )1280, 
        (short const   )1205,      (short const   )1251,      (short const   )1294,      (short const   )1310, 
        (short const   )1317,      (short const   )1326,      (short const   )1327,      (short const   )1124, 
        (short const   )1331,      (short const   )1338,      (short const   )1339,      (short const   )1290, 
        (short const   )1181,      (short const   )1346,      (short const   )1351,      (short const   )1265, 
        (short const   )1352,      (short const   )787,      (short const   )1353,      (short const   )1367, 
        (short const   )1378,      (short const   )1386,      (short const   )1392,      (short const   )1397, 
        (short const   )1241,      (short const   )1312,      (short const   )1356,      (short const   )1345, 
        (short const   )1357,      (short const   )1358,      (short const   )1359,      (short const   )1124, 
        (short const   )1356,      (short const   )1356,      (short const   )1364,      (short const   )1396, 
        (short const   )1433,      (short const   )1341,      (short const   )1381,      (short const   )1376, 
        (short const   )1379,      (short const   )1354,      (short const   )1391,      (short const   )1405, 
        (short const   )1362,      (short const   )1429,      (short const   )1423,      (short const   )1431, 
        (short const   )1434,      (short const   )1435,      (short const   )1437,      (short const   )1399, 
        (short const   )1410,      (short const   )1412,      (short const   )1382,      (short const   )1417, 
        (short const   )1420,      (short const   )1466,      (short const   )1372,      (short const   )1467, 
        (short const   )1468,      (short const   )1380,      (short const   )1384,      (short const   )1475, 
        (short const   )1394,      (short const   )1414,      (short const   )1416,      (short const   )1448, 
        (short const   )1440,      (short const   )1451,      (short const   )1452,      (short const   )1453, 
        (short const   )1454,      (short const   )1490,      (short const   )1493,      (short const   )1449, 
        (short const   )1455,      (short const   )1427,      (short const   )1436,      (short const   )1464, 
        (short const   )1465,      (short const   )1456,      (short const   )1498,      (short const   )1502, 
        (short const   )1419,      (short const   )1421,      (short const   )1507,      (short const   )1509, 
        (short const   )1491,      (short const   )1510,      (short const   )1513,      (short const   )1514, 
        (short const   )1516,      (short const   )1496,      (short const   )1500,      (short const   )1501, 
        (short const   )1503,      (short const   )1499,      (short const   )1505,      (short const   )1504, 
        (short const   )1508,      (short const   )1506,      (short const   )1511,      (short const   )1512, 
        (short const   )1515,      (short const   )1424,      (short const   )1517,      (short const   )1457, 
        (short const   )1460,      (short const   )1519,      (short const   )1474,      (short const   )1482, 
        (short const   )1483,      (short const   )1485,      (short const   )1486,      (short const   )1488, 
        (short const   )1489,      (short const   )1492,      (short const   )1541,      (short const   )1438, 
        (short const   )1441,      (short const   )1494,      (short const   )1495,      (short const   )1518, 
        (short const   )1520,      (short const   )1487,      (short const   )1555,      (short const   )1481, 
        (short const   )1522,      (short const   )1523,      (short const   )1526,      (short const   )1528, 
        (short const   )1561,      (short const   )1566,      (short const   )1580,      (short const   )1581, 
        (short const   )1586,      (short const   )1587,      (short const   )1588,      (short const   )1478, 
        (short const   )1484,      (short const   )1525,      (short const   )1575,      (short const   )1570, 
        (short const   )1572,      (short const   )1573,      (short const   )1574,      (short const   )1582, 
        (short const   )1568,      (short const   )1569,      (short const   )1578,      (short const   )1579, 
        (short const   )1583,      (short const   )1590};
static unsigned short const   yy_default[543]  = 
  {      (unsigned short const   )1554,      (unsigned short const   )1554,      (unsigned short const   )1554,      (unsigned short const   )1392, 
        (unsigned short const   )1171,      (unsigned short const   )1278,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1392,      (unsigned short const   )1392,      (unsigned short const   )1392, 
        (unsigned short const   )1171,      (unsigned short const   )1308,      (unsigned short const   )1308,      (unsigned short const   )1445, 
        (unsigned short const   )1202,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1391, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1475,      (unsigned short const   )1475,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1317, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1393,      (unsigned short const   )1394,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1444,      (unsigned short const   )1446, 
        (unsigned short const   )1409,      (unsigned short const   )1327,      (unsigned short const   )1326,      (unsigned short const   )1325, 
        (unsigned short const   )1324,      (unsigned short const   )1427,      (unsigned short const   )1295,      (unsigned short const   )1322, 
        (unsigned short const   )1315,      (unsigned short const   )1319,      (unsigned short const   )1387,      (unsigned short const   )1388, 
        (unsigned short const   )1386,      (unsigned short const   )1390,      (unsigned short const   )1394,      (unsigned short const   )1393, 
        (unsigned short const   )1171,      (unsigned short const   )1318,      (unsigned short const   )1358,      (unsigned short const   )1372, 
        (unsigned short const   )1357,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1366,      (unsigned short const   )1371,      (unsigned short const   )1377,      (unsigned short const   )1370, 
        (unsigned short const   )1367,      (unsigned short const   )1360,      (unsigned short const   )1359,      (unsigned short const   )1361, 
        (unsigned short const   )1362,      (unsigned short const   )1171,      (unsigned short const   )1192,      (unsigned short const   )1242, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1463,      (unsigned short const   )1462,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1202,      (unsigned short const   )1352,      (unsigned short const   )1351,      (unsigned short const   )1363, 
        (unsigned short const   )1364,      (unsigned short const   )1374,      (unsigned short const   )1373,      (unsigned short const   )1452, 
        (unsigned short const   )1510,      (unsigned short const   )1509,      (unsigned short const   )1410,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1475,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1475,      (unsigned short const   )1475, 
        (unsigned short const   )1171,      (unsigned short const   )1202,      (unsigned short const   )1475,      (unsigned short const   )1475, 
        (unsigned short const   )1198,      (unsigned short const   )1198,      (unsigned short const   )1302,      (unsigned short const   )1171, 
        (unsigned short const   )1458,      (unsigned short const   )1278,      (unsigned short const   )1269,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1449,      (unsigned short const   )1447,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1274, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1504, 
        (unsigned short const   )1171,      (unsigned short const   )1422,      (unsigned short const   )1256,      (unsigned short const   )1274, 
        (unsigned short const   )1274,      (unsigned short const   )1274,      (unsigned short const   )1274,      (unsigned short const   )1276, 
        (unsigned short const   )1257,      (unsigned short const   )1255,      (unsigned short const   )1268,      (unsigned short const   )1203, 
        (unsigned short const   )1178,      (unsigned short const   )1546,      (unsigned short const   )1321,      (unsigned short const   )1297, 
        (unsigned short const   )1297,      (unsigned short const   )1543,      (unsigned short const   )1321,      (unsigned short const   )1321, 
        (unsigned short const   )1543,      (unsigned short const   )1217,      (unsigned short const   )1524,      (unsigned short const   )1214, 
        (unsigned short const   )1308,      (unsigned short const   )1308,      (unsigned short const   )1308,      (unsigned short const   )1297, 
        (unsigned short const   )1302,      (unsigned short const   )1302,      (unsigned short const   )1389,      (unsigned short const   )1275, 
        (unsigned short const   )1268,      (unsigned short const   )1171,      (unsigned short const   )1546,      (unsigned short const   )1283, 
        (unsigned short const   )1283,      (unsigned short const   )1545,      (unsigned short const   )1545,      (unsigned short const   )1283, 
        (unsigned short const   )1410,      (unsigned short const   )1330,      (unsigned short const   )1336,      (unsigned short const   )1245, 
        (unsigned short const   )1321,      (unsigned short const   )1251,      (unsigned short const   )1251,      (unsigned short const   )1251, 
        (unsigned short const   )1251,      (unsigned short const   )1283,      (unsigned short const   )1189,      (unsigned short const   )1321, 
        (unsigned short const   )1321,      (unsigned short const   )1330,      (unsigned short const   )1336,      (unsigned short const   )1245, 
        (unsigned short const   )1245,      (unsigned short const   )1321,      (unsigned short const   )1283,      (unsigned short const   )1189, 
        (unsigned short const   )1426,      (unsigned short const   )1540,      (unsigned short const   )1283,      (unsigned short const   )1189, 
        (unsigned short const   )1400,      (unsigned short const   )1283,      (unsigned short const   )1189,      (unsigned short const   )1283, 
        (unsigned short const   )1189,      (unsigned short const   )1400,      (unsigned short const   )1243,      (unsigned short const   )1243, 
        (unsigned short const   )1243,      (unsigned short const   )1232,      (unsigned short const   )1400,      (unsigned short const   )1243, 
        (unsigned short const   )1217,      (unsigned short const   )1243,      (unsigned short const   )1232,      (unsigned short const   )1243, 
        (unsigned short const   )1243,      (unsigned short const   )1493,      (unsigned short const   )1400,      (unsigned short const   )1404, 
        (unsigned short const   )1404,      (unsigned short const   )1400,      (unsigned short const   )1301,      (unsigned short const   )1296, 
        (unsigned short const   )1301,      (unsigned short const   )1296,      (unsigned short const   )1301,      (unsigned short const   )1296, 
        (unsigned short const   )1301,      (unsigned short const   )1296,      (unsigned short const   )1283,      (unsigned short const   )1485, 
        (unsigned short const   )1485,      (unsigned short const   )1311,      (unsigned short const   )1311,      (unsigned short const   )1316, 
        (unsigned short const   )1302,      (unsigned short const   )1395,      (unsigned short const   )1283,      (unsigned short const   )1171, 
        (unsigned short const   )1316,      (unsigned short const   )1314,      (unsigned short const   )1312,      (unsigned short const   )1321, 
        (unsigned short const   )1195,      (unsigned short const   )1235,      (unsigned short const   )1507,      (unsigned short const   )1507, 
        (unsigned short const   )1503,      (unsigned short const   )1503,      (unsigned short const   )1503,      (unsigned short const   )1551, 
        (unsigned short const   )1551,      (unsigned short const   )1458,      (unsigned short const   )1519,      (unsigned short const   )1202, 
        (unsigned short const   )1202,      (unsigned short const   )1202,      (unsigned short const   )1202,      (unsigned short const   )1519, 
        (unsigned short const   )1219,      (unsigned short const   )1219,      (unsigned short const   )1203,      (unsigned short const   )1203, 
        (unsigned short const   )1202,      (unsigned short const   )1519,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1514,      (unsigned short const   )1171,      (unsigned short const   )1411,      (unsigned short const   )1287, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1341, 
        (unsigned short const   )1171,      (unsigned short const   )1174,      (unsigned short const   )1455,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1453,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1288,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1542, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1425,      (unsigned short const   )1424, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1285,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1313,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1490, 
        (unsigned short const   )1303,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1533, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1171, 
        (unsigned short const   )1171,      (unsigned short const   )1171,      (unsigned short const   )1528,      (unsigned short const   )1259, 
        (unsigned short const   )1343,      (unsigned short const   )1171,      (unsigned short const   )1342,      (unsigned short const   )1346, 
        (unsigned short const   )1171,      (unsigned short const   )1183,      (unsigned short const   )1171};
static unsigned short const   yyFallback[179]  = 
  {      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )0,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )0,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )59,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )59,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )59,      (unsigned short const   )0,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )59, 
        (unsigned short const   )59,      (unsigned short const   )59,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0};
static void sqlite3ParserInit(void *yypRawParser , Parse *pParse ) 
{ 
  yyParser *yypParser ;

  {
  yypParser = (yyParser *)yypRawParser;
  yypParser->pParse = pParse;
  yypParser->yytos = yypParser->yystack;
  yypParser->yystack[0].stateno = (unsigned short)0;
  yypParser->yystack[0].major = (unsigned short)0;
  yypParser->yystackEnd = & yypParser->yystack[99];
  return;
}
}
static void yy_destructor(yyParser *yypParser , unsigned short yymajor , YYMINORTYPE *yypminor ) 
{ 
  Parse *pParse ;

  {
  pParse = yypParser->pParse;
  switch ((int )yymajor) {
  case 244: 
  case 232: 
  case 231: 
  case 198: 
  sqlite3SelectDelete(pParse->db, yypminor->yy25);
  break;
  case 299: 
  case 285: 
  case 280: 
  case 273: 
  case 270: 
  case 268: 
  case 252: 
  case 240: 
  case 238: 
  case 210: 
  case 209: 
  sqlite3ExprDelete(pParse->db, yypminor->yy46);
  break;
  case 298: 
  case 269: 
  case 267: 
  case 259: 
  case 254: 
  case 246: 
  case 245: 
  case 241: 
  case 239: 
  case 236: 
  case 224: 
  case 223: 
  case 214: 
  sqlite3ExprListDelete(pParse->db, yypminor->yy138);
  break;
  case 255: 
  case 249: 
  case 248: 
  case 237: 
  case 230: 
  sqlite3SrcListDelete(pParse->db, yypminor->yy609);
  break;
  case 233: 
  sqlite3WithDelete(pParse->db, yypminor->yy297);
  break;
  case 294: 
  case 243: 
  sqlite3WindowListDelete(pParse->db, yypminor->yy455);
  break;
  case 261: 
  case 256: 
  case 253: 
  sqlite3IdListDelete(pParse->db, yypminor->yy406);
  break;
  case 300: 
  case 297: 
  case 296: 
  case 295: 
  case 263: 
  sqlite3WindowDelete(pParse->db, yypminor->yy455);
  break;
  case 281: 
  case 276: 
  sqlite3DeleteTriggerStep(pParse->db, yypminor->yy527);
  break;
  case 278: 
  sqlite3IdListDelete(pParse->db, yypminor->yy572.b);
  break;
  case 304: 
  case 303: 
  case 302: 
  sqlite3ExprDelete(pParse->db, yypminor->yy57.pExpr);
  break;
  default: 
  break;
  }
  return;
}
}
static void yy_pop_parser_stack(yyParser *pParser ) 
{ 
  yyStackEntry *yytos ;
  yyStackEntry *tmp ;

  {
  tmp = pParser->yytos;
  (pParser->yytos) --;
  yytos = tmp;
  yy_destructor(pParser, yytos->major, & yytos->minor);
  return;
}
}
static void sqlite3ParserFinalize(void *p ) 
{ 
  yyParser *pParser ;

  {
  pParser = (yyParser *)p;
  while ((unsigned long )pParser->yytos > (unsigned long )(pParser->yystack)) {
    yy_pop_parser_stack(pParser);
  }
  return;
}
}
static unsigned short yy_find_shift_action(unsigned short iLookAhead , unsigned short stateno ) 
{ 
  int i ;
  unsigned short iFallback ;
  int j ;

  {
  if ((int )stateno > 542) {
    return (stateno);
  }
  while (1) {
    i = (int )yy_shift_ofst[stateno];
    i += (int )iLookAhead;
    if ((int const   )yy_lookahead[i] != (int const   )iLookAhead) {
      iFallback = (unsigned short )yyFallback[iLookAhead];
      if ((int )iFallback != 0) {
        iLookAhead = iFallback;
        goto __Cont;
      }
      j = (i - (int )iLookAhead) + 98;
      if ((int const   )yy_lookahead[j] == 98) {
        if ((int )iLookAhead > 0) {
          return ((unsigned short )yy_action[j]);
        }
      }
      return ((unsigned short )yy_default[stateno]);
    } else {
      return ((unsigned short )yy_action[i]);
    }
    __Cont: /* CIL Label */ ;
  }
}
}
static unsigned short yy_find_reduce_action(unsigned short stateno , unsigned short iLookAhead ) 
{ 
  int i ;

  {
  i = (int )yy_reduce_ofst[stateno];
  i += (int )iLookAhead;
  return ((unsigned short )yy_action[i]);
}
}
static void yyStackOverflow(yyParser *yypParser ) 
{ 
  Parse *pParse ;

  {
  pParse = yypParser->pParse;
  while ((unsigned long )yypParser->yytos > (unsigned long )(yypParser->yystack)) {
    yy_pop_parser_stack(yypParser);
  }
  sqlite3ErrorMsg(pParse, "parser stack overflow");
  yypParser->pParse = pParse;
  return;
}
}
static void yy_shift(yyParser *yypParser , unsigned short yyNewState , unsigned short yyMajor ,
                     Token yyMinor ) 
{ 
  yyStackEntry *yytos ;

  {
  (yypParser->yytos) ++;
  if ((unsigned long )yypParser->yytos > (unsigned long )yypParser->yystackEnd) {
    (yypParser->yytos) --;
    yyStackOverflow(yypParser);
    return;
  }
  if ((int )yyNewState > 542) {
    yyNewState = (unsigned short )((int )yyNewState + 384);
  }
  yytos = yypParser->yytos;
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor.yy0 = yyMinor;
  return;
}
}
static unsigned short const   yyRuleInfoLhs[381]  = 
  {      (unsigned short const   )183,      (unsigned short const   )183,      (unsigned short const   )182,      (unsigned short const   )184, 
        (unsigned short const   )185,      (unsigned short const   )185,      (unsigned short const   )185,      (unsigned short const   )185, 
        (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184, 
        (unsigned short const   )184,      (unsigned short const   )189,      (unsigned short const   )191,      (unsigned short const   )193, 
        (unsigned short const   )193,      (unsigned short const   )192,      (unsigned short const   )192,      (unsigned short const   )190, 
        (unsigned short const   )190,      (unsigned short const   )197,      (unsigned short const   )197,      (unsigned short const   )199, 
        (unsigned short const   )201,      (unsigned short const   )201,      (unsigned short const   )201,      (unsigned short const   )202, 
        (unsigned short const   )206,      (unsigned short const   )207,      (unsigned short const   )208,      (unsigned short const   )208, 
        (unsigned short const   )208,      (unsigned short const   )208,      (unsigned short const   )208,      (unsigned short const   )208, 
        (unsigned short const   )208,      (unsigned short const   )208,      (unsigned short const   )208,      (unsigned short const   )208, 
        (unsigned short const   )208,      (unsigned short const   )208,      (unsigned short const   )208,      (unsigned short const   )213, 
        (unsigned short const   )213,      (unsigned short const   )215,      (unsigned short const   )215,      (unsigned short const   )217, 
        (unsigned short const   )217,      (unsigned short const   )217,      (unsigned short const   )217,      (unsigned short const   )218, 
        (unsigned short const   )218,      (unsigned short const   )218,      (unsigned short const   )218,      (unsigned short const   )218, 
        (unsigned short const   )216,      (unsigned short const   )216,      (unsigned short const   )219,      (unsigned short const   )219, 
        (unsigned short const   )219,      (unsigned short const   )196,      (unsigned short const   )221,      (unsigned short const   )222, 
        (unsigned short const   )222,      (unsigned short const   )222,      (unsigned short const   )222,      (unsigned short const   )222, 
        (unsigned short const   )225,      (unsigned short const   )211,      (unsigned short const   )211,      (unsigned short const   )226, 
        (unsigned short const   )226,      (unsigned short const   )227,      (unsigned short const   )227,      (unsigned short const   )184, 
        (unsigned short const   )229,      (unsigned short const   )229,      (unsigned short const   )184,      (unsigned short const   )184, 
        (unsigned short const   )184,      (unsigned short const   )198,      (unsigned short const   )198,      (unsigned short const   )198, 
        (unsigned short const   )231,      (unsigned short const   )234,      (unsigned short const   )234,      (unsigned short const   )234, 
        (unsigned short const   )232,      (unsigned short const   )232,      (unsigned short const   )244,      (unsigned short const   )244, 
        (unsigned short const   )235,      (unsigned short const   )235,      (unsigned short const   )235,      (unsigned short const   )246, 
        (unsigned short const   )236,      (unsigned short const   )236,      (unsigned short const   )236,      (unsigned short const   )247, 
        (unsigned short const   )247,      (unsigned short const   )237,      (unsigned short const   )237,      (unsigned short const   )249, 
        (unsigned short const   )249,      (unsigned short const   )248,      (unsigned short const   )248,      (unsigned short const   )248, 
        (unsigned short const   )248,      (unsigned short const   )194,      (unsigned short const   )194,      (unsigned short const   )230, 
        (unsigned short const   )230,      (unsigned short const   )255,      (unsigned short const   )255,      (unsigned short const   )255, 
        (unsigned short const   )255,      (unsigned short const   )250,      (unsigned short const   )250,      (unsigned short const   )250, 
        (unsigned short const   )250,      (unsigned short const   )252,      (unsigned short const   )252,      (unsigned short const   )251, 
        (unsigned short const   )251,      (unsigned short const   )251,      (unsigned short const   )253,      (unsigned short const   )253, 
        (unsigned short const   )241,      (unsigned short const   )241,      (unsigned short const   )223,      (unsigned short const   )223, 
        (unsigned short const   )212,      (unsigned short const   )212,      (unsigned short const   )212,      (unsigned short const   )257, 
        (unsigned short const   )257,      (unsigned short const   )257,      (unsigned short const   )239,      (unsigned short const   )239, 
        (unsigned short const   )240,      (unsigned short const   )240,      (unsigned short const   )242,      (unsigned short const   )242, 
        (unsigned short const   )242,      (unsigned short const   )242,      (unsigned short const   )184,      (unsigned short const   )238, 
        (unsigned short const   )238,      (unsigned short const   )184,      (unsigned short const   )259,      (unsigned short const   )259, 
        (unsigned short const   )259,      (unsigned short const   )259,      (unsigned short const   )184,      (unsigned short const   )184, 
        (unsigned short const   )262,      (unsigned short const   )262,      (unsigned short const   )262,      (unsigned short const   )262, 
        (unsigned short const   )260,      (unsigned short const   )260,      (unsigned short const   )261,      (unsigned short const   )261, 
        (unsigned short const   )256,      (unsigned short const   )256,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )209, 
        (unsigned short const   )209,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )209,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )264, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )265,      (unsigned short const   )265,      (unsigned short const   )210, 
        (unsigned short const   )266,      (unsigned short const   )266,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210,      (unsigned short const   )210, 
        (unsigned short const   )269,      (unsigned short const   )269,      (unsigned short const   )270,      (unsigned short const   )270, 
        (unsigned short const   )268,      (unsigned short const   )268,      (unsigned short const   )254,      (unsigned short const   )245, 
        (unsigned short const   )245,      (unsigned short const   )267,      (unsigned short const   )267,      (unsigned short const   )184, 
        (unsigned short const   )271,      (unsigned short const   )271,      (unsigned short const   )214,      (unsigned short const   )214, 
        (unsigned short const   )224,      (unsigned short const   )224,      (unsigned short const   )272,      (unsigned short const   )272, 
        (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )273, 
        (unsigned short const   )273,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184, 
        (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )204,      (unsigned short const   )205, 
        (unsigned short const   )184,      (unsigned short const   )275,      (unsigned short const   )277,      (unsigned short const   )277, 
        (unsigned short const   )277,      (unsigned short const   )278,      (unsigned short const   )278,      (unsigned short const   )278, 
        (unsigned short const   )280,      (unsigned short const   )280,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )282,      (unsigned short const   )283,      (unsigned short const   )283,      (unsigned short const   )281, 
        (unsigned short const   )281,      (unsigned short const   )281,      (unsigned short const   )281,      (unsigned short const   )210, 
        (unsigned short const   )210,      (unsigned short const   )228,      (unsigned short const   )228,      (unsigned short const   )228, 
        (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )285, 
        (unsigned short const   )285,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184, 
        (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )286, 
        (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )184,      (unsigned short const   )288, 
        (unsigned short const   )290,      (unsigned short const   )291,      (unsigned short const   )291,      (unsigned short const   )292, 
        (unsigned short const   )258,      (unsigned short const   )258,      (unsigned short const   )233,      (unsigned short const   )233, 
        (unsigned short const   )294,      (unsigned short const   )294,      (unsigned short const   )295,      (unsigned short const   )296, 
        (unsigned short const   )296,      (unsigned short const   )296,      (unsigned short const   )296,      (unsigned short const   )296, 
        (unsigned short const   )296,      (unsigned short const   )297,      (unsigned short const   )297,      (unsigned short const   )297, 
        (unsigned short const   )301,      (unsigned short const   )303,      (unsigned short const   )303,      (unsigned short const   )304, 
        (unsigned short const   )304,      (unsigned short const   )302,      (unsigned short const   )302,      (unsigned short const   )305, 
        (unsigned short const   )305,      (unsigned short const   )306,      (unsigned short const   )306,      (unsigned short const   )306, 
        (unsigned short const   )243,      (unsigned short const   )263,      (unsigned short const   )263,      (unsigned short const   )263, 
        (unsigned short const   )300,      (unsigned short const   )300,      (unsigned short const   )299,      (unsigned short const   )179, 
        (unsigned short const   )180,      (unsigned short const   )180,      (unsigned short const   )181,      (unsigned short const   )181, 
        (unsigned short const   )181,      (unsigned short const   )186,      (unsigned short const   )186,      (unsigned short const   )186, 
        (unsigned short const   )188,      (unsigned short const   )188,      (unsigned short const   )184,      (unsigned short const   )195, 
        (unsigned short const   )195,      (unsigned short const   )187,      (unsigned short const   )187,      (unsigned short const   )187, 
        (unsigned short const   )201,      (unsigned short const   )202,      (unsigned short const   )203,      (unsigned short const   )203, 
        (unsigned short const   )200,      (unsigned short const   )200,      (unsigned short const   )208,      (unsigned short const   )196, 
        (unsigned short const   )220,      (unsigned short const   )220,      (unsigned short const   )221,      (unsigned short const   )225, 
        (unsigned short const   )227,      (unsigned short const   )231,      (unsigned short const   )232,      (unsigned short const   )246, 
        (unsigned short const   )247,      (unsigned short const   )210,      (unsigned short const   )264,      (unsigned short const   )254, 
        (unsigned short const   )274,      (unsigned short const   )274,      (unsigned short const   )274,      (unsigned short const   )274, 
        (unsigned short const   )274,      (unsigned short const   )204,      (unsigned short const   )279,      (unsigned short const   )279, 
        (unsigned short const   )282,      (unsigned short const   )283,      (unsigned short const   )284,      (unsigned short const   )284, 
        (unsigned short const   )287,      (unsigned short const   )287,      (unsigned short const   )289,      (unsigned short const   )289, 
        (unsigned short const   )290,      (unsigned short const   )293,      (unsigned short const   )293,      (unsigned short const   )293, 
        (unsigned short const   )258};
static signed char const   yyRuleInfoNRhs[381]  = 
  {      (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-1,      (signed char const   )-3, 
        (signed char const   )0,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-3, 
        (signed char const   )-5,      (signed char const   )-6,      (signed char const   )-1,      (signed char const   )0, 
        (signed char const   )-3,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )-5, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-2, 
        (signed char const   )0,      (signed char const   )-4,      (signed char const   )-6,      (signed char const   )-2, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-3, 
        (signed char const   )-4,      (signed char const   )-4,      (signed char const   )-4,      (signed char const   )-3, 
        (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-2,      (signed char const   )-4, 
        (signed char const   )-4,      (signed char const   )-1,      (signed char const   )-2,      (signed char const   )0, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-2, 
        (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-2, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-2, 
        (signed char const   )-3,      (signed char const   )-2,      (signed char const   )0,      (signed char const   )-2, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-1,      (signed char const   )-2, 
        (signed char const   )-7,      (signed char const   )-5,      (signed char const   )-5,      (signed char const   )-10, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )-3,      (signed char const   )0, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-4, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-9,      (signed char const   )-4, 
        (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-4,      (signed char const   )-1, 
        (signed char const   )-3,      (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-1, 
        (signed char const   )-9,      (signed char const   )-10,      (signed char const   )-4,      (signed char const   )-5, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )-5,      (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-2, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-2, 
        (signed char const   )0,      (signed char const   )-7,      (signed char const   )-9,      (signed char const   )-7, 
        (signed char const   )-7,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-1, 
        (signed char const   )-3,      (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-5, 
        (signed char const   )-3,      (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-3, 
        (signed char const   )-4,      (signed char const   )-2,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )-3,      (signed char const   )-2,      (signed char const   )-4,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-3, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )-2, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )0,      (signed char const   )-3, 
        (signed char const   )0,      (signed char const   )-2,      (signed char const   )0,      (signed char const   )-2, 
        (signed char const   )-4,      (signed char const   )-4,      (signed char const   )-6,      (signed char const   )0, 
        (signed char const   )-2,      (signed char const   )-8,      (signed char const   )-5,      (signed char const   )-7, 
        (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-7,      (signed char const   )-7, 
        (signed char const   )0,      (signed char const   )-11,      (signed char const   )-8,      (signed char const   )-4, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )-3, 
        (signed char const   )-3,      (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-3, 
        (signed char const   )-6,      (signed char const   )-5,      (signed char const   )-4,      (signed char const   )-6, 
        (signed char const   )-5,      (signed char const   )-1,      (signed char const   )-5,      (signed char const   )-3, 
        (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-3, 
        (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-2, 
        (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-2,      (signed char const   )-3, 
        (signed char const   )-3,      (signed char const   )-4,      (signed char const   )-2,      (signed char const   )-2, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-5, 
        (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-5,      (signed char const   )-3, 
        (signed char const   )-5,      (signed char const   )-5,      (signed char const   )-4,      (signed char const   )-5, 
        (signed char const   )-5,      (signed char const   )-4,      (signed char const   )-2,      (signed char const   )0, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )0,      (signed char const   )-3, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )-3,      (signed char const   )-12, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )0,      (signed char const   )-3, 
        (signed char const   )-5,      (signed char const   )-3,      (signed char const   )0,      (signed char const   )-2, 
        (signed char const   )-4,      (signed char const   )-2,      (signed char const   )-3,      (signed char const   )-2, 
        (signed char const   )0,      (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-6, 
        (signed char const   )-5,      (signed char const   )-6,      (signed char const   )-2,      (signed char const   )-2, 
        (signed char const   )-5,      (signed char const   )-11,      (signed char const   )-1,      (signed char const   )-2, 
        (signed char const   )0,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-3, 
        (signed char const   )0,      (signed char const   )-2,      (signed char const   )-3,      (signed char const   )-2, 
        (signed char const   )-3,      (signed char const   )-3,      (signed char const   )-2,      (signed char const   )-8, 
        (signed char const   )-8,      (signed char const   )-6,      (signed char const   )-3,      (signed char const   )-4, 
        (signed char const   )-6,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-4,      (signed char const   )-6,      (signed char const   )-3,      (signed char const   )0, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-1, 
        (signed char const   )-3,      (signed char const   )-6,      (signed char const   )-7,      (signed char const   )-1, 
        (signed char const   )-8,      (signed char const   )-1,      (signed char const   )-4,      (signed char const   )-8, 
        (signed char const   )0,      (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-3,      (signed char const   )-6,      (signed char const   )-8, 
        (signed char const   )-1,      (signed char const   )-3,      (signed char const   )-5,      (signed char const   )-5, 
        (signed char const   )-6,      (signed char const   )-4,      (signed char const   )-5,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-3,      (signed char const   )-6, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-2,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-2,      (signed char const   )0, 
        (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-4,      (signed char const   )-2,      (signed char const   )-5,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-2, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-1,      (signed char const   )-2, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-4, 
        (signed char const   )-2,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-2,      (signed char const   )-2, 
        (signed char const   )-3,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-2, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )-3, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )-1,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-3, 
        (signed char const   )-2,      (signed char const   )0,      (signed char const   )-4,      (signed char const   )-2, 
        (signed char const   )0};
static void yy_accept(yyParser *yypParser ) ;
static unsigned short yy_reduce(yyParser *yypParser , unsigned int yyruleno , int yyLookahead ,
                                Token yyLookaheadToken , Parse *pParse ) 
{ 
  int yygoto ;
  unsigned short yyact ;
  yyStackEntry *yymsp ;
  int yysize ;
  YYMINORTYPE yylhsminor ;
  int tmp ;
  Expr *p ;
  Expr *tmp___0 ;
  Expr *p___0 ;
  Expr *tmp___1 ;
  SelectDest dest ;
  Select *p___1 ;
  Select *p___2 ;
  Select *p___3 ;
  Select *pRhs ;
  Select *pLhs ;
  SrcList *pFrom ;
  Token x___0 ;
  Select *pRight ;
  Select *pLeft ;
  Expr *p___4 ;
  Expr *tmp___2 ;
  Expr *pRight___0 ;
  Expr *tmp___3 ;
  Expr *pLeft___0 ;
  Expr *tmp___4 ;
  Expr *pDot ;
  Expr *tmp___5 ;
  void *tmp___6 ;
  struct SrcList_item *pNew ;
  struct SrcList_item *pOld ;
  char *tmp___7 ;
  Select *pSubquery ;
  Expr *temp1 ;
  Expr *tmp___8 ;
  Expr *temp2 ;
  Expr *tmp___9 ;
  Expr *temp1___0 ;
  Expr *tmp___10 ;
  Expr *temp2___0 ;
  Expr *tmp___11 ;
  Expr *temp3 ;
  Expr *tmp___12 ;
  Expr *temp4 ;
  Expr *tmp___13 ;
  u32 n ;
  Token t ;
  ExprList *pList ;
  ExprList *tmp___14 ;
  ExprList *pList___0 ;
  int bNot ;
  ExprList *pList___1 ;
  int bNot___0 ;
  int tmp___15 ;
  ExprList *pList___2 ;
  ExprList *tmp___16 ;
  char const   *tmp___17 ;
  SrcList *pSrc ;
  SrcList *tmp___18 ;
  Select *pSelect ;
  Select *tmp___19 ;
  SrcList *tmp___20 ;
  Expr *p___5 ;
  Expr *tmp___21 ;
  ExprList *tmp___22 ;
  SrcList *tmp___23 ;
  Token all ;
  void *tmp___24 ;
  void *tmp___25 ;

  {
  yymsp = yypParser->yytos;
  if ((int const   )yyRuleInfoNRhs[yyruleno] == 0) {
    if ((unsigned long )yypParser->yytos >= (unsigned long )yypParser->yystackEnd) {
      yyStackOverflow(yypParser);
      return ((unsigned short)0);
    }
  }
  switch (yyruleno) {
  case 0U: 
  pParse->explain = (u8 )1;
  break;
  case 1U: 
  pParse->explain = (u8 )2;
  break;
  case 2U: 
  sqlite3FinishCoding(pParse);
  break;
  case 3U: 
  sqlite3BeginTransaction(pParse, (yymsp + -1)->minor.yy32);
  break;
  case 4U: 
  (yymsp + 1)->minor.yy32 = 7;
  break;
  case 6U: 
  case 5U: ;
  case 7U: ;
  case 304U: 
  (yymsp + 0)->minor.yy32 = (int )(yymsp + 0)->major;
  break;
  case 9U: 
  case 8U: 
  sqlite3EndTransaction(pParse, (int )(yymsp + -1)->major);
  break;
  case 10U: 
  sqlite3Savepoint(pParse, 0, & (yymsp + 0)->minor.yy0);
  break;
  case 11U: 
  sqlite3Savepoint(pParse, 1, & (yymsp + 0)->minor.yy0);
  break;
  case 12U: 
  sqlite3Savepoint(pParse, 2, & (yymsp + 0)->minor.yy0);
  break;
  case 13U: 
  sqlite3StartTable(pParse, & (yymsp + -1)->minor.yy0, & (yymsp + 0)->minor.yy0, (yymsp + -4)->minor.yy32,
                    0, 0, (yymsp + -2)->minor.yy32);
  break;
  case 14U: 
  disableLookaside(pParse);
  break;
  case 18U: 
  case 15U: ;
  case 21U: ;
  case 43U: ;
  case 58U: ;
  case 68U: ;
  case 77U: ;
  case 94U: ;
  case 230U: 
  (yymsp + 1)->minor.yy32 = 0;
  break;
  case 16U: 
  (yymsp + -2)->minor.yy32 = 1;
  break;
  case 44U: 
  case 17U: 
  (yymsp + 0)->minor.yy32 = 1;
  break;
  case 19U: 
  sqlite3EndTable(pParse, & (yymsp + -2)->minor.yy0, & (yymsp + -1)->minor.yy0, (u8 )(yymsp + 0)->minor.yy32,
                  (Select *)0);
  break;
  case 20U: 
  sqlite3EndTable(pParse, (Token *)0, (Token *)0, (u8 )0, (yymsp + 0)->minor.yy25);
  sqlite3SelectDelete(pParse->db, (yymsp + 0)->minor.yy25);
  break;
  case 22U: 
  if ((yymsp + 0)->minor.yy0.n == 5U) {
    tmp = sqlite3_strnicmp((yymsp + 0)->minor.yy0.z, "rowid", 5);
    if (tmp == 0) {
      (yymsp + -1)->minor.yy32 = 96;
    } else {
      (yymsp + -1)->minor.yy32 = 0;
      sqlite3ErrorMsg(pParse, "unknown table option: %.*s", (yymsp + 0)->minor.yy0.n,
                      (yymsp + 0)->minor.yy0.z);
    }
  } else {
    (yymsp + -1)->minor.yy32 = 0;
    sqlite3ErrorMsg(pParse, "unknown table option: %.*s", (yymsp + 0)->minor.yy0.n,
                    (yymsp + 0)->minor.yy0.z);
  }
  break;
  case 23U: 
  sqlite3AddColumn(pParse, & (yymsp + -1)->minor.yy0, & (yymsp + 0)->minor.yy0);
  break;
  case 61U: 
  case 24U: ;
  case 100U: 
  (yymsp + 1)->minor.yy0.n = 0U;
  (yymsp + 1)->minor.yy0.z = (char const   *)0;
  break;
  case 25U: 
  (yymsp + -3)->minor.yy0.n = (unsigned int )((int )(((yymsp + 0)->minor.yy0.z + (yymsp + 0)->minor.yy0.n) - (yymsp + -3)->minor.yy0.z));
  break;
  case 26U: 
  (yymsp + -5)->minor.yy0.n = (unsigned int )((int )(((yymsp + 0)->minor.yy0.z + (yymsp + 0)->minor.yy0.n) - (yymsp + -5)->minor.yy0.z));
  break;
  case 27U: 
  (yymsp + -1)->minor.yy0.n = (yymsp + 0)->minor.yy0.n + (unsigned int )((int )((yymsp + 0)->minor.yy0.z - (yymsp + -1)->minor.yy0.z));
  break;
  case 28U: 
  (yymsp + 1)->minor.yy8 = yyLookaheadToken.z;
  break;
  case 29U: 
  (yymsp + 1)->minor.yy0 = yyLookaheadToken;
  break;
  case 63U: 
  case 30U: 
  pParse->constraintName = (yymsp + 0)->minor.yy0;
  break;
  case 31U: 
  sqlite3AddDefaultValue(pParse, (yymsp + 0)->minor.yy46, (yymsp + -1)->minor.yy0.z,
                         (yymsp + -1)->minor.yy0.z + (yymsp + -1)->minor.yy0.n);
  break;
  case 32U: 
  sqlite3AddDefaultValue(pParse, (yymsp + -1)->minor.yy46, (yymsp + -2)->minor.yy0.z + 1,
                         (yymsp + 0)->minor.yy0.z);
  break;
  case 33U: 
  sqlite3AddDefaultValue(pParse, (yymsp + 0)->minor.yy46, (yymsp + -2)->minor.yy0.z,
                         (yymsp + -1)->minor.yy0.z + (yymsp + -1)->minor.yy0.n);
  break;
  case 34U: 
  tmp___0 = sqlite3PExpr(pParse, 168, (yymsp + 0)->minor.yy46, (Expr *)0);
  p = tmp___0;
  sqlite3AddDefaultValue(pParse, p, (yymsp + -2)->minor.yy0.z, (yymsp + -1)->minor.yy0.z + (yymsp + -1)->minor.yy0.n);
  break;
  case 35U: 
  tmp___1 = tokenExpr(pParse, 113, (yymsp + 0)->minor.yy0);
  p___0 = tmp___1;
  if (p___0) {
    sqlite3ExprIdToTrueFalse(p___0);
  }
  sqlite3AddDefaultValue(pParse, p___0, (yymsp + 0)->minor.yy0.z, (yymsp + 0)->minor.yy0.z + (yymsp + 0)->minor.yy0.n);
  break;
  case 36U: 
  sqlite3AddNotNull(pParse, (yymsp + 0)->minor.yy32);
  break;
  case 37U: 
  sqlite3AddPrimaryKey(pParse, (ExprList *)0, (yymsp + -1)->minor.yy32, (yymsp + 0)->minor.yy32,
                       (yymsp + -2)->minor.yy32);
  break;
  case 38U: 
  sqlite3CreateIndex(pParse, (Token *)0, (Token *)0, (SrcList *)0, (ExprList *)0,
                     (yymsp + 0)->minor.yy32, (Token *)0, (Expr *)0, 0, 0, (u8 )1);
  break;
  case 39U: 
  sqlite3AddCheckConstraint(pParse, (yymsp + -1)->minor.yy46);
  break;
  case 40U: 
  sqlite3CreateForeignKey(pParse, (ExprList *)0, & (yymsp + -2)->minor.yy0, (yymsp + -1)->minor.yy138,
                          (yymsp + 0)->minor.yy32);
  break;
  case 41U: 
  sqlite3DeferForeignKey(pParse, (yymsp + 0)->minor.yy32);
  break;
  case 42U: 
  sqlite3AddCollateType(pParse, & (yymsp + 0)->minor.yy0);
  break;
  case 45U: 
  (yymsp + 1)->minor.yy32 = 0;
  break;
  case 46U: 
  (yymsp + -1)->minor.yy32 = ((yymsp + -1)->minor.yy32 & ~ (yymsp + 0)->minor.yy495.mask) | (yymsp + 0)->minor.yy495.value;
  break;
  case 47U: 
  (yymsp + -1)->minor.yy495.value = 0;
  (yymsp + -1)->minor.yy495.mask = 0;
  break;
  case 48U: 
  (yymsp + -2)->minor.yy495.value = 0;
  (yymsp + -2)->minor.yy495.mask = 0;
  break;
  case 49U: 
  (yymsp + -2)->minor.yy495.value = (yymsp + 0)->minor.yy32;
  (yymsp + -2)->minor.yy495.mask = 255;
  break;
  case 50U: 
  (yymsp + -2)->minor.yy495.value = (yymsp + 0)->minor.yy32 << 8;
  (yymsp + -2)->minor.yy495.mask = 65280;
  break;
  case 51U: 
  (yymsp + -1)->minor.yy32 = 8;
  break;
  case 52U: 
  (yymsp + -1)->minor.yy32 = 9;
  break;
  case 53U: 
  (yymsp + 0)->minor.yy32 = 10;
  break;
  case 54U: 
  (yymsp + 0)->minor.yy32 = 7;
  break;
  case 55U: 
  (yymsp + -1)->minor.yy32 = 0;
  break;
  case 56U: 
  (yymsp + -2)->minor.yy32 = 0;
  break;
  case 72U: 
  case 57U: ;
  case 160U: 
  (yymsp + -1)->minor.yy32 = (yymsp + 0)->minor.yy32;
  break;
  case 76U: 
  case 59U: ;
  case 202U: ;
  case 205U: ;
  case 231U: 
  (yymsp + -1)->minor.yy32 = 1;
  break;
  case 60U: 
  (yymsp + -1)->minor.yy32 = 0;
  break;
  case 62U: 
  pParse->constraintName.n = 0U;
  break;
  case 64U: 
  sqlite3AddPrimaryKey(pParse, (yymsp + -3)->minor.yy138, (yymsp + 0)->minor.yy32,
                       (yymsp + -2)->minor.yy32, 0);
  break;
  case 65U: 
  sqlite3CreateIndex(pParse, (Token *)0, (Token *)0, (SrcList *)0, (yymsp + -2)->minor.yy138,
                     (yymsp + 0)->minor.yy32, (Token *)0, (Expr *)0, 0, 0, (u8 )1);
  break;
  case 66U: 
  sqlite3AddCheckConstraint(pParse, (yymsp + -2)->minor.yy46);
  break;
  case 67U: 
  sqlite3CreateForeignKey(pParse, (yymsp + -6)->minor.yy138, & (yymsp + -3)->minor.yy0,
                          (yymsp + -2)->minor.yy138, (yymsp + -1)->minor.yy32);
  sqlite3DeferForeignKey(pParse, (yymsp + 0)->minor.yy32);
  break;
  case 71U: 
  case 69U: 
  (yymsp + 1)->minor.yy32 = 11;
  break;
  case 70U: 
  (yymsp + -2)->minor.yy32 = (yymsp + 0)->minor.yy32;
  break;
  case 73U: 
  (yymsp + 0)->minor.yy32 = 4;
  break;
  case 161U: 
  case 74U: 
  (yymsp + 0)->minor.yy32 = 5;
  break;
  case 75U: 
  sqlite3DropTable(pParse, (yymsp + 0)->minor.yy609, 0, (yymsp + -1)->minor.yy32);
  break;
  case 78U: 
  sqlite3CreateView(pParse, & (yymsp + -8)->minor.yy0, & (yymsp + -4)->minor.yy0,
                    & (yymsp + -3)->minor.yy0, (yymsp + -2)->minor.yy138, (yymsp + 0)->minor.yy25,
                    (yymsp + -7)->minor.yy32, (yymsp + -5)->minor.yy32);
  break;
  case 79U: 
  sqlite3DropTable(pParse, (yymsp + 0)->minor.yy609, 1, (yymsp + -1)->minor.yy32);
  break;
  case 80U: 
  dest.eDest = (u8 )9;
  dest.iSDParm = 0;
  dest.iSdst = 0;
  dest.nSdst = 0;
  dest.zAffSdst = (char *)0;
  dest.pOrderBy = (ExprList *)0;
  sqlite3Select(pParse, (yymsp + 0)->minor.yy25, & dest);
  sqlite3SelectDelete(pParse->db, (yymsp + 0)->minor.yy25);
  break;
  case 81U: 
  p___1 = (yymsp + 0)->minor.yy25;
  if (p___1) {
    p___1->pWith = (yymsp + -1)->minor.yy297;
    parserDoubleLinkSelect(pParse, p___1);
  } else {
    sqlite3WithDelete(pParse->db, (yymsp + -1)->minor.yy297);
  }
  (yymsp + -2)->minor.yy25 = p___1;
  break;
  case 82U: 
  p___2 = (yymsp + 0)->minor.yy25;
  if (p___2) {
    p___2->pWith = (yymsp + -1)->minor.yy297;
    parserDoubleLinkSelect(pParse, p___2);
  } else {
    sqlite3WithDelete(pParse->db, (yymsp + -1)->minor.yy297);
  }
  (yymsp + -3)->minor.yy25 = p___2;
  break;
  case 83U: 
  p___3 = (yymsp + 0)->minor.yy25;
  if (p___3) {
    parserDoubleLinkSelect(pParse, p___3);
  }
  (yymsp + 0)->minor.yy25 = p___3;
  break;
  case 84U: 
  pRhs = (yymsp + 0)->minor.yy25;
  pLhs = (yymsp + -2)->minor.yy25;
  if (pRhs) {
    if (pRhs->pPrior) {
      x___0.n = 0U;
      parserDoubleLinkSelect(pParse, pRhs);
      pFrom = sqlite3SrcListAppendFromTerm(pParse, (SrcList *)0, (Token *)0, (Token *)0,
                                           & x___0, pRhs, (Expr *)0, (IdList *)0);
      pRhs = sqlite3SelectNew(pParse, (ExprList *)0, pFrom, (Expr *)0, (ExprList *)0,
                              (Expr *)0, (ExprList *)0, (u32 )0, (Expr *)0);
    }
  }
  if (pRhs) {
    pRhs->op = (u8 )(yymsp + -1)->minor.yy32;
    pRhs->pPrior = pLhs;
    if (pLhs) {
      pLhs->selFlags &= 4294966271U;
    }
    pRhs->selFlags &= 4294966271U;
    if ((yymsp + -1)->minor.yy32 != 131) {
      pParse->hasCompound = (u8 )1;
    }
  } else {
    sqlite3SelectDelete(pParse->db, pLhs);
  }
  (yymsp + -2)->minor.yy25 = pRhs;
  break;
  case 87U: 
  case 85U: 
  (yymsp + 0)->minor.yy32 = (int )(yymsp + 0)->major;
  break;
  case 86U: 
  (yymsp + -1)->minor.yy32 = 131;
  break;
  case 88U: 
  (yymsp + -8)->minor.yy25 = sqlite3SelectNew(pParse, (yymsp + -6)->minor.yy138, (yymsp + -5)->minor.yy609,
                                              (yymsp + -4)->minor.yy46, (yymsp + -3)->minor.yy138,
                                              (yymsp + -2)->minor.yy46, (yymsp + -1)->minor.yy138,
                                              (u32 )(yymsp + -7)->minor.yy32, (yymsp + 0)->minor.yy46);
  break;
  case 89U: 
  (yymsp + -9)->minor.yy25 = sqlite3SelectNew(pParse, (yymsp + -7)->minor.yy138, (yymsp + -6)->minor.yy609,
                                              (yymsp + -5)->minor.yy46, (yymsp + -4)->minor.yy138,
                                              (yymsp + -3)->minor.yy46, (yymsp + -1)->minor.yy138,
                                              (u32 )(yymsp + -8)->minor.yy32, (yymsp + 0)->minor.yy46);
  if ((yymsp + -9)->minor.yy25) {
    ((yymsp + -9)->minor.yy25)->pWinDefn = (yymsp + -2)->minor.yy455;
  } else {
    sqlite3WindowListDelete(pParse->db, (yymsp + -2)->minor.yy455);
  }
  break;
  case 90U: 
  (yymsp + -3)->minor.yy25 = sqlite3SelectNew(pParse, (yymsp + -1)->minor.yy138, (SrcList *)0,
                                              (Expr *)0, (ExprList *)0, (Expr *)0,
                                              (ExprList *)0, (u32 )512, (Expr *)0);
  break;
  case 91U: 
  pLeft = (yymsp + -4)->minor.yy25;
  pRight = sqlite3SelectNew(pParse, (yymsp + -1)->minor.yy138, (SrcList *)0, (Expr *)0,
                            (ExprList *)0, (Expr *)0, (ExprList *)0, (u32 )1536, (Expr *)0);
  if (pLeft) {
    pLeft->selFlags &= 4294966271U;
  }
  if (pRight) {
    pRight->op = (u8 )131;
    pRight->pPrior = pLeft;
    (yymsp + -4)->minor.yy25 = pRight;
  } else {
    (yymsp + -4)->minor.yy25 = pLeft;
  }
  break;
  case 92U: 
  (yymsp + 0)->minor.yy32 = 1;
  break;
  case 93U: 
  (yymsp + 0)->minor.yy32 = 2;
  break;
  case 128U: 
  case 95U: ;
  case 138U: ;
  case 218U: ;
  case 221U: ;
  case 226U: 
  (yymsp + 1)->minor.yy138 = (ExprList *)0;
  break;
  case 96U: 
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -4)->minor.yy138,
                                                    (yymsp + -2)->minor.yy46);
  if ((yymsp + 0)->minor.yy0.n > 0U) {
    sqlite3ExprListSetName(pParse, (yymsp + -4)->minor.yy138, & (yymsp + 0)->minor.yy0,
                           1);
  }
  sqlite3ExprListSetSpan(pParse, (yymsp + -4)->minor.yy138, (yymsp + -3)->minor.yy8,
                         (yymsp + -1)->minor.yy8);
  break;
  case 97U: 
  tmp___2 = sqlite3Expr(pParse->db, 175, (char const   *)0);
  p___4 = tmp___2;
  (yymsp + -2)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -2)->minor.yy138,
                                                    p___4);
  break;
  case 98U: 
  tmp___3 = sqlite3PExpr(pParse, 175, (Expr *)0, (Expr *)0);
  pRight___0 = tmp___3;
  tmp___4 = sqlite3ExprAlloc(pParse->db, 59, (Token const   *)(& (yymsp + -2)->minor.yy0),
                             1);
  pLeft___0 = tmp___4;
  tmp___5 = sqlite3PExpr(pParse, 137, pLeft___0, pRight___0);
  pDot = tmp___5;
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -4)->minor.yy138,
                                                    pDot);
  break;
  case 110U: 
  case 99U: ;
  case 242U: ;
  case 243U: 
  (yymsp + -1)->minor.yy0 = (yymsp + 0)->minor.yy0;
  break;
  case 101U: 
  tmp___6 = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(*((yymsp + 1)->minor.yy609)));
  (yymsp + 1)->minor.yy609 = (SrcList *)tmp___6;
  break;
  case 102U: 
  (yymsp + -1)->minor.yy609 = (yymsp + 0)->minor.yy609;
  sqlite3SrcListShiftJoinType((yymsp + -1)->minor.yy609);
  break;
  case 103U: 
  if ((yymsp + -1)->minor.yy609) {
    if (((yymsp + -1)->minor.yy609)->nSrc > 0) {
      ((yymsp + -1)->minor.yy609)->a[((yymsp + -1)->minor.yy609)->nSrc - 1].fg.jointype = (u8 )(yymsp + 0)->minor.yy32;
    }
  }
  break;
  case 104U: 
  (yymsp + 1)->minor.yy609 = (SrcList *)0;
  break;
  case 105U: 
  (yymsp + -6)->minor.yy609 = sqlite3SrcListAppendFromTerm(pParse, (yymsp + -6)->minor.yy609,
                                                           & (yymsp + -5)->minor.yy0,
                                                           & (yymsp + -4)->minor.yy0,
                                                           & (yymsp + -3)->minor.yy0,
                                                           (Select *)0, (yymsp + -1)->minor.yy46,
                                                           (yymsp + 0)->minor.yy406);
  sqlite3SrcListIndexedBy(pParse, (yymsp + -6)->minor.yy609, & (yymsp + -2)->minor.yy0);
  break;
  case 106U: 
  (yymsp + -8)->minor.yy609 = sqlite3SrcListAppendFromTerm(pParse, (yymsp + -8)->minor.yy609,
                                                           & (yymsp + -7)->minor.yy0,
                                                           & (yymsp + -6)->minor.yy0,
                                                           & (yymsp + -2)->minor.yy0,
                                                           (Select *)0, (yymsp + -1)->minor.yy46,
                                                           (yymsp + 0)->minor.yy406);
  sqlite3SrcListFuncArgs(pParse, (yymsp + -8)->minor.yy609, (yymsp + -4)->minor.yy138);
  break;
  case 107U: 
  (yymsp + -6)->minor.yy609 = sqlite3SrcListAppendFromTerm(pParse, (yymsp + -6)->minor.yy609,
                                                           (Token *)0, (Token *)0,
                                                           & (yymsp + -2)->minor.yy0,
                                                           (yymsp + -4)->minor.yy25,
                                                           (yymsp + -1)->minor.yy46,
                                                           (yymsp + 0)->minor.yy406);
  break;
  case 108U: 
  if ((unsigned long )(yymsp + -6)->minor.yy609 == (unsigned long )((SrcList *)0)) {
    if ((yymsp + -2)->minor.yy0.n == 0U) {
      if ((unsigned long )(yymsp + -1)->minor.yy46 == (unsigned long )((Expr *)0)) {
        if ((unsigned long )(yymsp + 0)->minor.yy406 == (unsigned long )((IdList *)0)) {
          (yymsp + -6)->minor.yy609 = (yymsp + -4)->minor.yy609;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (((yymsp + -4)->minor.yy609)->nSrc == 1) {
    (yymsp + -6)->minor.yy609 = sqlite3SrcListAppendFromTerm(pParse, (yymsp + -6)->minor.yy609,
                                                             (Token *)0, (Token *)0,
                                                             & (yymsp + -2)->minor.yy0,
                                                             (Select *)0, (yymsp + -1)->minor.yy46,
                                                             (yymsp + 0)->minor.yy406);
    if ((yymsp + -6)->minor.yy609) {
      pNew = & ((yymsp + -6)->minor.yy609)->a[((yymsp + -6)->minor.yy609)->nSrc - 1];
      pOld = ((yymsp + -4)->minor.yy609)->a;
      pNew->zName = pOld->zName;
      pNew->zDatabase = pOld->zDatabase;
      pNew->pSelect = pOld->pSelect;
      if (pOld->fg.isTabFunc) {
        pNew->u1.pFuncArg = pOld->u1.pFuncArg;
        pOld->u1.pFuncArg = (ExprList *)0;
        pOld->fg.isTabFunc = 0U;
        pNew->fg.isTabFunc = 1U;
      }
      tmp___7 = (char *)0;
      pOld->zDatabase = tmp___7;
      pOld->zName = tmp___7;
      pOld->pSelect = (Select *)0;
    }
    sqlite3SrcListDelete(pParse->db, (yymsp + -4)->minor.yy609);
  } else {
    sqlite3SrcListShiftJoinType((yymsp + -4)->minor.yy609);
    pSubquery = sqlite3SelectNew(pParse, (ExprList *)0, (yymsp + -4)->minor.yy609,
                                 (Expr *)0, (ExprList *)0, (Expr *)0, (ExprList *)0,
                                 (u32 )2048, (Expr *)0);
    (yymsp + -6)->minor.yy609 = sqlite3SrcListAppendFromTerm(pParse, (yymsp + -6)->minor.yy609,
                                                             (Token *)0, (Token *)0,
                                                             & (yymsp + -2)->minor.yy0,
                                                             pSubquery, (yymsp + -1)->minor.yy46,
                                                             (yymsp + 0)->minor.yy406);
  }
  break;
  case 123U: 
  case 109U: 
  (yymsp + 1)->minor.yy0.z = (char const   *)0;
  (yymsp + 1)->minor.yy0.n = 0U;
  break;
  case 111U: 
  yylhsminor.yy609 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + 0)->minor.yy0,
                                          (Token *)0);
  if ((int )pParse->eParseMode >= 2) {
    if (yylhsminor.yy609) {
      sqlite3RenameTokenMap(pParse, (void *)(yylhsminor.yy609)->a[0].zName, & (yymsp + 0)->minor.yy0);
    }
  }
  (yymsp + 0)->minor.yy609 = yylhsminor.yy609;
  break;
  case 112U: 
  yylhsminor.yy609 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + -2)->minor.yy0,
                                          & (yymsp + 0)->minor.yy0);
  if ((int )pParse->eParseMode >= 2) {
    if (yylhsminor.yy609) {
      sqlite3RenameTokenMap(pParse, (void *)(yylhsminor.yy609)->a[0].zName, & (yymsp + 0)->minor.yy0);
    }
  }
  (yymsp + -2)->minor.yy609 = yylhsminor.yy609;
  break;
  case 113U: 
  (yymsp + 0)->minor.yy609 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + 0)->minor.yy0,
                                                  (Token *)0);
  break;
  case 114U: 
  (yymsp + -2)->minor.yy609 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + -2)->minor.yy0,
                                                   & (yymsp + 0)->minor.yy0);
  break;
  case 115U: 
  (yymsp + -4)->minor.yy609 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + -4)->minor.yy0,
                                                   & (yymsp + -2)->minor.yy0);
  if ((yymsp + -4)->minor.yy609) {
    ((yymsp + -4)->minor.yy609)->a[0].zAlias = sqlite3NameFromToken(pParse->db, & (yymsp + 0)->minor.yy0);
  }
  break;
  case 116U: 
  (yymsp + -2)->minor.yy609 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + -2)->minor.yy0,
                                                   (Token *)0);
  if ((yymsp + -2)->minor.yy609) {
    ((yymsp + -2)->minor.yy609)->a[0].zAlias = sqlite3NameFromToken(pParse->db, & (yymsp + 0)->minor.yy0);
  }
  break;
  case 117U: 
  (yymsp + 0)->minor.yy32 = 1;
  break;
  case 118U: 
  (yymsp + -1)->minor.yy32 = sqlite3JoinType(pParse, & (yymsp + -1)->minor.yy0, (Token *)0,
                                             (Token *)0);
  break;
  case 119U: 
  (yymsp + -2)->minor.yy32 = sqlite3JoinType(pParse, & (yymsp + -2)->minor.yy0, & (yymsp + -1)->minor.yy0,
                                             (Token *)0);
  break;
  case 120U: 
  (yymsp + -3)->minor.yy32 = sqlite3JoinType(pParse, & (yymsp + -3)->minor.yy0, & (yymsp + -2)->minor.yy0,
                                             & (yymsp + -1)->minor.yy0);
  break;
  case 141U: 
  case 121U: ;
  case 148U: ;
  case 214U: ;
  case 235U: 
  (yymsp + -1)->minor.yy46 = (yymsp + 0)->minor.yy46;
  break;
  case 140U: 
  case 122U: ;
  case 142U: ;
  case 147U: ;
  case 215U: ;
  case 217U: ;
  case 236U: 
  (yymsp + 1)->minor.yy46 = (Expr *)0;
  break;
  case 124U: 
  (yymsp + -2)->minor.yy0 = (yymsp + 0)->minor.yy0;
  break;
  case 125U: 
  (yymsp + -1)->minor.yy0.z = (char const   *)0;
  (yymsp + -1)->minor.yy0.n = 1U;
  break;
  case 126U: 
  (yymsp + -3)->minor.yy406 = (yymsp + -1)->minor.yy406;
  break;
  case 162U: 
  case 127U: 
  (yymsp + 1)->minor.yy406 = (IdList *)0;
  break;
  case 139U: 
  case 129U: 
  (yymsp + -2)->minor.yy138 = (yymsp + 0)->minor.yy138;
  break;
  case 130U: 
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -4)->minor.yy138,
                                                    (yymsp + -2)->minor.yy46);
  sqlite3ExprListSetSortOrder((yymsp + -4)->minor.yy138, (yymsp + -1)->minor.yy32,
                              (yymsp + 0)->minor.yy32);
  break;
  case 131U: 
  (yymsp + -2)->minor.yy138 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + -2)->minor.yy46);
  sqlite3ExprListSetSortOrder((yymsp + -2)->minor.yy138, (yymsp + -1)->minor.yy32,
                              (yymsp + 0)->minor.yy32);
  break;
  case 132U: 
  (yymsp + 0)->minor.yy32 = 0;
  break;
  case 133U: 
  (yymsp + 0)->minor.yy32 = 1;
  break;
  case 137U: 
  case 134U: 
  (yymsp + 1)->minor.yy32 = -1;
  break;
  case 135U: 
  (yymsp + -1)->minor.yy32 = 0;
  break;
  case 136U: 
  (yymsp + -1)->minor.yy32 = 1;
  break;
  case 143U: 
  (yymsp + -1)->minor.yy46 = sqlite3PExpr(pParse, 144, (yymsp + 0)->minor.yy46, (Expr *)0);
  break;
  case 144U: 
  (yymsp + -3)->minor.yy46 = sqlite3PExpr(pParse, 144, (yymsp + -2)->minor.yy46, (yymsp + 0)->minor.yy46);
  break;
  case 145U: 
  (yymsp + -3)->minor.yy46 = sqlite3PExpr(pParse, 144, (yymsp + 0)->minor.yy46, (yymsp + -2)->minor.yy46);
  break;
  case 146U: 
  sqlite3SrcListIndexedBy(pParse, (yymsp + -2)->minor.yy609, & (yymsp + -1)->minor.yy0);
  sqlite3DeleteFrom(pParse, (yymsp + -2)->minor.yy609, (yymsp + 0)->minor.yy46, (ExprList *)0,
                    (Expr *)0);
  break;
  case 149U: 
  sqlite3SrcListIndexedBy(pParse, (yymsp + -4)->minor.yy609, & (yymsp + -3)->minor.yy0);
  sqlite3ExprListCheckLength(pParse, (yymsp + -1)->minor.yy138, "set list");
  sqlite3Update(pParse, (yymsp + -4)->minor.yy609, (yymsp + -1)->minor.yy138, (yymsp + 0)->minor.yy46,
                (yymsp + -5)->minor.yy32, (ExprList *)0, (Expr *)0, (Upsert *)0);
  break;
  case 150U: 
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -4)->minor.yy138,
                                                    (yymsp + 0)->minor.yy46);
  sqlite3ExprListSetName(pParse, (yymsp + -4)->minor.yy138, & (yymsp + -2)->minor.yy0,
                         1);
  break;
  case 151U: 
  (yymsp + -6)->minor.yy138 = sqlite3ExprListAppendVector(pParse, (yymsp + -6)->minor.yy138,
                                                          (yymsp + -3)->minor.yy406,
                                                          (yymsp + 0)->minor.yy46);
  break;
  case 152U: 
  yylhsminor.yy138 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + 0)->minor.yy46);
  sqlite3ExprListSetName(pParse, yylhsminor.yy138, & (yymsp + -2)->minor.yy0, 1);
  (yymsp + -2)->minor.yy138 = yylhsminor.yy138;
  break;
  case 153U: 
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppendVector(pParse, (ExprList *)0, (yymsp + -3)->minor.yy406,
                                                          (yymsp + 0)->minor.yy46);
  break;
  case 154U: 
  sqlite3Insert(pParse, (yymsp + -3)->minor.yy609, (yymsp + -1)->minor.yy25, (yymsp + -2)->minor.yy406,
                (yymsp + -5)->minor.yy32, (yymsp + 0)->minor.yy288);
  break;
  case 155U: 
  sqlite3Insert(pParse, (yymsp + -3)->minor.yy609, (Select *)0, (yymsp + -2)->minor.yy406,
                (yymsp + -5)->minor.yy32, (Upsert *)0);
  break;
  case 156U: 
  (yymsp + 1)->minor.yy288 = (Upsert *)0;
  break;
  case 157U: 
  (yymsp + -10)->minor.yy288 = sqlite3UpsertNew(pParse->db, (yymsp + -7)->minor.yy138,
                                                (yymsp + -5)->minor.yy46, (yymsp + -1)->minor.yy138,
                                                (yymsp + 0)->minor.yy46);
  break;
  case 158U: 
  (yymsp + -7)->minor.yy288 = sqlite3UpsertNew(pParse->db, (yymsp + -4)->minor.yy138,
                                               (yymsp + -2)->minor.yy46, (ExprList *)0,
                                               (Expr *)0);
  break;
  case 159U: 
  (yymsp + -3)->minor.yy288 = sqlite3UpsertNew(pParse->db, (ExprList *)0, (Expr *)0,
                                               (ExprList *)0, (Expr *)0);
  break;
  case 163U: 
  (yymsp + -2)->minor.yy406 = (yymsp + -1)->minor.yy406;
  break;
  case 164U: 
  (yymsp + -2)->minor.yy406 = sqlite3IdListAppend(pParse, (yymsp + -2)->minor.yy406,
                                                  & (yymsp + 0)->minor.yy0);
  break;
  case 165U: 
  (yymsp + 0)->minor.yy406 = sqlite3IdListAppend(pParse, (IdList *)0, & (yymsp + 0)->minor.yy0);
  break;
  case 166U: 
  (yymsp + -2)->minor.yy46 = (yymsp + -1)->minor.yy46;
  break;
  case 168U: 
  case 167U: 
  (yymsp + 0)->minor.yy46 = tokenExpr(pParse, 59, (yymsp + 0)->minor.yy0);
  break;
  case 169U: 
  tmp___8 = sqlite3ExprAlloc(pParse->db, 59, (Token const   *)(& (yymsp + -2)->minor.yy0),
                             1);
  temp1 = tmp___8;
  tmp___9 = sqlite3ExprAlloc(pParse->db, 59, (Token const   *)(& (yymsp + 0)->minor.yy0),
                             1);
  temp2 = tmp___9;
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameTokenMap(pParse, (void *)temp2, & (yymsp + 0)->minor.yy0);
    sqlite3RenameTokenMap(pParse, (void *)temp1, & (yymsp + -2)->minor.yy0);
  }
  yylhsminor.yy46 = sqlite3PExpr(pParse, 137, temp1, temp2);
  (yymsp + -2)->minor.yy46 = yylhsminor.yy46;
  break;
  case 170U: 
  tmp___10 = sqlite3ExprAlloc(pParse->db, 59, (Token const   *)(& (yymsp + -4)->minor.yy0),
                              1);
  temp1___0 = tmp___10;
  tmp___11 = sqlite3ExprAlloc(pParse->db, 59, (Token const   *)(& (yymsp + -2)->minor.yy0),
                              1);
  temp2___0 = tmp___11;
  tmp___12 = sqlite3ExprAlloc(pParse->db, 59, (Token const   *)(& (yymsp + 0)->minor.yy0),
                              1);
  temp3 = tmp___12;
  tmp___13 = sqlite3PExpr(pParse, 137, temp2___0, temp3);
  temp4 = tmp___13;
  if ((int )pParse->eParseMode >= 2) {
    sqlite3RenameTokenMap(pParse, (void *)temp3, & (yymsp + 0)->minor.yy0);
    sqlite3RenameTokenMap(pParse, (void *)temp2___0, & (yymsp + -2)->minor.yy0);
  }
  yylhsminor.yy46 = sqlite3PExpr(pParse, 137, temp1___0, temp4);
  (yymsp + -4)->minor.yy46 = yylhsminor.yy46;
  break;
  case 172U: 
  case 171U: 
  (yymsp + 0)->minor.yy46 = tokenExpr(pParse, (int )(yymsp + 0)->major, (yymsp + 0)->minor.yy0);
  break;
  case 173U: 
  yylhsminor.yy46 = sqlite3ExprAlloc(pParse->db, 150, (Token const   *)(& (yymsp + 0)->minor.yy0),
                                     1);
  (yymsp + 0)->minor.yy46 = yylhsminor.yy46;
  break;
  case 174U: 
  if ((int const   )*((yymsp + 0)->minor.yy0.z + 0) == 35) {
    if ((int const   )sqlite3CtypeMap[(unsigned char )*((yymsp + 0)->minor.yy0.z + 1)] & 4) {
      t = (yymsp + 0)->minor.yy0;
      if ((int )pParse->nested == 0) {
        sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", & t);
        (yymsp + 0)->minor.yy46 = (Expr *)0;
      } else {
        (yymsp + 0)->minor.yy46 = sqlite3PExpr(pParse, 171, (Expr *)0, (Expr *)0);
        if ((yymsp + 0)->minor.yy46) {
          sqlite3GetInt32(t.z + 1, & ((yymsp + 0)->minor.yy46)->iTable);
        }
      }
    } else {
      n = (yymsp + 0)->minor.yy0.n;
      (yymsp + 0)->minor.yy46 = tokenExpr(pParse, 151, (yymsp + 0)->minor.yy0);
      sqlite3ExprAssignVarNumber(pParse, (yymsp + 0)->minor.yy46, n);
    }
  } else {
    n = (yymsp + 0)->minor.yy0.n;
    (yymsp + 0)->minor.yy46 = tokenExpr(pParse, 151, (yymsp + 0)->minor.yy0);
    sqlite3ExprAssignVarNumber(pParse, (yymsp + 0)->minor.yy46, n);
  }
  break;
  case 175U: 
  (yymsp + -2)->minor.yy46 = sqlite3ExprAddCollateToken(pParse, (yymsp + -2)->minor.yy46,
                                                        (Token const   *)(& (yymsp + 0)->minor.yy0),
                                                        1);
  break;
  case 176U: 
  (yymsp + -5)->minor.yy46 = sqlite3ExprAlloc(pParse->db, 36, (Token const   *)(& (yymsp + -1)->minor.yy0),
                                              1);
  sqlite3ExprAttachSubtrees(pParse->db, (yymsp + -5)->minor.yy46, (yymsp + -3)->minor.yy46,
                            (Expr *)0);
  break;
  case 177U: 
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, (yymsp + -1)->minor.yy138, & (yymsp + -4)->minor.yy0,
                                        (yymsp + -2)->minor.yy32);
  (yymsp + -4)->minor.yy46 = yylhsminor.yy46;
  break;
  case 178U: 
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, (ExprList *)0, & (yymsp + -3)->minor.yy0,
                                        0);
  (yymsp + -3)->minor.yy46 = yylhsminor.yy46;
  break;
  case 179U: 
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, (yymsp + -2)->minor.yy138, & (yymsp + -5)->minor.yy0,
                                        (yymsp + -3)->minor.yy32);
  sqlite3WindowAttach(pParse, yylhsminor.yy46, (yymsp + 0)->minor.yy455);
  (yymsp + -5)->minor.yy46 = yylhsminor.yy46;
  break;
  case 180U: 
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, (ExprList *)0, & (yymsp + -4)->minor.yy0,
                                        0);
  sqlite3WindowAttach(pParse, yylhsminor.yy46, (yymsp + 0)->minor.yy455);
  (yymsp + -4)->minor.yy46 = yylhsminor.yy46;
  break;
  case 181U: 
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, (ExprList *)0, & (yymsp + 0)->minor.yy0,
                                        0);
  (yymsp + 0)->minor.yy46 = yylhsminor.yy46;
  break;
  case 182U: 
  tmp___14 = sqlite3ExprListAppend(pParse, (yymsp + -3)->minor.yy138, (yymsp + -1)->minor.yy46);
  pList = tmp___14;
  (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 172, (Expr *)0, (Expr *)0);
  if ((yymsp + -4)->minor.yy46) {
    ((yymsp + -4)->minor.yy46)->x.pList = pList;
  } else {
    sqlite3ExprListDelete(pParse->db, pList);
  }
  break;
  case 183U: 
  (yymsp + -2)->minor.yy46 = sqlite3ExprAnd(pParse, (yymsp + -2)->minor.yy46, (yymsp + 0)->minor.yy46);
  break;
  case 185U: 
  case 184U: ;
  case 186U: ;
  case 187U: ;
  case 188U: ;
  case 189U: ;
  case 190U: 
  (yymsp + -2)->minor.yy46 = sqlite3PExpr(pParse, (int )(yymsp + -1)->major, (yymsp + -2)->minor.yy46,
                                          (yymsp + 0)->minor.yy46);
  break;
  case 191U: 
  (yymsp + -1)->minor.yy0 = (yymsp + 0)->minor.yy0;
  (yymsp + -1)->minor.yy0.n |= 2147483648U;
  break;
  case 192U: 
  bNot = (int )((yymsp + -1)->minor.yy0.n & 2147483648U);
  (yymsp + -1)->minor.yy0.n &= 2147483647U;
  pList___0 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + 0)->minor.yy46);
  pList___0 = sqlite3ExprListAppend(pParse, pList___0, (yymsp + -2)->minor.yy46);
  (yymsp + -2)->minor.yy46 = sqlite3ExprFunction(pParse, pList___0, & (yymsp + -1)->minor.yy0,
                                                 0);
  if (bNot) {
    (yymsp + -2)->minor.yy46 = sqlite3PExpr(pParse, 19, (yymsp + -2)->minor.yy46,
                                            (Expr *)0);
  }
  if ((yymsp + -2)->minor.yy46) {
    ((yymsp + -2)->minor.yy46)->flags |= 128U;
  }
  break;
  case 193U: 
  bNot___0 = (int )((yymsp + -3)->minor.yy0.n & 2147483648U);
  (yymsp + -3)->minor.yy0.n &= 2147483647U;
  pList___1 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + -2)->minor.yy46);
  pList___1 = sqlite3ExprListAppend(pParse, pList___1, (yymsp + -4)->minor.yy46);
  pList___1 = sqlite3ExprListAppend(pParse, pList___1, (yymsp + 0)->minor.yy46);
  (yymsp + -4)->minor.yy46 = sqlite3ExprFunction(pParse, pList___1, & (yymsp + -3)->minor.yy0,
                                                 0);
  if (bNot___0) {
    (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 19, (yymsp + -4)->minor.yy46,
                                            (Expr *)0);
  }
  if ((yymsp + -4)->minor.yy46) {
    ((yymsp + -4)->minor.yy46)->flags |= 128U;
  }
  break;
  case 194U: 
  (yymsp + -1)->minor.yy46 = sqlite3PExpr(pParse, (int )(yymsp + 0)->major, (yymsp + -1)->minor.yy46,
                                          (Expr *)0);
  break;
  case 195U: 
  (yymsp + -2)->minor.yy46 = sqlite3PExpr(pParse, 51, (yymsp + -2)->minor.yy46, (Expr *)0);
  break;
  case 196U: 
  (yymsp + -2)->minor.yy46 = sqlite3PExpr(pParse, 45, (yymsp + -2)->minor.yy46, (yymsp + 0)->minor.yy46);
  binaryToUnaryIfNull(pParse, (yymsp + 0)->minor.yy46, (yymsp + -2)->minor.yy46, 50);
  break;
  case 197U: 
  (yymsp + -3)->minor.yy46 = sqlite3PExpr(pParse, 166, (yymsp + -3)->minor.yy46, (yymsp + 0)->minor.yy46);
  binaryToUnaryIfNull(pParse, (yymsp + 0)->minor.yy46, (yymsp + -3)->minor.yy46, 51);
  break;
  case 199U: 
  case 198U: 
  (yymsp + -1)->minor.yy46 = sqlite3PExpr(pParse, (int )(yymsp + -1)->major, (yymsp + 0)->minor.yy46,
                                          (Expr *)0);
  break;
  case 200U: 
  if ((int )(yymsp + -1)->major == 103) {
    tmp___15 = 169;
  } else {
    tmp___15 = 168;
  }
  (yymsp + -1)->minor.yy46 = sqlite3PExpr(pParse, tmp___15, (yymsp + 0)->minor.yy46,
                                          (Expr *)0);
  break;
  case 204U: 
  case 201U: 
  (yymsp + 0)->minor.yy32 = 0;
  break;
  case 203U: 
  tmp___16 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + -2)->minor.yy46);
  pList___2 = tmp___16;
  pList___2 = sqlite3ExprListAppend(pParse, pList___2, (yymsp + 0)->minor.yy46);
  (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 48, (yymsp + -4)->minor.yy46, (Expr *)0);
  if ((yymsp + -4)->minor.yy46) {
    ((yymsp + -4)->minor.yy46)->x.pList = pList___2;
  } else {
    sqlite3ExprListDelete(pParse->db, pList___2);
  }
  if ((yymsp + -3)->minor.yy32) {
    (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 19, (yymsp + -4)->minor.yy46,
                                            (Expr *)0);
  }
  break;
  case 206U: 
  if ((unsigned long )(yymsp + -1)->minor.yy138 == (unsigned long )((ExprList *)0)) {
    sqlite3ExprUnmapAndDelete(pParse, (yymsp + -4)->minor.yy46);
    if ((yymsp + -3)->minor.yy32) {
      tmp___17 = "1";
    } else {
      tmp___17 = "0";
    }
    (yymsp + -4)->minor.yy46 = sqlite3Expr(pParse->db, 150, tmp___17);
  } else {
    (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 49, (yymsp + -4)->minor.yy46,
                                            (Expr *)0);
    if ((yymsp + -4)->minor.yy46) {
      ((yymsp + -4)->minor.yy46)->x.pList = (yymsp + -1)->minor.yy138;
      sqlite3ExprSetHeightAndFlags(pParse, (yymsp + -4)->minor.yy46);
    } else {
      sqlite3ExprListDelete(pParse->db, (yymsp + -1)->minor.yy138);
    }
    if ((yymsp + -3)->minor.yy32) {
      (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 19, (yymsp + -4)->minor.yy46,
                                              (Expr *)0);
    }
  }
  break;
  case 207U: 
  (yymsp + -2)->minor.yy46 = sqlite3PExpr(pParse, 134, (Expr *)0, (Expr *)0);
  sqlite3PExprAddSelect(pParse, (yymsp + -2)->minor.yy46, (yymsp + -1)->minor.yy25);
  break;
  case 208U: 
  (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 49, (yymsp + -4)->minor.yy46, (Expr *)0);
  sqlite3PExprAddSelect(pParse, (yymsp + -4)->minor.yy46, (yymsp + -1)->minor.yy25);
  if ((yymsp + -3)->minor.yy32) {
    (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 19, (yymsp + -4)->minor.yy46,
                                            (Expr *)0);
  }
  break;
  case 209U: 
  tmp___18 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + -2)->minor.yy0,
                                  & (yymsp + -1)->minor.yy0);
  pSrc = tmp___18;
  tmp___19 = sqlite3SelectNew(pParse, (ExprList *)0, pSrc, (Expr *)0, (ExprList *)0,
                              (Expr *)0, (ExprList *)0, (u32 )0, (Expr *)0);
  pSelect = tmp___19;
  if ((yymsp + 0)->minor.yy138) {
    if (pSelect) {
      tmp___20 = pSrc;
    } else {
      tmp___20 = (SrcList *)0;
    }
    sqlite3SrcListFuncArgs(pParse, tmp___20, (yymsp + 0)->minor.yy138);
  }
  (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 49, (yymsp + -4)->minor.yy46, (Expr *)0);
  sqlite3PExprAddSelect(pParse, (yymsp + -4)->minor.yy46, pSelect);
  if ((yymsp + -3)->minor.yy32) {
    (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 19, (yymsp + -4)->minor.yy46,
                                            (Expr *)0);
  }
  break;
  case 210U: 
  tmp___21 = sqlite3PExpr(pParse, 20, (Expr *)0, (Expr *)0);
  (yymsp + -3)->minor.yy46 = tmp___21;
  p___5 = tmp___21;
  sqlite3PExprAddSelect(pParse, p___5, (yymsp + -1)->minor.yy25);
  break;
  case 211U: 
  (yymsp + -4)->minor.yy46 = sqlite3PExpr(pParse, 152, (yymsp + -3)->minor.yy46, (Expr *)0);
  if ((yymsp + -4)->minor.yy46) {
    if ((yymsp + -1)->minor.yy46) {
      tmp___22 = sqlite3ExprListAppend(pParse, (yymsp + -2)->minor.yy138, (yymsp + -1)->minor.yy46);
      ((yymsp + -4)->minor.yy46)->x.pList = tmp___22;
    } else {
      ((yymsp + -4)->minor.yy46)->x.pList = (yymsp + -2)->minor.yy138;
    }
    sqlite3ExprSetHeightAndFlags(pParse, (yymsp + -4)->minor.yy46);
  } else {
    sqlite3ExprListDelete(pParse->db, (yymsp + -2)->minor.yy138);
    sqlite3ExprDelete(pParse->db, (yymsp + -1)->minor.yy46);
  }
  break;
  case 212U: 
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -4)->minor.yy138,
                                                    (yymsp + -2)->minor.yy46);
  (yymsp + -4)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -4)->minor.yy138,
                                                    (yymsp + 0)->minor.yy46);
  break;
  case 213U: 
  (yymsp + -3)->minor.yy138 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + -2)->minor.yy46);
  (yymsp + -3)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -3)->minor.yy138,
                                                    (yymsp + 0)->minor.yy46);
  break;
  case 216U: 
  (yymsp + 0)->minor.yy46 = (yymsp + 0)->minor.yy46;
  break;
  case 219U: 
  (yymsp + -2)->minor.yy138 = sqlite3ExprListAppend(pParse, (yymsp + -2)->minor.yy138,
                                                    (yymsp + 0)->minor.yy46);
  break;
  case 220U: 
  (yymsp + 0)->minor.yy138 = sqlite3ExprListAppend(pParse, (ExprList *)0, (yymsp + 0)->minor.yy46);
  break;
  case 227U: 
  case 222U: 
  (yymsp + -2)->minor.yy138 = (yymsp + -1)->minor.yy138;
  break;
  case 223U: 
  tmp___23 = sqlite3SrcListAppend(pParse, (SrcList *)0, & (yymsp + -4)->minor.yy0,
                                  (Token *)0);
  sqlite3CreateIndex(pParse, & (yymsp + -7)->minor.yy0, & (yymsp + -6)->minor.yy0,
                     tmp___23, (yymsp + -2)->minor.yy138, (yymsp + -10)->minor.yy32,
                     & (yymsp + -11)->minor.yy0, (yymsp + 0)->minor.yy46, 0, (yymsp + -8)->minor.yy32,
                     (u8 )0);
  if ((int )pParse->eParseMode >= 2) {
    if (pParse->pNewIndex) {
      sqlite3RenameTokenMap(pParse, (void *)(pParse->pNewIndex)->zName, & (yymsp + -4)->minor.yy0);
    }
  }
  break;
  case 266U: 
  case 224U: 
  (yymsp + 0)->minor.yy32 = 2;
  break;
  case 225U: 
  (yymsp + 1)->minor.yy32 = 0;
  break;
  case 228U: 
  (yymsp + -4)->minor.yy138 = parserAddExprIdListTerm(pParse, (yymsp + -4)->minor.yy138,
                                                      & (yymsp + -2)->minor.yy0, (yymsp + -1)->minor.yy32,
                                                      (yymsp + 0)->minor.yy32);
  break;
  case 229U: 
  (yymsp + -2)->minor.yy138 = parserAddExprIdListTerm(pParse, (ExprList *)0, & (yymsp + -2)->minor.yy0,
                                                      (yymsp + -1)->minor.yy32, (yymsp + 0)->minor.yy32);
  break;
  case 232U: 
  sqlite3DropIndex(pParse, (yymsp + 0)->minor.yy609, (yymsp + -1)->minor.yy32);
  break;
  case 233U: 
  sqlite3Vacuum(pParse, (Token *)0, (yymsp + 0)->minor.yy46);
  break;
  case 234U: 
  sqlite3Vacuum(pParse, & (yymsp + -1)->minor.yy0, (yymsp + 0)->minor.yy46);
  break;
  case 237U: 
  sqlite3Pragma(pParse, & (yymsp + -1)->minor.yy0, & (yymsp + 0)->minor.yy0, (Token *)0,
                0);
  break;
  case 238U: 
  sqlite3Pragma(pParse, & (yymsp + -3)->minor.yy0, & (yymsp + -2)->minor.yy0, & (yymsp + 0)->minor.yy0,
                0);
  break;
  case 239U: 
  sqlite3Pragma(pParse, & (yymsp + -4)->minor.yy0, & (yymsp + -3)->minor.yy0, & (yymsp + -1)->minor.yy0,
                0);
  break;
  case 240U: 
  sqlite3Pragma(pParse, & (yymsp + -3)->minor.yy0, & (yymsp + -2)->minor.yy0, & (yymsp + 0)->minor.yy0,
                1);
  break;
  case 241U: 
  sqlite3Pragma(pParse, & (yymsp + -4)->minor.yy0, & (yymsp + -3)->minor.yy0, & (yymsp + -1)->minor.yy0,
                1);
  break;
  case 244U: 
  all.z = (yymsp + -3)->minor.yy0.z;
  all.n = (unsigned int )((int )((yymsp + 0)->minor.yy0.z - (yymsp + -3)->minor.yy0.z)) + (yymsp + 0)->minor.yy0.n;
  sqlite3FinishTrigger(pParse, (yymsp + -1)->minor.yy527, & all);
  break;
  case 245U: 
  sqlite3BeginTrigger(pParse, & (yymsp + -7)->minor.yy0, & (yymsp + -6)->minor.yy0,
                      (yymsp + -5)->minor.yy32, (yymsp + -4)->minor.yy572.a, (yymsp + -4)->minor.yy572.b,
                      (yymsp + -2)->minor.yy609, (yymsp + 0)->minor.yy46, (yymsp + -10)->minor.yy32,
                      (yymsp + -8)->minor.yy32);
  if ((yymsp + -6)->minor.yy0.n == 0U) {
    (yymsp + -10)->minor.yy0 = (yymsp + -7)->minor.yy0;
  } else {
    (yymsp + -10)->minor.yy0 = (yymsp + -6)->minor.yy0;
  }
  break;
  case 246U: 
  (yymsp + 0)->minor.yy32 = (int )(yymsp + 0)->major;
  break;
  case 247U: 
  (yymsp + -1)->minor.yy32 = 65;
  break;
  case 248U: 
  (yymsp + 1)->minor.yy32 = 33;
  break;
  case 250U: 
  case 249U: 
  (yymsp + 0)->minor.yy572.a = (int )(yymsp + 0)->major;
  (yymsp + 0)->minor.yy572.b = (IdList *)0;
  break;
  case 251U: 
  (yymsp + -2)->minor.yy572.a = 125;
  (yymsp + -2)->minor.yy572.b = (yymsp + 0)->minor.yy406;
  break;
  case 271U: 
  case 252U: 
  (yymsp + 1)->minor.yy46 = (Expr *)0;
  break;
  case 272U: 
  case 253U: 
  (yymsp + -1)->minor.yy46 = (yymsp + 0)->minor.yy46;
  break;
  case 254U: 
  (((yymsp + -2)->minor.yy527)->pLast)->pNext = (yymsp + -1)->minor.yy527;
  ((yymsp + -2)->minor.yy527)->pLast = (yymsp + -1)->minor.yy527;
  break;
  case 255U: 
  ((yymsp + -1)->minor.yy527)->pLast = (yymsp + -1)->minor.yy527;
  break;
  case 256U: 
  (yymsp + -2)->minor.yy0 = (yymsp + 0)->minor.yy0;
  sqlite3ErrorMsg(pParse, "qualified table names are not allowed on INSERT, UPDATE, and DELETE statements within triggers");
  break;
  case 257U: 
  sqlite3ErrorMsg(pParse, "the INDEXED BY clause is not allowed on UPDATE or DELETE statements within triggers");
  break;
  case 258U: 
  sqlite3ErrorMsg(pParse, "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements within triggers");
  break;
  case 259U: 
  yylhsminor.yy527 = sqlite3TriggerUpdateStep(pParse, & (yymsp + -5)->minor.yy0, (yymsp + -2)->minor.yy138,
                                              (yymsp + -1)->minor.yy46, (u8 )(yymsp + -6)->minor.yy32,
                                              (yymsp + -7)->minor.yy0.z, (yymsp + 0)->minor.yy8);
  (yymsp + -7)->minor.yy527 = yylhsminor.yy527;
  break;
  case 260U: 
  yylhsminor.yy527 = sqlite3TriggerInsertStep(pParse, & (yymsp + -4)->minor.yy0, (yymsp + -3)->minor.yy406,
                                              (yymsp + -2)->minor.yy25, (u8 )(yymsp + -6)->minor.yy32,
                                              (yymsp + -1)->minor.yy288, (yymsp + -7)->minor.yy8,
                                              (yymsp + 0)->minor.yy8);
  (yymsp + -7)->minor.yy527 = yylhsminor.yy527;
  break;
  case 261U: 
  yylhsminor.yy527 = sqlite3TriggerDeleteStep(pParse, & (yymsp + -3)->minor.yy0, (yymsp + -1)->minor.yy46,
                                              (yymsp + -5)->minor.yy0.z, (yymsp + 0)->minor.yy8);
  (yymsp + -5)->minor.yy527 = yylhsminor.yy527;
  break;
  case 262U: 
  yylhsminor.yy527 = sqlite3TriggerSelectStep(pParse->db, (yymsp + -1)->minor.yy25,
                                              (yymsp + -2)->minor.yy8, (yymsp + 0)->minor.yy8);
  (yymsp + -2)->minor.yy527 = yylhsminor.yy527;
  break;
  case 263U: 
  (yymsp + -3)->minor.yy46 = sqlite3PExpr(pParse, 71, (Expr *)0, (Expr *)0);
  if ((yymsp + -3)->minor.yy46) {
    ((yymsp + -3)->minor.yy46)->affExpr = (char)4;
  }
  break;
  case 264U: 
  (yymsp + -5)->minor.yy46 = sqlite3ExprAlloc(pParse->db, 71, (Token const   *)(& (yymsp + -1)->minor.yy0),
                                              1);
  if ((yymsp + -5)->minor.yy46) {
    ((yymsp + -5)->minor.yy46)->affExpr = (char )(yymsp + -3)->minor.yy32;
  }
  break;
  case 265U: 
  (yymsp + 0)->minor.yy32 = 1;
  break;
  case 267U: 
  (yymsp + 0)->minor.yy32 = 3;
  break;
  case 268U: 
  sqlite3DropTrigger(pParse, (yymsp + 0)->minor.yy609, (yymsp + -1)->minor.yy32);
  break;
  case 269U: 
  sqlite3Attach(pParse, (yymsp + -3)->minor.yy46, (yymsp + -1)->minor.yy46, (yymsp + 0)->minor.yy46);
  break;
  case 270U: 
  sqlite3Detach(pParse, (yymsp + 0)->minor.yy46);
  break;
  case 273U: 
  sqlite3Reindex(pParse, (Token *)0, (Token *)0);
  break;
  case 274U: 
  sqlite3Reindex(pParse, & (yymsp + -1)->minor.yy0, & (yymsp + 0)->minor.yy0);
  break;
  case 275U: 
  sqlite3Analyze(pParse, (Token *)0, (Token *)0);
  break;
  case 276U: 
  sqlite3Analyze(pParse, & (yymsp + -1)->minor.yy0, & (yymsp + 0)->minor.yy0);
  break;
  case 277U: 
  sqlite3AlterRenameTable(pParse, (yymsp + -3)->minor.yy609, & (yymsp + 0)->minor.yy0);
  break;
  case 278U: 
  (yymsp + -1)->minor.yy0.n = (unsigned int )((int )(pParse->sLastToken.z - (yymsp + -1)->minor.yy0.z)) + pParse->sLastToken.n;
  sqlite3AlterFinishAddColumn(pParse, & (yymsp + -1)->minor.yy0);
  break;
  case 279U: 
  disableLookaside(pParse);
  sqlite3AlterBeginAddColumn(pParse, (yymsp + 0)->minor.yy609);
  break;
  case 280U: 
  sqlite3AlterRenameColumn(pParse, (yymsp + -5)->minor.yy609, & (yymsp + -2)->minor.yy0,
                           & (yymsp + 0)->minor.yy0);
  break;
  case 281U: 
  sqlite3VtabFinishParse(pParse, (Token *)0);
  break;
  case 282U: 
  sqlite3VtabFinishParse(pParse, & (yymsp + 0)->minor.yy0);
  break;
  case 283U: 
  sqlite3VtabBeginParse(pParse, & (yymsp + -3)->minor.yy0, & (yymsp + -2)->minor.yy0,
                        & (yymsp + 0)->minor.yy0, (yymsp + -4)->minor.yy32);
  break;
  case 284U: 
  sqlite3VtabArgInit(pParse);
  break;
  case 286U: 
  case 285U: ;
  case 287U: 
  sqlite3VtabArgExtend(pParse, & (yymsp + 0)->minor.yy0);
  break;
  case 289U: 
  case 288U: 
  sqlite3WithPush(pParse, (yymsp + 0)->minor.yy297, (u8 )1);
  break;
  case 290U: 
  (yymsp + -5)->minor.yy297 = sqlite3WithAdd(pParse, (With *)0, & (yymsp + -5)->minor.yy0,
                                             (yymsp + -4)->minor.yy138, (yymsp + -1)->minor.yy25);
  break;
  case 291U: 
  (yymsp + -7)->minor.yy297 = sqlite3WithAdd(pParse, (yymsp + -7)->minor.yy297, & (yymsp + -5)->minor.yy0,
                                             (yymsp + -4)->minor.yy138, (yymsp + -1)->minor.yy25);
  break;
  case 292U: 
  yylhsminor.yy455 = (yymsp + 0)->minor.yy455;
  (yymsp + 0)->minor.yy455 = yylhsminor.yy455;
  break;
  case 293U: 
  sqlite3WindowChain(pParse, (yymsp + 0)->minor.yy455, (yymsp + -2)->minor.yy455);
  ((yymsp + 0)->minor.yy455)->pNextWin = (yymsp + -2)->minor.yy455;
  yylhsminor.yy455 = (yymsp + 0)->minor.yy455;
  (yymsp + -2)->minor.yy455 = yylhsminor.yy455;
  break;
  case 294U: 
  if ((yymsp + -1)->minor.yy455) {
    ((yymsp + -1)->minor.yy455)->zName = sqlite3DbStrNDup(pParse->db, (yymsp + -4)->minor.yy0.z,
                                                          (u64 )(yymsp + -4)->minor.yy0.n);
  }
  yylhsminor.yy455 = (yymsp + -1)->minor.yy455;
  (yymsp + -4)->minor.yy455 = yylhsminor.yy455;
  break;
  case 295U: 
  (yymsp + -4)->minor.yy455 = sqlite3WindowAssemble(pParse, (yymsp + 0)->minor.yy455,
                                                    (yymsp + -2)->minor.yy138, (yymsp + -1)->minor.yy138,
                                                    (Token *)0);
  break;
  case 296U: 
  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, (yymsp + 0)->minor.yy455, (yymsp + -2)->minor.yy138,
                                           (yymsp + -1)->minor.yy138, & (yymsp + -5)->minor.yy0);
  (yymsp + -5)->minor.yy455 = yylhsminor.yy455;
  break;
  case 297U: 
  (yymsp + -3)->minor.yy455 = sqlite3WindowAssemble(pParse, (yymsp + 0)->minor.yy455,
                                                    (ExprList *)0, (yymsp + -1)->minor.yy138,
                                                    (Token *)0);
  break;
  case 298U: 
  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, (yymsp + 0)->minor.yy455, (ExprList *)0,
                                           (yymsp + -1)->minor.yy138, & (yymsp + -4)->minor.yy0);
  (yymsp + -4)->minor.yy455 = yylhsminor.yy455;
  break;
  case 318U: 
  case 299U: 
  yylhsminor.yy455 = (yymsp + 0)->minor.yy455;
  (yymsp + 0)->minor.yy455 = yylhsminor.yy455;
  break;
  case 300U: 
  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, (yymsp + 0)->minor.yy455, (ExprList *)0,
                                           (ExprList *)0, & (yymsp + -1)->minor.yy0);
  (yymsp + -1)->minor.yy455 = yylhsminor.yy455;
  break;
  case 301U: 
  (yymsp + 1)->minor.yy455 = sqlite3WindowAlloc(pParse, 0, 90, (Expr *)0, 85, (Expr *)0,
                                                (u8 )0);
  break;
  case 302U: 
  yylhsminor.yy455 = sqlite3WindowAlloc(pParse, (yymsp + -2)->minor.yy32, (yymsp + -1)->minor.yy57.eType,
                                        (yymsp + -1)->minor.yy57.pExpr, 85, (Expr *)0,
                                        (yymsp + 0)->minor.yy118);
  (yymsp + -2)->minor.yy455 = yylhsminor.yy455;
  break;
  case 303U: 
  yylhsminor.yy455 = sqlite3WindowAlloc(pParse, (yymsp + -5)->minor.yy32, (yymsp + -3)->minor.yy57.eType,
                                        (yymsp + -3)->minor.yy57.pExpr, (yymsp + -1)->minor.yy57.eType,
                                        (yymsp + -1)->minor.yy57.pExpr, (yymsp + 0)->minor.yy118);
  (yymsp + -5)->minor.yy455 = yylhsminor.yy455;
  break;
  case 307U: 
  case 305U: 
  yylhsminor.yy57 = (yymsp + 0)->minor.yy57;
  (yymsp + 0)->minor.yy57 = yylhsminor.yy57;
  break;
  case 308U: 
  case 306U: ;
  case 310U: 
  yylhsminor.yy57.eType = (int )(yymsp + -1)->major;
  yylhsminor.yy57.pExpr = (Expr *)0;
  (yymsp + -1)->minor.yy57 = yylhsminor.yy57;
  break;
  case 309U: 
  yylhsminor.yy57.eType = (int )(yymsp + 0)->major;
  yylhsminor.yy57.pExpr = (yymsp + -1)->minor.yy46;
  (yymsp + -1)->minor.yy57 = yylhsminor.yy57;
  break;
  case 311U: 
  (yymsp + 1)->minor.yy118 = (u8 )0;
  break;
  case 312U: 
  (yymsp + -1)->minor.yy118 = (yymsp + 0)->minor.yy118;
  break;
  case 314U: 
  case 313U: 
  (yymsp + -1)->minor.yy118 = (u8 )(yymsp + -1)->major;
  break;
  case 315U: 
  (yymsp + 0)->minor.yy118 = (u8 )(yymsp + 0)->major;
  break;
  case 316U: 
  (yymsp + -1)->minor.yy455 = (yymsp + 0)->minor.yy455;
  break;
  case 317U: 
  ((yymsp + 0)->minor.yy455)->pFilter = (yymsp + -1)->minor.yy46;
  yylhsminor.yy455 = (yymsp + 0)->minor.yy455;
  (yymsp + -1)->minor.yy455 = yylhsminor.yy455;
  break;
  case 319U: 
  tmp___24 = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(Window ));
  yylhsminor.yy455 = (Window *)tmp___24;
  if (yylhsminor.yy455) {
    (yylhsminor.yy455)->eFrmType = (u8 )161;
    (yylhsminor.yy455)->pFilter = (yymsp + 0)->minor.yy46;
  } else {
    sqlite3ExprDelete(pParse->db, (yymsp + 0)->minor.yy46);
  }
  (yymsp + 0)->minor.yy455 = yylhsminor.yy455;
  break;
  case 320U: 
  (yymsp + -3)->minor.yy455 = (yymsp + -1)->minor.yy455;
  break;
  case 321U: 
  tmp___25 = sqlite3DbMallocZero(pParse->db, (u64 )sizeof(Window ));
  (yymsp + -1)->minor.yy455 = (Window *)tmp___25;
  if ((yymsp + -1)->minor.yy455) {
    ((yymsp + -1)->minor.yy455)->zName = sqlite3DbStrNDup(pParse->db, (yymsp + 0)->minor.yy0.z,
                                                          (u64 )(yymsp + 0)->minor.yy0.n);
  }
  break;
  case 322U: 
  (yymsp + -4)->minor.yy46 = (yymsp + -1)->minor.yy46;
  break;
  default: ;
  break;
  }
  yygoto = (int )yyRuleInfoLhs[yyruleno];
  yysize = (int )yyRuleInfoNRhs[yyruleno];
  yyact = yy_find_reduce_action((yymsp + yysize)->stateno, (unsigned short )yygoto);
  yymsp += yysize + 1;
  yypParser->yytos = yymsp;
  yymsp->stateno = yyact;
  yymsp->major = (unsigned short )yygoto;
  return (yyact);
}
}
static void yy_syntax_error(yyParser *yypParser , int yymajor , Token yyminor ) 
{ 
  Parse *pParse ;

  {
  pParse = yypParser->pParse;
  if (*(yyminor.z + 0)) {
    sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", & yyminor);
  } else {
    sqlite3ErrorMsg(pParse, "incomplete input");
  }
  yypParser->pParse = pParse;
  return;
}
}
static void yy_accept(yyParser *yypParser ) 
{ 
  Parse *pParse ;

  {
  pParse = yypParser->pParse;
  yypParser->pParse = pParse;
  return;
}
}
static void sqlite3Parser(void *yyp , int yymajor , Token yyminor ) 
{ 
  YYMINORTYPE yyminorunion ;
  unsigned short yyact ;
  yyParser *yypParser ;
  Parse *pParse ;

  {
  yypParser = (yyParser *)yyp;
  pParse = yypParser->pParse;
  yyact = (yypParser->yytos)->stateno;
  while (1) {
    yyact = yy_find_shift_action((unsigned short )yymajor, yyact);
    if ((int )yyact >= 1174) {
      yyact = yy_reduce(yypParser, (unsigned int )((int )yyact - 1174), yymajor, yyminor,
                        pParse);
    } else
    if ((int )yyact <= 1170) {
      yy_shift(yypParser, yyact, (unsigned short )yymajor, yyminor);
      break;
    } else
    if ((int )yyact == 1172) {
      (yypParser->yytos) --;
      yy_accept(yypParser);
      return;
    } else {
      yyminorunion.yy0 = yyminor;
      yy_syntax_error(yypParser, yymajor, yyminor);
      yy_destructor(yypParser, (unsigned short )yymajor, & yyminorunion);
      break;
    }
    if (! ((unsigned long )yypParser->yytos > (unsigned long )(yypParser->yystack))) {
      break;
    }
  }
  return;
}
}
static int sqlite3ParserFallback(int iToken ) 
{ 


  {
  return ((int )yyFallback[iToken]);
  return (0);
}
}
static unsigned char const   aiClass[256]  = 
  {      (unsigned char const   )28,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )27,      (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )27, 
        (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )7,      (unsigned char const   )15,      (unsigned char const   )8,      (unsigned char const   )5, 
        (unsigned char const   )4,      (unsigned char const   )22,      (unsigned char const   )24,      (unsigned char const   )8, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )21,      (unsigned char const   )20, 
        (unsigned char const   )23,      (unsigned char const   )11,      (unsigned char const   )26,      (unsigned char const   )16, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )5,      (unsigned char const   )19, 
        (unsigned char const   )12,      (unsigned char const   )14,      (unsigned char const   )13,      (unsigned char const   )6, 
        (unsigned char const   )5,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )9, 
        (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )27,      (unsigned char const   )1, 
        (unsigned char const   )8,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )27, 
        (unsigned char const   )10,      (unsigned char const   )27,      (unsigned char const   )25,      (unsigned char const   )27, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2};
static char const   zKWText[637]  = 
  {      (char const   )'R',      (char const   )'E',      (char const   )'I',      (char const   )'N', 
        (char const   )'D',      (char const   )'E',      (char const   )'X',      (char const   )'E', 
        (char const   )'D',      (char const   )'E',      (char const   )'S',      (char const   )'C', 
        (char const   )'A',      (char const   )'P',      (char const   )'E',      (char const   )'A', 
        (char const   )'C',      (char const   )'H',      (char const   )'E',      (char const   )'C', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )'B', 
        (char const   )'E',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'E',      (char const   )'I',      (char const   )'G',      (char const   )'N', 
        (char const   )'O',      (char const   )'R',      (char const   )'E',      (char const   )'G', 
        (char const   )'E',      (char const   )'X',      (char const   )'P',      (char const   )'L', 
        (char const   )'A',      (char const   )'I',      (char const   )'N',      (char const   )'S', 
        (char const   )'T',      (char const   )'E',      (char const   )'A',      (char const   )'D', 
        (char const   )'D',      (char const   )'A',      (char const   )'T',      (char const   )'A', 
        (char const   )'B',      (char const   )'A',      (char const   )'S',      (char const   )'E', 
        (char const   )'L',      (char const   )'E',      (char const   )'C',      (char const   )'T', 
        (char const   )'A',      (char const   )'B',      (char const   )'L',      (char const   )'E', 
        (char const   )'F',      (char const   )'T',      (char const   )'H',      (char const   )'E', 
        (char const   )'N',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'E',      (char const   )'R',      (char const   )'R',      (char const   )'A', 
        (char const   )'B',      (char const   )'L',      (char const   )'E',      (char const   )'L', 
        (char const   )'S',      (char const   )'E',      (char const   )'X',      (char const   )'C', 
        (char const   )'L',      (char const   )'U',      (char const   )'D',      (char const   )'E', 
        (char const   )'L',      (char const   )'E',      (char const   )'T',      (char const   )'E', 
        (char const   )'M',      (char const   )'P',      (char const   )'O',      (char const   )'R', 
        (char const   )'A',      (char const   )'R',      (char const   )'Y',      (char const   )'I', 
        (char const   )'S',      (char const   )'N',      (char const   )'U',      (char const   )'L', 
        (char const   )'L',      (char const   )'S',      (char const   )'A',      (char const   )'V', 
        (char const   )'E',      (char const   )'P',      (char const   )'O',      (char const   )'I', 
        (char const   )'N',      (char const   )'T',      (char const   )'E',      (char const   )'R', 
        (char const   )'S',      (char const   )'E',      (char const   )'C',      (char const   )'T', 
        (char const   )'I',      (char const   )'E',      (char const   )'S',      (char const   )'N', 
        (char const   )'O',      (char const   )'T',      (char const   )'N',      (char const   )'U', 
        (char const   )'L',      (char const   )'L',      (char const   )'I',      (char const   )'K', 
        (char const   )'E',      (char const   )'X',      (char const   )'C',      (char const   )'E', 
        (char const   )'P',      (char const   )'T',      (char const   )'R',      (char const   )'A', 
        (char const   )'N',      (char const   )'S',      (char const   )'A',      (char const   )'C', 
        (char const   )'T',      (char const   )'I',      (char const   )'O',      (char const   )'N', 
        (char const   )'A',      (char const   )'T',      (char const   )'U',      (char const   )'R', 
        (char const   )'A',      (char const   )'L',      (char const   )'T',      (char const   )'E', 
        (char const   )'R',      (char const   )'A',      (char const   )'I',      (char const   )'S', 
        (char const   )'E',      (char const   )'X',      (char const   )'C',      (char const   )'L', 
        (char const   )'U',      (char const   )'S',      (char const   )'I',      (char const   )'V', 
        (char const   )'E',      (char const   )'X',      (char const   )'I',      (char const   )'S', 
        (char const   )'T',      (char const   )'S',      (char const   )'C',      (char const   )'O', 
        (char const   )'N',      (char const   )'S',      (char const   )'T',      (char const   )'R', 
        (char const   )'A',      (char const   )'I',      (char const   )'N',      (char const   )'T', 
        (char const   )'O',      (char const   )'F',      (char const   )'F',      (char const   )'S', 
        (char const   )'E',      (char const   )'T',      (char const   )'R',      (char const   )'I', 
        (char const   )'G',      (char const   )'G',      (char const   )'E',      (char const   )'R', 
        (char const   )'E',      (char const   )'F',      (char const   )'E',      (char const   )'R', 
        (char const   )'E',      (char const   )'N',      (char const   )'C',      (char const   )'E', 
        (char const   )'S',      (char const   )'U',      (char const   )'N',      (char const   )'I', 
        (char const   )'Q',      (char const   )'U',      (char const   )'E',      (char const   )'R', 
        (char const   )'Y',      (char const   )'W',      (char const   )'I',      (char const   )'T', 
        (char const   )'H',      (char const   )'O',      (char const   )'U',      (char const   )'T', 
        (char const   )'E',      (char const   )'R',      (char const   )'E',      (char const   )'L', 
        (char const   )'E',      (char const   )'A',      (char const   )'S',      (char const   )'E', 
        (char const   )'A',      (char const   )'T',      (char const   )'T',      (char const   )'A', 
        (char const   )'C',      (char const   )'H',      (char const   )'A',      (char const   )'V', 
        (char const   )'I',      (char const   )'N',      (char const   )'G',      (char const   )'L', 
        (char const   )'O',      (char const   )'B',      (char const   )'E',      (char const   )'G', 
        (char const   )'I',      (char const   )'N',      (char const   )'N',      (char const   )'E', 
        (char const   )'R',      (char const   )'A',      (char const   )'N',      (char const   )'G', 
        (char const   )'E',      (char const   )'B',      (char const   )'E',      (char const   )'T', 
        (char const   )'W',      (char const   )'E',      (char const   )'E',      (char const   )'N', 
        (char const   )'O',      (char const   )'T',      (char const   )'H',      (char const   )'I', 
        (char const   )'N',      (char const   )'G',      (char const   )'R',      (char const   )'O', 
        (char const   )'U',      (char const   )'P',      (char const   )'S',      (char const   )'C', 
        (char const   )'A',      (char const   )'S',      (char const   )'C',      (char const   )'A', 
        (char const   )'D',      (char const   )'E',      (char const   )'T',      (char const   )'A', 
        (char const   )'C',      (char const   )'H',      (char const   )'C',      (char const   )'A', 
        (char const   )'S',      (char const   )'E',      (char const   )'C',      (char const   )'O', 
        (char const   )'L',      (char const   )'L',      (char const   )'A',      (char const   )'T', 
        (char const   )'E',      (char const   )'C',      (char const   )'R',      (char const   )'E', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )'C', 
        (char const   )'U',      (char const   )'R',      (char const   )'R',      (char const   )'E', 
        (char const   )'N',      (char const   )'T',      (char const   )'_',      (char const   )'D', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )'I', 
        (char const   )'M',      (char const   )'M',      (char const   )'E',      (char const   )'D', 
        (char const   )'I',      (char const   )'A',      (char const   )'T',      (char const   )'E', 
        (char const   )'J',      (char const   )'O',      (char const   )'I',      (char const   )'N', 
        (char const   )'S',      (char const   )'E',      (char const   )'R',      (char const   )'T', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )'C', 
        (char const   )'H',      (char const   )'P',      (char const   )'L',      (char const   )'A', 
        (char const   )'N',      (char const   )'A',      (char const   )'L',      (char const   )'Y', 
        (char const   )'Z',      (char const   )'E',      (char const   )'P',      (char const   )'R', 
        (char const   )'A',      (char const   )'G',      (char const   )'M',      (char const   )'A', 
        (char const   )'B',      (char const   )'O',      (char const   )'R',      (char const   )'T', 
        (char const   )'U',      (char const   )'P',      (char const   )'D',      (char const   )'A', 
        (char const   )'T',      (char const   )'E',      (char const   )'V',      (char const   )'A', 
        (char const   )'L',      (char const   )'U',      (char const   )'E',      (char const   )'S', 
        (char const   )'V',      (char const   )'I',      (char const   )'R',      (char const   )'T', 
        (char const   )'U',      (char const   )'A',      (char const   )'L',      (char const   )'A', 
        (char const   )'S',      (char const   )'T',      (char const   )'W',      (char const   )'H', 
        (char const   )'E',      (char const   )'N',      (char const   )'W',      (char const   )'H', 
        (char const   )'E',      (char const   )'R',      (char const   )'E',      (char const   )'C', 
        (char const   )'U',      (char const   )'R',      (char const   )'S',      (char const   )'I', 
        (char const   )'V',      (char const   )'E',      (char const   )'A',      (char const   )'F', 
        (char const   )'T',      (char const   )'E',      (char const   )'R',      (char const   )'E', 
        (char const   )'N',      (char const   )'A',      (char const   )'M',      (char const   )'E', 
        (char const   )'A',      (char const   )'N',      (char const   )'D',      (char const   )'E', 
        (char const   )'F',      (char const   )'A',      (char const   )'U',      (char const   )'L', 
        (char const   )'T',      (char const   )'A',      (char const   )'U',      (char const   )'T', 
        (char const   )'O',      (char const   )'I',      (char const   )'N',      (char const   )'C', 
        (char const   )'R',      (char const   )'E',      (char const   )'M',      (char const   )'E', 
        (char const   )'N',      (char const   )'T',      (char const   )'C',      (char const   )'A', 
        (char const   )'S',      (char const   )'T',      (char const   )'C',      (char const   )'O', 
        (char const   )'L',      (char const   )'U',      (char const   )'M',      (char const   )'N', 
        (char const   )'C',      (char const   )'O',      (char const   )'M',      (char const   )'M', 
        (char const   )'I',      (char const   )'T',      (char const   )'C',      (char const   )'O', 
        (char const   )'N',      (char const   )'F',      (char const   )'L',      (char const   )'I', 
        (char const   )'C',      (char const   )'T',      (char const   )'C',      (char const   )'R', 
        (char const   )'O',      (char const   )'S',      (char const   )'S',      (char const   )'C', 
        (char const   )'U',      (char const   )'R',      (char const   )'R',      (char const   )'E', 
        (char const   )'N',      (char const   )'T',      (char const   )'_',      (char const   )'T', 
        (char const   )'I',      (char const   )'M',      (char const   )'E',      (char const   )'S', 
        (char const   )'T',      (char const   )'A',      (char const   )'M',      (char const   )'P', 
        (char const   )'A',      (char const   )'R',      (char const   )'T',      (char const   )'I', 
        (char const   )'T',      (char const   )'I',      (char const   )'O',      (char const   )'N', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'E', 
        (char const   )'R',      (char const   )'R',      (char const   )'E',      (char const   )'D', 
        (char const   )'I',      (char const   )'S',      (char const   )'T',      (char const   )'I', 
        (char const   )'N',      (char const   )'C',      (char const   )'T',      (char const   )'D', 
        (char const   )'R',      (char const   )'O',      (char const   )'P',      (char const   )'R', 
        (char const   )'E',      (char const   )'C',      (char const   )'E',      (char const   )'D', 
        (char const   )'I',      (char const   )'N',      (char const   )'G',      (char const   )'F', 
        (char const   )'A',      (char const   )'I',      (char const   )'L',      (char const   )'I', 
        (char const   )'M',      (char const   )'I',      (char const   )'T',      (char const   )'F', 
        (char const   )'I',      (char const   )'L',      (char const   )'T',      (char const   )'E', 
        (char const   )'R',      (char const   )'E',      (char const   )'P',      (char const   )'L', 
        (char const   )'A',      (char const   )'C',      (char const   )'E',      (char const   )'F', 
        (char const   )'I',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'F',      (char const   )'O',      (char const   )'L',      (char const   )'L', 
        (char const   )'O',      (char const   )'W',      (char const   )'I',      (char const   )'N', 
        (char const   )'G',      (char const   )'F',      (char const   )'R',      (char const   )'O', 
        (char const   )'M',      (char const   )'F',      (char const   )'U',      (char const   )'L', 
        (char const   )'L',      (char const   )'I',      (char const   )'F',      (char const   )'O', 
        (char const   )'R',      (char const   )'D',      (char const   )'E',      (char const   )'R', 
        (char const   )'E',      (char const   )'S',      (char const   )'T',      (char const   )'R', 
        (char const   )'I',      (char const   )'C',      (char const   )'T',      (char const   )'O', 
        (char const   )'T',      (char const   )'H',      (char const   )'E',      (char const   )'R', 
        (char const   )'S',      (char const   )'O',      (char const   )'V',      (char const   )'E', 
        (char const   )'R',      (char const   )'I',      (char const   )'G',      (char const   )'H', 
        (char const   )'T',      (char const   )'R',      (char const   )'O',      (char const   )'L', 
        (char const   )'L',      (char const   )'B',      (char const   )'A',      (char const   )'C', 
        (char const   )'K',      (char const   )'R',      (char const   )'O',      (char const   )'W', 
        (char const   )'S',      (char const   )'U',      (char const   )'N',      (char const   )'B', 
        (char const   )'O',      (char const   )'U',      (char const   )'N',      (char const   )'D', 
        (char const   )'E',      (char const   )'D',      (char const   )'U',      (char const   )'N', 
        (char const   )'I',      (char const   )'O',      (char const   )'N',      (char const   )'U', 
        (char const   )'S',      (char const   )'I',      (char const   )'N',      (char const   )'G', 
        (char const   )'V',      (char const   )'A',      (char const   )'C',      (char const   )'U', 
        (char const   )'U',      (char const   )'M',      (char const   )'V',      (char const   )'I', 
        (char const   )'E',      (char const   )'W',      (char const   )'I',      (char const   )'N', 
        (char const   )'D',      (char const   )'O',      (char const   )'W',      (char const   )'B', 
        (char const   )'Y',      (char const   )'I',      (char const   )'N',      (char const   )'I', 
        (char const   )'T',      (char const   )'I',      (char const   )'A',      (char const   )'L', 
        (char const   )'L',      (char const   )'Y',      (char const   )'P',      (char const   )'R', 
        (char const   )'I',      (char const   )'M',      (char const   )'A',      (char const   )'R', 
        (char const   )'Y'};
static unsigned char const   aKWHash[127]  = 
  {      (unsigned char const   )82,      (unsigned char const   )113,      (unsigned char const   )130,      (unsigned char const   )80, 
        (unsigned char const   )110,      (unsigned char const   )29,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )89,      (unsigned char const   )0,      (unsigned char const   )83,      (unsigned char const   )70, 
        (unsigned char const   )0,      (unsigned char const   )53,      (unsigned char const   )35,      (unsigned char const   )84, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )129,      (unsigned char const   )92, 
        (unsigned char const   )64,      (unsigned char const   )124,      (unsigned char const   )131,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )136,      (unsigned char const   )0, 
        (unsigned char const   )134,      (unsigned char const   )126,      (unsigned char const   )0,      (unsigned char const   )22, 
        (unsigned char const   )100,      (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )121,      (unsigned char const   )78,      (unsigned char const   )0, 
        (unsigned char const   )76,      (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )58, 
        (unsigned char const   )97,      (unsigned char const   )143,      (unsigned char const   )0,      (unsigned char const   )132, 
        (unsigned char const   )108,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )111,      (unsigned char const   )24,      (unsigned char const   )0, 
        (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )137,      (unsigned char const   )63, 
        (unsigned char const   )23,      (unsigned char const   )26,      (unsigned char const   )5,      (unsigned char const   )65, 
        (unsigned char const   )138,      (unsigned char const   )103,      (unsigned char const   )120,      (unsigned char const   )0, 
        (unsigned char const   )142,      (unsigned char const   )114,      (unsigned char const   )69,      (unsigned char const   )141, 
        (unsigned char const   )66,      (unsigned char const   )118,      (unsigned char const   )72,      (unsigned char const   )0, 
        (unsigned char const   )98,      (unsigned char const   )0,      (unsigned char const   )107,      (unsigned char const   )41, 
        (unsigned char const   )0,      (unsigned char const   )106,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )102,      (unsigned char const   )99,      (unsigned char const   )104, 
        (unsigned char const   )109,      (unsigned char const   )123,      (unsigned char const   )14,      (unsigned char const   )50, 
        (unsigned char const   )122,      (unsigned char const   )0,      (unsigned char const   )87,      (unsigned char const   )0, 
        (unsigned char const   )139,      (unsigned char const   )119,      (unsigned char const   )140,      (unsigned char const   )68, 
        (unsigned char const   )127,      (unsigned char const   )135,      (unsigned char const   )86,      (unsigned char const   )81, 
        (unsigned char const   )37,      (unsigned char const   )91,      (unsigned char const   )117,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )101,      (unsigned char const   )51,      (unsigned char const   )128, 
        (unsigned char const   )125,      (unsigned char const   )0,      (unsigned char const   )133,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )44,      (unsigned char const   )0,      (unsigned char const   )93, 
        (unsigned char const   )67,      (unsigned char const   )39,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )45,      (unsigned char const   )115,      (unsigned char const   )88};
static unsigned char const   aKWNext[143]  = 
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )21,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )36,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )31, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )40, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )54, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )38,      (unsigned char const   )47, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )74,      (unsigned char const   )1, 
        (unsigned char const   )73,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )52,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57, 
        (unsigned char const   )59,      (unsigned char const   )56,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )46,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )49,      (unsigned char const   )10,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )11,      (unsigned char const   )79, 
        (unsigned char const   )95,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8, 
        (unsigned char const   )0,      (unsigned char const   )112,      (unsigned char const   )0,      (unsigned char const   )105, 
        (unsigned char const   )0,      (unsigned char const   )43,      (unsigned char const   )62,      (unsigned char const   )0, 
        (unsigned char const   )77,      (unsigned char const   )0,      (unsigned char const   )116,      (unsigned char const   )0, 
        (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )94, 
        (unsigned char const   )42,      (unsigned char const   )55,      (unsigned char const   )0,      (unsigned char const   )75, 
        (unsigned char const   )34,      (unsigned char const   )90,      (unsigned char const   )32,      (unsigned char const   )33, 
        (unsigned char const   )27,      (unsigned char const   )25,      (unsigned char const   )18,      (unsigned char const   )96, 
        (unsigned char const   )0,      (unsigned char const   )71,      (unsigned char const   )85};
static unsigned char const   aKWLen[143]  = 
  {      (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )5,      (unsigned char const   )4, 
        (unsigned char const   )6,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )3, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )3,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )3, 
        (unsigned char const   )8,      (unsigned char const   )2,      (unsigned char const   )6,      (unsigned char const   )5, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )3,      (unsigned char const   )10, 
        (unsigned char const   )4,      (unsigned char const   )7,      (unsigned char const   )6,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )2,      (unsigned char const   )6,      (unsigned char const   )5, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )4,      (unsigned char const   )7, 
        (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )6,      (unsigned char const   )11,      (unsigned char const   )6,      (unsigned char const   )2, 
        (unsigned char const   )7,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )9, 
        (unsigned char const   )6,      (unsigned char const   )10,      (unsigned char const   )4,      (unsigned char const   )6, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )10, 
        (unsigned char const   )6,      (unsigned char const   )5,      (unsigned char const   )7,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )7,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5, 
        (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )6,      (unsigned char const   )5, 
        (unsigned char const   )7,      (unsigned char const   )3,      (unsigned char const   )6,      (unsigned char const   )4, 
        (unsigned char const   )7,      (unsigned char const   )6,      (unsigned char const   )12,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )5,      (unsigned char const   )4, 
        (unsigned char const   )7,      (unsigned char const   )6,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )9,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )13,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )8,      (unsigned char const   )5,      (unsigned char const   )17,      (unsigned char const   )12, 
        (unsigned char const   )7,      (unsigned char const   )9,      (unsigned char const   )8,      (unsigned char const   )8, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )9,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )5, 
        (unsigned char const   )9,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )2, 
        (unsigned char const   )5,      (unsigned char const   )8,      (unsigned char const   )6,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )8,      (unsigned char const   )4,      (unsigned char const   )3, 
        (unsigned char const   )9,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )9,      (unsigned char const   )3,      (unsigned char const   )7};
static unsigned short const   aKWOffset[143]  = 
  {      (unsigned short const   )0,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )8, 
        (unsigned short const   )9,      (unsigned short const   )14,      (unsigned short const   )16,      (unsigned short const   )20, 
        (unsigned short const   )23,      (unsigned short const   )25,      (unsigned short const   )25,      (unsigned short const   )29, 
        (unsigned short const   )33,      (unsigned short const   )36,      (unsigned short const   )41,      (unsigned short const   )46, 
        (unsigned short const   )48,      (unsigned short const   )53,      (unsigned short const   )54,      (unsigned short const   )59, 
        (unsigned short const   )62,      (unsigned short const   )65,      (unsigned short const   )67,      (unsigned short const   )69, 
        (unsigned short const   )78,      (unsigned short const   )81,      (unsigned short const   )86,      (unsigned short const   )90, 
        (unsigned short const   )90,      (unsigned short const   )94,      (unsigned short const   )99,      (unsigned short const   )101, 
        (unsigned short const   )105,      (unsigned short const   )111,      (unsigned short const   )119,      (unsigned short const   )123, 
        (unsigned short const   )123,      (unsigned short const   )123,      (unsigned short const   )126,      (unsigned short const   )129, 
        (unsigned short const   )132,      (unsigned short const   )137,      (unsigned short const   )142,      (unsigned short const   )146, 
        (unsigned short const   )147,      (unsigned short const   )152,      (unsigned short const   )156,      (unsigned short const   )160, 
        (unsigned short const   )168,      (unsigned short const   )174,      (unsigned short const   )181,      (unsigned short const   )184, 
        (unsigned short const   )184,      (unsigned short const   )187,      (unsigned short const   )189,      (unsigned short const   )195, 
        (unsigned short const   )205,      (unsigned short const   )208,      (unsigned short const   )213,      (unsigned short const   )213, 
        (unsigned short const   )217,      (unsigned short const   )221,      (unsigned short const   )228,      (unsigned short const   )233, 
        (unsigned short const   )238,      (unsigned short const   )241,      (unsigned short const   )244,      (unsigned short const   )248, 
        (unsigned short const   )253,      (unsigned short const   )259,      (unsigned short const   )265,      (unsigned short const   )265, 
        (unsigned short const   )271,      (unsigned short const   )272,      (unsigned short const   )276,      (unsigned short const   )282, 
        (unsigned short const   )286,      (unsigned short const   )293,      (unsigned short const   )299,      (unsigned short const   )311, 
        (unsigned short const   )320,      (unsigned short const   )322,      (unsigned short const   )328,      (unsigned short const   )333, 
        (unsigned short const   )335,      (unsigned short const   )342,      (unsigned short const   )347,      (unsigned short const   )352, 
        (unsigned short const   )358,      (unsigned short const   )364,      (unsigned short const   )370,      (unsigned short const   )374, 
        (unsigned short const   )378,      (unsigned short const   )381,      (unsigned short const   )390,      (unsigned short const   )394, 
        (unsigned short const   )400,      (unsigned short const   )402,      (unsigned short const   )409,      (unsigned short const   )411, 
        (unsigned short const   )413,      (unsigned short const   )422,      (unsigned short const   )426,      (unsigned short const   )432, 
        (unsigned short const   )438,      (unsigned short const   )446,      (unsigned short const   )451,      (unsigned short const   )451, 
        (unsigned short const   )451,      (unsigned short const   )467,      (unsigned short const   )476,      (unsigned short const   )483, 
        (unsigned short const   )484,      (unsigned short const   )491,      (unsigned short const   )494,      (unsigned short const   )503, 
        (unsigned short const   )506,      (unsigned short const   )511,      (unsigned short const   )516,      (unsigned short const   )523, 
        (unsigned short const   )528,      (unsigned short const   )537,      (unsigned short const   )541,      (unsigned short const   )545, 
        (unsigned short const   )547,      (unsigned short const   )551,      (unsigned short const   )559,      (unsigned short const   )565, 
        (unsigned short const   )568,      (unsigned short const   )573,      (unsigned short const   )581,      (unsigned short const   )581, 
        (unsigned short const   )585,      (unsigned short const   )594,      (unsigned short const   )599,      (unsigned short const   )604, 
        (unsigned short const   )610,      (unsigned short const   )613,      (unsigned short const   )616,      (unsigned short const   )619, 
        (unsigned short const   )621,      (unsigned short const   )626,      (unsigned short const   )630};
static unsigned char const   aKWCode[143]  = 
  {      (unsigned char const   )95,      (unsigned char const   )112,      (unsigned char const   )156,      (unsigned char const   )39, 
        (unsigned char const   )58,      (unsigned char const   )41,      (unsigned char const   )120,      (unsigned char const   )67, 
        (unsigned char const   )33,      (unsigned char const   )128,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )47,      (unsigned char const   )2,      (unsigned char const   )65,      (unsigned char const   )158, 
        (unsigned char const   )38,      (unsigned char const   )24,      (unsigned char const   )134,      (unsigned char const   )16, 
        (unsigned char const   )114,      (unsigned char const   )154,      (unsigned char const   )11,      (unsigned char const   )127, 
        (unsigned char const   )155,      (unsigned char const   )91,      (unsigned char const   )124,      (unsigned char const   )21, 
        (unsigned char const   )21,      (unsigned char const   )43,      (unsigned char const   )50,      (unsigned char const   )82, 
        (unsigned char const   )13,      (unsigned char const   )133,      (unsigned char const   )94,      (unsigned char const   )51, 
        (unsigned char const   )19,      (unsigned char const   )66,      (unsigned char const   )117,      (unsigned char const   )47, 
        (unsigned char const   )132,      (unsigned char const   )6,      (unsigned char const   )28,      (unsigned char const   )111, 
        (unsigned char const   )114,      (unsigned char const   )157,      (unsigned char const   )71,      (unsigned char const   )9, 
        (unsigned char const   )20,      (unsigned char const   )115,      (unsigned char const   )146,      (unsigned char const   )69, 
        (unsigned char const   )68,      (unsigned char const   )126,      (unsigned char const   )77,      (unsigned char const   )121, 
        (unsigned char const   )119,      (unsigned char const   )3,      (unsigned char const   )25,      (unsigned char const   )81, 
        (unsigned char const   )114,      (unsigned char const   )14,      (unsigned char const   )32,      (unsigned char const   )143, 
        (unsigned char const   )47,      (unsigned char const   )5,      (unsigned char const   )114,      (unsigned char const   )89, 
        (unsigned char const   )48,      (unsigned char const   )147,      (unsigned char const   )92,      (unsigned char const   )142, 
        (unsigned char const   )35,      (unsigned char const   )31,      (unsigned char const   )40,      (unsigned char const   )152, 
        (unsigned char const   )109,      (unsigned char const   )17,      (unsigned char const   )97,      (unsigned char const   )8, 
        (unsigned char const   )139,      (unsigned char const   )123,      (unsigned char const   )46,      (unsigned char const   )4, 
        (unsigned char const   )30,      (unsigned char const   )70,      (unsigned char const   )27,      (unsigned char const   )125, 
        (unsigned char const   )135,      (unsigned char const   )80,      (unsigned char const   )84,      (unsigned char const   )153, 
        (unsigned char const   )145,      (unsigned char const   )72,      (unsigned char const   )29,      (unsigned char const   )96, 
        (unsigned char const   )44,      (unsigned char const   )116,      (unsigned char const   )122,      (unsigned char const   )15, 
        (unsigned char const   )49,      (unsigned char const   )36,      (unsigned char const   )60,      (unsigned char const   )10, 
        (unsigned char const   )37,      (unsigned char const   )114,      (unsigned char const   )97,      (unsigned char const   )97, 
        (unsigned char const   )85,      (unsigned char const   )87,      (unsigned char const   )7,      (unsigned char const   )136, 
        (unsigned char const   )45,      (unsigned char const   )129,      (unsigned char const   )88,      (unsigned char const   )42, 
        (unsigned char const   )144,      (unsigned char const   )161,      (unsigned char const   )73,      (unsigned char const   )83, 
        (unsigned char const   )86,      (unsigned char const   )138,      (unsigned char const   )114,      (unsigned char const   )18, 
        (unsigned char const   )141,      (unsigned char const   )74,      (unsigned char const   )93,      (unsigned char const   )160, 
        (unsigned char const   )114,      (unsigned char const   )12,      (unsigned char const   )76,      (unsigned char const   )75, 
        (unsigned char const   )90,      (unsigned char const   )130,      (unsigned char const   )140,      (unsigned char const   )78, 
        (unsigned char const   )79,      (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )34, 
        (unsigned char const   )64,      (unsigned char const   )131,      (unsigned char const   )118};
static int keywordCode(char const   *z , int n , int *pType ) 
{ 
  int i ;
  int j ;
  char const   *zKW ;

  {
  if (n >= 2) {
    i = (int )((((int const   )sqlite3UpperToLower[(unsigned char )*(z + 0)] * 4 ^ (int const   )sqlite3UpperToLower[(unsigned char )*(z + (n - 1))] * 3) ^ (int const   )n) % 127);
    i = (int )aKWHash[i] - 1;
    while (i >= 0) {
      if ((int const   )aKWLen[i] != (int const   )n) {
        goto __Cont;
      }
      j = 0;
      zKW = & zKWText[aKWOffset[i]];
      while (1) {
        if (j < n) {
          if (! (((int const   )*(z + j) & -33) == (int const   )*(zKW + j))) {
            break;
          }
        } else {
          break;
        }
        j ++;
      }
      if (j < n) {
        goto __Cont;
      }
      *pType = (int )aKWCode[i];
      break;
      __Cont: /* CIL Label */ 
      i = (int )aKWNext[i] - 1;
    }
  }
  return (n);
}
}
static int sqlite3KeywordCode(unsigned char const   *z , int n ) 
{ 
  int id ;

  {
  id = 59;
  keywordCode((char const   *)((char *)z), n, & id);
  return (id);
}
}
int sqlite3_keyword_name(int i , char const   **pzName , int *pnName ) 
{ 


  {
  if (i < 0) {
    return (1);
  } else
  if (i >= 143) {
    return (1);
  }
  *pzName = zKWText + (int const   )aKWOffset[i];
  *pnName = (int )aKWLen[i];
  return (0);
}
}
int sqlite3_keyword_count(void) 
{ 


  {
  return (143);
}
}
int sqlite3_keyword_check(char const   *zName , int nName ) 
{ 
  int tmp ;

  {
  tmp = sqlite3KeywordCode((u8 const   *)zName, nName);
  return (59 != tmp);
}
}
static int sqlite3IsIdChar(u8 c ) 
{ 


  {
  return (((int const   )sqlite3CtypeMap[c] & 70) != 0);
}
}
static int getToken(unsigned char const   **pz ) 
{ 
  unsigned char const   *z ;
  int t ;
  int tmp ;
  int tmp___0 ;

  {
  z = *pz;
  while (1) {
    tmp = sqlite3GetToken(z, & t);
    z += tmp;
    if (! (t == 177)) {
      break;
    }
  }
  if (t == 59) {
    t = 59;
  } else
  if (t == 113) {
    t = 59;
  } else
  if (t == 114) {
    t = 59;
  } else
  if (t == 159) {
    t = 59;
  } else
  if (t == 160) {
    t = 59;
  } else {
    tmp___0 = sqlite3ParserFallback(t);
    if (tmp___0 == 59) {
      t = 59;
    }
  }
  *pz = z;
  return (t);
}
}
static int analyzeWindowKeyword(unsigned char const   *z ) 
{ 
  int t ;

  {
  t = getToken(& z);
  if (t != 59) {
    return (59);
  }
  t = getToken(& z);
  if (t != 24) {
    return (59);
  }
  return (159);
}
}
static int analyzeOverKeyword(unsigned char const   *z , int lastToken ) 
{ 
  int t ;
  int tmp ;

  {
  if (lastToken == 23) {
    tmp = getToken(& z);
    t = tmp;
    if (t == 22) {
      return (160);
    } else
    if (t == 59) {
      return (160);
    }
  }
  return (59);
}
}
static int analyzeFilterKeyword(unsigned char const   *z , int lastToken ) 
{ 
  int tmp ;

  {
  if (lastToken == 23) {
    tmp = getToken(& z);
    if (tmp == 22) {
      return (161);
    }
  }
  return (59);
}
}
static int sqlite3GetToken(unsigned char const   *z , int *tokenType ) 
{ 
  int i ;
  int c ;
  int delim ;
  int n ;
  int tmp ;

  {
  switch ((int const   )aiClass[*z]) {
  case 7: 
  i = 1;
  while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 1) {
    i ++;
  }
  *tokenType = 177;
  return (i);
  case 11: 
  if ((int const   )*(z + 1) == 45) {
    i = 2;
    while (1) {
      c = (int )*(z + i);
      if (c != 0) {
        if (! (c != 10)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    *tokenType = 177;
    return (i);
  }
  *tokenType = 104;
  return (1);
  case 17: 
  *tokenType = 22;
  return (1);
  case 18: 
  *tokenType = 23;
  return (1);
  case 19: 
  *tokenType = 1;
  return (1);
  case 20: 
  *tokenType = 103;
  return (1);
  case 21: 
  *tokenType = 105;
  return (1);
  case 16: 
  if ((int const   )*(z + 1) != 42) {
    *tokenType = 106;
    return (1);
  } else
  if ((int const   )*(z + 2) == 0) {
    *tokenType = 106;
    return (1);
  }
  i = 3;
  c = (int )*(z + 2);
  while (1) {
    if (c != 42) {
      goto _L;
    } else
    if ((int const   )*(z + i) != 47) {
      _L: /* CIL Label */ 
      c = (int )*(z + i);
      if (! (c != 0)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (c) {
    i ++;
  }
  *tokenType = 177;
  return (i);
  case 22: 
  *tokenType = 107;
  return (1);
  case 14: 
  *tokenType = 53;
  return (1 + ((int const   )*(z + 1) == 61));
  case 12: 
  c = (int )*(z + 1);
  if (c == 61) {
    *tokenType = 55;
    return (2);
  } else
  if (c == 62) {
    *tokenType = 52;
    return (2);
  } else
  if (c == 60) {
    *tokenType = 101;
    return (2);
  } else {
    *tokenType = 56;
    return (1);
  }
  case 13: 
  c = (int )*(z + 1);
  if (c == 61) {
    *tokenType = 57;
    return (2);
  } else
  if (c == 62) {
    *tokenType = 102;
    return (2);
  } else {
    *tokenType = 54;
    return (1);
  }
  case 15: 
  if ((int const   )*(z + 1) != 61) {
    *tokenType = 178;
    return (1);
  } else {
    *tokenType = 52;
    return (2);
  }
  case 10: 
  if ((int const   )*(z + 1) != 124) {
    *tokenType = 100;
    return (1);
  } else {
    *tokenType = 108;
    return (2);
  }
  case 23: 
  *tokenType = 26;
  return (1);
  case 24: 
  *tokenType = 99;
  return (1);
  case 25: 
  *tokenType = 110;
  return (1);
  case 8: 
  delim = (int )*(z + 0);
  i = 1;
  while (1) {
    c = (int )*(z + i);
    if (! (c != 0)) {
      break;
    }
    if (c == delim) {
      if ((int const   )*(z + (i + 1)) == (int const   )delim) {
        i ++;
      } else {
        break;
      }
    }
    i ++;
  }
  if (c == 39) {
    *tokenType = 113;
    return (i + 1);
  } else
  if (c != 0) {
    *tokenType = 59;
    return (i + 1);
  } else {
    *tokenType = 178;
    return (i);
  }
  case 26: 
  if (! ((int const   )sqlite3CtypeMap[(unsigned char )*(z + 1)] & 4)) {
    *tokenType = 137;
    return (1);
  }
  case 3: 
  *tokenType = 150;
  if ((int const   )*(z + 0) == 48) {
    if ((int const   )*(z + 1) == 120) {
      goto _L___0;
    } else
    if ((int const   )*(z + 1) == 88) {
      _L___0: /* CIL Label */ 
      if ((int const   )sqlite3CtypeMap[(unsigned char )*(z + 2)] & 8) {
        i = 3;
        while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 8) {
          i ++;
        }
        return (i);
      }
    }
  }
  i = 0;
  while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 4) {
    i ++;
  }
  if ((int const   )*(z + i) == 46) {
    i ++;
    while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 4) {
      i ++;
    }
    *tokenType = 148;
  }
  if ((int const   )*(z + i) == 101) {
    goto _L___3;
  } else
  if ((int const   )*(z + i) == 69) {
    _L___3: /* CIL Label */ 
    if ((int const   )sqlite3CtypeMap[(unsigned char )*(z + (i + 1))] & 4) {
      goto _L___1;
    } else
    if ((int const   )*(z + (i + 1)) == 43) {
      goto _L___2;
    } else
    if ((int const   )*(z + (i + 1)) == 45) {
      _L___2: /* CIL Label */ 
      if ((int const   )sqlite3CtypeMap[(unsigned char )*(z + (i + 2))] & 4) {
        _L___1: /* CIL Label */ 
        i += 2;
        while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 4) {
          i ++;
        }
        *tokenType = 148;
      }
    }
  }
  while (((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 70) != 0) {
    *tokenType = 178;
    i ++;
  }
  return (i);
  case 9: 
  i = 1;
  c = (int )*(z + 0);
  while (1) {
    if (c != 93) {
      c = (int )*(z + i);
      if (! (c != 0)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (c == 93) {
    *tokenType = 59;
  } else {
    *tokenType = 178;
  }
  return (i);
  case 6: 
  *tokenType = 151;
  i = 1;
  while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 4) {
    i ++;
  }
  return (i);
  case 5: 
  case 4: 
  n = 0;
  *tokenType = 151;
  i = 1;
  while (1) {
    c = (int )*(z + i);
    if (! (c != 0)) {
      break;
    }
    if (((int const   )sqlite3CtypeMap[(unsigned char )c] & 70) != 0) {
      n ++;
    } else
    if (c == 40) {
      if (n > 0) {
        while (1) {
          i ++;
          c = (int )*(z + i);
          if (c != 0) {
            if (! ((int const   )sqlite3CtypeMap[(unsigned char )c] & 1)) {
              if (! (c != 41)) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        }
        if (c == 41) {
          i ++;
        } else {
          *tokenType = 178;
        }
        break;
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (c == 58) {
      if ((int const   )*(z + (i + 1)) == 58) {
        i ++;
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if (n == 0) {
    *tokenType = 178;
  }
  return (i);
  case 1: 
  i = 1;
  while ((int const   )aiClass[*(z + i)] <= 1) {
    i ++;
  }
  if (((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 70) != 0) {
    i ++;
    break;
  }
  *tokenType = 59;
  tmp = keywordCode((char const   *)((char *)z), i, tokenType);
  return (tmp);
  case 0: 
  if ((int const   )*(z + 1) == 39) {
    *tokenType = 149;
    i = 2;
    while ((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 8) {
      i ++;
    }
    if ((int const   )*(z + i) != 39) {
      goto _L___5;
    } else
    if (i % 2) {
      _L___5: /* CIL Label */ 
      *tokenType = 178;
      while (1) {
        if (*(z + i)) {
          if (! ((int const   )*(z + i) != 39)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
    }
    if (*(z + i)) {
      i ++;
    }
    return (i);
  }
  case 2: 
  i = 1;
  break;
  case 28: 
  *tokenType = 178;
  return (0);
  default: 
  *tokenType = 178;
  return (1);
  }
  while (((int const   )sqlite3CtypeMap[(unsigned char )*(z + i)] & 70) != 0) {
    i ++;
  }
  *tokenType = 59;
  return (i);
}
}
static int sqlite3RunParser(Parse *pParse , char const   *zSql , char **pzErrMsg ) 
{ 
  int nErr ;
  void *pEngine ;
  int n ;
  int tokenType ;
  int lastTokenParsed ;
  sqlite3 *db ;
  int mxSqlLen ;
  yyParser sEngine ;
  char const   *tmp ;
  AutoincInfo *p ;
  Table *p___0 ;

  {
  nErr = 0;
  n = 0;
  lastTokenParsed = -1;
  db = pParse->db;
  mxSqlLen = db->aLimit[1];
  if (db->nVdbeActive == 0) {
    db->u1.isInterrupted = (int volatile   )0;
  }
  pParse->rc = 0;
  pParse->zTail = zSql;
  pEngine = (void *)(& sEngine);
  sqlite3ParserInit(pEngine, pParse);
  pParse->pParentParse = db->pParse;
  db->pParse = pParse;
  while (1) {
    n = sqlite3GetToken((unsigned char const   *)((u8 *)zSql), & tokenType);
    mxSqlLen -= n;
    if (mxSqlLen < 0) {
      pParse->rc = 18;
      break;
    }
    if (tokenType >= 159) {
      if (db->u1.isInterrupted) {
        pParse->rc = 9;
        break;
      }
      if (tokenType == 177) {
        zSql += n;
        continue;
      }
      if ((int const   )*(zSql + 0) == 0) {
        if (lastTokenParsed == 1) {
          tokenType = 0;
        } else
        if (lastTokenParsed == 0) {
          break;
        } else {
          tokenType = 1;
        }
        n = 0;
      } else
      if (tokenType == 159) {
        tokenType = analyzeWindowKeyword((u8 const   *)(zSql + 6));
      } else
      if (tokenType == 160) {
        tokenType = analyzeOverKeyword((u8 const   *)(zSql + 4), lastTokenParsed);
      } else
      if (tokenType == 161) {
        tokenType = analyzeFilterKeyword((u8 const   *)(zSql + 6), lastTokenParsed);
      } else {
        sqlite3ErrorMsg(pParse, "unrecognized token: \"%.*s\"", n, zSql);
        break;
      }
    }
    pParse->sLastToken.z = zSql;
    pParse->sLastToken.n = (unsigned int )n;
    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);
    lastTokenParsed = tokenType;
    zSql += n;
    if (pParse->rc != 0) {
      break;
    }
  }
  sqlite3ParserFinalize(pEngine);
  if (db->mallocFailed) {
    pParse->rc = 7;
  }
  if (pParse->rc != 0) {
    if (pParse->rc != 101) {
      if ((unsigned long )pParse->zErrMsg == (unsigned long )((char *)0)) {
        tmp = sqlite3ErrStr(pParse->rc);
        pParse->zErrMsg = sqlite3MPrintf(db, "%s", tmp);
      }
    }
  }
  if (pParse->zErrMsg) {
    *pzErrMsg = pParse->zErrMsg;
    sqlite3_log(pParse->rc, "%s in \"%s\"", *pzErrMsg, pParse->zTail);
    pParse->zErrMsg = (char *)0;
    nErr ++;
  }
  pParse->zTail = zSql;
  if (pParse->pVdbe) {
    if (pParse->nErr > 0) {
      if ((int )pParse->nested == 0) {
        sqlite3VdbeDelete(pParse->pVdbe);
        pParse->pVdbe = (Vdbe *)0;
      }
    }
  }
  if ((int )pParse->nested == 0) {
    sqlite3DbFree(db, (void *)pParse->aTableLock);
    pParse->aTableLock = (TableLock *)0;
    pParse->nTableLock = 0;
  }
  sqlite3_free((void *)pParse->apVtabLock);
  if (! ((int )pParse->eParseMode != 0)) {
    sqlite3DeleteTable(db, pParse->pNewTable);
  }
  if (! ((int )pParse->eParseMode >= 2)) {
    sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  }
  if (pParse->pWithToFree) {
    sqlite3WithDelete(db, pParse->pWithToFree);
  }
  sqlite3DbFree(db, (void *)pParse->pVList);
  while (pParse->pAinc) {
    p = pParse->pAinc;
    pParse->pAinc = p->pNext;
    sqlite3DbFreeNN(db, (void *)p);
  }
  while (pParse->pZombieTab) {
    p___0 = pParse->pZombieTab;
    pParse->pZombieTab = p___0->pNextZombie;
    sqlite3DeleteTable(db, p___0);
  }
  db->pParse = pParse->pParentParse;
  pParse->pParentParse = (Parse *)0;
  return (nErr);
}
}
static u8 const   trans[8][8]  = 
  { {        (u8 const   )1,        (u8 const   )0,        (u8 const   )2,        (u8 const   )3, 
            (u8 const   )4,        (u8 const   )2,        (u8 const   )2,        (u8 const   )2}, 
   {        (u8 const   )1,        (u8 const   )1,        (u8 const   )2,        (u8 const   )3, 
            (u8 const   )4,        (u8 const   )2,        (u8 const   )2,        (u8 const   )2}, 
   {        (u8 const   )1,        (u8 const   )2,        (u8 const   )2,        (u8 const   )2, 
            (u8 const   )2,        (u8 const   )2,        (u8 const   )2,        (u8 const   )2}, 
   {        (u8 const   )1,        (u8 const   )3,        (u8 const   )3,        (u8 const   )2, 
            (u8 const   )4,        (u8 const   )2,        (u8 const   )2,        (u8 const   )2}, 
   {        (u8 const   )1,        (u8 const   )4,        (u8 const   )2,        (u8 const   )2, 
            (u8 const   )2,        (u8 const   )4,        (u8 const   )5,        (u8 const   )2}, 
   {        (u8 const   )6,        (u8 const   )5,        (u8 const   )5,        (u8 const   )5, 
            (u8 const   )5,        (u8 const   )5,        (u8 const   )5,        (u8 const   )5}, 
   {        (u8 const   )6,        (u8 const   )6,        (u8 const   )5,        (u8 const   )5, 
            (u8 const   )5,        (u8 const   )5,        (u8 const   )5,        (u8 const   )7}, 
   {        (u8 const   )1,        (u8 const   )7,        (u8 const   )5,        (u8 const   )5, 
            (u8 const   )5,        (u8 const   )5,        (u8 const   )5,        (u8 const   )5}};
int sqlite3_complete(char const   *zSql ) 
{ 
  u8 state ;
  u8 token ;
  int c ;
  int nId ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  state = (u8 )0;
  while (*zSql) {
    switch ((int const   )*zSql) {
    case 59: 
    token = (u8 )0;
    break;
    case 12: 
    case 10: 
    case 9: 
    case 13: 
    case 32: 
    token = (u8 )1;
    break;
    case 47: 
    if ((int const   )*(zSql + 1) != 42) {
      token = (u8 )2;
      break;
    }
    zSql += 2;
    while (1) {
      if (*(zSql + 0)) {
        if (! ((int const   )*(zSql + 0) != 42)) {
          if (! ((int const   )*(zSql + 1) != 47)) {
            break;
          }
        }
      } else {
        break;
      }
      zSql ++;
    }
    if ((int const   )*(zSql + 0) == 0) {
      return (0);
    }
    zSql ++;
    token = (u8 )1;
    break;
    case 45: 
    if ((int const   )*(zSql + 1) != 45) {
      token = (u8 )2;
      break;
    }
    while (1) {
      if (*zSql) {
        if (! ((int const   )*zSql != 10)) {
          break;
        }
      } else {
        break;
      }
      zSql ++;
    }
    if ((int const   )*zSql == 0) {
      return ((int )state == 1);
    }
    token = (u8 )1;
    break;
    case 91: 
    zSql ++;
    while (1) {
      if (*zSql) {
        if (! ((int const   )*zSql != 93)) {
          break;
        }
      } else {
        break;
      }
      zSql ++;
    }
    if ((int const   )*zSql == 0) {
      return (0);
    }
    token = (u8 )2;
    break;
    case 39: 
    case 34: 
    case 96: 
    c = (int )*zSql;
    zSql ++;
    while (1) {
      if (*zSql) {
        if (! ((int const   )*zSql != (int const   )c)) {
          break;
        }
      } else {
        break;
      }
      zSql ++;
    }
    if ((int const   )*zSql == 0) {
      return (0);
    }
    token = (u8 )2;
    break;
    default: 
    if (((int const   )sqlite3CtypeMap[(u8 )*zSql] & 70) != 0) {
      nId = 1;
      while (((int const   )sqlite3CtypeMap[(unsigned char )*(zSql + nId)] & 70) != 0) {
        nId ++;
      }
      switch ((int const   )*zSql) {
      case 67: 
      case 99: 
      if (nId == 6) {
        tmp = sqlite3_strnicmp(zSql, "create", 6);
        if (tmp == 0) {
          token = (u8 )4;
        } else {
          token = (u8 )2;
        }
      } else {
        token = (u8 )2;
      }
      break;
      case 84: 
      case 116: 
      if (nId == 7) {
        tmp___2 = sqlite3_strnicmp(zSql, "trigger", 7);
        if (tmp___2 == 0) {
          token = (u8 )6;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (nId == 4) {
        tmp___1 = sqlite3_strnicmp(zSql, "temp", 4);
        if (tmp___1 == 0) {
          token = (u8 )5;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (nId == 9) {
        tmp___0 = sqlite3_strnicmp(zSql, "temporary", 9);
        if (tmp___0 == 0) {
          token = (u8 )5;
        } else {
          token = (u8 )2;
        }
      } else {
        token = (u8 )2;
      }
      break;
      case 69: 
      case 101: 
      if (nId == 3) {
        tmp___4 = sqlite3_strnicmp(zSql, "end", 3);
        if (tmp___4 == 0) {
          token = (u8 )7;
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (nId == 7) {
        tmp___3 = sqlite3_strnicmp(zSql, "explain", 7);
        if (tmp___3 == 0) {
          token = (u8 )3;
        } else {
          token = (u8 )2;
        }
      } else {
        token = (u8 )2;
      }
      break;
      default: 
      token = (u8 )2;
      break;
      }
      zSql += nId - 1;
    } else {
      token = (u8 )2;
    }
    break;
    }
    state = (u8 )trans[state][token];
    zSql ++;
  }
  return ((int )state == 1);
}
}
int sqlite3_complete16(void const   *zSql ) 
{ 
  sqlite3_value *pVal ;
  char const   *zSql8 ;
  int rc ;
  void const   *tmp ;

  {
  rc = sqlite3_initialize();
  if (rc) {
    return (rc);
  }
  pVal = sqlite3ValueNew((sqlite3 *)0);
  sqlite3ValueSetStr(pVal, -1, zSql, (u8 )2, (void (*)(void * ))0);
  tmp = sqlite3ValueText(pVal, (u8 )1);
  zSql8 = (char const   *)tmp;
  if (zSql8) {
    rc = sqlite3_complete(zSql8);
  } else {
    rc = 7;
  }
  sqlite3ValueFree(pVal);
  return (rc & 255);
}
}
char const   *sqlite3_libversion(void) 
{ 


  {
  return (sqlite3_version);
}
}
int sqlite3_libversion_number(void) 
{ 


  {
  return (3030000);
}
}
int sqlite3_threadsafe(void) 
{ 


  {
  return (0);
}
}
char *sqlite3_temp_directory  =    (char *)0;
char *sqlite3_data_directory  =    (char *)0;
int sqlite3_initialize(void) 
{ 
  int rc ;

  {
  if (sqlite3Config.isInit) {
    return (0);
  }
  rc = 0;
  if (rc) {
    return (rc);
  }
  sqlite3Config.isMutexInit = 1;
  if (! sqlite3Config.isMallocInit) {
    rc = sqlite3MallocInit();
  }
  if (rc == 0) {
    sqlite3Config.isMallocInit = 1;
    if (! sqlite3Config.pInitMutex) {
      sqlite3Config.pInitMutex = (sqlite3_mutex *)8;
      if (sqlite3Config.bCoreMutex) {
        if (! sqlite3Config.pInitMutex) {
          rc = 7;
        }
      }
    }
  }
  if (rc == 0) {
    (sqlite3Config.nRefInitMutex) ++;
  }
  if (rc != 0) {
    return (rc);
  }
  if (sqlite3Config.isInit == 0) {
    if (sqlite3Config.inProgress == 0) {
      sqlite3Config.inProgress = 1;
      memset((void *)(& sqlite3BuiltinFunctions), 0, sizeof(sqlite3BuiltinFunctions));
      sqlite3RegisterBuiltinFunctions();
      if (sqlite3Config.isPCacheInit == 0) {
        rc = sqlite3PcacheInitialize();
      }
      if (rc == 0) {
        sqlite3Config.isPCacheInit = 1;
        rc = sqlite3OsInit();
      }
      if (rc == 0) {
        sqlite3PCacheBufferSetup(sqlite3Config.pPage, sqlite3Config.szPage, sqlite3Config.nPage);
        sqlite3Config.isInit = 1;
      }
      sqlite3Config.inProgress = 0;
    }
  }
  (sqlite3Config.nRefInitMutex) --;
  if (sqlite3Config.nRefInitMutex <= 0) {
    sqlite3Config.pInitMutex = (sqlite3_mutex *)0;
  }
  return (rc);
}
}
int sqlite3_shutdown(void) 
{ 


  {
  if (sqlite3Config.isInit) {
    sqlite3_os_end();
    sqlite3_reset_auto_extension();
    sqlite3Config.isInit = 0;
  }
  if (sqlite3Config.isPCacheInit) {
    sqlite3PcacheShutdown();
    sqlite3Config.isPCacheInit = 0;
  }
  if (sqlite3Config.isMallocInit) {
    sqlite3MallocEnd();
    sqlite3Config.isMallocInit = 0;
    sqlite3_data_directory = (char *)0;
    sqlite3_temp_directory = (char *)0;
  }
  if (sqlite3Config.isMutexInit) {
    sqlite3Config.isMutexInit = 0;
  }
  return (0);
}
}
int sqlite3_config(int op  , ...) 
{ 
  va_list ap ;
  int rc ;
  int tmp ;
  sqlite3_mem_methods *tmp___1 ;
  sqlite3_mem_methods *tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  sqlite3_pcache_methods2 *tmp___15 ;
  sqlite3_pcache_methods2 *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void (*tmp___20)(void * , int  , char const   * ) ;
  void *tmp___21 ;
  u8 tmp___22 ;
  u8 tmp___23 ;
  sqlite_int64 szMmap ;
  sqlite_int64 tmp___25 ;
  sqlite_int64 mxMmap ;
  sqlite_int64 tmp___27 ;
  u32 tmp___28 ;
  int tmp___29 ;

  {
  rc = 0;
  if (sqlite3Config.isInit) {
    tmp = sqlite3MisuseError(156579);
    return (tmp);
  }
  __builtin_va_start(ap, op);
  switch (op) {
  case 4: 
  tmp___1 = __builtin_va_arg(ap, sqlite3_mem_methods *);
  sqlite3Config.m = *tmp___1;
  break;
  case 5: 
  if ((unsigned long )sqlite3Config.m.xMalloc == (unsigned long )((void *(*)(int  ))0)) {
    sqlite3MemSetDefault();
  }
  tmp___3 = __builtin_va_arg(ap, sqlite3_mem_methods *);
  *tmp___3 = sqlite3Config.m;
  break;
  case 9: 
  tmp___4 = __builtin_va_arg(ap, int );
  sqlite3Config.bMemstat = tmp___4;
  break;
  case 27: 
  tmp___5 = __builtin_va_arg(ap, int );
  sqlite3Config.bSmallMalloc = tmp___5;
  break;
  case 7: 
  tmp___6 = __builtin_va_arg(ap, void *);
  sqlite3Config.pPage = tmp___6;
  tmp___7 = __builtin_va_arg(ap, int );
  sqlite3Config.szPage = tmp___7;
  tmp___8 = __builtin_va_arg(ap, int );
  sqlite3Config.nPage = tmp___8;
  break;
  case 24: 
  tmp___10 = __builtin_va_arg(ap, int *);
  tmp___11 = sqlite3HeaderSizeBtree();
  tmp___12 = sqlite3HeaderSizePcache();
  tmp___13 = sqlite3HeaderSizePcache1();
  *tmp___10 = (tmp___11 + tmp___12) + tmp___13;
  break;
  case 14: 
  break;
  case 15: 
  rc = 1;
  break;
  case 18: 
  tmp___15 = __builtin_va_arg(ap, sqlite3_pcache_methods2 *);
  sqlite3Config.pcache2 = *tmp___15;
  break;
  case 19: 
  if ((unsigned long )sqlite3Config.pcache2.xInit == (unsigned long )((int (*)(void * ))0)) {
    sqlite3PCacheSetDefault();
  }
  tmp___17 = __builtin_va_arg(ap, sqlite3_pcache_methods2 *);
  *tmp___17 = sqlite3Config.pcache2;
  break;
  case 13: 
  tmp___18 = __builtin_va_arg(ap, int );
  sqlite3Config.szLookaside = tmp___18;
  tmp___19 = __builtin_va_arg(ap, int );
  sqlite3Config.nLookaside = tmp___19;
  break;
  case 16: 
  tmp___20 = __builtin_va_arg(ap, void (*)(void * , int  , char const   * ));
  sqlite3Config.xLog = tmp___20;
  tmp___21 = __builtin_va_arg(ap, void *);
  sqlite3Config.pLogArg = tmp___21;
  break;
  case 17: 
  tmp___22 = __builtin_va_arg(ap, int );
  sqlite3Config.bOpenUri = tmp___22;
  break;
  case 20: 
  tmp___23 = __builtin_va_arg(ap, int );
  sqlite3Config.bUseCis = tmp___23;
  break;
  case 22: 
  tmp___25 = __builtin_va_arg(ap, sqlite_int64 );
  szMmap = tmp___25;
  tmp___27 = __builtin_va_arg(ap, sqlite_int64 );
  mxMmap = tmp___27;
  if (mxMmap < 0LL) {
    mxMmap = (sqlite_int64 )2147418112;
  } else
  if (mxMmap > 2147418112LL) {
    mxMmap = (sqlite_int64 )2147418112;
  }
  if (szMmap < 0LL) {
    szMmap = (sqlite_int64 )0;
  }
  if (szMmap > mxMmap) {
    szMmap = mxMmap;
  }
  sqlite3Config.mxMmap = mxMmap;
  sqlite3Config.szMmap = szMmap;
  break;
  case 25: 
  tmp___28 = __builtin_va_arg(ap, unsigned int );
  sqlite3Config.szPma = tmp___28;
  break;
  case 26: 
  tmp___29 = __builtin_va_arg(ap, int );
  sqlite3Config.nStmtSpill = tmp___29;
  break;
  default: 
  rc = 1;
  break;
  }
  __builtin_va_end(ap);
  return (rc);
}
}
static int setupLookaside(sqlite3 *db , void *pBuf , int sz , int cnt ) 
{ 
  void *pStart ;
  int tmp ;
  int tmp___0 ;
  int i ;
  LookasideSlot *p ;

  {
  tmp = sqlite3LookasideUsed(db, (int *)0);
  if (tmp > 0) {
    return (5);
  }
  if (db->lookaside.bMalloced) {
    sqlite3_free(db->lookaside.pStart);
  }
  sz &= -8;
  if (sz <= (int )sizeof(LookasideSlot *)) {
    sz = 0;
  }
  if (cnt < 0) {
    cnt = 0;
  }
  if (sz == 0) {
    sz = 0;
    pStart = (void *)0;
  } else
  if (cnt == 0) {
    sz = 0;
    pStart = (void *)0;
  } else
  if ((unsigned long )pBuf == (unsigned long )((void *)0)) {
    sqlite3BeginBenignMalloc();
    pStart = sqlite3Malloc((u64 )((sqlite_int64 )sz * (sqlite_int64 )cnt));
    sqlite3EndBenignMalloc();
    if (pStart) {
      tmp___0 = sqlite3MallocSize(pStart);
      cnt = tmp___0 / sz;
    }
  } else {
    pStart = pBuf;
  }
  db->lookaside.pStart = pStart;
  db->lookaside.pInit = (LookasideSlot *)0;
  db->lookaside.pFree = (LookasideSlot *)0;
  db->lookaside.sz = (u16 )sz;
  if (pStart) {
    db->lookaside.nSlot = (u32 )cnt;
    p = (LookasideSlot *)pStart;
    i = cnt - 1;
    while (i >= 0) {
      p->pNext = db->lookaside.pInit;
      db->lookaside.pInit = p;
      p = (LookasideSlot *)((u8 *)p + sz);
      i --;
    }
    db->lookaside.pEnd = (void *)p;
    db->lookaside.bDisable = (u32 )0;
    if ((unsigned long )pBuf == (unsigned long )((void *)0)) {
      db->lookaside.bMalloced = (u8 )1;
    } else {
      db->lookaside.bMalloced = (u8 )0;
    }
  } else {
    db->lookaside.pStart = (void *)db;
    db->lookaside.pEnd = (void *)db;
    db->lookaside.bDisable = (u32 )1;
    db->lookaside.bMalloced = (u8 )0;
    db->lookaside.nSlot = (u32 )0;
  }
  return (0);
}
}
sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db ) 
{ 


  {
  return (db->mutex);
}
}
int sqlite3_db_release_memory(sqlite3 *db ) 
{ 
  int i ;
  Btree *pBt ;
  Pager *pPager ;
  struct Pager *tmp ;

  {
  sqlite3BtreeEnterAll(db);
  i = 0;
  while (i < db->nDb) {
    pBt = (db->aDb + i)->pBt;
    if (pBt) {
      tmp = sqlite3BtreePager(pBt);
      pPager = tmp;
      sqlite3PagerShrink(pPager);
    }
    i ++;
  }
  return (0);
}
}
int sqlite3_db_cacheflush(sqlite3 *db ) 
{ 
  int i ;
  int rc ;
  int bSeenBusy ;
  Btree *pBt ;
  Pager *pPager ;
  struct Pager *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  rc = 0;
  bSeenBusy = 0;
  sqlite3BtreeEnterAll(db);
  i = 0;
  while (1) {
    if (rc == 0) {
      if (! (i < db->nDb)) {
        break;
      }
    } else {
      break;
    }
    pBt = (db->aDb + i)->pBt;
    if (pBt) {
      tmp___0 = sqlite3BtreeIsInTrans(pBt);
      if (tmp___0) {
        tmp = sqlite3BtreePager(pBt);
        pPager = tmp;
        rc = sqlite3PagerFlush(pPager);
        if (rc == 5) {
          bSeenBusy = 1;
          rc = 0;
        }
      }
    }
    i ++;
  }
  if (rc == 0) {
    if (bSeenBusy) {
      tmp___1 = 5;
    } else {
      tmp___1 = rc;
    }
  } else {
    tmp___1 = rc;
  }
  return (tmp___1);
}
}
static struct __anonstruct_aFlagOp_1035562233  const  aFlagOp[14]  = 
  {      {1002, (u32 )16384}, 
        {1003, (u32 )262144}, 
        {1015, 2147483648U}, 
        {1004, (u32 )4194304}, 
        {1005, (u32 )65536}, 
        {1006, (u32 )2048}, 
        {1007, (u32 )8388608}, 
        {1008, (u32 )16777216}, 
        {1009, (u32 )33554432}, 
        {1010, (u32 )268435456}, 
        {1011, (u32 )134217729}, 
        {1012, (u32 )67108864}, 
        {1014, (u32 )536870912}, 
        {1013, (u32 )1073741824}};
int sqlite3_db_config(sqlite3 *db , int op  , ...) 
{ 
  va_list ap ;
  int rc ;
  char *tmp ;
  void *pBuf ;
  void *tmp___1 ;
  int sz ;
  int tmp___3 ;
  int cnt ;
  int tmp___5 ;
  unsigned int i ;
  int onoff ;
  int tmp___7 ;
  int *pRes ;
  int *tmp___9 ;
  u64 oldFlags ;

  {
  __builtin_va_start(ap, op);
  switch (op) {
  case 1000: 
  tmp = __builtin_va_arg(ap, char *);
  (db->aDb + 0)->zDbSName = tmp;
  rc = 0;
  break;
  case 1001: 
  tmp___1 = __builtin_va_arg(ap, void *);
  pBuf = tmp___1;
  tmp___3 = __builtin_va_arg(ap, int );
  sz = tmp___3;
  tmp___5 = __builtin_va_arg(ap, int );
  cnt = tmp___5;
  rc = setupLookaside(db, pBuf, sz, cnt);
  break;
  default: 
  rc = 1;
  i = 0U;
  while (i < (unsigned int )((int )(sizeof(aFlagOp) / sizeof(aFlagOp[0])))) {
    if (aFlagOp[i].op == (int const   )op) {
      tmp___7 = __builtin_va_arg(ap, int );
      onoff = tmp___7;
      tmp___9 = __builtin_va_arg(ap, int *);
      pRes = tmp___9;
      oldFlags = db->flags;
      if (onoff > 0) {
        db->flags |= (unsigned long long )aFlagOp[i].mask;
      } else
      if (onoff == 0) {
        db->flags &= ~ ((u64 )aFlagOp[i].mask);
      }
      if (oldFlags != db->flags) {
        sqlite3ExpirePreparedStatements(db, 0);
      }
      if (pRes) {
        *pRes = (db->flags & (unsigned long long )aFlagOp[i].mask) != 0ULL;
      }
      rc = 0;
      break;
    }
    i ++;
  }
  break;
  }
  __builtin_va_end(ap);
  return (rc);
}
}
static int binCollFunc(void *NotUsed , int nKey1 , void const   *pKey1 , int nKey2 ,
                       void const   *pKey2 ) 
{ 
  int rc ;
  int n ;

  {
  if (nKey1 < nKey2) {
    n = nKey1;
  } else {
    n = nKey2;
  }
  rc = memcmp(pKey1, pKey2, (size_t )n);
  if (rc == 0) {
    rc = nKey1 - nKey2;
  }
  return (rc);
}
}
static int rtrimCollFunc(void *pUser , int nKey1 , void const   *pKey1 , int nKey2 ,
                         void const   *pKey2 ) 
{ 
  u8 const   *pK1 ;
  u8 const   *pK2 ;
  int tmp ;

  {
  pK1 = (u8 const   *)pKey1;
  pK2 = (u8 const   *)pKey2;
  while (1) {
    if (nKey1) {
      if (! ((int const   )*(pK1 + (nKey1 - 1)) == 32)) {
        break;
      }
    } else {
      break;
    }
    nKey1 --;
  }
  while (1) {
    if (nKey2) {
      if (! ((int const   )*(pK2 + (nKey2 - 1)) == 32)) {
        break;
      }
    } else {
      break;
    }
    nKey2 --;
  }
  tmp = binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2);
  return (tmp);
}
}
static int sqlite3IsBinary(CollSeq const   *p ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p == (unsigned long )((CollSeq const   *)0)) {
    tmp = 1;
  } else
  if ((unsigned long )p->xCmp == (unsigned long )(& binCollFunc)) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static int nocaseCollatingFunc(void *NotUsed , int nKey1 , void const   *pKey1 , int nKey2 ,
                               void const   *pKey2 ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  if (nKey1 < nKey2) {
    tmp = nKey1;
  } else {
    tmp = nKey2;
  }
  tmp___0 = sqlite3_strnicmp((char const   *)pKey1, (char const   *)pKey2, tmp);
  r = tmp___0;
  if (0 == r) {
    r = nKey1 - nKey2;
  }
  return (r);
}
}
long long sqlite3_last_insert_rowid(sqlite3 *db ) 
{ 


  {
  return (db->lastRowid);
}
}
void sqlite3_set_last_insert_rowid(sqlite3 *db , sqlite_int64 iRowid ) 
{ 


  {
  db->lastRowid = iRowid;
  return;
}
}
int sqlite3_changes(sqlite3 *db ) 
{ 


  {
  return (db->nChange);
}
}
int sqlite3_total_changes(sqlite3 *db ) 
{ 


  {
  return (db->nTotalChange);
}
}
static void sqlite3CloseSavepoints(sqlite3 *db ) 
{ 
  Savepoint *pTmp ;

  {
  while (db->pSavepoint) {
    pTmp = db->pSavepoint;
    db->pSavepoint = pTmp->pNext;
    sqlite3DbFree(db, (void *)pTmp);
  }
  db->nSavepoint = 0;
  db->nStatement = 0;
  db->isTransactionSavepoint = (u8 )0;
  return;
}
}
static void functionDestroy(sqlite3 *db , FuncDef *p ) 
{ 
  FuncDestructor *pDestructor ;

  {
  pDestructor = p->u.pDestructor;
  if (pDestructor) {
    (pDestructor->nRef) --;
    if (pDestructor->nRef == 0) {
      (*(pDestructor->xDestroy))(pDestructor->pUserData);
      sqlite3DbFree(db, (void *)pDestructor);
    }
  }
  return;
}
}
static void disconnectAllVtab(sqlite3 *db ) 
{ 
  int i ;
  HashElem *p ;
  Schema *pSchema ;
  Table *pTab ;
  Module *pMod ;

  {
  sqlite3BtreeEnterAll(db);
  i = 0;
  while (i < db->nDb) {
    pSchema = (db->aDb + i)->pSchema;
    if (pSchema) {
      p = pSchema->tblHash.first;
      while (p) {
        pTab = (Table *)p->data;
        if (pTab->nModuleArg) {
          sqlite3VtabDisconnect(db, pTab);
        }
        p = p->next;
      }
    }
    i ++;
  }
  p = db->aModule.first;
  while (p) {
    pMod = (Module *)p->data;
    if (pMod->pEpoTab) {
      sqlite3VtabDisconnect(db, pMod->pEpoTab);
    }
    p = p->next;
  }
  sqlite3VtabUnlockList(db);
  return;
}
}
static int connectionIsBusy(sqlite3 *db ) 
{ 
  int j ;
  Btree *pBt ;
  int tmp ;

  {
  if (db->pVdbe) {
    return (1);
  }
  j = 0;
  while (j < db->nDb) {
    pBt = (db->aDb + j)->pBt;
    if (pBt) {
      tmp = sqlite3BtreeIsInBackup(pBt);
      if (tmp) {
        return (1);
      }
    }
    j ++;
  }
  return (0);
}
}
static int sqlite3Close(sqlite3 *db , int forceZombie ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! db) {
    return (0);
  }
  tmp___0 = sqlite3SafetyCheckSickOrOk(db);
  if (! tmp___0) {
    tmp = sqlite3MisuseError(157303);
    return (tmp);
  }
  if ((int )db->mTrace & 8) {
    (*(db->xTrace))((u32 )8, db->pTraceArg, (void *)db, (void *)0);
  }
  disconnectAllVtab(db);
  sqlite3VtabRollback(db);
  if (! forceZombie) {
    tmp___1 = connectionIsBusy(db);
    if (tmp___1) {
      sqlite3ErrorWithMsg(db, 5, "unable to close due to unfinalized statements or unfinished backups");
      return (5);
    }
  }
  db->magic = (u32 )1691352191;
  sqlite3LeaveMutexAndCloseZombie(db);
  return (0);
}
}
int sqlite3_close(sqlite3 *db ) 
{ 
  int tmp ;

  {
  tmp = sqlite3Close(db, 0);
  return (tmp);
}
}
int sqlite3_close_v2(sqlite3 *db ) 
{ 
  int tmp ;

  {
  tmp = sqlite3Close(db, 1);
  return (tmp);
}
}
static void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db ) 
{ 
  HashElem *i ;
  int j ;
  int tmp ;
  struct Db *pDb ;
  FuncDef *pNext ;
  FuncDef *p ;
  CollSeq *pColl ;
  Module *pMod ;

  {
  if (db->magic != 1691352191U) {
    return;
  } else {
    tmp = connectionIsBusy(db);
    if (tmp) {
      return;
    }
  }
  sqlite3RollbackAll(db, 0);
  sqlite3CloseSavepoints(db);
  j = 0;
  while (j < db->nDb) {
    pDb = db->aDb + j;
    if (pDb->pBt) {
      sqlite3BtreeClose(pDb->pBt);
      pDb->pBt = (Btree *)0;
      if (j != 1) {
        pDb->pSchema = (Schema *)0;
      }
    }
    j ++;
  }
  if ((db->aDb + 1)->pSchema) {
    sqlite3SchemaClear((void *)(db->aDb + 1)->pSchema);
  }
  sqlite3VtabUnlockList(db);
  sqlite3CollapseDatabaseArray(db);
  i = db->aFunc.first;
  while (i) {
    p = (FuncDef *)i->data;
    while (1) {
      functionDestroy(db, p);
      pNext = p->pNext;
      sqlite3DbFree(db, (void *)p);
      p = pNext;
      if (! p) {
        break;
      }
    }
    i = i->next;
  }
  sqlite3HashClear(& db->aFunc);
  i = db->aCollSeq.first;
  while (i) {
    pColl = (CollSeq *)i->data;
    j = 0;
    while (j < 3) {
      if ((pColl + j)->xDel) {
        (*((pColl + j)->xDel))((pColl + j)->pUser);
      }
      j ++;
    }
    sqlite3DbFree(db, (void *)pColl);
    i = i->next;
  }
  sqlite3HashClear(& db->aCollSeq);
  i = db->aModule.first;
  while (i) {
    pMod = (Module *)i->data;
    sqlite3VtabEponymousTableClear(db, pMod);
    sqlite3VtabModuleUnref(db, pMod);
    i = i->next;
  }
  sqlite3HashClear(& db->aModule);
  sqlite3Error(db, 0);
  sqlite3ValueFree(db->pErr);
  db->magic = 3040180528U;
  sqlite3DbFree(db, (void *)(db->aDb + 1)->pSchema);
  db->magic = 2671521075U;
  if (db->lookaside.bMalloced) {
    sqlite3_free(db->lookaside.pStart);
  }
  sqlite3_free((void *)db);
  return;
}
}
static void sqlite3RollbackAll(sqlite3 *db , int tripCode ) 
{ 
  int i ;
  int inTrans ;
  int schemaChange ;
  int tmp ;
  Btree *p ;
  int tmp___0 ;

  {
  inTrans = 0;
  sqlite3BeginBenignMalloc();
  sqlite3BtreeEnterAll(db);
  if ((db->mDbFlags & 1U) != 0U) {
    if ((int )db->init.busy == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  schemaChange = tmp;
  i = 0;
  while (i < db->nDb) {
    p = (db->aDb + i)->pBt;
    if (p) {
      tmp___0 = sqlite3BtreeIsInTrans(p);
      if (tmp___0) {
        inTrans = 1;
      }
      sqlite3BtreeRollback(p, tripCode, ! schemaChange);
    }
    i ++;
  }
  sqlite3VtabRollback(db);
  sqlite3EndBenignMalloc();
  if (schemaChange) {
    sqlite3ExpirePreparedStatements(db, 0);
    sqlite3ResetAllSchemasOfConnection(db);
  }
  db->nDeferredCons = (i64 )0;
  db->nDeferredImmCons = (i64 )0;
  db->flags &= 0xfffffffffff7ffffULL;
  if (db->xRollbackCallback) {
    if (inTrans) {
      (*(db->xRollbackCallback))(db->pRollbackArg);
    } else
    if (! db->autoCommit) {
      (*(db->xRollbackCallback))(db->pRollbackArg);
    }
  }
  return;
}
}
static char const   * const  aMsg[29]  = 
  {      (char const   * const  )"not an error",      (char const   * const  )"SQL logic error",      (char const   * const  )0,      (char const   * const  )"access permission denied", 
        (char const   * const  )"query aborted",      (char const   * const  )"database is locked",      (char const   * const  )"database table is locked",      (char const   * const  )"out of memory", 
        (char const   * const  )"attempt to write a readonly database",      (char const   * const  )"interrupted",      (char const   * const  )"disk I/O error",      (char const   * const  )"database disk image is malformed", 
        (char const   * const  )"unknown operation",      (char const   * const  )"database or disk is full",      (char const   * const  )"unable to open database file",      (char const   * const  )"locking protocol", 
        (char const   * const  )0,      (char const   * const  )"database schema has changed",      (char const   * const  )"string or blob too big",      (char const   * const  )"constraint failed", 
        (char const   * const  )"datatype mismatch",      (char const   * const  )"bad parameter or other API misuse",      (char const   * const  )0,      (char const   * const  )"authorization denied", 
        (char const   * const  )0,      (char const   * const  )"column index out of range",      (char const   * const  )"file is not a database",      (char const   * const  )"notification message", 
        (char const   * const  )"warning message"};
static char const   *sqlite3ErrStr(int rc ) 
{ 
  char const   *zErr ;

  {
  zErr = "unknown error";
  switch (rc) {
  case 4 | (2 << 8): 
  zErr = "abort due to ROLLBACK";
  break;
  case 100: 
  zErr = "another row available";
  break;
  case 101: 
  zErr = "no more rows available";
  break;
  default: 
  rc &= 255;
  if (rc >= 0) {
    if (rc < (int )(sizeof(aMsg) / sizeof(aMsg[0]))) {
      if ((unsigned long )aMsg[rc] != (unsigned long )((char const   * const  )0)) {
        zErr = (char const   *)aMsg[rc];
      }
    }
  }
  break;
  }
  return (zErr);
}
}
static int sqliteDefaultBusyCallback(void *ptr , int count , sqlite3_file *pFile ) 
{ 
  sqlite3 *db ;
  int tmout ;

  {
  db = (sqlite3 *)ptr;
  tmout = ((sqlite3 *)ptr)->busyTimeout;
  if ((count + 1) * 1000 > tmout) {
    return (0);
  }
  sqlite3OsSleep(db->pVfs, 1000000);
  return (1);
}
}
static int sqlite3InvokeBusyHandler(BusyHandler *p , sqlite3_file *pFile ) 
{ 
  int rc ;
  int (*xTra)(void * , int  , sqlite3_file * ) ;

  {
  if ((unsigned long )p->xBusyHandler == (unsigned long )((int (*)(void * , int  ))0)) {
    return (0);
  } else
  if (p->nBusy < 0) {
    return (0);
  }
  if (p->bExtraFileArg) {
    xTra = (int (*)(void * , int  , sqlite3_file * ))p->xBusyHandler;
    rc = (*xTra)(p->pBusyArg, p->nBusy, pFile);
  } else {
    rc = (*(p->xBusyHandler))(p->pBusyArg, p->nBusy);
  }
  if (rc == 0) {
    p->nBusy = -1;
  } else {
    (p->nBusy) ++;
  }
  return (rc);
}
}
int sqlite3_busy_handler(sqlite3 *db , int (*xBusy)(void * , int  ) , void *pArg ) 
{ 


  {
  db->busyHandler.xBusyHandler = xBusy;
  db->busyHandler.pBusyArg = pArg;
  db->busyHandler.nBusy = 0;
  db->busyHandler.bExtraFileArg = (u8 )0;
  db->busyTimeout = 0;
  return (0);
}
}
void sqlite3_progress_handler(sqlite3 *db , int nOps , int (*xProgress)(void * ) ,
                              void *pArg ) 
{ 


  {
  if (nOps > 0) {
    db->xProgress = xProgress;
    db->nProgressOps = (unsigned int )nOps;
    db->pProgressArg = pArg;
  } else {
    db->xProgress = (int (*)(void * ))0;
    db->nProgressOps = 0U;
    db->pProgressArg = (void *)0;
  }
  return;
}
}
int sqlite3_busy_timeout(sqlite3 *db , int ms ) 
{ 


  {
  if (ms > 0) {
    sqlite3_busy_handler(db, (int (*)(void * , int  ))(& sqliteDefaultBusyCallback),
                         (void *)db);
    db->busyTimeout = ms;
    db->busyHandler.bExtraFileArg = (u8 )1;
  } else {
    sqlite3_busy_handler(db, (int (*)(void * , int  ))0, (void *)0);
  }
  return (0);
}
}
void sqlite3_interrupt(sqlite3 *db ) 
{ 


  {
  db->u1.isInterrupted = (int volatile   )1;
  return;
}
}
static int sqlite3CreateFunc(sqlite3 *db , char const   *zFunctionName , int nArg ,
                             int enc , void *pUserData , void (*xSFunc)(sqlite3_context * ,
                                                                        int  , sqlite3_value ** ) ,
                             void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             void (*xFinal)(sqlite3_context * ) , void (*xValue)(sqlite3_context * ) ,
                             void (*xInverse)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             FuncDestructor *pDestructor ) 
{ 
  FuncDef *p ;
  int nName ;
  int extraFlags ;
  int tmp ;
  int rc ;

  {
  if ((unsigned long )zFunctionName == (unsigned long )((char const   *)0)) {
    tmp = sqlite3MisuseError(157925);
    return (tmp);
  } else
  if ((unsigned long )xSFunc != (unsigned long )((void (*)(sqlite3_context * , int  ,
                                                           sqlite3_value ** ))0)) {
    if ((unsigned long )xFinal != (unsigned long )((void (*)(sqlite3_context * ))0)) {
      tmp = sqlite3MisuseError(157925);
      return (tmp);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (((unsigned long )xFinal == (unsigned long )((void (*)(sqlite3_context * ))0)) != ((unsigned long )xStep == (unsigned long )((void (*)(sqlite3_context * ,
                                                                                                                                            int  ,
                                                                                                                                            sqlite3_value ** ))0))) {
    tmp = sqlite3MisuseError(157925);
    return (tmp);
  } else
  if (((unsigned long )xValue == (unsigned long )((void (*)(sqlite3_context * ))0)) != ((unsigned long )xInverse == (unsigned long )((void (*)(sqlite3_context * ,
                                                                                                                                               int  ,
                                                                                                                                               sqlite3_value ** ))0))) {
    tmp = sqlite3MisuseError(157925);
    return (tmp);
  } else
  if (nArg < -1) {
    tmp = sqlite3MisuseError(157925);
    return (tmp);
  } else
  if (nArg > 127) {
    tmp = sqlite3MisuseError(157925);
    return (tmp);
  } else {
    nName = sqlite3Strlen30(zFunctionName);
    if (255 < nName) {
      tmp = sqlite3MisuseError(157925);
      return (tmp);
    }
  }
  extraFlags = enc & 1574912;
  enc &= 7;
  if (enc == 4) {
    enc = 2;
  } else
  if (enc == 5) {
    rc = sqlite3CreateFunc(db, zFunctionName, nArg, 1 | extraFlags, pUserData, xSFunc,
                           xStep, xFinal, xValue, xInverse, pDestructor);
    if (rc == 0) {
      rc = sqlite3CreateFunc(db, zFunctionName, nArg, 2 | extraFlags, pUserData, xSFunc,
                             xStep, xFinal, xValue, xInverse, pDestructor);
    }
    if (rc != 0) {
      return (rc);
    }
    enc = 3;
  }
  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8 )enc, (u8 )0);
  if (p) {
    if ((p->funcFlags & 3U) == (u32 )enc) {
      if ((int )p->nArg == nArg) {
        if (db->nVdbeActive) {
          sqlite3ErrorWithMsg(db, 5, "unable to delete/modify user-function due to active statements");
          return (5);
        } else {
          sqlite3ExpirePreparedStatements(db, 0);
        }
      }
    }
  }
  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8 )enc, (u8 )1);
  if (! p) {
    return (7);
  }
  functionDestroy(db, p);
  if (pDestructor) {
    (pDestructor->nRef) ++;
  }
  p->u.pDestructor = pDestructor;
  p->funcFlags = (p->funcFlags & 3U) | (unsigned int )extraFlags;
  if (xSFunc) {
    p->xSFunc = xSFunc;
  } else {
    p->xSFunc = xStep;
  }
  p->xFinalize = xFinal;
  p->xValue = xValue;
  p->xInverse = xInverse;
  p->pUserData = pUserData;
  p->nArg = (i8 )((u16 )nArg);
  return (0);
}
}
static int createFunctionApi(sqlite3 *db , char const   *zFunc , int nArg , int enc ,
                             void *p , void (*xSFunc)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             void (*xFinal)(sqlite3_context * ) , void (*xValue)(sqlite3_context * ) ,
                             void (*xInverse)(sqlite3_context * , int  , sqlite3_value ** ) ,
                             void (*xDestroy)(void * ) ) 
{ 
  int rc ;
  FuncDestructor *pArg ;
  void *tmp ;

  {
  rc = 1;
  pArg = (FuncDestructor *)0;
  if (xDestroy) {
    tmp = sqlite3Malloc((u64 )sizeof(FuncDestructor ));
    pArg = (FuncDestructor *)tmp;
    if (! pArg) {
      sqlite3OomFault(db);
      (*xDestroy)(p);
      goto out;
    }
    pArg->nRef = 0;
    pArg->xDestroy = xDestroy;
    pArg->pUserData = p;
  }
  rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, xValue, xInverse,
                         pArg);
  if (pArg) {
    if (pArg->nRef == 0) {
      (*xDestroy)(p);
      sqlite3_free((void *)pArg);
    }
  }
  out: 
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_create_function(sqlite3 *db , char const   *zFunc , int nArg , int enc ,
                            void *p , void (*xSFunc)(sqlite3_context * , int  , sqlite3_value ** ) ,
                            void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                            void (*xFinal)(sqlite3_context * ) ) 
{ 
  int tmp ;

  {
  tmp = createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, (void (*)(sqlite3_context * ))0,
                          (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                          (void (*)(void * ))0);
  return (tmp);
}
}
int sqlite3_create_function_v2(sqlite3 *db , char const   *zFunc , int nArg , int enc ,
                               void *p , void (*xSFunc)(sqlite3_context * , int  ,
                                                        sqlite3_value ** ) , void (*xStep)(sqlite3_context * ,
                                                                                           int  ,
                                                                                           sqlite3_value ** ) ,
                               void (*xFinal)(sqlite3_context * ) , void (*xDestroy)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, (void (*)(sqlite3_context * ))0,
                          (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                          xDestroy);
  return (tmp);
}
}
int sqlite3_create_window_function(sqlite3 *db , char const   *zFunc , int nArg ,
                                   int enc , void *p , void (*xStep)(sqlite3_context * ,
                                                                     int  , sqlite3_value ** ) ,
                                   void (*xFinal)(sqlite3_context * ) , void (*xValue)(sqlite3_context * ) ,
                                   void (*xInverse)(sqlite3_context * , int  , sqlite3_value ** ) ,
                                   void (*xDestroy)(void * ) ) 
{ 
  int tmp ;

  {
  tmp = createFunctionApi(db, zFunc, nArg, enc, p, (void (*)(sqlite3_context * , int  ,
                                                             sqlite3_value ** ))0,
                          xStep, xFinal, xValue, xInverse, xDestroy);
  return (tmp);
}
}
int sqlite3_create_function16(sqlite3 *db , void const   *zFunctionName , int nArg ,
                              int eTextRep , void *p , void (*xSFunc)(sqlite3_context * ,
                                                                      int  , sqlite3_value ** ) ,
                              void (*xStep)(sqlite3_context * , int  , sqlite3_value ** ) ,
                              void (*xFinal)(sqlite3_context * ) ) 
{ 
  int rc ;
  char *zFunc8 ;

  {
  zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, (u8 )2);
  rc = sqlite3CreateFunc(db, (char const   *)zFunc8, nArg, eTextRep, p, xSFunc, xStep,
                         xFinal, (void (*)(sqlite3_context * ))0, (void (*)(sqlite3_context * ,
                                                                            int  ,
                                                                            sqlite3_value ** ))0,
                         (FuncDestructor *)0);
  sqlite3DbFree(db, (void *)zFunc8);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
static void sqlite3InvalidFunction(sqlite3_context *context , int NotUsed , sqlite3_value **NotUsed2 ) 
{ 
  char const   *zName ;
  void *tmp ;
  char *zErr ;

  {
  tmp = sqlite3_user_data(context);
  zName = (char const   *)tmp;
  zErr = sqlite3_mprintf("unable to use function %s in the requested context", zName);
  sqlite3_result_error(context, (char const   *)zErr, -1);
  sqlite3_free((void *)zErr);
  return;
}
}
int sqlite3_overload_function(sqlite3 *db , char const   *zName , int nArg ) 
{ 
  int rc ;
  char *zCopy ;
  FuncDef *tmp ;
  int tmp___0 ;

  {
  tmp = sqlite3FindFunction(db, zName, nArg, (u8 )1, (u8 )0);
  rc = (unsigned long )tmp != (unsigned long )((FuncDef *)0);
  if (rc) {
    return (0);
  }
  zCopy = sqlite3_mprintf(zName);
  if ((unsigned long )zCopy == (unsigned long )((char *)0)) {
    return (7);
  }
  tmp___0 = sqlite3_create_function_v2(db, zName, nArg, 1, (void *)zCopy, & sqlite3InvalidFunction,
                                       (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                                       (void (*)(sqlite3_context * ))0, & sqlite3_free);
  return (tmp___0);
}
}
void *sqlite3_trace(sqlite3 *db , void (*xTrace)(void * , char const   * ) , void *pArg ) 
{ 
  void *pOld ;

  {
  pOld = db->pTraceArg;
  if (xTrace) {
    db->mTrace = (u8 )64;
  } else {
    db->mTrace = (u8 )0;
  }
  db->xTrace = (int (*)(u32  , void * , void * , void * ))xTrace;
  db->pTraceArg = pArg;
  return (pOld);
}
}
int sqlite3_trace_v2(sqlite3 *db , unsigned int mTrace , int (*xTrace)(unsigned int  ,
                                                                       void * , void * ,
                                                                       void * ) ,
                     void *pArg ) 
{ 


  {
  if (mTrace == 0U) {
    xTrace = (int (*)(unsigned int  , void * , void * , void * ))0;
  }
  if ((unsigned long )xTrace == (unsigned long )((int (*)(unsigned int  , void * ,
                                                          void * , void * ))0)) {
    mTrace = 0U;
  }
  db->mTrace = (u8 )mTrace;
  db->xTrace = xTrace;
  db->pTraceArg = pArg;
  return (0);
}
}
void *sqlite3_profile(sqlite3 *db , void (*xProfile)(void * , char const   * , unsigned long long  ) ,
                      void *pArg ) 
{ 
  void *pOld ;

  {
  pOld = db->pProfileArg;
  db->xProfile = xProfile;
  db->pProfileArg = pArg;
  db->mTrace = (u8 )((int )db->mTrace & 15);
  if (db->xProfile) {
    db->mTrace = (u8 )((int )db->mTrace | 128);
  }
  return (pOld);
}
}
void *sqlite3_commit_hook(sqlite3 *db , int (*xCallback)(void * ) , void *pArg ) 
{ 
  void *pOld ;

  {
  pOld = db->pCommitArg;
  db->xCommitCallback = xCallback;
  db->pCommitArg = pArg;
  return (pOld);
}
}
void *sqlite3_update_hook(sqlite3 *db , void (*xCallback)(void * , int  , char const   * ,
                                                          char const   * , long long  ) ,
                          void *pArg ) 
{ 
  void *pRet ;

  {
  pRet = db->pUpdateArg;
  db->xUpdateCallback = xCallback;
  db->pUpdateArg = pArg;
  return (pRet);
}
}
void *sqlite3_rollback_hook(sqlite3 *db , void (*xCallback)(void * ) , void *pArg ) 
{ 
  void *pRet ;

  {
  pRet = db->pRollbackArg;
  db->xRollbackCallback = xCallback;
  db->pRollbackArg = pArg;
  return (pRet);
}
}
static int sqlite3WalDefaultHook(void *pClientData , sqlite3 *db , char const   *zDb ,
                                 int nFrame ) 
{ 


  {
  if (nFrame >= (int )((long )pClientData)) {
    sqlite3BeginBenignMalloc();
    sqlite3_wal_checkpoint(db, zDb);
    sqlite3EndBenignMalloc();
  }
  return (0);
}
}
int sqlite3_wal_autocheckpoint(sqlite3 *db , int nFrame ) 
{ 


  {
  if (nFrame > 0) {
    sqlite3_wal_hook(db, & sqlite3WalDefaultHook, (void *)((long )nFrame));
  } else {
    sqlite3_wal_hook(db, (int (*)(void * , sqlite3 * , char const   * , int  ))0,
                     (void *)0);
  }
  return (0);
}
}
void *sqlite3_wal_hook(sqlite3 *db , int (*xCallback)(void * , sqlite3 * , char const   * ,
                                                      int  ) , void *pArg ) 
{ 
  void *pRet ;

  {
  pRet = db->pWalArg;
  db->xWalCallback = xCallback;
  db->pWalArg = pArg;
  return (pRet);
}
}
int sqlite3_wal_checkpoint_v2(sqlite3 *db , char const   *zDb , int eMode , int *pnLog ,
                              int *pnCkpt ) 
{ 
  int rc ;
  int iDb ;

  {
  iDb = 10;
  if (pnLog) {
    *pnLog = -1;
  }
  if (pnCkpt) {
    *pnCkpt = -1;
  }
  if (eMode < 0) {
    return (21);
  } else
  if (eMode > 3) {
    return (21);
  }
  if (zDb) {
    if (*(zDb + 0)) {
      iDb = sqlite3FindDbName(db, zDb);
    }
  }
  if (iDb < 0) {
    rc = 1;
    sqlite3ErrorWithMsg(db, 1, "unknown database: %s", zDb);
  } else {
    db->busyHandler.nBusy = 0;
    rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);
    sqlite3Error(db, rc);
  }
  rc = sqlite3ApiExit(db, rc);
  if (db->nVdbeActive == 0) {
    db->u1.isInterrupted = (int volatile   )0;
  }
  return (rc);
}
}
int sqlite3_wal_checkpoint(sqlite3 *db , char const   *zDb ) 
{ 
  int tmp ;

  {
  tmp = sqlite3_wal_checkpoint_v2(db, zDb, 0, (int *)0, (int *)0);
  return (tmp);
}
}
static int sqlite3Checkpoint(sqlite3 *db , int iDb , int eMode , int *pnLog , int *pnCkpt ) 
{ 
  int rc ;
  int i ;
  int bBusy ;
  int tmp ;

  {
  rc = 0;
  bBusy = 0;
  i = 0;
  while (1) {
    if (i < db->nDb) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    if (i == iDb) {
      goto _L;
    } else
    if (iDb == 10) {
      _L: /* CIL Label */ 
      rc = sqlite3BtreeCheckpoint((db->aDb + i)->pBt, eMode, pnLog, pnCkpt);
      pnLog = (int *)0;
      pnCkpt = (int *)0;
      if (rc == 5) {
        bBusy = 1;
        rc = 0;
      }
    }
    i ++;
  }
  if (rc == 0) {
    if (bBusy) {
      tmp = 5;
    } else {
      tmp = rc;
    }
  } else {
    tmp = rc;
  }
  return (tmp);
}
}
static int sqlite3TempInMemory(sqlite3 const   *db ) 
{ 


  {
  return ((int const   )db->temp_store == 2);
}
}
char const   *sqlite3_errmsg(sqlite3 *db ) 
{ 
  char const   *z ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  unsigned char const   *tmp___3 ;

  {
  if (! db) {
    tmp = sqlite3ErrStr(7);
    return (tmp);
  }
  tmp___2 = sqlite3SafetyCheckSickOrOk(db);
  if (! tmp___2) {
    tmp___0 = sqlite3MisuseError(158614);
    tmp___1 = sqlite3ErrStr(tmp___0);
    return (tmp___1);
  }
  if (db->mallocFailed) {
    z = sqlite3ErrStr(7);
  } else {
    if (db->errCode) {
      tmp___3 = sqlite3_value_text(db->pErr);
      z = (char const   *)((char *)tmp___3);
    } else {
      z = (char const   *)0;
    }
    if ((unsigned long )z == (unsigned long )((char const   *)0)) {
      z = sqlite3ErrStr(db->errCode);
    }
  }
  return (z);
}
}
static u16 const   outOfMem[14]  = 
  {      (u16 const   )'o',      (u16 const   )'u',      (u16 const   )'t',      (u16 const   )' ', 
        (u16 const   )'o',      (u16 const   )'f',      (u16 const   )' ',      (u16 const   )'m', 
        (u16 const   )'e',      (u16 const   )'m',      (u16 const   )'o',      (u16 const   )'r', 
        (u16 const   )'y',      (u16 const   )0};
static u16 const   misuse[34]  = 
  {      (u16 const   )'b',      (u16 const   )'a',      (u16 const   )'d',      (u16 const   )' ', 
        (u16 const   )'p',      (u16 const   )'a',      (u16 const   )'r',      (u16 const   )'a', 
        (u16 const   )'m',      (u16 const   )'e',      (u16 const   )'t',      (u16 const   )'e', 
        (u16 const   )'r',      (u16 const   )' ',      (u16 const   )'o',      (u16 const   )'r', 
        (u16 const   )' ',      (u16 const   )'o',      (u16 const   )'t',      (u16 const   )'h', 
        (u16 const   )'e',      (u16 const   )'r',      (u16 const   )' ',      (u16 const   )'A', 
        (u16 const   )'P',      (u16 const   )'I',      (u16 const   )' ',      (u16 const   )'m', 
        (u16 const   )'i',      (u16 const   )'s',      (u16 const   )'u',      (u16 const   )'s', 
        (u16 const   )'e',      (u16 const   )0};
void const   *sqlite3_errmsg16(sqlite3 *db ) 
{ 
  void const   *z ;
  int tmp ;
  char const   *tmp___0 ;

  {
  if (! db) {
    return ((void const   *)((void *)(outOfMem)));
  }
  tmp = sqlite3SafetyCheckSickOrOk(db);
  if (! tmp) {
    return ((void const   *)((void *)(misuse)));
  }
  if (db->mallocFailed) {
    z = (void const   *)((void *)(outOfMem));
  } else {
    z = sqlite3_value_text16(db->pErr);
    if ((unsigned long )z == (unsigned long )((void const   *)0)) {
      tmp___0 = sqlite3ErrStr(db->errCode);
      sqlite3ErrorWithMsg(db, db->errCode, tmp___0);
      z = sqlite3_value_text16(db->pErr);
    }
    sqlite3OomClear(db);
  }
  return (z);
}
}
int sqlite3_errcode(sqlite3 *db ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (db) {
    tmp___0 = sqlite3SafetyCheckSickOrOk(db);
    if (! tmp___0) {
      tmp = sqlite3MisuseError(158680);
      return (tmp);
    }
  }
  if (! db) {
    return (7);
  } else
  if (db->mallocFailed) {
    return (7);
  }
  return (db->errCode & db->errMask);
}
}
int sqlite3_extended_errcode(sqlite3 *db ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (db) {
    tmp___0 = sqlite3SafetyCheckSickOrOk(db);
    if (! tmp___0) {
      tmp = sqlite3MisuseError(158689);
      return (tmp);
    }
  }
  if (! db) {
    return (7);
  } else
  if (db->mallocFailed) {
    return (7);
  }
  return (db->errCode);
}
}
int sqlite3_system_errno(sqlite3 *db ) 
{ 
  int tmp ;

  {
  if (db) {
    tmp = db->iSysErrno;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
char const   *sqlite3_errstr(int rc ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3ErrStr(rc);
  return (tmp);
}
}
static int createCollation(sqlite3 *db , char const   *zName , u8 enc , void *pCtx ,
                           int (*xCompare)(void * , int  , void const   * , int  ,
                                           void const   * ) , void (*xDel)(void * ) ) 
{ 
  CollSeq *pColl ;
  int enc2 ;
  int tmp ;
  CollSeq *aColl ;
  void *tmp___0 ;
  int j ;
  CollSeq *p ;

  {
  enc2 = (int )enc;
  if (enc2 == 4) {
    enc2 = 2;
  } else
  if (enc2 == 8) {
    enc2 = 2;
  }
  if (enc2 < 1) {
    tmp = sqlite3MisuseError(158737);
    return (tmp);
  } else
  if (enc2 > 3) {
    tmp = sqlite3MisuseError(158737);
    return (tmp);
  }
  pColl = sqlite3FindCollSeq(db, (u8 )enc2, zName, 0);
  if (pColl) {
    if (pColl->xCmp) {
      if (db->nVdbeActive) {
        sqlite3ErrorWithMsg(db, 5, "unable to delete/modify collation sequence due to active statements");
        return (5);
      }
      sqlite3ExpirePreparedStatements(db, 0);
      if (((int )pColl->enc & -9) == enc2) {
        tmp___0 = sqlite3HashFind((Hash const   *)(& db->aCollSeq), zName);
        aColl = (CollSeq *)tmp___0;
        j = 0;
        while (j < 3) {
          p = aColl + j;
          if ((int )p->enc == (int )pColl->enc) {
            if (p->xDel) {
              (*(p->xDel))(p->pUser);
            }
            p->xCmp = (int (*)(void * , int  , void const   * , int  , void const   * ))0;
          }
          j ++;
        }
      }
    }
  }
  pColl = sqlite3FindCollSeq(db, (u8 )enc2, zName, 1);
  if ((unsigned long )pColl == (unsigned long )((CollSeq *)0)) {
    return (7);
  }
  pColl->xCmp = xCompare;
  pColl->pUser = pCtx;
  pColl->xDel = xDel;
  pColl->enc = (u8 )(enc2 | ((int )enc & 8));
  sqlite3Error(db, 0);
  return (0);
}
}
static int const   aHardLimit[12]  = 
  {      (int const   )1000000000,      (int const   )1000000000,      (int const   )2000,      (int const   )1000, 
        (int const   )500,      (int const   )250000000,      (int const   )127,      (int const   )10, 
        (int const   )50000,      (int const   )999,      (int const   )1000,      (int const   )0};
int sqlite3_limit(sqlite3 *db , int limitId , int newLimit ) 
{ 
  int oldLimit ;

  {
  if (limitId < 0) {
    return (-1);
  } else
  if (limitId >= 12) {
    return (-1);
  }
  oldLimit = db->aLimit[limitId];
  if (newLimit >= 0) {
    if (newLimit > (int )aHardLimit[limitId]) {
      newLimit = (int )aHardLimit[limitId];
    }
    db->aLimit[limitId] = newLimit;
  }
  return (oldLimit);
}
}
static struct OpenMode aCacheMode[3]  = {      {"shared", 131072}, 
        {"private", 262144}, 
        {(char const   *)0, 0}};
static struct OpenMode aOpenMode[5]  = {      {"ro", 1}, 
        {"rw", 2}, 
        {"rwc", 6}, 
        {"memory", 128}, 
        {(char const   *)0, 0}};
static int sqlite3ParseUri(char const   *zDefaultVfs , char const   *zUri , unsigned int *pFlags ,
                           sqlite3_vfs **ppVfs , char **pzFile , char **pzErrMsg ) 
{ 
  int rc ;
  unsigned int flags___0 ;
  char const   *zVfs ;
  char *zFile ;
  char c ;
  int nUri ;
  int tmp ;
  char *zOpt ;
  int eState ;
  int iIn ;
  int iOut ;
  u64 nByte ;
  void *tmp___0 ;
  int tmp___1 ;
  int octet ;
  int tmp___2 ;
  u8 tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int nOpt ;
  int tmp___12 ;
  char *zVal ;
  int nVal ;
  int tmp___13 ;
  struct OpenMode *aMode ;
  char *zModeType ;
  int mask ;
  int limit ;
  int tmp___14 ;
  int tmp___15 ;
  int i ;
  int mode ;
  char const   *z ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;

  {
  rc = 0;
  flags___0 = *pFlags;
  zVfs = zDefaultVfs;
  tmp = sqlite3Strlen30(zUri);
  nUri = tmp;
  if (flags___0 & 64U) {
    goto _L___9;
  } else
  if (sqlite3Config.bOpenUri) {
    _L___9: /* CIL Label */ 
    if (nUri >= 5) {
      tmp___20 = memcmp((void const   *)zUri, (void const   *)"file:", (size_t )5);
      if (tmp___20 == 0) {
        iOut = 0;
        nByte = (u64 )(nUri + 2);
        flags___0 |= 64U;
        iIn = 0;
        while (iIn < nUri) {
          nByte += (u64 )((int const   )*(zUri + iIn) == 38);
          iIn ++;
        }
        tmp___0 = sqlite3_malloc64(nByte);
        zFile = (char *)tmp___0;
        if (! zFile) {
          return (7);
        }
        iIn = 5;
        if ((int const   )*(zUri + 5) == 47) {
          if ((int const   )*(zUri + 6) == 47) {
            iIn = 7;
            while (1) {
              if (*(zUri + iIn)) {
                if (! ((int const   )*(zUri + iIn) != 47)) {
                  break;
                }
              } else {
                break;
              }
              iIn ++;
            }
            if (iIn != 7) {
              if (iIn != 16) {
                *pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s", iIn - 7,
                                            zUri + 7);
                rc = 1;
                goto parse_uri_out;
              } else {
                tmp___1 = memcmp((void const   *)"localhost", (void const   *)(zUri + 7),
                                 (size_t )9);
                if (tmp___1) {
                  *pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s", iIn - 7,
                                              zUri + 7);
                  rc = 1;
                  goto parse_uri_out;
                }
              }
            }
          }
        }
        eState = 0;
        while (1) {
          c = (char )*(zUri + iIn);
          if ((int )c != 0) {
            if (! ((int )c != 35)) {
              break;
            }
          } else {
            break;
          }
          iIn ++;
          if ((int )c == 37) {
            if ((int const   )sqlite3CtypeMap[(unsigned char )*(zUri + iIn)] & 8) {
              if ((int const   )sqlite3CtypeMap[(unsigned char )*(zUri + (iIn + 1))] & 8) {
                tmp___2 = iIn;
                iIn ++;
                tmp___3 = sqlite3HexToInt((int )*(zUri + tmp___2));
                octet = (int )tmp___3 << 4;
                tmp___4 = iIn;
                iIn ++;
                tmp___5 = sqlite3HexToInt((int )*(zUri + tmp___4));
                octet += (int )tmp___5;
                if (octet == 0) {
                  while (1) {
                    c = (char )*(zUri + iIn);
                    if ((int )c != 0) {
                      if ((int )c != 35) {
                        if (eState != 0) {
                          goto _L___0;
                        } else
                        if ((int )c != 63) {
                          _L___0: /* CIL Label */ 
                          if (eState != 1) {
                            goto _L;
                          } else
                          if ((int )c != 61) {
                            if ((int )c != 38) {
                              _L: /* CIL Label */ 
                              if (! (eState != 2)) {
                                if (! ((int )c != 38)) {
                                  break;
                                }
                              }
                            } else {
                              break;
                            }
                          } else {
                            break;
                          }
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                    iIn ++;
                  }
                  continue;
                }
                c = (char )octet;
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
          if (eState == 1) {
            if ((int )c == 38) {
              goto _L___3;
            } else
            if ((int )c == 61) {
              _L___3: /* CIL Label */ 
              if ((int )*(zFile + (iOut - 1)) == 0) {
                while (1) {
                  if (*(zUri + iIn)) {
                    if ((int const   )*(zUri + iIn) != 35) {
                      if (! ((int const   )*(zUri + (iIn - 1)) != 38)) {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  iIn ++;
                }
                continue;
              }
              if ((int )c == 38) {
                tmp___6 = iOut;
                iOut ++;
                *(zFile + tmp___6) = (char )'\000';
              } else {
                eState = 2;
              }
              c = (char)0;
            } else {
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
          if (eState == 0) {
            if ((int )c == 63) {
              c = (char)0;
              eState = 1;
            } else {
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
          if (eState == 2) {
            if ((int )c == 38) {
              c = (char)0;
              eState = 1;
            }
          }
          tmp___7 = iOut;
          iOut ++;
          *(zFile + tmp___7) = c;
        }
        if (eState == 1) {
          tmp___8 = iOut;
          iOut ++;
          *(zFile + tmp___8) = (char )'\000';
        }
        tmp___9 = iOut;
        iOut ++;
        *(zFile + tmp___9) = (char )'\000';
        tmp___10 = iOut;
        iOut ++;
        *(zFile + tmp___10) = (char )'\000';
        tmp___11 = sqlite3Strlen30((char const   *)zFile);
        zOpt = zFile + (tmp___11 + 1);
        while (*(zOpt + 0)) {
          tmp___12 = sqlite3Strlen30((char const   *)zOpt);
          nOpt = tmp___12;
          zVal = zOpt + (nOpt + 1);
          tmp___13 = sqlite3Strlen30((char const   *)zVal);
          nVal = tmp___13;
          if (nOpt == 3) {
            tmp___18 = memcmp((void const   *)"vfs", (void const   *)zOpt, (size_t )3);
            if (tmp___18 == 0) {
              zVfs = (char const   *)zVal;
            } else {
              goto _L___6;
            }
          } else {
            _L___6: /* CIL Label */ 
            aMode = (struct OpenMode *)0;
            zModeType = (char *)0;
            mask = 0;
            limit = 0;
            if (nOpt == 5) {
              tmp___14 = memcmp((void const   *)"cache", (void const   *)zOpt, (size_t )5);
              if (tmp___14 == 0) {
                mask = 393216;
                aMode = aCacheMode;
                limit = mask;
                zModeType = (char *)"cache";
              }
            }
            if (nOpt == 4) {
              tmp___15 = memcmp((void const   *)"mode", (void const   *)zOpt, (size_t )4);
              if (tmp___15 == 0) {
                mask = 135;
                aMode = aOpenMode;
                limit = (int )((unsigned int )mask & flags___0);
                zModeType = (char *)"access";
              }
            }
            if (aMode) {
              mode = 0;
              i = 0;
              while ((aMode + i)->z) {
                z = (aMode + i)->z;
                tmp___16 = sqlite3Strlen30(z);
                if (nVal == tmp___16) {
                  tmp___17 = memcmp((void const   *)zVal, (void const   *)z, (size_t )nVal);
                  if (0 == tmp___17) {
                    mode = (aMode + i)->mode;
                    break;
                  }
                }
                i ++;
              }
              if (mode == 0) {
                *pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
                rc = 1;
                goto parse_uri_out;
              }
              if ((mode & -129) > limit) {
                *pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s", zModeType,
                                            zVal);
                rc = 3;
                goto parse_uri_out;
              }
              flags___0 = (flags___0 & (unsigned int )(~ mask)) | (unsigned int )mode;
            }
          }
          zOpt = zVal + (nVal + 1);
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    tmp___19 = sqlite3_malloc64((sqlite_uint64 )(nUri + 2));
    zFile = (char *)tmp___19;
    if (! zFile) {
      return (7);
    }
    if (nUri) {
      memcpy((void * __restrict  )zFile, (void const   * __restrict  )zUri, (size_t )nUri);
    }
    *(zFile + nUri) = (char )'\000';
    *(zFile + (nUri + 1)) = (char )'\000';
    flags___0 &= 4294967231U;
  }
  *ppVfs = sqlite3_vfs_find(zVfs);
  if ((unsigned long )*ppVfs == (unsigned long )((sqlite3_vfs *)0)) {
    *pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
    rc = 1;
  }
  parse_uri_out: 
  if (rc != 0) {
    sqlite3_free((void *)zFile);
    zFile = (char *)0;
  }
  *pFlags = flags___0;
  *pzFile = zFile;
  return (rc);
}
}
static int openDatabase(char const   *zFilename , sqlite3 **ppDb , unsigned int flags___0 ,
                        char const   *zVfs ) 
{ 
  sqlite3 *db ;
  int rc ;
  int isThreadsafe ;
  char *zOpen ;
  char *zErrMsg ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  zOpen = (char *)0;
  zErrMsg = (char *)0;
  *ppDb = (sqlite3 *)0;
  rc = sqlite3_initialize();
  if (rc) {
    return (rc);
  }
  if ((int )sqlite3Config.bCoreMutex == 0) {
    isThreadsafe = 0;
  } else
  if (flags___0 & 32768U) {
    isThreadsafe = 0;
  } else
  if (flags___0 & 65536U) {
    isThreadsafe = 1;
  } else {
    isThreadsafe = (int )sqlite3Config.bFullMutex;
  }
  if (flags___0 & 262144U) {
    flags___0 &= 4294836223U;
  } else
  if (sqlite3Config.sharedCacheEnabled) {
    flags___0 |= 131072U;
  }
  flags___0 &= 4294312167U;
  tmp = sqlite3MallocZero((u64 )sizeof(sqlite3 ));
  db = (sqlite3 *)tmp;
  if ((unsigned long )db == (unsigned long )((sqlite3 *)0)) {
    goto opendb_out;
  }
  if (isThreadsafe) {
    db->mutex = (sqlite3_mutex *)8;
    if ((unsigned long )db->mutex == (unsigned long )((sqlite3_mutex *)0)) {
      sqlite3_free((void *)db);
      db = (sqlite3 *)0;
      goto opendb_out;
    }
  }
  db->errMask = 255;
  db->nDb = 2;
  db->magic = 4030429446U;
  db->aDb = db->aDbStatic;
  db->lookaside.bDisable = (u32 )1;
  memcpy((void * __restrict  )(db->aLimit), (void const   * __restrict  )(aHardLimit),
         sizeof(db->aLimit));
  db->aLimit[11] = 0;
  db->autoCommit = (u8 )1;
  db->nextAutovac = (signed char)-1;
  db->szMmap = sqlite3Config.szMmap;
  db->nextPagesize = 0;
  db->nMaxSorterMmap = 2147483647;
  db->flags |= 3758391392ULL;
  sqlite3HashInit(& db->aCollSeq);
  sqlite3HashInit(& db->aModule);
  createCollation(db, sqlite3StrBINARY, (u8 )1, (void *)0, & binCollFunc, (void (*)(void * ))0);
  createCollation(db, sqlite3StrBINARY, (u8 )3, (void *)0, & binCollFunc, (void (*)(void * ))0);
  createCollation(db, sqlite3StrBINARY, (u8 )2, (void *)0, & binCollFunc, (void (*)(void * ))0);
  createCollation(db, "NOCASE", (u8 )1, (void *)0, & nocaseCollatingFunc, (void (*)(void * ))0);
  createCollation(db, "RTRIM", (u8 )1, (void *)0, & rtrimCollFunc, (void (*)(void * ))0);
  if (db->mallocFailed) {
    goto opendb_out;
  }
  db->pDfltColl = sqlite3FindCollSeq(db, (u8 )1, sqlite3StrBINARY, 0);
  db->openFlags = flags___0;
  if (((1 << (flags___0 & 7U)) & 70) == 0) {
    rc = sqlite3MisuseError(159394);
  } else {
    rc = sqlite3ParseUri(zVfs, zFilename, & flags___0, & db->pVfs, & zOpen, & zErrMsg);
  }
  if (rc != 0) {
    if (rc == 7) {
      sqlite3OomFault(db);
    }
    if (zErrMsg) {
      tmp___0 = "%s";
    } else {
      tmp___0 = (char const   *)0;
    }
    sqlite3ErrorWithMsg(db, rc, tmp___0, zErrMsg);
    sqlite3_free((void *)zErrMsg);
    goto opendb_out;
  }
  rc = sqlite3BtreeOpen(db->pVfs, (char const   *)zOpen, db, & (db->aDb + 0)->pBt,
                        0, (int )(flags___0 | 256U));
  if (rc != 0) {
    if (rc == (10 | (12 << 8))) {
      rc = 7;
    }
    sqlite3Error(db, rc);
    goto opendb_out;
  }
  sqlite3BtreeEnter((db->aDb + 0)->pBt);
  (db->aDb + 0)->pSchema = sqlite3SchemaGet(db, (db->aDb + 0)->pBt);
  if (! db->mallocFailed) {
    db->enc = ((db->aDb + 0)->pSchema)->enc;
  }
  (db->aDb + 1)->pSchema = sqlite3SchemaGet(db, (Btree *)0);
  (db->aDb + 0)->zDbSName = (char *)"main";
  (db->aDb + 0)->safety_level = (u8 )3;
  (db->aDb + 1)->zDbSName = (char *)"temp";
  (db->aDb + 1)->safety_level = (u8 )1;
  db->magic = 2687084183U;
  if (db->mallocFailed) {
    goto opendb_out;
  }
  sqlite3Error(db, 0);
  sqlite3RegisterPerConnectionBuiltinFunctions(db);
  rc = sqlite3_errcode(db);
  if (rc == 0) {
    sqlite3AutoLoadExtensions(db);
    rc = sqlite3_errcode(db);
    if (rc != 0) {
      goto opendb_out;
    }
  }
  if (rc) {
    sqlite3Error(db, rc);
  }
  setupLookaside(db, (void *)0, sqlite3Config.szLookaside, sqlite3Config.nLookaside);
  sqlite3_wal_autocheckpoint(db, 1000);
  opendb_out: 
  rc = sqlite3_errcode(db);
  if (rc == 7) {
    sqlite3_close(db);
    db = (sqlite3 *)0;
  } else
  if (rc != 0) {
    db->magic = (u32 )1266094736;
  }
  *ppDb = db;
  sqlite3_free((void *)zOpen);
  return (rc & 255);
}
}
int sqlite3_open(char const   *zFilename , sqlite3 **ppDb ) 
{ 
  int tmp ;

  {
  tmp = openDatabase(zFilename, ppDb, 6U, (char const   *)0);
  return (tmp);
}
}
int sqlite3_open_v2(char const   *filename , sqlite3 **ppDb , int flags___0 , char const   *zVfs ) 
{ 
  int tmp ;

  {
  tmp = openDatabase(filename, ppDb, (unsigned int )flags___0, zVfs);
  return (tmp);
}
}
int sqlite3_open16(void const   *zFilename , sqlite3 **ppDb ) 
{ 
  char const   *zFilename8 ;
  sqlite3_value *pVal ;
  int rc ;
  void const   *tmp ;
  u8 tmp___0 ;

  {
  *ppDb = (sqlite3 *)0;
  rc = sqlite3_initialize();
  if (rc) {
    return (rc);
  }
  if ((unsigned long )zFilename == (unsigned long )((void const   *)0)) {
    zFilename = (void const   *)"\000\000";
  }
  pVal = sqlite3ValueNew((sqlite3 *)0);
  sqlite3ValueSetStr(pVal, -1, zFilename, (u8 )2, (void (*)(void * ))0);
  tmp = sqlite3ValueText(pVal, (u8 )1);
  zFilename8 = (char const   *)tmp;
  if (zFilename8) {
    rc = openDatabase(zFilename8, ppDb, 6U, (char const   *)0);
    if (rc == 0) {
      if (! (((int )(((*ppDb)->aDb + 0)->pSchema)->schemaFlags & 1) == 1)) {
        tmp___0 = (u8 )2;
        (*ppDb)->enc = tmp___0;
        (((*ppDb)->aDb + 0)->pSchema)->enc = tmp___0;
      }
    }
  } else {
    rc = 7;
  }
  sqlite3ValueFree(pVal);
  return (rc & 255);
}
}
int sqlite3_create_collation(sqlite3 *db , char const   *zName , int enc , void *pCtx ,
                             int (*xCompare)(void * , int  , void const   * , int  ,
                                             void const   * ) ) 
{ 
  int tmp ;

  {
  tmp = sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, (void (*)(void * ))0);
  return (tmp);
}
}
int sqlite3_create_collation_v2(sqlite3 *db , char const   *zName , int enc , void *pCtx ,
                                int (*xCompare)(void * , int  , void const   * , int  ,
                                                void const   * ) , void (*xDel)(void * ) ) 
{ 
  int rc ;

  {
  rc = createCollation(db, zName, (u8 )enc, pCtx, xCompare, xDel);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_create_collation16(sqlite3 *db , void const   *zName , int enc , void *pCtx ,
                               int (*xCompare)(void * , int  , void const   * , int  ,
                                               void const   * ) ) 
{ 
  int rc ;
  char *zName8 ;

  {
  rc = 0;
  zName8 = sqlite3Utf16to8(db, zName, -1, (u8 )2);
  if (zName8) {
    rc = createCollation(db, (char const   *)zName8, (u8 )enc, pCtx, xCompare, (void (*)(void * ))0);
    sqlite3DbFree(db, (void *)zName8);
  }
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_collation_needed(sqlite3 *db , void *pCollNeededArg , void (*xCollNeeded)(void * ,
                                                                                      sqlite3 * ,
                                                                                      int eTextRep ,
                                                                                      char const   * ) ) 
{ 


  {
  db->xCollNeeded = xCollNeeded;
  db->xCollNeeded16 = (void (*)(void * , sqlite3 * , int eTextRep , void const   * ))0;
  db->pCollNeededArg = pCollNeededArg;
  return (0);
}
}
int sqlite3_collation_needed16(sqlite3 *db , void *pCollNeededArg , void (*xCollNeeded16)(void * ,
                                                                                          sqlite3 * ,
                                                                                          int eTextRep ,
                                                                                          void const   * ) ) 
{ 


  {
  db->xCollNeeded = (void (*)(void * , sqlite3 * , int eTextRep , char const   * ))0;
  db->xCollNeeded16 = xCollNeeded16;
  db->pCollNeededArg = pCollNeededArg;
  return (0);
}
}
int sqlite3_global_recover(void) 
{ 


  {
  return (0);
}
}
int sqlite3_get_autocommit(sqlite3 *db ) 
{ 


  {
  return ((int )db->autoCommit);
}
}
static int sqlite3ReportError(int iErr , int lineno , char const   *zType ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3_sourceid();
  sqlite3_log(iErr, "%s at line %d of [%.10s]", zType, lineno, tmp + 20);
  return (iErr);
}
}
static int sqlite3CorruptError(int lineno ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ReportError(11, lineno, "database corruption");
  return (tmp);
}
}
static int sqlite3MisuseError(int lineno ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ReportError(21, lineno, "misuse");
  return (tmp);
}
}
static int sqlite3CantopenError(int lineno ) 
{ 
  int tmp ;

  {
  tmp = sqlite3ReportError(14, lineno, "cannot open file");
  return (tmp);
}
}
void sqlite3_thread_cleanup(void) 
{ 


  {
  return;
}
}
int sqlite3_table_column_metadata(sqlite3 *db , char const   *zDbName , char const   *zTableName ,
                                  char const   *zColumnName , char const   **pzDataType ,
                                  char const   **pzCollSeq , int *pNotNull , int *pPrimaryKey ,
                                  int *pAutoinc ) 
{ 
  int rc ;
  char *zErrMsg ;
  Table *pTab ;
  Column *pCol ;
  int iCol ;
  char const   *zDataType ;
  char const   *zCollSeq ;
  int notnull ;
  int primarykey ;
  int autoinc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
  zErrMsg = (char *)0;
  pTab = (Table *)0;
  pCol = (Column *)0;
  iCol = 0;
  zDataType = (char const   *)0;
  zCollSeq = (char const   *)0;
  notnull = 0;
  primarykey = 0;
  autoinc = 0;
  sqlite3BtreeEnterAll(db);
  rc = sqlite3Init(db, & zErrMsg);
  if (0 != rc) {
    goto error_out;
  }
  pTab = sqlite3FindTable(db, zTableName, zDbName);
  if (! pTab) {
    pTab = (Table *)0;
    goto error_out;
  } else
  if (pTab->pSelect) {
    pTab = (Table *)0;
    goto error_out;
  }
  if (! ((unsigned long )zColumnName == (unsigned long )((char const   *)0))) {
    iCol = 0;
    while (iCol < (int )pTab->nCol) {
      pCol = pTab->aCol + iCol;
      tmp = sqlite3StrICmp((char const   *)pCol->zName, zColumnName);
      if (0 == tmp) {
        break;
      }
      iCol ++;
    }
    if (iCol == (int )pTab->nCol) {
      if ((pTab->tabFlags & 32U) == 0U) {
        tmp___0 = sqlite3IsRowid(zColumnName);
        if (tmp___0) {
          iCol = (int )pTab->iPKey;
          if (iCol >= 0) {
            pCol = pTab->aCol + iCol;
          } else {
            pCol = (Column *)0;
          }
        } else {
          pTab = (Table *)0;
          goto error_out;
        }
      } else {
        pTab = (Table *)0;
        goto error_out;
      }
    }
  }
  if (pCol) {
    tmp___1 = sqlite3ColumnType(pCol, (char *)0);
    zDataType = (char const   *)tmp___1;
    zCollSeq = (char const   *)pCol->zColl;
    notnull = (int )pCol->notNull != 0;
    primarykey = ((int )pCol->colFlags & 1) != 0;
    if ((int )pTab->iPKey == iCol) {
      if ((pTab->tabFlags & 8U) != 0U) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
    autoinc = tmp___2;
  } else {
    zDataType = "INTEGER";
    primarykey = 1;
  }
  if (! zCollSeq) {
    zCollSeq = sqlite3StrBINARY;
  }
  error_out: ;
  if (pzDataType) {
    *pzDataType = zDataType;
  }
  if (pzCollSeq) {
    *pzCollSeq = zCollSeq;
  }
  if (pNotNull) {
    *pNotNull = notnull;
  }
  if (pPrimaryKey) {
    *pPrimaryKey = primarykey;
  }
  if (pAutoinc) {
    *pAutoinc = autoinc;
  }
  if (0 == rc) {
    if (! pTab) {
      sqlite3DbFree(db, (void *)zErrMsg);
      zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName, zColumnName);
      rc = 1;
    }
  }
  if (zErrMsg) {
    tmp___3 = "%s";
  } else {
    tmp___3 = (char const   *)0;
  }
  sqlite3ErrorWithMsg(db, rc, tmp___3, zErrMsg);
  sqlite3DbFree(db, (void *)zErrMsg);
  rc = sqlite3ApiExit(db, rc);
  return (rc);
}
}
int sqlite3_sleep(int ms ) 
{ 
  sqlite3_vfs *pVfs ;
  int rc ;
  int tmp ;

  {
  pVfs = sqlite3_vfs_find((char const   *)0);
  if ((unsigned long )pVfs == (unsigned long )((sqlite3_vfs *)0)) {
    return (0);
  }
  tmp = sqlite3OsSleep(pVfs, 1000 * ms);
  rc = tmp / 1000;
  return (rc);
}
}
int sqlite3_extended_result_codes(sqlite3 *db , int onoff ) 
{ 


  {
  if (onoff) {
    db->errMask = -1;
  } else {
    db->errMask = 255;
  }
  return (0);
}
}
int sqlite3_file_control(sqlite3 *db , char const   *zDbName , int op , void *pArg ) 
{ 
  int rc ;
  Btree *pBtree ;
  Pager *pPager ;
  sqlite3_file *fd ;

  {
  rc = 1;
  pBtree = sqlite3DbNameToBtree(db, zDbName);
  if (pBtree) {
    sqlite3BtreeEnter(pBtree);
    pPager = sqlite3BtreePager(pBtree);
    fd = sqlite3PagerFile(pPager);
    if (op == 7) {
      *((sqlite3_file **)pArg) = fd;
      rc = 0;
    } else
    if (op == 27) {
      *((sqlite3_vfs **)pArg) = sqlite3PagerVfs(pPager);
      rc = 0;
    } else
    if (op == 28) {
      *((sqlite3_file **)pArg) = sqlite3PagerJrnlFile(pPager);
      rc = 0;
    } else
    if (op == 35) {
      *((unsigned int *)pArg) = sqlite3PagerDataVersion(pPager);
      rc = 0;
    } else {
      rc = sqlite3OsFileControl(fd, op, pArg);
    }
  }
  return (rc);
}
}
int sqlite3_test_control(int op  , ...) 
{ 
  int rc ;
  va_list ap ;
  int x___0 ;
  int tmp___0 ;
  int y ;
  sqlite3 *db ;
  sqlite3 *tmp___2 ;
  int sz ;
  int tmp___4 ;
  int *aProg ;
  int *tmp___6 ;
  int (*tmp___7)(int  ) ;
  void (*xBenignBegin)(void) ;
  void (*xBenignEnd)(void) ;
  void (*tmp___8)(void) ;
  void (*tmp___9)(void) ;
  unsigned int newVal ;
  unsigned int tmp___11 ;
  int volatile   x___1 ;
  int x___2 ;
  int tmp___13 ;
  sqlite3 *db___0 ;
  sqlite3 *tmp___15 ;
  int x___3 ;
  int tmp___17 ;
  sqlite3 *db___1 ;
  sqlite3 *tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  u8 tmp___25 ;
  int tmp___26 ;
  sqlite3 *db___2 ;
  sqlite3 *tmp___28 ;
  int tmp___29 ;
  sqlite3 *db___3 ;
  sqlite3 *tmp___31 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  int tmp___37 ;
  sqlite3_context *pCtx ;
  sqlite3_context *tmp___39 ;

  {
  rc = 0;
  __builtin_va_start(ap, op);
  switch (op) {
  case 5: 
  sqlite3PrngSaveState();
  break;
  case 6: 
  sqlite3PrngRestoreState();
  break;
  case 28: 
  tmp___0 = __builtin_va_arg(ap, int );
  x___0 = tmp___0;
  tmp___2 = __builtin_va_arg(ap, sqlite3 *);
  db = tmp___2;
  if (db) {
    y = ((db->aDb + 0)->pSchema)->schema_cookie;
    if (y != 0) {
      x___0 = y;
    }
  }
  sqlite3Config.iPrngSeed = (unsigned int )x___0;
  sqlite3_randomness(0, (void *)0);
  break;
  case 8: 
  tmp___4 = __builtin_va_arg(ap, int );
  sz = tmp___4;
  tmp___6 = __builtin_va_arg(ap, int *);
  aProg = tmp___6;
  rc = sqlite3BitvecBuiltinTest(sz, aProg);
  break;
  case 9: 
  tmp___7 = __builtin_va_arg(ap, int (*)(int  ));
  sqlite3Config.xTestCallback = tmp___7;
  rc = sqlite3FaultSim(0);
  break;
  case 10: 
  tmp___8 = __builtin_va_arg(ap, void (*)(void));
  xBenignBegin = tmp___8;
  tmp___9 = __builtin_va_arg(ap, void (*)(void));
  xBenignEnd = tmp___9;
  sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
  break;
  case 11: 
  rc = sqlite3PendingByte;
  tmp___11 = __builtin_va_arg(ap, unsigned int );
  newVal = tmp___11;
  if (newVal) {
    sqlite3PendingByte = (int )newVal;
  }
  break;
  case 12: 
  x___1 = (int volatile   )0;
  rc = (int )x___1;
  break;
  case 13: 
  tmp___13 = __builtin_va_arg(ap, int );
  x___2 = tmp___13;
  if (x___2) {
    rc = x___2;
  } else {
    rc = 0;
  }
  break;
  case 22: 
  rc = 123410;
  break;
  case 14: 
  tmp___15 = __builtin_va_arg(ap, sqlite3 *);
  db___0 = tmp___15;
  tmp___17 = __builtin_va_arg(ap, int );
  x___3 = tmp___17;
  sqlite3BtreeSetPageSize((db___0->aDb + 0)->pBt, 0, x___3, 0);
  break;
  case 15: 
  tmp___19 = __builtin_va_arg(ap, sqlite3 *);
  db___1 = tmp___19;
  tmp___21 = __builtin_va_arg(ap, int );
  db___1->dbOptFlags = (u16 )(tmp___21 & 65535);
  break;
  case 18: 
  tmp___22 = __builtin_va_arg(ap, int );
  sqlite3Config.bLocaltimeFault = tmp___22;
  break;
  case 17: 
  tmp___23 = __builtin_va_arg(ap, int );
  sqlite3Config.bInternalFunctions = tmp___23;
  break;
  case 20: 
  tmp___24 = __builtin_va_arg(ap, int );
  sqlite3Config.neverCorrupt = tmp___24;
  break;
  case 29: 
  tmp___25 = __builtin_va_arg(ap, int );
  sqlite3Config.bExtraSchemaChecks = tmp___25;
  break;
  case 19: 
  tmp___26 = __builtin_va_arg(ap, int );
  sqlite3Config.iOnceResetThreshold = tmp___26;
  break;
  case 21: 
  break;
  case 24: 
  tmp___28 = __builtin_va_arg(ap, sqlite3 *);
  db___2 = tmp___28;
  tmp___29 = __builtin_va_arg(ap, int );
  db___2->nMaxSorterMmap = tmp___29;
  break;
  case 23: 
  if (sqlite3Config.isInit == 0) {
    rc = 1;
  }
  break;
  case 25: 
  tmp___31 = __builtin_va_arg(ap, sqlite3 *);
  db___3 = tmp___31;
  tmp___33 = __builtin_va_arg(ap, char const   *);
  tmp___34 = sqlite3FindDbName(db___3, tmp___33);
  db___3->init.iDb = (u8 )tmp___34;
  tmp___36 = __builtin_va_arg(ap, int );
  tmp___35 = tmp___36;
  db___3->init.imposterTable = tmp___35;
  db___3->init.busy = (u8 )tmp___35;
  tmp___37 = __builtin_va_arg(ap, int );
  db___3->init.newTnum = tmp___37;
  if ((int )db___3->init.busy == 0) {
    if (db___3->init.newTnum > 0) {
      sqlite3ResetAllSchemasOfConnection(db___3);
    }
  }
  break;
  case 27: 
  tmp___39 = __builtin_va_arg(ap, sqlite3_context *);
  pCtx = tmp___39;
  sqlite3ResultIntReal(pCtx);
  break;
  }
  __builtin_va_end(ap);
  return (rc);
}
}
char const   *sqlite3_uri_parameter(char const   *zFilename , char const   *zParam ) 
{ 
  int tmp ;
  int x___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )zFilename == (unsigned long )((char const   *)0)) {
    return ((char const   *)0);
  } else
  if ((unsigned long )zParam == (unsigned long )((char const   *)0)) {
    return ((char const   *)0);
  }
  tmp = sqlite3Strlen30(zFilename);
  zFilename += tmp + 1;
  while (*(zFilename + 0)) {
    tmp___0 = strcmp(zFilename, zParam);
    x___0 = tmp___0;
    tmp___1 = sqlite3Strlen30(zFilename);
    zFilename += tmp___1 + 1;
    if (x___0 == 0) {
      return (zFilename);
    }
    tmp___2 = sqlite3Strlen30(zFilename);
    zFilename += tmp___2 + 1;
  }
  return ((char const   *)0);
}
}
int sqlite3_uri_boolean(char const   *zFilename , char const   *zParam , int bDflt ) 
{ 
  char const   *z ;
  char const   *tmp ;
  u8 tmp___0 ;
  int tmp___1 ;

  {
  tmp = sqlite3_uri_parameter(zFilename, zParam);
  z = tmp;
  bDflt = bDflt != 0;
  if (z) {
    tmp___0 = sqlite3GetBoolean(z, (u8 )bDflt);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = bDflt;
  }
  return (tmp___1);
}
}
sqlite_int64 sqlite3_uri_int64(char const   *zFilename , char const   *zParam , sqlite_int64 bDflt ) 
{ 
  char const   *z ;
  char const   *tmp ;
  sqlite_int64 v ;
  int tmp___0 ;

  {
  tmp = sqlite3_uri_parameter(zFilename, zParam);
  z = tmp;
  if (z) {
    tmp___0 = sqlite3DecOrHexToI64(z, & v);
    if (tmp___0 == 0) {
      bDflt = v;
    }
  }
  return (bDflt);
}
}
static Btree *sqlite3DbNameToBtree(sqlite3 *db , char const   *zDbName ) 
{ 
  int iDb ;
  int tmp ;
  int tmp___0 ;
  Btree *tmp___1 ;

  {
  if (zDbName) {
    tmp = sqlite3FindDbName(db, zDbName);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  iDb = tmp___0;
  if (iDb < 0) {
    tmp___1 = (Btree *)0;
  } else {
    tmp___1 = (db->aDb + iDb)->pBt;
  }
  return (tmp___1);
}
}
char const   *sqlite3_db_filename(sqlite3 *db , char const   *zDbName ) 
{ 
  Btree *pBt ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  pBt = sqlite3DbNameToBtree(db, zDbName);
  if (pBt) {
    tmp = sqlite3BtreeGetFilename(pBt);
    tmp___0 = tmp;
  } else {
    tmp___0 = (char const   *)0;
  }
  return (tmp___0);
}
}
int sqlite3_db_readonly(sqlite3 *db , char const   *zDbName ) 
{ 
  Btree *pBt ;
  int tmp ;
  int tmp___0 ;

  {
  pBt = sqlite3DbNameToBtree(db, zDbName);
  if (pBt) {
    tmp = sqlite3BtreeIsReadonly(pBt);
    tmp___0 = tmp;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
int sqlite3_compileoption_used(char const   *zOptName ) 
{ 
  int i ;
  int n ;
  int nOpt ;
  char const   **azCompileOpt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  azCompileOpt = sqlite3CompileOptions(& nOpt);
  tmp = sqlite3_strnicmp(zOptName, "SQLITE_", 7);
  if (tmp == 0) {
    zOptName += 7;
  }
  n = sqlite3Strlen30(zOptName);
  i = 0;
  while (i < nOpt) {
    tmp___0 = sqlite3_strnicmp(zOptName, *(azCompileOpt + i), n);
    if (tmp___0 == 0) {
      tmp___1 = sqlite3IsIdChar((unsigned char )*(*(azCompileOpt + i) + n));
      if (tmp___1 == 0) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
char const   *sqlite3_compileoption_get(int N ) 
{ 
  int nOpt ;
  char const   **azCompileOpt ;

  {
  azCompileOpt = sqlite3CompileOptions(& nOpt);
  if (N >= 0) {
    if (N < nOpt) {
      return (*(azCompileOpt + N));
    }
  }
  return ((char const   *)0);
}
}
char const   *sqlite3_sourceid(void) 
{ 


  {
  return ("2019-10-04 15:03:17 c20a35336432025445f9f7e289d0cc3e4003fb17f45a4ce74c6269c407c6alt2");
}
}
#pragma merger("0","shell.i","")
#pragma merger("0","/tmp/cil-P8EdYyoy.i","")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern int system(char const   *__command ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int fgetc(FILE *__stream ) ;
extern int fputc(int __c , FILE *__stream ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern void rewind(FILE *__stream ) ;
extern FILE *popen(char const   *__command , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
static int enableTimer  =    0;
static sqlite_int64 timeOfDay(void) ;
static sqlite3_vfs *clockVfs  =    (sqlite3_vfs *)0;
static sqlite_int64 timeOfDay(void) 
{ 
  sqlite_int64 t ;
  double r ;

  {
  if ((unsigned long )clockVfs == (unsigned long )((sqlite3_vfs *)0)) {
    clockVfs = sqlite3_vfs_find((char const   *)0);
  }
  if (clockVfs->iVersion >= 2) {
    if ((unsigned long )clockVfs->xCurrentTimeInt64 != (unsigned long )((int (*)(sqlite3_vfs * ,
                                                                                 sqlite_int64 * ))0)) {
      (*(clockVfs->xCurrentTimeInt64))(clockVfs, & t);
    } else {
      (*(clockVfs->xCurrentTime))(clockVfs, & r);
      t = (sqlite_int64 )(r * 86400000.0);
    }
  } else {
    (*(clockVfs->xCurrentTime))(clockVfs, & r);
    t = (sqlite_int64 )(r * 86400000.0);
  }
  return (t);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
static struct rusage sBegin  ;
static sqlite_int64 iBegin  ;
static void beginTimer(void) 
{ 


  {
  if (enableTimer) {
    getrusage(0, & sBegin);
    iBegin = timeOfDay();
  }
  return;
}
}
static double timeDiff(struct timeval *pStart , struct timeval *pEnd ) 
{ 


  {
  return ((double )(pEnd->tv_usec - pStart->tv_usec) * 0.000001 + (double )(pEnd->tv_sec - pStart->tv_sec));
}
}
static void endTimer(void) 
{ 
  sqlite_int64 iEnd ;
  sqlite_int64 tmp ;
  struct rusage sEnd ;
  double tmp___0 ;
  double tmp___1 ;

  {
  if (enableTimer) {
    tmp = timeOfDay();
    iEnd = tmp;
    getrusage(0, & sEnd);
    tmp___0 = timeDiff(& sBegin.ru_stime, & sEnd.ru_stime);
    tmp___1 = timeDiff(& sBegin.ru_utime, & sEnd.ru_utime);
    printf((char const   * __restrict  )"Run Time: real %.3f user %f sys %f\n", (double )(iEnd - iBegin) * 0.001,
           tmp___1, tmp___0);
  }
  return;
}
}
static int bail_on_error  =    0;
static int stdin_is_interactive  =    1;
static int stdout_is_console  =    1;
static sqlite3 *globalDb  =    (sqlite3 *)0;
static int volatile   seenInterrupt  =    (int volatile   )0;
static char *Argv0  ;
static char mainPrompt[20]  ;
static char continuePrompt[20]  ;
static void shell_out_of_memory(void) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: out of memory\n");
  exit(1);
}
}
static void utf8_width_print(FILE *pOut , int w , char const   *zUtf ) 
{ 
  int i ;
  int n ;
  int aw ;
  int tmp ;
  char zBuf[1000] ;

  {
  if (w < 0) {
    tmp = - w;
  } else {
    tmp = w;
  }
  aw = tmp;
  if (aw > (int )sizeof(zBuf) / 3) {
    aw = (int )sizeof(zBuf) / 3;
  }
  n = 0;
  i = n;
  while (*(zUtf + i)) {
    if (((int const   )*(zUtf + i) & 192) != 128) {
      n ++;
      if (n == aw) {
        while (1) {
          i ++;
          if (! (((int const   )*(zUtf + i) & 192) == 128)) {
            break;
          }
        }
        break;
      }
    }
    i ++;
  }
  if (n >= aw) {
    fprintf((FILE * __restrict  )pOut, (char const   * __restrict  )"%.*s", i, zUtf);
  } else
  if (w < 0) {
    fprintf((FILE * __restrict  )pOut, (char const   * __restrict  )"%*s%s", aw - n,
            "", zUtf);
  } else {
    fprintf((FILE * __restrict  )pOut, (char const   * __restrict  )"%s%*s", zUtf,
            aw - n, "");
  }
  return;
}
}
static int isNumber(char const   *z , int *realnum ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  if ((int const   )*z == 45) {
    z ++;
  } else
  if ((int const   )*z == 43) {
    z ++;
  }
  tmp = __ctype_b_loc();
  if (! ((int const   )*(*tmp + (int )((unsigned char )*z)) & 2048)) {
    return (0);
  }
  z ++;
  if (realnum) {
    *realnum = 0;
  }
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*z)) & 2048)) {
      break;
    }
    z ++;
  }
  if ((int const   )*z == 46) {
    z ++;
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*z)) & 2048)) {
      return (0);
    }
    while (1) {
      tmp___2 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*z)) & 2048)) {
        break;
      }
      z ++;
    }
    if (realnum) {
      *realnum = 1;
    }
  }
  if ((int const   )*z == 101) {
    goto _L;
  } else
  if ((int const   )*z == 69) {
    _L: /* CIL Label */ 
    z ++;
    if ((int const   )*z == 43) {
      z ++;
    } else
    if ((int const   )*z == 45) {
      z ++;
    }
    tmp___3 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*z)) & 2048)) {
      return (0);
    }
    while (1) {
      tmp___4 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*z)) & 2048)) {
        break;
      }
      z ++;
    }
    if (realnum) {
      *realnum = 1;
    }
  }
  return ((int const   )*z == 0);
}
}
static int strlen30(char const   *z ) 
{ 
  char const   *z2 ;

  {
  z2 = z;
  while (*z2) {
    z2 ++;
  }
  return (1073741823 & (int )(z2 - z));
}
}
static int strlenChar(char const   *z ) 
{ 
  int n ;
  char const   *tmp ;

  {
  n = 0;
  while (*z) {
    tmp = z;
    z ++;
    if ((192 & (int )*tmp) != 128) {
      n ++;
    }
  }
  return (n);
}
}
static char *local_getline(char *zLine , FILE *in ) 
{ 
  int nLine ;
  int tmp ;
  int n ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned long )zLine == (unsigned long )((char *)0)) {
    tmp = 0;
  } else {
    tmp = 100;
  }
  nLine = tmp;
  n = 0;
  while (1) {
    if (n + 100 > nLine) {
      nLine = nLine * 2 + 100;
      tmp___0 = realloc((void *)zLine, (size_t )nLine);
      zLine = (char *)tmp___0;
      if ((unsigned long )zLine == (unsigned long )((char *)0)) {
        shell_out_of_memory();
      }
    }
    tmp___1 = fgets((char * __restrict  )(zLine + n), nLine - n, (FILE * __restrict  )in);
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
      if (n == 0) {
        free((void *)zLine);
        return ((char *)0);
      }
      *(zLine + n) = (char)0;
      break;
    }
    while (*(zLine + n)) {
      n ++;
    }
    if (n > 0) {
      if ((int )*(zLine + (n - 1)) == 10) {
        n --;
        if (n > 0) {
          if ((int )*(zLine + (n - 1)) == 13) {
            n --;
          }
        }
        *(zLine + n) = (char)0;
        break;
      }
    }
  }
  return (zLine);
}
}
static char *one_input_line(FILE *in , char *zPrior , int isContinuation ) 
{ 
  char *zPrompt ;
  char *zResult ;

  {
  if ((unsigned long )in != (unsigned long )((FILE *)0)) {
    zResult = local_getline(zPrior, in);
  } else {
    if (isContinuation) {
      zPrompt = continuePrompt;
    } else {
      zPrompt = mainPrompt;
    }
    printf((char const   * __restrict  )"%s", zPrompt);
    fflush(stdout);
    zResult = local_getline(zPrior, stdin);
  }
  return (zResult);
}
}
static int hexDigitValue(char c ) 
{ 


  {
  if ((int )c >= 48) {
    if ((int )c <= 57) {
      return ((int )c - 48);
    }
  }
  if ((int )c >= 97) {
    if ((int )c <= 102) {
      return (((int )c - 97) + 10);
    }
  }
  if ((int )c >= 65) {
    if ((int )c <= 70) {
      return (((int )c - 65) + 10);
    }
  }
  return (-1);
}
}
static sqlite_int64 integerValue(char const   *zArg ) ;
static struct __anonstruct_aMult_1036346510  const  aMult[9]  = 
  {      {(char *)"KiB", 1024}, 
        {(char *)"MiB", 1048576}, 
        {(char *)"GiB", 1073741824}, 
        {(char *)"KB", 1000}, 
        {(char *)"MB", 1000000}, 
        {(char *)"GB", 1000000000}, 
        {(char *)"K", 1000}, 
        {(char *)"M", 1000000}, 
        {(char *)"G", 1000000000}};
static sqlite_int64 integerValue(char const   *zArg ) 
{ 
  sqlite_int64 v ;
  int i ;
  int isNeg ;
  int x___0 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  sqlite_int64 tmp___1 ;

  {
  v = (sqlite_int64 )0;
  isNeg = 0;
  if ((int const   )*(zArg + 0) == 45) {
    isNeg = 1;
    zArg ++;
  } else
  if ((int const   )*(zArg + 0) == 43) {
    zArg ++;
  }
  if ((int const   )*(zArg + 0) == 48) {
    if ((int const   )*(zArg + 1) == 120) {
      zArg += 2;
      while (1) {
        x___0 = hexDigitValue((char )*(zArg + 0));
        if (! (x___0 >= 0)) {
          break;
        }
        v = (v << 4) + (sqlite_int64 )x___0;
        zArg ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    while (1) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(zArg + 0))) & 2048)) {
        break;
      }
      v = (v * 10LL + (sqlite_int64 )*(zArg + 0)) - 48LL;
      zArg ++;
    }
  }
  i = 0;
  while (i < (int )(sizeof(aMult) / sizeof(aMult[0]))) {
    tmp___0 = sqlite3_stricmp((char const   *)aMult[i].zSuffix, zArg);
    if (tmp___0 == 0) {
      v *= (sqlite_int64 )aMult[i].iMult;
      break;
    }
    i ++;
  }
  if (isNeg) {
    tmp___1 = - v;
  } else {
    tmp___1 = v;
  }
  return (tmp___1);
}
}
static void initText(ShellText *p ) 
{ 


  {
  memset((void *)p, 0, sizeof(*p));
  return;
}
}
static void freeText(ShellText *p ) 
{ 


  {
  free((void *)p->z);
  initText(p);
  return;
}
}
static void appendText(ShellText *p , char const   *zAppend , char quote ) 
{ 
  int len ;
  int i ;
  int nAppend ;
  int tmp ;
  void *tmp___0 ;
  char *zCsr ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  tmp = strlen30(zAppend);
  nAppend = tmp;
  len = (nAppend + p->n) + 1;
  if (quote) {
    len += 2;
    i = 0;
    while (i < nAppend) {
      if ((int const   )*(zAppend + i) == (int const   )quote) {
        len ++;
      }
      i ++;
    }
  }
  if (p->n + len >= p->nAlloc) {
    p->nAlloc = (p->nAlloc * 2 + len) + 20;
    tmp___0 = realloc((void *)p->z, (size_t )p->nAlloc);
    p->z = (char *)tmp___0;
    if ((unsigned long )p->z == (unsigned long )((char *)0)) {
      shell_out_of_memory();
    }
  }
  if (quote) {
    zCsr = p->z + p->n;
    tmp___1 = zCsr;
    zCsr ++;
    *tmp___1 = quote;
    i = 0;
    while (i < nAppend) {
      tmp___2 = zCsr;
      zCsr ++;
      *tmp___2 = (char )*(zAppend + i);
      if ((int const   )*(zAppend + i) == (int const   )quote) {
        tmp___3 = zCsr;
        zCsr ++;
        *tmp___3 = quote;
      }
      i ++;
    }
    tmp___4 = zCsr;
    zCsr ++;
    *tmp___4 = quote;
    p->n = (int )(zCsr - p->z);
    *zCsr = (char )'\000';
  } else {
    memcpy((void * __restrict  )(p->z + p->n), (void const   * __restrict  )zAppend,
           (size_t )nAppend);
    p->n += nAppend;
    *(p->z + p->n) = (char )'\000';
  }
  return;
}
}
static char quoteChar(char const   *zName ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = __ctype_b_loc();
  if (! ((int const   )*(*tmp + (int )((unsigned char )*(zName + 0))) & 1024)) {
    if ((int const   )*(zName + 0) != 95) {
      return ((char )'\"');
    }
  }
  i = 0;
  while (*(zName + i)) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(zName + i))) & 8)) {
      if ((int const   )*(zName + i) != 95) {
        return ((char )'\"');
      }
    }
    i ++;
  }
  tmp___3 = sqlite3_keyword_check(zName, i);
  if (tmp___3) {
    tmp___2 = '\"';
  } else {
    tmp___2 = 0;
  }
  return ((char )tmp___2);
}
}
static char *shellFakeSchema(sqlite3 *db , char const   *zSchema , char const   *zName ) 
{ 
  sqlite3_stmt *pStmt ;
  char *zSql ;
  ShellText s ;
  char cQuote ;
  char *zDiv ;
  int nRow ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *zCol ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;

  {
  pStmt = (sqlite3_stmt *)0;
  zDiv = (char *)"(";
  nRow = 0;
  if (zSchema) {
    tmp = zSchema;
  } else {
    tmp = "main";
  }
  zSql = sqlite3_mprintf("PRAGMA \"%w\".table_info=%Q;", tmp, zName);
  sqlite3_prepare_v2(db, (char const   *)zSql, -1, & pStmt, (char const   **)0);
  sqlite3_free((void *)zSql);
  initText(& s);
  if (zSchema) {
    cQuote = quoteChar(zSchema);
    if (cQuote) {
      tmp___0 = sqlite3_stricmp(zSchema, "temp");
      if (tmp___0 == 0) {
        cQuote = (char)0;
      }
    }
    appendText(& s, zSchema, cQuote);
    appendText(& s, ".", (char)0);
  }
  cQuote = quoteChar(zName);
  appendText(& s, zName, cQuote);
  while (1) {
    tmp___2 = sqlite3_step(pStmt);
    if (! (tmp___2 == 100)) {
      break;
    }
    tmp___1 = sqlite3_column_text(pStmt, 1);
    zCol = (char const   *)tmp___1;
    nRow ++;
    appendText(& s, (char const   *)zDiv, (char)0);
    zDiv = (char *)",";
    cQuote = quoteChar(zCol);
    appendText(& s, zCol, cQuote);
  }
  appendText(& s, ")", (char)0);
  sqlite3_finalize(pStmt);
  if (nRow == 0) {
    freeText(& s);
    s.z = (char *)0;
  }
  return (s.z);
}
}
static void shellModuleSchema(sqlite3_context *pCtx , int nVal , sqlite3_value **apVal ) 
{ 
  char const   *zName ;
  unsigned char const   *tmp ;
  char *zFake ;
  sqlite3 *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = sqlite3_value_text(*(apVal + 0));
  zName = (char const   *)tmp;
  tmp___0 = sqlite3_context_db_handle(pCtx);
  tmp___1 = shellFakeSchema(tmp___0, (char const   *)0, zName);
  zFake = tmp___1;
  if (zFake) {
    tmp___2 = sqlite3_mprintf("/* %s */", zFake);
    sqlite3_result_text(pCtx, (char const   *)tmp___2, -1, & sqlite3_free);
    free((void *)zFake);
  }
  return;
}
}
static void shellAddSchemaName(sqlite3_context *pCtx , int nVal , sqlite3_value **apVal ) ;
static char const   *aPrefix___0[6]  = {      "TABLE",      "INDEX",      "UNIQUE INDEX",      "VIEW", 
        "TRIGGER",      "VIRTUAL TABLE"};
static void shellAddSchemaName(sqlite3_context *pCtx , int nVal , sqlite3_value **apVal ) 
{ 
  int i ;
  char const   *zIn ;
  unsigned char const   *tmp ;
  char const   *zSchema ;
  unsigned char const   *tmp___0 ;
  char const   *zName ;
  unsigned char const   *tmp___1 ;
  sqlite3 *db ;
  sqlite3 *tmp___2 ;
  int n ;
  int tmp___3 ;
  char *z ;
  char *zFake ;
  char cQuote ;
  char tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  i = 0;
  tmp = sqlite3_value_text(*(apVal + 0));
  zIn = (char const   *)tmp;
  tmp___0 = sqlite3_value_text(*(apVal + 1));
  zSchema = (char const   *)tmp___0;
  tmp___1 = sqlite3_value_text(*(apVal + 2));
  zName = (char const   *)tmp___1;
  tmp___2 = sqlite3_context_db_handle(pCtx);
  db = tmp___2;
  if ((unsigned long )zIn != (unsigned long )((char const   *)0)) {
    tmp___7 = strncmp(zIn, "CREATE ", (size_t )7);
    if (tmp___7 == 0) {
      i = 0;
      while (i < (int )(sizeof(aPrefix___0) / sizeof(aPrefix___0[0]))) {
        tmp___3 = strlen30(aPrefix___0[i]);
        n = tmp___3;
        tmp___6 = strncmp(zIn + 7, aPrefix___0[i], (size_t )n);
        if (tmp___6 == 0) {
          if ((int const   )*(zIn + (n + 7)) == 32) {
            z = (char *)0;
            zFake = (char *)0;
            if (zSchema) {
              tmp___4 = quoteChar(zSchema);
              cQuote = tmp___4;
              if (cQuote) {
                tmp___5 = sqlite3_stricmp(zSchema, "temp");
                if (tmp___5 != 0) {
                  z = sqlite3_mprintf("%.*s \"%w\".%s", n + 7, zIn, zSchema, (zIn + n) + 8);
                } else {
                  z = sqlite3_mprintf("%.*s %s.%s", n + 7, zIn, zSchema, (zIn + n) + 8);
                }
              } else {
                z = sqlite3_mprintf("%.*s %s.%s", n + 7, zIn, zSchema, (zIn + n) + 8);
              }
            }
            if (zName) {
              if ((int const   )*(aPrefix___0[i] + 0) == 86) {
                zFake = shellFakeSchema(db, zSchema, zName);
                if ((unsigned long )zFake != (unsigned long )((char *)0)) {
                  if ((unsigned long )z == (unsigned long )((char *)0)) {
                    z = sqlite3_mprintf("%s\n/* %s */", zIn, zFake);
                  } else {
                    z = sqlite3_mprintf("%z\n/* %s */", z, zFake);
                  }
                  free((void *)zFake);
                }
              }
            }
            if (z) {
              sqlite3_result_text(pCtx, (char const   *)z, -1, & sqlite3_free);
              return;
            }
          }
        }
        i ++;
      }
    }
  }
  sqlite3_result_value(pCtx, *(apVal + 0));
  return;
}
}
static void KeccakF1600Step(SHA3Context *p ) ;
static u64 const   RC[24]  = 
  {      (u64 const   )1ULL,      (u64 const   )32898ULL,      (u64 const   )0x800000000000808aULL,      (u64 const   )0x8000000080008000ULL, 
        (u64 const   )32907ULL,      (u64 const   )2147483649ULL,      (u64 const   )0x8000000080008081ULL,      (u64 const   )0x8000000000008009ULL, 
        (u64 const   )138ULL,      (u64 const   )136ULL,      (u64 const   )2147516425ULL,      (u64 const   )2147483658ULL, 
        (u64 const   )2147516555ULL,      (u64 const   )0x800000000000008bULL,      (u64 const   )0x8000000000008089ULL,      (u64 const   )0x8000000000008003ULL, 
        (u64 const   )0x8000000000008002ULL,      (u64 const   )0x8000000000000080ULL,      (u64 const   )32778ULL,      (u64 const   )0x800000008000000aULL, 
        (u64 const   )0x8000000080008081ULL,      (u64 const   )0x8000000000008080ULL,      (u64 const   )2147483649ULL,      (u64 const   )0x8000000080008008ULL};
static void KeccakF1600Step(SHA3Context *p ) 
{ 
  int i ;
  u64 b0 ;
  u64 b1 ;
  u64 b2 ;
  u64 b3 ;
  u64 b4 ;
  u64 c0 ;
  u64 c1 ;
  u64 c2 ;
  u64 c3 ;
  u64 c4 ;
  u64 d0 ;
  u64 d1 ;
  u64 d2 ;
  u64 d3 ;
  u64 d4 ;

  {
  i = 0;
  while (i < 24) {
    c0 = (((p->u.s[0] ^ p->u.s[5]) ^ p->u.s[10]) ^ p->u.s[15]) ^ p->u.s[20];
    c1 = (((p->u.s[1] ^ p->u.s[6]) ^ p->u.s[11]) ^ p->u.s[16]) ^ p->u.s[21];
    c2 = (((p->u.s[2] ^ p->u.s[7]) ^ p->u.s[12]) ^ p->u.s[17]) ^ p->u.s[22];
    c3 = (((p->u.s[3] ^ p->u.s[8]) ^ p->u.s[13]) ^ p->u.s[18]) ^ p->u.s[23];
    c4 = (((p->u.s[4] ^ p->u.s[9]) ^ p->u.s[14]) ^ p->u.s[19]) ^ p->u.s[24];
    d0 = c4 ^ ((c1 << 1) | (c1 >> 63));
    d1 = c0 ^ ((c2 << 1) | (c2 >> 63));
    d2 = c1 ^ ((c3 << 1) | (c3 >> 63));
    d3 = c2 ^ ((c4 << 1) | (c4 >> 63));
    d4 = c3 ^ ((c0 << 1) | (c0 >> 63));
    b0 = p->u.s[0] ^ d0;
    b1 = ((p->u.s[6] ^ d1) << 44) | ((p->u.s[6] ^ d1) >> 20);
    b2 = ((p->u.s[12] ^ d2) << 43) | ((p->u.s[12] ^ d2) >> 21);
    b3 = ((p->u.s[18] ^ d3) << 21) | ((p->u.s[18] ^ d3) >> 43);
    b4 = ((p->u.s[24] ^ d4) << 14) | ((p->u.s[24] ^ d4) >> 50);
    p->u.s[0] = b0 ^ (~ b1 & b2);
    p->u.s[0] ^= (unsigned long long )RC[i];
    p->u.s[6] = b1 ^ (~ b2 & b3);
    p->u.s[12] = b2 ^ (~ b3 & b4);
    p->u.s[18] = b3 ^ (~ b4 & b0);
    p->u.s[24] = b4 ^ (~ b0 & b1);
    b2 = ((p->u.s[10] ^ d0) << 3) | ((p->u.s[10] ^ d0) >> 61);
    b3 = ((p->u.s[16] ^ d1) << 45) | ((p->u.s[16] ^ d1) >> 19);
    b4 = ((p->u.s[22] ^ d2) << 61) | ((p->u.s[22] ^ d2) >> 3);
    b0 = ((p->u.s[3] ^ d3) << 28) | ((p->u.s[3] ^ d3) >> 36);
    b1 = ((p->u.s[9] ^ d4) << 20) | ((p->u.s[9] ^ d4) >> 44);
    p->u.s[10] = b0 ^ (~ b1 & b2);
    p->u.s[16] = b1 ^ (~ b2 & b3);
    p->u.s[22] = b2 ^ (~ b3 & b4);
    p->u.s[3] = b3 ^ (~ b4 & b0);
    p->u.s[9] = b4 ^ (~ b0 & b1);
    b4 = ((p->u.s[20] ^ d0) << 18) | ((p->u.s[20] ^ d0) >> 46);
    b0 = ((p->u.s[1] ^ d1) << 1) | ((p->u.s[1] ^ d1) >> 63);
    b1 = ((p->u.s[7] ^ d2) << 6) | ((p->u.s[7] ^ d2) >> 58);
    b2 = ((p->u.s[13] ^ d3) << 25) | ((p->u.s[13] ^ d3) >> 39);
    b3 = ((p->u.s[19] ^ d4) << 8) | ((p->u.s[19] ^ d4) >> 56);
    p->u.s[20] = b0 ^ (~ b1 & b2);
    p->u.s[1] = b1 ^ (~ b2 & b3);
    p->u.s[7] = b2 ^ (~ b3 & b4);
    p->u.s[13] = b3 ^ (~ b4 & b0);
    p->u.s[19] = b4 ^ (~ b0 & b1);
    b1 = ((p->u.s[5] ^ d0) << 36) | ((p->u.s[5] ^ d0) >> 28);
    b2 = ((p->u.s[11] ^ d1) << 10) | ((p->u.s[11] ^ d1) >> 54);
    b3 = ((p->u.s[17] ^ d2) << 15) | ((p->u.s[17] ^ d2) >> 49);
    b4 = ((p->u.s[23] ^ d3) << 56) | ((p->u.s[23] ^ d3) >> 8);
    b0 = ((p->u.s[4] ^ d4) << 27) | ((p->u.s[4] ^ d4) >> 37);
    p->u.s[5] = b0 ^ (~ b1 & b2);
    p->u.s[11] = b1 ^ (~ b2 & b3);
    p->u.s[17] = b2 ^ (~ b3 & b4);
    p->u.s[23] = b3 ^ (~ b4 & b0);
    p->u.s[4] = b4 ^ (~ b0 & b1);
    b3 = ((p->u.s[15] ^ d0) << 41) | ((p->u.s[15] ^ d0) >> 23);
    b4 = ((p->u.s[21] ^ d1) << 2) | ((p->u.s[21] ^ d1) >> 62);
    b0 = ((p->u.s[2] ^ d2) << 62) | ((p->u.s[2] ^ d2) >> 2);
    b1 = ((p->u.s[8] ^ d3) << 55) | ((p->u.s[8] ^ d3) >> 9);
    b2 = ((p->u.s[14] ^ d4) << 39) | ((p->u.s[14] ^ d4) >> 25);
    p->u.s[15] = b0 ^ (~ b1 & b2);
    p->u.s[21] = b1 ^ (~ b2 & b3);
    p->u.s[2] = b2 ^ (~ b3 & b4);
    p->u.s[8] = b3 ^ (~ b4 & b0);
    p->u.s[14] = b4 ^ (~ b0 & b1);
    c0 = (((p->u.s[0] ^ p->u.s[10]) ^ p->u.s[20]) ^ p->u.s[5]) ^ p->u.s[15];
    c1 = (((p->u.s[6] ^ p->u.s[16]) ^ p->u.s[1]) ^ p->u.s[11]) ^ p->u.s[21];
    c2 = (((p->u.s[12] ^ p->u.s[22]) ^ p->u.s[7]) ^ p->u.s[17]) ^ p->u.s[2];
    c3 = (((p->u.s[18] ^ p->u.s[3]) ^ p->u.s[13]) ^ p->u.s[23]) ^ p->u.s[8];
    c4 = (((p->u.s[24] ^ p->u.s[9]) ^ p->u.s[19]) ^ p->u.s[4]) ^ p->u.s[14];
    d0 = c4 ^ ((c1 << 1) | (c1 >> 63));
    d1 = c0 ^ ((c2 << 1) | (c2 >> 63));
    d2 = c1 ^ ((c3 << 1) | (c3 >> 63));
    d3 = c2 ^ ((c4 << 1) | (c4 >> 63));
    d4 = c3 ^ ((c0 << 1) | (c0 >> 63));
    b0 = p->u.s[0] ^ d0;
    b1 = ((p->u.s[16] ^ d1) << 44) | ((p->u.s[16] ^ d1) >> 20);
    b2 = ((p->u.s[7] ^ d2) << 43) | ((p->u.s[7] ^ d2) >> 21);
    b3 = ((p->u.s[23] ^ d3) << 21) | ((p->u.s[23] ^ d3) >> 43);
    b4 = ((p->u.s[14] ^ d4) << 14) | ((p->u.s[14] ^ d4) >> 50);
    p->u.s[0] = b0 ^ (~ b1 & b2);
    p->u.s[0] ^= (unsigned long long )RC[i + 1];
    p->u.s[16] = b1 ^ (~ b2 & b3);
    p->u.s[7] = b2 ^ (~ b3 & b4);
    p->u.s[23] = b3 ^ (~ b4 & b0);
    p->u.s[14] = b4 ^ (~ b0 & b1);
    b2 = ((p->u.s[20] ^ d0) << 3) | ((p->u.s[20] ^ d0) >> 61);
    b3 = ((p->u.s[11] ^ d1) << 45) | ((p->u.s[11] ^ d1) >> 19);
    b4 = ((p->u.s[2] ^ d2) << 61) | ((p->u.s[2] ^ d2) >> 3);
    b0 = ((p->u.s[18] ^ d3) << 28) | ((p->u.s[18] ^ d3) >> 36);
    b1 = ((p->u.s[9] ^ d4) << 20) | ((p->u.s[9] ^ d4) >> 44);
    p->u.s[20] = b0 ^ (~ b1 & b2);
    p->u.s[11] = b1 ^ (~ b2 & b3);
    p->u.s[2] = b2 ^ (~ b3 & b4);
    p->u.s[18] = b3 ^ (~ b4 & b0);
    p->u.s[9] = b4 ^ (~ b0 & b1);
    b4 = ((p->u.s[15] ^ d0) << 18) | ((p->u.s[15] ^ d0) >> 46);
    b0 = ((p->u.s[6] ^ d1) << 1) | ((p->u.s[6] ^ d1) >> 63);
    b1 = ((p->u.s[22] ^ d2) << 6) | ((p->u.s[22] ^ d2) >> 58);
    b2 = ((p->u.s[13] ^ d3) << 25) | ((p->u.s[13] ^ d3) >> 39);
    b3 = ((p->u.s[4] ^ d4) << 8) | ((p->u.s[4] ^ d4) >> 56);
    p->u.s[15] = b0 ^ (~ b1 & b2);
    p->u.s[6] = b1 ^ (~ b2 & b3);
    p->u.s[22] = b2 ^ (~ b3 & b4);
    p->u.s[13] = b3 ^ (~ b4 & b0);
    p->u.s[4] = b4 ^ (~ b0 & b1);
    b1 = ((p->u.s[10] ^ d0) << 36) | ((p->u.s[10] ^ d0) >> 28);
    b2 = ((p->u.s[1] ^ d1) << 10) | ((p->u.s[1] ^ d1) >> 54);
    b3 = ((p->u.s[17] ^ d2) << 15) | ((p->u.s[17] ^ d2) >> 49);
    b4 = ((p->u.s[8] ^ d3) << 56) | ((p->u.s[8] ^ d3) >> 8);
    b0 = ((p->u.s[24] ^ d4) << 27) | ((p->u.s[24] ^ d4) >> 37);
    p->u.s[10] = b0 ^ (~ b1 & b2);
    p->u.s[1] = b1 ^ (~ b2 & b3);
    p->u.s[17] = b2 ^ (~ b3 & b4);
    p->u.s[8] = b3 ^ (~ b4 & b0);
    p->u.s[24] = b4 ^ (~ b0 & b1);
    b3 = ((p->u.s[5] ^ d0) << 41) | ((p->u.s[5] ^ d0) >> 23);
    b4 = ((p->u.s[21] ^ d1) << 2) | ((p->u.s[21] ^ d1) >> 62);
    b0 = ((p->u.s[12] ^ d2) << 62) | ((p->u.s[12] ^ d2) >> 2);
    b1 = ((p->u.s[3] ^ d3) << 55) | ((p->u.s[3] ^ d3) >> 9);
    b2 = ((p->u.s[19] ^ d4) << 39) | ((p->u.s[19] ^ d4) >> 25);
    p->u.s[5] = b0 ^ (~ b1 & b2);
    p->u.s[21] = b1 ^ (~ b2 & b3);
    p->u.s[12] = b2 ^ (~ b3 & b4);
    p->u.s[3] = b3 ^ (~ b4 & b0);
    p->u.s[19] = b4 ^ (~ b0 & b1);
    c0 = (((p->u.s[0] ^ p->u.s[20]) ^ p->u.s[15]) ^ p->u.s[10]) ^ p->u.s[5];
    c1 = (((p->u.s[16] ^ p->u.s[11]) ^ p->u.s[6]) ^ p->u.s[1]) ^ p->u.s[21];
    c2 = (((p->u.s[7] ^ p->u.s[2]) ^ p->u.s[22]) ^ p->u.s[17]) ^ p->u.s[12];
    c3 = (((p->u.s[23] ^ p->u.s[18]) ^ p->u.s[13]) ^ p->u.s[8]) ^ p->u.s[3];
    c4 = (((p->u.s[14] ^ p->u.s[9]) ^ p->u.s[4]) ^ p->u.s[24]) ^ p->u.s[19];
    d0 = c4 ^ ((c1 << 1) | (c1 >> 63));
    d1 = c0 ^ ((c2 << 1) | (c2 >> 63));
    d2 = c1 ^ ((c3 << 1) | (c3 >> 63));
    d3 = c2 ^ ((c4 << 1) | (c4 >> 63));
    d4 = c3 ^ ((c0 << 1) | (c0 >> 63));
    b0 = p->u.s[0] ^ d0;
    b1 = ((p->u.s[11] ^ d1) << 44) | ((p->u.s[11] ^ d1) >> 20);
    b2 = ((p->u.s[22] ^ d2) << 43) | ((p->u.s[22] ^ d2) >> 21);
    b3 = ((p->u.s[8] ^ d3) << 21) | ((p->u.s[8] ^ d3) >> 43);
    b4 = ((p->u.s[19] ^ d4) << 14) | ((p->u.s[19] ^ d4) >> 50);
    p->u.s[0] = b0 ^ (~ b1 & b2);
    p->u.s[0] ^= (unsigned long long )RC[i + 2];
    p->u.s[11] = b1 ^ (~ b2 & b3);
    p->u.s[22] = b2 ^ (~ b3 & b4);
    p->u.s[8] = b3 ^ (~ b4 & b0);
    p->u.s[19] = b4 ^ (~ b0 & b1);
    b2 = ((p->u.s[15] ^ d0) << 3) | ((p->u.s[15] ^ d0) >> 61);
    b3 = ((p->u.s[1] ^ d1) << 45) | ((p->u.s[1] ^ d1) >> 19);
    b4 = ((p->u.s[12] ^ d2) << 61) | ((p->u.s[12] ^ d2) >> 3);
    b0 = ((p->u.s[23] ^ d3) << 28) | ((p->u.s[23] ^ d3) >> 36);
    b1 = ((p->u.s[9] ^ d4) << 20) | ((p->u.s[9] ^ d4) >> 44);
    p->u.s[15] = b0 ^ (~ b1 & b2);
    p->u.s[1] = b1 ^ (~ b2 & b3);
    p->u.s[12] = b2 ^ (~ b3 & b4);
    p->u.s[23] = b3 ^ (~ b4 & b0);
    p->u.s[9] = b4 ^ (~ b0 & b1);
    b4 = ((p->u.s[5] ^ d0) << 18) | ((p->u.s[5] ^ d0) >> 46);
    b0 = ((p->u.s[16] ^ d1) << 1) | ((p->u.s[16] ^ d1) >> 63);
    b1 = ((p->u.s[2] ^ d2) << 6) | ((p->u.s[2] ^ d2) >> 58);
    b2 = ((p->u.s[13] ^ d3) << 25) | ((p->u.s[13] ^ d3) >> 39);
    b3 = ((p->u.s[24] ^ d4) << 8) | ((p->u.s[24] ^ d4) >> 56);
    p->u.s[5] = b0 ^ (~ b1 & b2);
    p->u.s[16] = b1 ^ (~ b2 & b3);
    p->u.s[2] = b2 ^ (~ b3 & b4);
    p->u.s[13] = b3 ^ (~ b4 & b0);
    p->u.s[24] = b4 ^ (~ b0 & b1);
    b1 = ((p->u.s[20] ^ d0) << 36) | ((p->u.s[20] ^ d0) >> 28);
    b2 = ((p->u.s[6] ^ d1) << 10) | ((p->u.s[6] ^ d1) >> 54);
    b3 = ((p->u.s[17] ^ d2) << 15) | ((p->u.s[17] ^ d2) >> 49);
    b4 = ((p->u.s[3] ^ d3) << 56) | ((p->u.s[3] ^ d3) >> 8);
    b0 = ((p->u.s[14] ^ d4) << 27) | ((p->u.s[14] ^ d4) >> 37);
    p->u.s[20] = b0 ^ (~ b1 & b2);
    p->u.s[6] = b1 ^ (~ b2 & b3);
    p->u.s[17] = b2 ^ (~ b3 & b4);
    p->u.s[3] = b3 ^ (~ b4 & b0);
    p->u.s[14] = b4 ^ (~ b0 & b1);
    b3 = ((p->u.s[10] ^ d0) << 41) | ((p->u.s[10] ^ d0) >> 23);
    b4 = ((p->u.s[21] ^ d1) << 2) | ((p->u.s[21] ^ d1) >> 62);
    b0 = ((p->u.s[7] ^ d2) << 62) | ((p->u.s[7] ^ d2) >> 2);
    b1 = ((p->u.s[18] ^ d3) << 55) | ((p->u.s[18] ^ d3) >> 9);
    b2 = ((p->u.s[4] ^ d4) << 39) | ((p->u.s[4] ^ d4) >> 25);
    p->u.s[10] = b0 ^ (~ b1 & b2);
    p->u.s[21] = b1 ^ (~ b2 & b3);
    p->u.s[7] = b2 ^ (~ b3 & b4);
    p->u.s[18] = b3 ^ (~ b4 & b0);
    p->u.s[4] = b4 ^ (~ b0 & b1);
    c0 = (((p->u.s[0] ^ p->u.s[15]) ^ p->u.s[5]) ^ p->u.s[20]) ^ p->u.s[10];
    c1 = (((p->u.s[11] ^ p->u.s[1]) ^ p->u.s[16]) ^ p->u.s[6]) ^ p->u.s[21];
    c2 = (((p->u.s[22] ^ p->u.s[12]) ^ p->u.s[2]) ^ p->u.s[17]) ^ p->u.s[7];
    c3 = (((p->u.s[8] ^ p->u.s[23]) ^ p->u.s[13]) ^ p->u.s[3]) ^ p->u.s[18];
    c4 = (((p->u.s[19] ^ p->u.s[9]) ^ p->u.s[24]) ^ p->u.s[14]) ^ p->u.s[4];
    d0 = c4 ^ ((c1 << 1) | (c1 >> 63));
    d1 = c0 ^ ((c2 << 1) | (c2 >> 63));
    d2 = c1 ^ ((c3 << 1) | (c3 >> 63));
    d3 = c2 ^ ((c4 << 1) | (c4 >> 63));
    d4 = c3 ^ ((c0 << 1) | (c0 >> 63));
    b0 = p->u.s[0] ^ d0;
    b1 = ((p->u.s[1] ^ d1) << 44) | ((p->u.s[1] ^ d1) >> 20);
    b2 = ((p->u.s[2] ^ d2) << 43) | ((p->u.s[2] ^ d2) >> 21);
    b3 = ((p->u.s[3] ^ d3) << 21) | ((p->u.s[3] ^ d3) >> 43);
    b4 = ((p->u.s[4] ^ d4) << 14) | ((p->u.s[4] ^ d4) >> 50);
    p->u.s[0] = b0 ^ (~ b1 & b2);
    p->u.s[0] ^= (unsigned long long )RC[i + 3];
    p->u.s[1] = b1 ^ (~ b2 & b3);
    p->u.s[2] = b2 ^ (~ b3 & b4);
    p->u.s[3] = b3 ^ (~ b4 & b0);
    p->u.s[4] = b4 ^ (~ b0 & b1);
    b2 = ((p->u.s[5] ^ d0) << 3) | ((p->u.s[5] ^ d0) >> 61);
    b3 = ((p->u.s[6] ^ d1) << 45) | ((p->u.s[6] ^ d1) >> 19);
    b4 = ((p->u.s[7] ^ d2) << 61) | ((p->u.s[7] ^ d2) >> 3);
    b0 = ((p->u.s[8] ^ d3) << 28) | ((p->u.s[8] ^ d3) >> 36);
    b1 = ((p->u.s[9] ^ d4) << 20) | ((p->u.s[9] ^ d4) >> 44);
    p->u.s[5] = b0 ^ (~ b1 & b2);
    p->u.s[6] = b1 ^ (~ b2 & b3);
    p->u.s[7] = b2 ^ (~ b3 & b4);
    p->u.s[8] = b3 ^ (~ b4 & b0);
    p->u.s[9] = b4 ^ (~ b0 & b1);
    b4 = ((p->u.s[10] ^ d0) << 18) | ((p->u.s[10] ^ d0) >> 46);
    b0 = ((p->u.s[11] ^ d1) << 1) | ((p->u.s[11] ^ d1) >> 63);
    b1 = ((p->u.s[12] ^ d2) << 6) | ((p->u.s[12] ^ d2) >> 58);
    b2 = ((p->u.s[13] ^ d3) << 25) | ((p->u.s[13] ^ d3) >> 39);
    b3 = ((p->u.s[14] ^ d4) << 8) | ((p->u.s[14] ^ d4) >> 56);
    p->u.s[10] = b0 ^ (~ b1 & b2);
    p->u.s[11] = b1 ^ (~ b2 & b3);
    p->u.s[12] = b2 ^ (~ b3 & b4);
    p->u.s[13] = b3 ^ (~ b4 & b0);
    p->u.s[14] = b4 ^ (~ b0 & b1);
    b1 = ((p->u.s[15] ^ d0) << 36) | ((p->u.s[15] ^ d0) >> 28);
    b2 = ((p->u.s[16] ^ d1) << 10) | ((p->u.s[16] ^ d1) >> 54);
    b3 = ((p->u.s[17] ^ d2) << 15) | ((p->u.s[17] ^ d2) >> 49);
    b4 = ((p->u.s[18] ^ d3) << 56) | ((p->u.s[18] ^ d3) >> 8);
    b0 = ((p->u.s[19] ^ d4) << 27) | ((p->u.s[19] ^ d4) >> 37);
    p->u.s[15] = b0 ^ (~ b1 & b2);
    p->u.s[16] = b1 ^ (~ b2 & b3);
    p->u.s[17] = b2 ^ (~ b3 & b4);
    p->u.s[18] = b3 ^ (~ b4 & b0);
    p->u.s[19] = b4 ^ (~ b0 & b1);
    b3 = ((p->u.s[20] ^ d0) << 41) | ((p->u.s[20] ^ d0) >> 23);
    b4 = ((p->u.s[21] ^ d1) << 2) | ((p->u.s[21] ^ d1) >> 62);
    b0 = ((p->u.s[22] ^ d2) << 62) | ((p->u.s[22] ^ d2) >> 2);
    b1 = ((p->u.s[23] ^ d3) << 55) | ((p->u.s[23] ^ d3) >> 9);
    b2 = ((p->u.s[24] ^ d4) << 39) | ((p->u.s[24] ^ d4) >> 25);
    p->u.s[20] = b0 ^ (~ b1 & b2);
    p->u.s[21] = b1 ^ (~ b2 & b3);
    p->u.s[22] = b2 ^ (~ b3 & b4);
    p->u.s[23] = b3 ^ (~ b4 & b0);
    p->u.s[24] = b4 ^ (~ b0 & b1);
    i += 4;
  }
  return;
}
}
static void SHA3Init(SHA3Context *p , int iSize ) 
{ 


  {
  memset((void *)p, 0, sizeof(*p));
  if (iSize >= 128) {
    if (iSize <= 512) {
      p->nRate = (unsigned int )((1600 - ((iSize + 31) & -32) * 2) / 8);
    } else {
      p->nRate = 136U;
    }
  } else {
    p->nRate = 136U;
  }
  return;
}
}
static void SHA3Update(SHA3Context *p , unsigned char const   *aData , unsigned int nData ) 
{ 
  unsigned int i ;

  {
  i = 0U;
  if (p->nLoaded % 8U == 0U) {
    if (((aData - (unsigned char const   *)0) & 7L) == 0L) {
      while (i + 7U < nData) {
        p->u.s[p->nLoaded / 8U] ^= *((u64 *)(aData + i));
        p->nLoaded += 8U;
        if (p->nLoaded >= p->nRate) {
          KeccakF1600Step(p);
          p->nLoaded = 0U;
        }
        i += 8U;
      }
    }
  }
  while (i < nData) {
    p->u.x[p->nLoaded] = (unsigned char )((int )p->u.x[p->nLoaded] ^ (int )*(aData + i));
    (p->nLoaded) ++;
    if (p->nLoaded == p->nRate) {
      KeccakF1600Step(p);
      p->nLoaded = 0U;
    }
    i ++;
  }
  return;
}
}
static unsigned char *SHA3Final(SHA3Context *p ) 
{ 
  unsigned int i ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;

  {
  if (p->nLoaded == p->nRate - 1U) {
    c1 = (unsigned char)134;
    SHA3Update(p, (unsigned char const   *)(& c1), 1U);
  } else {
    c2 = (unsigned char)6;
    c3 = (unsigned char)128;
    SHA3Update(p, (unsigned char const   *)(& c2), 1U);
    p->nLoaded = p->nRate - 1U;
    SHA3Update(p, (unsigned char const   *)(& c3), 1U);
  }
  i = 0U;
  while (i < p->nRate) {
    p->u.x[i + p->nRate] = p->u.x[i ^ p->ixMask];
    i ++;
  }
  return (& p->u.x[p->nRate]);
}
}
static void sha3Func(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  SHA3Context cx ;
  int eType ;
  int tmp ;
  int nByte ;
  int tmp___0 ;
  int iSize ;
  void const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char *tmp___3 ;

  {
  tmp = sqlite3_value_type(*(argv + 0));
  eType = tmp;
  tmp___0 = sqlite3_value_bytes(*(argv + 0));
  nByte = tmp___0;
  if (argc == 1) {
    iSize = 256;
  } else {
    iSize = sqlite3_value_int(*(argv + 1));
    if (iSize != 224) {
      if (iSize != 256) {
        if (iSize != 384) {
          if (iSize != 512) {
            sqlite3_result_error(context, "SHA3 size should be one of: 224 256 384 512",
                                 -1);
            return;
          }
        }
      }
    }
  }
  if (eType == 5) {
    return;
  }
  SHA3Init(& cx, iSize);
  if (eType == 4) {
    tmp___1 = sqlite3_value_blob(*(argv + 0));
    SHA3Update(& cx, (unsigned char const   *)tmp___1, (unsigned int )nByte);
  } else {
    tmp___2 = sqlite3_value_text(*(argv + 0));
    SHA3Update(& cx, tmp___2, (unsigned int )nByte);
  }
  tmp___3 = SHA3Final(& cx);
  sqlite3_result_blob(context, (void const   *)tmp___3, iSize / 8, (void (*)(void * ))-1);
  return;
}
}
static void hash_step_vformat(SHA3Context *p , char const   *zFormat  , ...) 
{ 
  va_list ap ;
  int n ;
  char zBuf[50] ;
  size_t tmp ;

  {
  __builtin_va_start(ap, zFormat);
  sqlite3_vsnprintf((int )sizeof(zBuf), zBuf, zFormat, ap);
  __builtin_va_end(ap);
  tmp = strlen((char const   *)(zBuf));
  n = (int )tmp;
  SHA3Update(p, (unsigned char const   *)((unsigned char *)(zBuf)), (unsigned int )n);
  return;
}
}
static void sha3QueryFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  char const   *zSql ;
  unsigned char const   *tmp___0 ;
  sqlite3_stmt *pStmt ;
  int nCol ;
  int i ;
  int rc ;
  int n ;
  char const   *z ;
  SHA3Context cx ;
  int iSize ;
  char *zMsg ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *zMsg___0 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  sqlite_uint64 u ;
  int j ;
  unsigned char x___0[9] ;
  sqlite_int64 v ;
  sqlite_int64 tmp___8 ;
  sqlite_uint64 u___0 ;
  int j___0 ;
  unsigned char x___1[9] ;
  double r ;
  double tmp___9 ;
  int n2 ;
  int tmp___10 ;
  unsigned char const   *z2 ;
  unsigned char const   *tmp___11 ;
  int n2___0 ;
  int tmp___12 ;
  unsigned char const   *z2___0 ;
  void const   *tmp___13 ;
  int tmp___14 ;
  unsigned char *tmp___15 ;

  {
  tmp = sqlite3_context_db_handle(context);
  db = tmp;
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zSql = (char const   *)tmp___0;
  pStmt = (sqlite3_stmt *)0;
  if (argc == 1) {
    iSize = 256;
  } else {
    iSize = sqlite3_value_int(*(argv + 1));
    if (iSize != 224) {
      if (iSize != 256) {
        if (iSize != 384) {
          if (iSize != 512) {
            sqlite3_result_error(context, "SHA3 size should be one of: 224 256 384 512",
                                 -1);
            return;
          }
        }
      }
    }
  }
  if ((unsigned long )zSql == (unsigned long )((char const   *)0)) {
    return;
  }
  SHA3Init(& cx, iSize);
  while (*(zSql + 0)) {
    rc = sqlite3_prepare_v2(db, zSql, -1, & pStmt, & zSql);
    if (rc) {
      tmp___1 = sqlite3_errmsg(db);
      tmp___2 = sqlite3_mprintf("error SQL statement [%s]: %s", zSql, tmp___1);
      zMsg = tmp___2;
      sqlite3_finalize(pStmt);
      sqlite3_result_error(context, (char const   *)zMsg, -1);
      sqlite3_free((void *)zMsg);
      return;
    }
    tmp___5 = sqlite3_stmt_readonly(pStmt);
    if (! tmp___5) {
      tmp___3 = sqlite3_sql(pStmt);
      tmp___4 = sqlite3_mprintf("non-query: [%s]", tmp___3);
      zMsg___0 = tmp___4;
      sqlite3_finalize(pStmt);
      sqlite3_result_error(context, (char const   *)zMsg___0, -1);
      sqlite3_free((void *)zMsg___0);
      return;
    }
    nCol = sqlite3_column_count(pStmt);
    z = sqlite3_sql(pStmt);
    tmp___6 = strlen(z);
    n = (int )tmp___6;
    hash_step_vformat(& cx, "S%d:", n);
    SHA3Update(& cx, (unsigned char const   *)((unsigned char *)z), (unsigned int )n);
    while (1) {
      tmp___14 = sqlite3_step(pStmt);
      if (! (100 == tmp___14)) {
        break;
      }
      SHA3Update(& cx, (unsigned char const   *)"R", 1U);
      i = 0;
      while (i < nCol) {
        tmp___7 = sqlite3_column_type(pStmt, i);
        switch (tmp___7) {
        case 5: 
        SHA3Update(& cx, (unsigned char const   *)"N", 1U);
        break;
        case 1: 
        tmp___8 = sqlite3_column_int64(pStmt, i);
        v = tmp___8;
        memcpy((void * __restrict  )(& u), (void const   * __restrict  )(& v), (size_t )8);
        j = 8;
        while (j >= 1) {
          x___0[j] = (unsigned char )(u & 255ULL);
          u >>= 8;
          j --;
        }
        x___0[0] = (unsigned char )'I';
        SHA3Update(& cx, (unsigned char const   *)(x___0), 9U);
        break;
        case 2: 
        tmp___9 = sqlite3_column_double(pStmt, i);
        r = tmp___9;
        memcpy((void * __restrict  )(& u___0), (void const   * __restrict  )(& r),
               (size_t )8);
        j___0 = 8;
        while (j___0 >= 1) {
          x___1[j___0] = (unsigned char )(u___0 & 255ULL);
          u___0 >>= 8;
          j___0 --;
        }
        x___1[0] = (unsigned char )'F';
        SHA3Update(& cx, (unsigned char const   *)(x___1), 9U);
        break;
        case 3: 
        tmp___10 = sqlite3_column_bytes(pStmt, i);
        n2 = tmp___10;
        tmp___11 = sqlite3_column_text(pStmt, i);
        z2 = tmp___11;
        hash_step_vformat(& cx, "T%d:", n2);
        SHA3Update(& cx, z2, (unsigned int )n2);
        break;
        case 4: 
        tmp___12 = sqlite3_column_bytes(pStmt, i);
        n2___0 = tmp___12;
        tmp___13 = sqlite3_column_blob(pStmt, i);
        z2___0 = (unsigned char const   *)tmp___13;
        hash_step_vformat(& cx, "B%d:", n2___0);
        SHA3Update(& cx, z2___0, (unsigned int )n2___0);
        break;
        }
        i ++;
      }
    }
    sqlite3_finalize(pStmt);
  }
  tmp___15 = SHA3Final(& cx);
  sqlite3_result_blob(context, (void const   *)tmp___15, iSize / 8, (void (*)(void * ))-1);
  return;
}
}
int sqlite3_shathree_init(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pApi ) 
{ 
  int rc ;

  {
  rc = 0;
  rc = sqlite3_create_function(db, "sha3", 1, 1, (void *)0, & sha3Func, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
                               (void (*)(sqlite3_context * ))0);
  if (rc == 0) {
    rc = sqlite3_create_function(db, "sha3", 2, 1, (void *)0, & sha3Func, (void (*)(sqlite3_context * ,
                                                                                    int  ,
                                                                                    sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  if (rc == 0) {
    rc = sqlite3_create_function(db, "sha3_query", 1, 1, (void *)0, & sha3QueryFunc,
                                 (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  if (rc == 0) {
    rc = sqlite3_create_function(db, "sha3_query", 2, 1, (void *)0, & sha3QueryFunc,
                                 (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  return (rc);
}
}
static void readFileContents(sqlite3_context *ctx , char const   *zName ) 
{ 
  FILE *in ;
  sqlite_int64 nIn ;
  void *pBuf ;
  sqlite3 *db ;
  int mxBlob ;
  long tmp ;
  sqlite_int64 tmp___0 ;
  size_t tmp___1 ;

  {
  in = fopen((char const   * __restrict  )zName, (char const   * __restrict  )"rb");
  if ((unsigned long )in == (unsigned long )((FILE *)0)) {
    return;
  }
  fseek(in, 0L, 2);
  tmp = ftell(in);
  nIn = (sqlite_int64 )tmp;
  rewind(in);
  db = sqlite3_context_db_handle(ctx);
  mxBlob = sqlite3_limit(db, 0, -1);
  if (nIn > (sqlite_int64 )mxBlob) {
    sqlite3_result_error_code(ctx, 18);
    fclose(in);
    return;
  }
  if (nIn) {
    tmp___0 = nIn;
  } else {
    tmp___0 = (sqlite_int64 )1;
  }
  pBuf = sqlite3_malloc64((sqlite_uint64 )tmp___0);
  if ((unsigned long )pBuf == (unsigned long )((void *)0)) {
    sqlite3_result_error_nomem(ctx);
    fclose(in);
    return;
  }
  tmp___1 = fread((void * __restrict  )pBuf, (size_t )1, (size_t )nIn, (FILE * __restrict  )in);
  if (nIn == (sqlite_int64 )tmp___1) {
    sqlite3_result_blob64(ctx, (void const   *)pBuf, (sqlite_uint64 )nIn, & sqlite3_free);
  } else {
    sqlite3_result_error_code(ctx, 10);
    sqlite3_free(pBuf);
  }
  fclose(in);
  return;
}
}
static void readfileFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zName ;
  unsigned char const   *tmp ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  zName = (char const   *)tmp;
  if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
    return;
  }
  readFileContents(context, zName);
  return;
}
}
static void ctxErrorMsg(sqlite3_context *ctx , char const   *zFmt  , ...) 
{ 
  char *zMsg ;
  va_list ap ;

  {
  zMsg = (char *)0;
  __builtin_va_start(ap, zFmt);
  zMsg = sqlite3_vmprintf(zFmt, ap);
  sqlite3_result_error(ctx, (char const   *)zMsg, -1);
  sqlite3_free((void *)zMsg);
  __builtin_va_end(ap);
  return;
}
}
static int fileStat(char const   *zPath , struct stat *pStatBuf ) 
{ 
  int tmp ;

  {
  tmp = stat((char const   * __restrict  )zPath, (struct stat * __restrict  )pStatBuf);
  return (tmp);
}
}
static int fileLinkStat(char const   *zPath , struct stat *pStatBuf ) 
{ 
  int tmp ;

  {
  tmp = lstat((char const   * __restrict  )zPath, (struct stat * __restrict  )pStatBuf);
  return (tmp);
}
}
static int makeDirectory(char const   *zFile ) 
{ 
  char *zCopy ;
  char *tmp ;
  int rc ;
  int nCopy ;
  size_t tmp___0 ;
  int i ;
  struct stat sStat ;
  int rc2 ;
  int tmp___1 ;

  {
  tmp = sqlite3_mprintf("%s", zFile);
  zCopy = tmp;
  rc = 0;
  if ((unsigned long )zCopy == (unsigned long )((char *)0)) {
    rc = 7;
  } else {
    tmp___0 = strlen((char const   *)zCopy);
    nCopy = (int )tmp___0;
    i = 1;
    while (rc == 0) {
      while (1) {
        if ((int )*(zCopy + i) != 47) {
          if (! (i < nCopy)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      if (i == nCopy) {
        break;
      }
      *(zCopy + i) = (char )'\000';
      rc2 = fileStat((char const   *)zCopy, & sStat);
      if (rc2 != 0) {
        tmp___1 = mkdir((char const   *)zCopy, (__mode_t )511);
        if (tmp___1) {
          rc = 1;
        }
      } else
      if (! ((sStat.st_mode & 61440U) == 16384U)) {
        rc = 1;
      }
      *(zCopy + i) = (char )'/';
      i ++;
    }
    sqlite3_free((void *)zCopy);
  }
  return (rc);
}
}
static int writeFile(sqlite3_context *pCtx , char const   *zFile , sqlite3_value *pData ,
                     mode_t mode , sqlite_int64 mtime ) 
{ 
  char const   *zTo ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  struct stat sStat ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  sqlite_int64 nWrite ;
  char const   *z ;
  int rc ;
  FILE *out ;
  FILE *tmp___5 ;
  void const   *tmp___6 ;
  sqlite_int64 n ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct timeval times[2] ;
  int tmp___11 ;

  {
  if ((mode & 61440U) == 40960U) {
    tmp = sqlite3_value_text(pData);
    zTo = (char const   *)tmp;
    tmp___0 = symlink(zTo, zFile);
    if (tmp___0 < 0) {
      return (1);
    }
  } else
  if ((mode & 61440U) == 16384U) {
    tmp___4 = mkdir(zFile, mode);
    if (tmp___4) {
      tmp___1 = __errno_location();
      if (*tmp___1 != 17) {
        return (1);
      } else {
        tmp___2 = fileStat(zFile, & sStat);
        if (0 != tmp___2) {
          return (1);
        } else
        if (! ((sStat.st_mode & 61440U) == 16384U)) {
          return (1);
        } else
        if ((sStat.st_mode & 511U) != (mode & 511U)) {
          tmp___3 = chmod(zFile, mode & 511U);
          if (0 != tmp___3) {
            return (1);
          }
        }
      }
    }
  } else {
    nWrite = (sqlite_int64 )0;
    rc = 0;
    tmp___5 = fopen((char const   * __restrict  )zFile, (char const   * __restrict  )"wb");
    out = tmp___5;
    if ((unsigned long )out == (unsigned long )((FILE *)0)) {
      return (1);
    }
    tmp___6 = sqlite3_value_blob(pData);
    z = (char const   *)tmp___6;
    if (z) {
      tmp___7 = sqlite3_value_bytes(pData);
      tmp___8 = fwrite((void const   * __restrict  )z, (size_t )1, (size_t )tmp___7,
                       (FILE * __restrict  )out);
      n = (sqlite_int64 )tmp___8;
      tmp___9 = sqlite3_value_bytes(pData);
      nWrite = (sqlite_int64 )tmp___9;
      if (nWrite != n) {
        rc = 1;
      }
    }
    fclose(out);
    if (rc == 0) {
      if (mode) {
        tmp___10 = chmod(zFile, mode & 511U);
        if (tmp___10) {
          rc = 1;
        }
      }
    }
    if (rc) {
      return (2);
    }
    sqlite3_result_int64(pCtx, nWrite);
  }
  if (mtime >= 0LL) {
    times[1].tv_usec = (__suseconds_t )0;
    times[0].tv_usec = times[1].tv_usec;
    times[0].tv_sec = time((time_t *)0);
    times[1].tv_sec = (__time_t )mtime;
    tmp___11 = utimes(zFile, (struct timeval  const  *)(times));
    if (tmp___11) {
      return (1);
    }
  }
  return (0);
}
}
static void writefileFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zFile ;
  mode_t mode ;
  int res ;
  sqlite_int64 mtime ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  mode = (mode_t )0;
  mtime = (sqlite_int64 )-1;
  if (argc < 2) {
    sqlite3_result_error(context, "wrong number of arguments to function writefile()",
                         -1);
    return;
  } else
  if (argc > 4) {
    sqlite3_result_error(context, "wrong number of arguments to function writefile()",
                         -1);
    return;
  }
  tmp = sqlite3_value_text(*(argv + 0));
  zFile = (char const   *)tmp;
  if ((unsigned long )zFile == (unsigned long )((char const   *)0)) {
    return;
  }
  if (argc >= 3) {
    tmp___0 = sqlite3_value_int(*(argv + 2));
    mode = (mode_t )tmp___0;
  }
  if (argc == 4) {
    mtime = sqlite3_value_int64(*(argv + 3));
  }
  res = writeFile(context, zFile, *(argv + 1), mode, mtime);
  if (res == 1) {
    tmp___2 = __errno_location();
    if (*tmp___2 == 2) {
      tmp___1 = makeDirectory(zFile);
      if (tmp___1 == 0) {
        res = writeFile(context, zFile, *(argv + 1), mode, mtime);
      }
    }
  }
  if (argc > 2) {
    if (res != 0) {
      if ((mode & 61440U) == 40960U) {
        ctxErrorMsg(context, "failed to create symlink: %s", zFile);
      } else
      if ((mode & 61440U) == 16384U) {
        ctxErrorMsg(context, "failed to create directory: %s", zFile);
      } else {
        ctxErrorMsg(context, "failed to write file: %s", zFile);
      }
    }
  }
  return;
}
}
static void lsModeFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  int i ;
  int iMode ;
  int tmp ;
  char z[16] ;
  int m ;
  char *a___0 ;

  {
  tmp = sqlite3_value_int(*(argv + 0));
  iMode = tmp;
  if ((iMode & 61440) == 40960) {
    z[0] = (char )'l';
  } else
  if ((iMode & 61440) == 32768) {
    z[0] = (char )'-';
  } else
  if ((iMode & 61440) == 16384) {
    z[0] = (char )'d';
  } else {
    z[0] = (char )'?';
  }
  i = 0;
  while (i < 3) {
    m = iMode >> (2 - i) * 3;
    a___0 = & z[1 + i * 3];
    if (m & 4) {
      *(a___0 + 0) = (char )'r';
    } else {
      *(a___0 + 0) = (char )'-';
    }
    if (m & 2) {
      *(a___0 + 1) = (char )'w';
    } else {
      *(a___0 + 1) = (char )'-';
    }
    if (m & 1) {
      *(a___0 + 2) = (char )'x';
    } else {
      *(a___0 + 2) = (char )'-';
    }
    i ++;
  }
  z[10] = (char )'\000';
  sqlite3_result_text(context, (char const   *)(z), -1, (void (*)(void * ))-1);
  return;
}
}
static int fsdirConnect(sqlite3 *db , void *pAux , int argc , char const   * const  *argv ,
                        sqlite3_vtab **ppVtab , char **pzErr ) 
{ 
  fsdir_tab *pNew ;
  int rc ;
  void *tmp ;

  {
  pNew = (fsdir_tab *)0;
  rc = sqlite3_declare_vtab(db, "CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)");
  if (rc == 0) {
    tmp = sqlite3_malloc((int )sizeof(*pNew));
    pNew = (fsdir_tab *)tmp;
    if ((unsigned long )pNew == (unsigned long )((fsdir_tab *)0)) {
      return (7);
    }
    memset((void *)pNew, 0, sizeof(*pNew));
  }
  *ppVtab = (sqlite3_vtab *)pNew;
  return (rc);
}
}
static int fsdirDisconnect(sqlite3_vtab *pVtab ) 
{ 


  {
  sqlite3_free((void *)pVtab);
  return (0);
}
}
static int fsdirOpen(sqlite3_vtab *p , sqlite3_vtab_cursor **ppCursor ) 
{ 
  fsdir_cursor *pCur ;
  void *tmp ;

  {
  tmp = sqlite3_malloc((int )sizeof(*pCur));
  pCur = (fsdir_cursor *)tmp;
  if ((unsigned long )pCur == (unsigned long )((fsdir_cursor *)0)) {
    return (7);
  }
  memset((void *)pCur, 0, sizeof(*pCur));
  pCur->iLvl = -1;
  *ppCursor = & pCur->base;
  return (0);
}
}
static void fsdirResetCursor(fsdir_cursor *pCur ) 
{ 
  int i ;
  FsdirLevel *pLvl ;

  {
  i = 0;
  while (i <= pCur->iLvl) {
    pLvl = pCur->aLvl + i;
    if (pLvl->pDir) {
      closedir(pLvl->pDir);
    }
    sqlite3_free((void *)pLvl->zDir);
    i ++;
  }
  sqlite3_free((void *)pCur->zPath);
  sqlite3_free((void *)pCur->aLvl);
  pCur->aLvl = (FsdirLevel *)0;
  pCur->zPath = (char *)0;
  pCur->zBase = (char const   *)0;
  pCur->nBase = 0;
  pCur->nLvl = 0;
  pCur->iLvl = -1;
  pCur->iRowid = (sqlite_int64 )1;
  return;
}
}
static int fsdirClose(sqlite3_vtab_cursor *cur ) 
{ 
  fsdir_cursor *pCur ;

  {
  pCur = (fsdir_cursor *)cur;
  fsdirResetCursor(pCur);
  sqlite3_free((void *)pCur);
  return (0);
}
}
static void fsdirSetErrmsg(fsdir_cursor *pCur , char const   *zFmt  , ...) 
{ 
  va_list ap ;

  {
  __builtin_va_start(ap, zFmt);
  (pCur->base.pVtab)->zErrMsg = sqlite3_vmprintf(zFmt, ap);
  __builtin_va_end(ap);
  return;
}
}
static int fsdirNext(sqlite3_vtab_cursor *cur ) 
{ 
  fsdir_cursor *pCur ;
  mode_t m ;
  int iNew ;
  FsdirLevel *pLvl ;
  int nNew ;
  sqlite_int64 nByte ;
  FsdirLevel *aNew ;
  void *tmp ;
  FsdirLevel *pLvl___0 ;
  struct dirent *pEntry ;
  struct dirent *tmp___0 ;
  int tmp___1 ;

  {
  pCur = (fsdir_cursor *)cur;
  m = pCur->sStat.st_mode;
  (pCur->iRowid) ++;
  if ((m & 61440U) == 16384U) {
    iNew = pCur->iLvl + 1;
    if (iNew >= pCur->nLvl) {
      nNew = iNew + 1;
      nByte = (sqlite_int64 )((unsigned long )nNew * sizeof(FsdirLevel ));
      tmp = sqlite3_realloc64((void *)pCur->aLvl, (sqlite_uint64 )nByte);
      aNew = (FsdirLevel *)tmp;
      if ((unsigned long )aNew == (unsigned long )((FsdirLevel *)0)) {
        return (7);
      }
      memset((void *)(aNew + pCur->nLvl), 0, sizeof(FsdirLevel ) * (unsigned long )(nNew - pCur->nLvl));
      pCur->aLvl = aNew;
      pCur->nLvl = nNew;
    }
    pCur->iLvl = iNew;
    pLvl = pCur->aLvl + iNew;
    pLvl->zDir = pCur->zPath;
    pCur->zPath = (char *)0;
    pLvl->pDir = opendir((char const   *)pLvl->zDir);
    if ((unsigned long )pLvl->pDir == (unsigned long )((DIR *)0)) {
      fsdirSetErrmsg(pCur, "cannot read directory: %s", pCur->zPath);
      return (1);
    }
  }
  while (pCur->iLvl >= 0) {
    pLvl___0 = pCur->aLvl + pCur->iLvl;
    tmp___0 = readdir(pLvl___0->pDir);
    pEntry = tmp___0;
    if (pEntry) {
      if ((int )pEntry->d_name[0] == 46) {
        if ((int )pEntry->d_name[1] == 46) {
          if ((int )pEntry->d_name[2] == 0) {
            continue;
          }
        }
        if ((int )pEntry->d_name[1] == 0) {
          continue;
        }
      }
      sqlite3_free((void *)pCur->zPath);
      pCur->zPath = sqlite3_mprintf("%s/%s", pLvl___0->zDir, pEntry->d_name);
      if ((unsigned long )pCur->zPath == (unsigned long )((char *)0)) {
        return (7);
      }
      tmp___1 = fileLinkStat((char const   *)pCur->zPath, & pCur->sStat);
      if (tmp___1) {
        fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
        return (1);
      }
      return (0);
    }
    closedir(pLvl___0->pDir);
    sqlite3_free((void *)pLvl___0->zDir);
    pLvl___0->pDir = (DIR *)0;
    pLvl___0->zDir = (char *)0;
    (pCur->iLvl) --;
  }
  sqlite3_free((void *)pCur->zPath);
  pCur->zPath = (char *)0;
  return (0);
}
}
static int fsdirColumn(sqlite3_vtab_cursor *cur , sqlite3_context *ctx , int i ) 
{ 
  fsdir_cursor *pCur ;
  mode_t m ;
  char aStatic[64] ;
  char *aBuf ;
  sqlite_int64 nBuf ;
  int n ;
  ssize_t tmp ;
  void *tmp___0 ;

  {
  pCur = (fsdir_cursor *)cur;
  switch (i) {
  case 0: 
  sqlite3_result_text(ctx, (char const   *)(pCur->zPath + pCur->nBase), -1, (void (*)(void * ))-1);
  break;
  case 1: 
  sqlite3_result_int64(ctx, (sqlite_int64 )pCur->sStat.st_mode);
  break;
  case 2: 
  sqlite3_result_int64(ctx, (sqlite_int64 )pCur->sStat.st_mtim.tv_sec);
  break;
  case 3: 
  m = pCur->sStat.st_mode;
  if ((m & 61440U) == 16384U) {
    sqlite3_result_null(ctx);
  } else
  if ((m & 61440U) == 40960U) {
    aBuf = aStatic;
    nBuf = (sqlite_int64 )64;
    while (1) {
      tmp = readlink((char const   * __restrict  )pCur->zPath, (char * __restrict  )aBuf,
                     (size_t )nBuf);
      n = (int )tmp;
      if ((sqlite_int64 )n < nBuf) {
        break;
      }
      if ((unsigned long )aBuf != (unsigned long )(aStatic)) {
        sqlite3_free((void *)aBuf);
      }
      nBuf *= 2LL;
      tmp___0 = sqlite3_malloc64((sqlite_uint64 )nBuf);
      aBuf = (char *)tmp___0;
      if ((unsigned long )aBuf == (unsigned long )((char *)0)) {
        sqlite3_result_error_nomem(ctx);
        return (7);
      }
    }
    sqlite3_result_text(ctx, (char const   *)aBuf, n, (void (*)(void * ))-1);
    if ((unsigned long )aBuf != (unsigned long )(aStatic)) {
      sqlite3_free((void *)aBuf);
    }
  } else {
    readFileContents(ctx, (char const   *)pCur->zPath);
  }
  default: 
  break;
  }
  return (0);
}
}
static int fsdirRowid(sqlite3_vtab_cursor *cur , sqlite_int64 *pRowid ) 
{ 
  fsdir_cursor *pCur ;

  {
  pCur = (fsdir_cursor *)cur;
  *pRowid = pCur->iRowid;
  return (0);
}
}
static int fsdirEof(sqlite3_vtab_cursor *cur ) 
{ 
  fsdir_cursor *pCur ;

  {
  pCur = (fsdir_cursor *)cur;
  return ((unsigned long )pCur->zPath == (unsigned long )((char *)0));
}
}
static int fsdirFilter(sqlite3_vtab_cursor *cur , int idxNum , char const   *idxStr ,
                       int argc , sqlite3_value **argv ) 
{ 
  char const   *zDir ;
  fsdir_cursor *pCur ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  zDir = (char const   *)0;
  pCur = (fsdir_cursor *)cur;
  fsdirResetCursor(pCur);
  if (idxNum == 0) {
    fsdirSetErrmsg(pCur, "table function fsdir requires an argument");
    return (1);
  }
  if (argc == idxNum) {
    if (! (argc == 1)) {
      if (! (argc == 2)) {
        __assert_fail("argc==idxNum && (argc==1 || argc==2)", "shell.c", 2856U, "fsdirFilter");
      }
    }
  } else {
    __assert_fail("argc==idxNum && (argc==1 || argc==2)", "shell.c", 2856U, "fsdirFilter");
  }
  tmp___0 = sqlite3_value_text(*(argv + 0));
  zDir = (char const   *)tmp___0;
  if ((unsigned long )zDir == (unsigned long )((char const   *)0)) {
    fsdirSetErrmsg(pCur, "table function fsdir requires a non-NULL argument");
    return (1);
  }
  if (argc == 2) {
    tmp___1 = sqlite3_value_text(*(argv + 1));
    pCur->zBase = (char const   *)tmp___1;
  }
  if (pCur->zBase) {
    tmp___2 = strlen(pCur->zBase);
    pCur->nBase = (int )tmp___2 + 1;
    pCur->zPath = sqlite3_mprintf("%s/%s", pCur->zBase, zDir);
  } else {
    pCur->zPath = sqlite3_mprintf("%s", zDir);
  }
  if ((unsigned long )pCur->zPath == (unsigned long )((char *)0)) {
    return (7);
  }
  tmp___3 = fileLinkStat((char const   *)pCur->zPath, & pCur->sStat);
  if (tmp___3) {
    fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
    return (1);
  }
  return (0);
}
}
static int fsdirBestIndex(sqlite3_vtab *tab , sqlite3_index_info *pIdxInfo ) 
{ 
  int i ;
  int idxPath ;
  int idxDir ;
  int seenPath ;
  int seenDir ;
  struct sqlite3_index_constraint  const  *pConstraint ;

  {
  idxPath = -1;
  idxDir = -1;
  seenPath = 0;
  seenDir = 0;
  pConstraint = (struct sqlite3_index_constraint  const  *)pIdxInfo->aConstraint;
  i = 0;
  while (i < pIdxInfo->nConstraint) {
    if ((int const   )pConstraint->op != 2) {
      goto __Cont;
    }
    switch (pConstraint->iColumn) {
    case 4: 
    if (pConstraint->usable) {
      idxPath = i;
      seenPath = 0;
    } else
    if (idxPath < 0) {
      seenPath = 1;
    }
    break;
    case 5: 
    if (pConstraint->usable) {
      idxDir = i;
      seenDir = 0;
    } else
    if (idxDir < 0) {
      seenDir = 1;
    }
    break;
    }
    __Cont: /* CIL Label */ 
    i ++;
    pConstraint ++;
  }
  if (seenPath) {
    return (19);
  } else
  if (seenDir) {
    return (19);
  }
  if (idxPath < 0) {
    pIdxInfo->idxNum = 0;
    pIdxInfo->estimatedRows = (sqlite_int64 )2147483647;
  } else {
    (pIdxInfo->aConstraintUsage + idxPath)->omit = (unsigned char)1;
    (pIdxInfo->aConstraintUsage + idxPath)->argvIndex = 1;
    if (idxDir >= 0) {
      (pIdxInfo->aConstraintUsage + idxDir)->omit = (unsigned char)1;
      (pIdxInfo->aConstraintUsage + idxDir)->argvIndex = 2;
      pIdxInfo->idxNum = 2;
      pIdxInfo->estimatedCost = 10.0;
    } else {
      pIdxInfo->idxNum = 1;
      pIdxInfo->estimatedCost = 100.0;
    }
  }
  return (0);
}
}
static int fsdirRegister(sqlite3 *db ) ;
static sqlite3_module fsdirModule  = 
     {0, (int (*)(sqlite3 * , void *pAux , int argc , char const   * const  *argv ,
                sqlite3_vtab **ppVTab , char ** ))0, & fsdirConnect, & fsdirBestIndex,
    & fsdirDisconnect, (int (*)(sqlite3_vtab *pVTab ))0, & fsdirOpen, & fsdirClose,
    & fsdirFilter, & fsdirNext, & fsdirEof, & fsdirColumn, & fsdirRowid, (int (*)(sqlite3_vtab * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ,
                                                                                  sqlite_int64 * ))0,
    (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0,
    (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVtab , int nArg , char const   *zName ,
                                               void (**pxFunc)(sqlite3_context * ,
                                                               int  , sqlite3_value ** ) ,
                                               void **ppArg ))0, (int (*)(sqlite3_vtab *pVtab ,
                                                                          char const   *zNew ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(sqlite3_vtab *pVTab , int  ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(char const   * ))0};
static int fsdirRegister(sqlite3 *db ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_create_module(db, "fsdir", (sqlite3_module const   *)(& fsdirModule),
                              (void *)0);
  rc = tmp;
  return (rc);
}
}
int sqlite3_fileio_init(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pApi ) 
{ 
  int rc ;

  {
  rc = 0;
  rc = sqlite3_create_function(db, "readfile", 1, 1, (void *)0, & readfileFunc, (void (*)(sqlite3_context * ,
                                                                                          int  ,
                                                                                          sqlite3_value ** ))0,
                               (void (*)(sqlite3_context * ))0);
  if (rc == 0) {
    rc = sqlite3_create_function(db, "writefile", -1, 1, (void *)0, & writefileFunc,
                                 (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  if (rc == 0) {
    rc = sqlite3_create_function(db, "lsmode", 1, 1, (void *)0, & lsModeFunc, (void (*)(sqlite3_context * ,
                                                                                        int  ,
                                                                                        sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  if (rc == 0) {
    rc = fsdirRegister(db);
  }
  return (rc);
}
}
static int completionConnect(sqlite3 *db , void *pAux , int argc , char const   * const  *argv ,
                             sqlite3_vtab **ppVtab , char **pzErr ) 
{ 
  completion_vtab *pNew ;
  int rc ;
  void *tmp ;

  {
  rc = sqlite3_declare_vtab(db, "CREATE TABLE x(  candidate TEXT,  prefix TEXT HIDDEN,  wholeline TEXT HIDDEN,  phase INT HIDDEN)");
  if (rc == 0) {
    tmp = sqlite3_malloc((int )sizeof(*pNew));
    pNew = (completion_vtab *)tmp;
    *ppVtab = (sqlite3_vtab *)pNew;
    if ((unsigned long )pNew == (unsigned long )((completion_vtab *)0)) {
      return (7);
    }
    memset((void *)pNew, 0, sizeof(*pNew));
    pNew->db = db;
  }
  return (rc);
}
}
static int completionDisconnect(sqlite3_vtab *pVtab ) 
{ 


  {
  sqlite3_free((void *)pVtab);
  return (0);
}
}
static int completionOpen(sqlite3_vtab *p , sqlite3_vtab_cursor **ppCursor ) 
{ 
  completion_cursor *pCur ;
  void *tmp ;

  {
  tmp = sqlite3_malloc((int )sizeof(*pCur));
  pCur = (completion_cursor *)tmp;
  if ((unsigned long )pCur == (unsigned long )((completion_cursor *)0)) {
    return (7);
  }
  memset((void *)pCur, 0, sizeof(*pCur));
  pCur->db = ((completion_vtab *)p)->db;
  *ppCursor = & pCur->base;
  return (0);
}
}
static void completionCursorReset(completion_cursor *pCur ) 
{ 


  {
  sqlite3_free((void *)pCur->zPrefix);
  pCur->zPrefix = (char *)0;
  pCur->nPrefix = 0;
  sqlite3_free((void *)pCur->zLine);
  pCur->zLine = (char *)0;
  pCur->nLine = 0;
  sqlite3_finalize(pCur->pStmt);
  pCur->pStmt = (sqlite3_stmt *)0;
  pCur->j = 0;
  return;
}
}
static int completionClose(sqlite3_vtab_cursor *cur ) 
{ 


  {
  completionCursorReset((completion_cursor *)cur);
  sqlite3_free((void *)cur);
  return (0);
}
}
static int completionNext(sqlite3_vtab_cursor *cur ) 
{ 
  completion_cursor *pCur ;
  int eNextPhase ;
  int iCol ;
  int tmp ;
  int tmp___0 ;
  sqlite3_stmt *pS2 ;
  char *zSql ;
  char const   *zSep ;
  char const   *zDb ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  sqlite3_stmt *pS2___0 ;
  char *zSql___0 ;
  char const   *zSep___0 ;
  char const   *zDb___0 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  unsigned char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  pCur = (completion_cursor *)cur;
  eNextPhase = 0;
  iCol = -1;
  (pCur->iRowid) ++;
  while (pCur->ePhase != 11) {
    switch (pCur->ePhase) {
    case 1: 
    tmp___0 = sqlite3_keyword_count();
    if (pCur->j >= tmp___0) {
      pCur->zCurrentRow = (char const   *)0;
      pCur->ePhase = 7;
    } else {
      tmp = pCur->j;
      (pCur->j) ++;
      sqlite3_keyword_name(tmp, & pCur->zCurrentRow, & pCur->szRow);
    }
    iCol = -1;
    break;
    case 7: 
    if ((unsigned long )pCur->pStmt == (unsigned long )((sqlite3_stmt *)0)) {
      sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, & pCur->pStmt, (char const   **)0);
    }
    iCol = 1;
    eNextPhase = 8;
    break;
    case 8: 
    if ((unsigned long )pCur->pStmt == (unsigned long )((sqlite3_stmt *)0)) {
      zSql = (char *)0;
      zSep = "";
      sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, & pS2, (char const   **)0);
      while (1) {
        tmp___2 = sqlite3_step(pS2);
        if (! (tmp___2 == 100)) {
          break;
        }
        tmp___1 = sqlite3_column_text(pS2, 1);
        zDb = (char const   *)tmp___1;
        zSql = sqlite3_mprintf("%z%sSELECT name FROM \"%w\".sqlite_master", zSql,
                               zSep, zDb);
        if ((unsigned long )zSql == (unsigned long )((char *)0)) {
          return (7);
        }
        zSep = " UNION ";
      }
      sqlite3_finalize(pS2);
      sqlite3_prepare_v2(pCur->db, (char const   *)zSql, -1, & pCur->pStmt, (char const   **)0);
      sqlite3_free((void *)zSql);
    }
    iCol = 0;
    eNextPhase = 9;
    break;
    case 9: 
    if ((unsigned long )pCur->pStmt == (unsigned long )((sqlite3_stmt *)0)) {
      zSql___0 = (char *)0;
      zSep___0 = "";
      sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, & pS2___0, (char const   **)0);
      while (1) {
        tmp___4 = sqlite3_step(pS2___0);
        if (! (tmp___4 == 100)) {
          break;
        }
        tmp___3 = sqlite3_column_text(pS2___0, 1);
        zDb___0 = (char const   *)tmp___3;
        zSql___0 = sqlite3_mprintf("%z%sSELECT pti.name FROM \"%w\".sqlite_master AS sm JOIN pragma_table_info(sm.name,%Q) AS pti WHERE sm.type=\'table\'",
                                   zSql___0, zSep___0, zDb___0, zDb___0);
        if ((unsigned long )zSql___0 == (unsigned long )((char *)0)) {
          return (7);
        }
        zSep___0 = " UNION ";
      }
      sqlite3_finalize(pS2___0);
      sqlite3_prepare_v2(pCur->db, (char const   *)zSql___0, -1, & pCur->pStmt, (char const   **)0);
      sqlite3_free((void *)zSql___0);
    }
    iCol = 0;
    eNextPhase = 11;
    break;
    }
    if (iCol < 0) {
      if ((unsigned long )pCur->zCurrentRow == (unsigned long )((char const   *)0)) {
        continue;
      }
    } else {
      tmp___6 = sqlite3_step(pCur->pStmt);
      if (tmp___6 == 100) {
        tmp___5 = sqlite3_column_text(pCur->pStmt, iCol);
        pCur->zCurrentRow = (char const   *)tmp___5;
        pCur->szRow = sqlite3_column_bytes(pCur->pStmt, iCol);
      } else {
        sqlite3_finalize(pCur->pStmt);
        pCur->pStmt = (sqlite3_stmt *)0;
        pCur->ePhase = eNextPhase;
        continue;
      }
    }
    if (pCur->nPrefix == 0) {
      break;
    }
    if (pCur->nPrefix <= pCur->szRow) {
      tmp___7 = sqlite3_strnicmp((char const   *)pCur->zPrefix, pCur->zCurrentRow,
                                 pCur->nPrefix);
      if (tmp___7 == 0) {
        break;
      }
    }
  }
  return (0);
}
}
static int completionColumn(sqlite3_vtab_cursor *cur , sqlite3_context *ctx , int i ) 
{ 
  completion_cursor *pCur ;

  {
  pCur = (completion_cursor *)cur;
  switch (i) {
  case 0: 
  sqlite3_result_text(ctx, pCur->zCurrentRow, pCur->szRow, (void (*)(void * ))-1);
  break;
  case 1: 
  sqlite3_result_text(ctx, (char const   *)pCur->zPrefix, -1, (void (*)(void * ))-1);
  break;
  case 2: 
  sqlite3_result_text(ctx, (char const   *)pCur->zLine, -1, (void (*)(void * ))-1);
  break;
  case 3: 
  sqlite3_result_int(ctx, pCur->ePhase);
  break;
  }
  return (0);
}
}
static int completionRowid(sqlite3_vtab_cursor *cur , sqlite_int64 *pRowid ) 
{ 
  completion_cursor *pCur ;

  {
  pCur = (completion_cursor *)cur;
  *pRowid = pCur->iRowid;
  return (0);
}
}
static int completionEof(sqlite3_vtab_cursor *cur ) 
{ 
  completion_cursor *pCur ;

  {
  pCur = (completion_cursor *)cur;
  return (pCur->ePhase >= 11);
}
}
static int completionFilter(sqlite3_vtab_cursor *pVtabCursor , int idxNum , char const   *idxStr ,
                            int argc , sqlite3_value **argv ) 
{ 
  completion_cursor *pCur ;
  int iArg ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int i ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  pCur = (completion_cursor *)pVtabCursor;
  iArg = 0;
  completionCursorReset(pCur);
  if (idxNum & 1) {
    pCur->nPrefix = sqlite3_value_bytes(*(argv + iArg));
    if (pCur->nPrefix > 0) {
      tmp = sqlite3_value_text(*(argv + iArg));
      pCur->zPrefix = sqlite3_mprintf("%s", tmp);
      if ((unsigned long )pCur->zPrefix == (unsigned long )((char *)0)) {
        return (7);
      }
    }
    iArg = 1;
  }
  if (idxNum & 2) {
    pCur->nLine = sqlite3_value_bytes(*(argv + iArg));
    if (pCur->nLine > 0) {
      tmp___0 = sqlite3_value_text(*(argv + iArg));
      pCur->zLine = sqlite3_mprintf("%s", tmp___0);
      if ((unsigned long )pCur->zLine == (unsigned long )((char *)0)) {
        return (7);
      }
    }
  }
  if ((unsigned long )pCur->zLine != (unsigned long )((char *)0)) {
    if ((unsigned long )pCur->zPrefix == (unsigned long )((char *)0)) {
      i = pCur->nLine;
      while (1) {
        if (i > 0) {
          tmp___1 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___1 + (int )*(pCur->zLine + (i - 1))) & 8)) {
            if (! ((int )*(pCur->zLine + (i - 1)) == 95)) {
              break;
            }
          }
        } else {
          break;
        }
        i --;
      }
      pCur->nPrefix = pCur->nLine - i;
      if (pCur->nPrefix > 0) {
        pCur->zPrefix = sqlite3_mprintf("%.*s", pCur->nPrefix, pCur->zLine + i);
        if ((unsigned long )pCur->zPrefix == (unsigned long )((char *)0)) {
          return (7);
        }
      }
    }
  }
  pCur->iRowid = (sqlite_int64 )0;
  pCur->ePhase = 1;
  tmp___2 = completionNext(pVtabCursor);
  return (tmp___2);
}
}
static int completionBestIndex(sqlite3_vtab *tab , sqlite3_index_info *pIdxInfo ) 
{ 
  int i ;
  int idxNum ;
  int prefixIdx ;
  int wholelineIdx ;
  int nArg ;
  struct sqlite3_index_constraint  const  *pConstraint ;

  {
  idxNum = 0;
  prefixIdx = -1;
  wholelineIdx = -1;
  nArg = 0;
  pConstraint = (struct sqlite3_index_constraint  const  *)pIdxInfo->aConstraint;
  i = 0;
  while (i < pIdxInfo->nConstraint) {
    if ((int const   )pConstraint->usable == 0) {
      goto __Cont;
    }
    if ((int const   )pConstraint->op != 2) {
      goto __Cont;
    }
    switch (pConstraint->iColumn) {
    case 1: 
    prefixIdx = i;
    idxNum |= 1;
    break;
    case 2: 
    wholelineIdx = i;
    idxNum |= 2;
    break;
    }
    __Cont: /* CIL Label */ 
    i ++;
    pConstraint ++;
  }
  if (prefixIdx >= 0) {
    nArg ++;
    (pIdxInfo->aConstraintUsage + prefixIdx)->argvIndex = nArg;
    (pIdxInfo->aConstraintUsage + prefixIdx)->omit = (unsigned char)1;
  }
  if (wholelineIdx >= 0) {
    nArg ++;
    (pIdxInfo->aConstraintUsage + wholelineIdx)->argvIndex = nArg;
    (pIdxInfo->aConstraintUsage + wholelineIdx)->omit = (unsigned char)1;
  }
  pIdxInfo->idxNum = idxNum;
  pIdxInfo->estimatedCost = (double )5000 - (double )(1000 * nArg);
  pIdxInfo->estimatedRows = (sqlite_int64 )(500 - 100 * nArg);
  return (0);
}
}
static sqlite3_module completionModule  = 
     {0, (int (*)(sqlite3 * , void *pAux , int argc , char const   * const  *argv ,
                sqlite3_vtab **ppVTab , char ** ))0, & completionConnect, & completionBestIndex,
    & completionDisconnect, (int (*)(sqlite3_vtab *pVTab ))0, & completionOpen, & completionClose,
    & completionFilter, & completionNext, & completionEof, & completionColumn, & completionRowid,
    (int (*)(sqlite3_vtab * , int  , sqlite3_value ** , sqlite_int64 * ))0, (int (*)(sqlite3_vtab *pVTab ))0,
    (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0,
    (int (*)(sqlite3_vtab *pVtab , int nArg , char const   *zName , void (**pxFunc)(sqlite3_context * ,
                                                                                    int  ,
                                                                                    sqlite3_value ** ) ,
             void **ppArg ))0, (int (*)(sqlite3_vtab *pVtab , char const   *zNew ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(sqlite3_vtab *pVTab , int  ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(char const   * ))0};
int sqlite3CompletionVtabInit(sqlite3 *db ) 
{ 
  int rc ;

  {
  rc = 0;
  rc = sqlite3_create_module(db, "completion", (sqlite3_module const   *)(& completionModule),
                             (void *)0);
  return (rc);
}
}
int sqlite3_completion_init(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pApi ) 
{ 
  int rc ;

  {
  rc = 0;
  rc = sqlite3CompletionVtabInit(db);
  return (rc);
}
}
static int apndClose(sqlite3_file *pFile ) ;
static int apndRead(sqlite3_file *pFile , void *zBuf , int iAmt , long long iOfst ) ;
static int apndWrite(sqlite3_file *pFile , void const   *zBuf , int iAmt , long long iOfst ) ;
static int apndTruncate(sqlite3_file *pFile , long long size ) ;
static int apndSync(sqlite3_file *pFile , int flags___0 ) ;
static int apndFileSize(sqlite3_file *pFile , long long *pSize ) ;
static int apndLock(sqlite3_file *pFile , int eLock ) ;
static int apndUnlock(sqlite3_file *pFile , int eLock ) ;
static int apndCheckReservedLock(sqlite3_file *pFile , int *pResOut ) ;
static int apndFileControl(sqlite3_file *pFile , int op , void *pArg ) ;
static int apndSectorSize(sqlite3_file *pFile ) ;
static int apndDeviceCharacteristics(sqlite3_file *pFile ) ;
static int apndShmMap(sqlite3_file *pFile , int iPg , int pgsz___0 , int bExtend ,
                      void volatile   **pp ) ;
static int apndShmLock(sqlite3_file *pFile , int offset , int n , int flags___0 ) ;
static void apndShmBarrier(sqlite3_file *pFile ) ;
static int apndShmUnmap(sqlite3_file *pFile , int deleteFlag ) ;
static int apndFetch(sqlite3_file *pFile , sqlite_int64 iOfst , int iAmt , void **pp ) ;
static int apndUnfetch(sqlite3_file *pFile , sqlite_int64 iOfst , void *pPage ) ;
static int apndOpen(sqlite3_vfs *pVfs , char const   *zName , sqlite3_file *pFile ,
                    int flags___0 , int *pOutFlags ) ;
static int apndDelete(sqlite3_vfs *pVfs , char const   *zPath , int dirSync ) ;
static int apndAccess(sqlite3_vfs *pVfs , char const   *zPath , int flags___0 , int *pResOut ) ;
static int apndFullPathname(sqlite3_vfs *pVfs , char const   *zPath , int nOut , char *zOut ) ;
static void *apndDlOpen(sqlite3_vfs *pVfs , char const   *zPath ) ;
static void apndDlError(sqlite3_vfs *pVfs , int nByte , char *zErrMsg ) ;
static void (*apndDlSym(sqlite3_vfs *pVfs , void *p , char const   *zSym ))(void) ;
static void apndDlClose(sqlite3_vfs *pVfs , void *pHandle ) ;
static int apndRandomness(sqlite3_vfs *pVfs , int nByte , char *zBufOut ) ;
static int apndSleep(sqlite3_vfs *pVfs , int nMicro ) ;
static int apndCurrentTime(sqlite3_vfs *pVfs , double *pTimeOut ) ;
static int apndGetLastError(sqlite3_vfs *pVfs , int a___0 , char *b ) ;
static int apndCurrentTimeInt64(sqlite3_vfs *pVfs , sqlite_int64 *p ) ;
static int apndSetSystemCall(sqlite3_vfs *pVfs , char const   *zName , void (*pCall)(void) ) ;
static sqlite3_syscall_ptr apndGetSystemCall(sqlite3_vfs *pVfs , char const   *zName ) ;
static char const   *apndNextSystemCall(sqlite3_vfs *pVfs , char const   *zName ) ;
static sqlite3_vfs apnd_vfs  = 
     {3, 0, 1024, (sqlite3_vfs *)0, "apndvfs", (void *)0, & apndOpen, & apndDelete,
    & apndAccess, & apndFullPathname, & apndDlOpen, & apndDlError, & apndDlSym, & apndDlClose,
    & apndRandomness, & apndSleep, & apndCurrentTime, & apndGetLastError, & apndCurrentTimeInt64,
    & apndSetSystemCall, & apndGetSystemCall, & apndNextSystemCall};
static struct sqlite3_io_methods  const  apnd_io_methods  = 
     {3, & apndClose, & apndRead, & apndWrite, & apndTruncate, & apndSync, & apndFileSize,
    & apndLock, & apndUnlock, & apndCheckReservedLock, & apndFileControl, & apndSectorSize,
    & apndDeviceCharacteristics, & apndShmMap, & apndShmLock, & apndShmBarrier, & apndShmUnmap,
    & apndFetch, & apndUnfetch};
static int apndClose(sqlite3_file *pFile ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xClose))(pFile);
  return (tmp);
}
}
static int apndRead(sqlite3_file *pFile , void *zBuf , int iAmt , long long iOfst ) 
{ 
  ApndFile *p ;
  int tmp ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xRead))(pFile, zBuf, iAmt, iOfst + p->iPgOne);
  return (tmp);
}
}
static int apndWriteMark(ApndFile *p , sqlite3_file *pFile ) 
{ 
  int i ;
  unsigned char a___0[25] ;
  int tmp ;

  {
  memcpy((void * __restrict  )(a___0), (void const   * __restrict  )"Start-Of-SQLite3-",
         (size_t )17);
  i = 0;
  while (i < 8) {
    a___0[17 + i] = (unsigned char )((p->iPgOne >> (56 - i * 8)) & 255LL);
    i ++;
  }
  tmp = (*((pFile->pMethods)->xWrite))(pFile, (void const   *)(a___0), 25, p->iMark);
  return (tmp);
}
}
static int apndWrite(sqlite3_file *pFile , void const   *zBuf , int iAmt , long long iOfst ) 
{ 
  int rc ;
  ApndFile *p ;
  sqlite_int64 sz ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  if (iOfst + (long long )iAmt >= 1000013824LL) {
    return (13);
  }
  rc = (*((pFile->pMethods)->xWrite))(pFile, zBuf, iAmt, iOfst + p->iPgOne);
  if (rc == 0) {
    if ((iOfst + (long long )iAmt) + p->iPgOne > p->iMark) {
      sz = (sqlite_int64 )0;
      rc = (*((pFile->pMethods)->xFileSize))(pFile, & sz);
      if (rc == 0) {
        p->iMark = sz - 25LL;
        if ((iOfst + (long long )iAmt) + p->iPgOne > p->iMark) {
          p->iMark = (p->iPgOne + iOfst) + (sqlite_int64 )iAmt;
          rc = apndWriteMark(p, pFile);
        }
      }
    }
  }
  return (rc);
}
}
static int apndTruncate(sqlite3_file *pFile , long long size ) 
{ 
  int rc ;
  ApndFile *p ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  rc = (*((pFile->pMethods)->xTruncate))(pFile, (size + p->iPgOne) + 25LL);
  if (rc == 0) {
    p->iMark = p->iPgOne + size;
    rc = apndWriteMark(p, pFile);
  }
  return (rc);
}
}
static int apndSync(sqlite3_file *pFile , int flags___0 ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xSync))(pFile, flags___0);
  return (tmp);
}
}
static int apndFileSize(sqlite3_file *pFile , long long *pSize ) 
{ 
  ApndFile *p ;
  int rc ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)(p + 1);
  rc = (*((pFile->pMethods)->xFileSize))(pFile, pSize);
  if (rc == 0) {
    if (p->iPgOne) {
      *pSize -= p->iPgOne + 25LL;
    }
  }
  return (rc);
}
}
static int apndLock(sqlite3_file *pFile , int eLock ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xLock))(pFile, eLock);
  return (tmp);
}
}
static int apndUnlock(sqlite3_file *pFile , int eLock ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xUnlock))(pFile, eLock);
  return (tmp);
}
}
static int apndCheckReservedLock(sqlite3_file *pFile , int *pResOut ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xCheckReservedLock))(pFile, pResOut);
  return (tmp);
}
}
static int apndFileControl(sqlite3_file *pFile , int op , void *pArg ) 
{ 
  ApndFile *p ;
  int rc ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  rc = (*((pFile->pMethods)->xFileControl))(pFile, op, pArg);
  if (rc == 0) {
    if (op == 12) {
      *((char **)pArg) = sqlite3_mprintf("apnd(%lld)/%z", p->iPgOne, *((char **)pArg));
    }
  }
  return (rc);
}
}
static int apndSectorSize(sqlite3_file *pFile ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xSectorSize))(pFile);
  return (tmp);
}
}
static int apndDeviceCharacteristics(sqlite3_file *pFile ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xDeviceCharacteristics))(pFile);
  return (tmp);
}
}
static int apndShmMap(sqlite3_file *pFile , int iPg , int pgsz___0 , int bExtend ,
                      void volatile   **pp ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xShmMap))(pFile, iPg, pgsz___0, bExtend, pp);
  return (tmp);
}
}
static int apndShmLock(sqlite3_file *pFile , int offset , int n , int flags___0 ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xShmLock))(pFile, offset, n, flags___0);
  return (tmp);
}
}
static void apndShmBarrier(sqlite3_file *pFile ) 
{ 


  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  (*((pFile->pMethods)->xShmBarrier))(pFile);
  return;
}
}
static int apndShmUnmap(sqlite3_file *pFile , int deleteFlag ) 
{ 
  int tmp ;

  {
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xShmUnmap))(pFile, deleteFlag);
  return (tmp);
}
}
static int apndFetch(sqlite3_file *pFile , sqlite_int64 iOfst , int iAmt , void **pp ) 
{ 
  ApndFile *p ;
  int tmp ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xFetch))(pFile, iOfst + p->iPgOne, iAmt, pp);
  return (tmp);
}
}
static int apndUnfetch(sqlite3_file *pFile , sqlite_int64 iOfst , void *pPage ) 
{ 
  ApndFile *p ;
  int tmp ;

  {
  p = (ApndFile *)pFile;
  pFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  tmp = (*((pFile->pMethods)->xUnfetch))(pFile, iOfst + p->iPgOne, pPage);
  return (tmp);
}
}
static int apndIsOrdinaryDatabaseFile(sqlite_int64 sz , sqlite3_file *pFile ) ;
static char const   aSqliteHdr[16]  = 
  {      (char const   )'S',      (char const   )'Q',      (char const   )'L',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )' ',      (char const   )'3',      (char const   )'\000'};
static int apndIsOrdinaryDatabaseFile(sqlite_int64 sz , sqlite3_file *pFile ) 
{ 
  int rc ;
  char zHdr[16] ;
  int tmp ;

  {
  if (sz < 512LL) {
    return (0);
  }
  rc = (*((pFile->pMethods)->xRead))(pFile, (void *)(zHdr), (int )sizeof(zHdr), (sqlite_int64 )0);
  if (rc) {
    return (0);
  }
  tmp = memcmp((void const   *)(zHdr), (void const   *)(aSqliteHdr), sizeof(zHdr));
  return (tmp == 0);
}
}
static sqlite_int64 apndReadMark(sqlite_int64 sz , sqlite3_file *pFile ) 
{ 
  int rc ;
  int i ;
  sqlite_int64 iMark ;
  unsigned char a___0[25] ;
  int tmp ;

  {
  if (sz <= 25LL) {
    return ((sqlite_int64 )-1);
  }
  rc = (*((pFile->pMethods)->xRead))(pFile, (void *)(a___0), 25, sz - 25LL);
  if (rc) {
    return ((sqlite_int64 )-1);
  }
  tmp = memcmp((void const   *)(a___0), (void const   *)"Start-Of-SQLite3-", (size_t )17);
  if (tmp != 0) {
    return ((sqlite_int64 )-1);
  }
  iMark = (sqlite_int64 )((int )a___0[17] & 127) << 56;
  i = 1;
  while (i < 8) {
    iMark += (sqlite_int64 )a___0[17 + i] << (56 - 8 * i);
    i ++;
  }
  return (iMark);
}
}
static int apndOpen(sqlite3_vfs *pVfs , char const   *zName , sqlite3_file *pFile ,
                    int flags___0 , int *pOutFlags ) 
{ 
  ApndFile *p ;
  sqlite3_file *pSubFile ;
  sqlite3_vfs *pSubVfs ;
  int rc ;
  sqlite_int64 sz ;
  int tmp ;
  int tmp___0 ;

  {
  pSubVfs = (sqlite3_vfs *)pVfs->pAppData;
  if ((flags___0 & 256) == 0) {
    tmp = (*(pSubVfs->xOpen))(pSubVfs, zName, pFile, flags___0, pOutFlags);
    return (tmp);
  }
  p = (ApndFile *)pFile;
  memset((void *)p, 0, sizeof(*p));
  pSubFile = (sqlite3_file *)((ApndFile *)pFile + 1);
  p->base.pMethods = & apnd_io_methods;
  rc = (*(pSubVfs->xOpen))(pSubVfs, zName, pSubFile, flags___0, pOutFlags);
  if (rc) {
    goto apnd_open_done;
  }
  rc = (*((pSubFile->pMethods)->xFileSize))(pSubFile, & sz);
  if (rc) {
    (*((pSubFile->pMethods)->xClose))(pSubFile);
    goto apnd_open_done;
  }
  tmp___0 = apndIsOrdinaryDatabaseFile(sz, pSubFile);
  if (tmp___0) {
    memmove((void *)pFile, (void const   *)pSubFile, (size_t )pSubVfs->szOsFile);
    return (0);
  }
  p->iMark = (sqlite_int64 )0;
  p->iPgOne = apndReadMark(sz, pFile);
  if (p->iPgOne > 0LL) {
    return (0);
  }
  if ((flags___0 & 4) == 0) {
    (*((pSubFile->pMethods)->xClose))(pSubFile);
    rc = 14;
  }
  p->iPgOne = (sz + 4095LL) & -4096LL;
  apnd_open_done: 
  if (rc) {
    pFile->pMethods = (struct sqlite3_io_methods  const  *)0;
  }
  return (rc);
}
}
static int apndDelete(sqlite3_vfs *pVfs , char const   *zPath , int dirSync ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xDelete))((sqlite3_vfs *)pVfs->pAppData,
                                                      zPath, dirSync);
  return (tmp);
}
}
static int apndAccess(sqlite3_vfs *pVfs , char const   *zPath , int flags___0 , int *pResOut ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xAccess))((sqlite3_vfs *)pVfs->pAppData,
                                                      zPath, flags___0, pResOut);
  return (tmp);
}
}
static int apndFullPathname(sqlite3_vfs *pVfs , char const   *zPath , int nOut , char *zOut ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xFullPathname))((sqlite3_vfs *)pVfs->pAppData,
                                                            zPath, nOut, zOut);
  return (tmp);
}
}
static void *apndDlOpen(sqlite3_vfs *pVfs , char const   *zPath ) 
{ 
  void *tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xDlOpen))((sqlite3_vfs *)pVfs->pAppData,
                                                      zPath);
  return (tmp);
}
}
static void apndDlError(sqlite3_vfs *pVfs , int nByte , char *zErrMsg ) 
{ 


  {
  (*(((sqlite3_vfs *)pVfs->pAppData)->xDlError))((sqlite3_vfs *)pVfs->pAppData, nByte,
                                                 zErrMsg);
  return;
}
}
static void (*apndDlSym(sqlite3_vfs *pVfs , void *p , char const   *zSym ))(void) 
{ 
  void (*tmp)(void) ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xDlSym))((sqlite3_vfs *)pVfs->pAppData,
                                                     p, zSym);
  return (tmp);
}
}
static void apndDlClose(sqlite3_vfs *pVfs , void *pHandle ) 
{ 


  {
  (*(((sqlite3_vfs *)pVfs->pAppData)->xDlClose))((sqlite3_vfs *)pVfs->pAppData, pHandle);
  return;
}
}
static int apndRandomness(sqlite3_vfs *pVfs , int nByte , char *zBufOut ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xRandomness))((sqlite3_vfs *)pVfs->pAppData,
                                                          nByte, zBufOut);
  return (tmp);
}
}
static int apndSleep(sqlite3_vfs *pVfs , int nMicro ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xSleep))((sqlite3_vfs *)pVfs->pAppData,
                                                     nMicro);
  return (tmp);
}
}
static int apndCurrentTime(sqlite3_vfs *pVfs , double *pTimeOut ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xCurrentTime))((sqlite3_vfs *)pVfs->pAppData,
                                                           pTimeOut);
  return (tmp);
}
}
static int apndGetLastError(sqlite3_vfs *pVfs , int a___0 , char *b ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xGetLastError))((sqlite3_vfs *)pVfs->pAppData,
                                                            a___0, b);
  return (tmp);
}
}
static int apndCurrentTimeInt64(sqlite3_vfs *pVfs , sqlite_int64 *p ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xCurrentTimeInt64))((sqlite3_vfs *)pVfs->pAppData,
                                                                p);
  return (tmp);
}
}
static int apndSetSystemCall(sqlite3_vfs *pVfs , char const   *zName , void (*pCall)(void) ) 
{ 
  int tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xSetSystemCall))((sqlite3_vfs *)pVfs->pAppData,
                                                             zName, pCall);
  return (tmp);
}
}
static sqlite3_syscall_ptr apndGetSystemCall(sqlite3_vfs *pVfs , char const   *zName ) 
{ 
  sqlite3_syscall_ptr tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xGetSystemCall))((sqlite3_vfs *)pVfs->pAppData,
                                                             zName);
  return (tmp);
}
}
static char const   *apndNextSystemCall(sqlite3_vfs *pVfs , char const   *zName ) 
{ 
  char const   *tmp ;

  {
  tmp = (*(((sqlite3_vfs *)pVfs->pAppData)->xNextSystemCall))((sqlite3_vfs *)pVfs->pAppData,
                                                              zName);
  return (tmp);
}
}
int sqlite3_appendvfs_init(sqlite3 *db , char **pzErrMsg , sqlite3_api_routines const   *pApi ) 
{ 
  int rc ;
  sqlite3_vfs *pOrig ;

  {
  rc = 0;
  pOrig = sqlite3_vfs_find((char const   *)0);
  apnd_vfs.iVersion = pOrig->iVersion;
  apnd_vfs.pAppData = (void *)pOrig;
  apnd_vfs.szOsFile = (int )((unsigned long )pOrig->szOsFile + sizeof(ApndFile ));
  rc = sqlite3_vfs_register(& apnd_vfs, 0);
  if (rc == 0) {
    rc = 1 << 8;
  }
  return (rc);
}
}
static sqlite3_mem_methods memtraceBase  ;
static FILE *memtraceOut  ;
static void *memtraceMalloc(int n ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  if (memtraceOut) {
    tmp = (*(memtraceBase.xRoundup))(n);
    fprintf((FILE * __restrict  )memtraceOut, (char const   * __restrict  )"MEMTRACE: allocate %d bytes\n",
            tmp);
  }
  tmp___0 = (*(memtraceBase.xMalloc))(n);
  return (tmp___0);
}
}
static void memtraceFree(void *p ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return;
  }
  if (memtraceOut) {
    tmp = (*(memtraceBase.xSize))(p);
    fprintf((FILE * __restrict  )memtraceOut, (char const   * __restrict  )"MEMTRACE: free %d bytes\n",
            tmp);
  }
  (*(memtraceBase.xFree))(p);
  return;
}
}
static void *memtraceRealloc(void *p , int n ) 
{ 
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    tmp = memtraceMalloc(n);
    return (tmp);
  }
  if (n == 0) {
    memtraceFree(p);
    return ((void *)0);
  }
  if (memtraceOut) {
    tmp___0 = (*(memtraceBase.xRoundup))(n);
    tmp___1 = (*(memtraceBase.xSize))(p);
    fprintf((FILE * __restrict  )memtraceOut, (char const   * __restrict  )"MEMTRACE: resize %d -> %d bytes\n",
            tmp___1, tmp___0);
  }
  tmp___2 = (*(memtraceBase.xRealloc))(p, n);
  return (tmp___2);
}
}
static int memtraceSize(void *p ) 
{ 
  int tmp ;

  {
  tmp = (*(memtraceBase.xSize))(p);
  return (tmp);
}
}
static int memtraceRoundup(int n ) 
{ 
  int tmp ;

  {
  tmp = (*(memtraceBase.xRoundup))(n);
  return (tmp);
}
}
static int memtraceInit(void *p ) 
{ 
  int tmp ;

  {
  tmp = (*(memtraceBase.xInit))(p);
  return (tmp);
}
}
static void memtraceShutdown(void *p ) 
{ 


  {
  (*(memtraceBase.xShutdown))(p);
  return;
}
}
static sqlite3_mem_methods ersaztMethods  = 
     {& memtraceMalloc, & memtraceFree, & memtraceRealloc, & memtraceSize, & memtraceRoundup,
    & memtraceInit, & memtraceShutdown, (void *)0};
int sqlite3MemTraceActivate(FILE *out ) 
{ 
  int rc ;

  {
  rc = 0;
  if ((unsigned long )memtraceBase.xMalloc == (unsigned long )((void *(*)(int  ))0)) {
    rc = sqlite3_config(5, & memtraceBase);
    if (rc == 0) {
      rc = sqlite3_config(4, & ersaztMethods);
    }
  }
  memtraceOut = out;
  return (rc);
}
}
int sqlite3MemTraceDeactivate(void) 
{ 
  int rc ;

  {
  rc = 0;
  if ((unsigned long )memtraceBase.xMalloc != (unsigned long )((void *(*)(int  ))0)) {
    rc = sqlite3_config(4, & memtraceBase);
    if (rc == 0) {
      memset((void *)(& memtraceBase), 0, sizeof(memtraceBase));
    }
  }
  memtraceOut = (FILE *)0;
  return (rc);
}
}
sqlite3expert *sqlite3_expert_new(sqlite3 *db , char **pzErrmsg ) ;
int sqlite3_expert_config(sqlite3expert *p , int op  , ...) ;
int sqlite3_expert_sql(sqlite3expert *p , char const   *zSql , char **pzErr ) ;
int sqlite3_expert_analyze(sqlite3expert *p , char **pzErr ) ;
int sqlite3_expert_count(sqlite3expert *p ) ;
char const   *sqlite3_expert_report(sqlite3expert *p , int iStmt , int eReport ) ;
void sqlite3_expert_destroy(sqlite3expert *p ) ;
static void *idxMalloc(int *pRc , int nByte ) 
{ 
  void *pRet ;

  {
  if (! (*pRc == 0)) {
    __assert_fail("*pRc==SQLITE_OK", "shell.c", 6846U, "idxMalloc");
  }
  if (! (nByte > 0)) {
    __assert_fail("nByte>0", "shell.c", 6847U, "idxMalloc");
  }
  pRet = sqlite3_malloc(nByte);
  if (pRet) {
    memset(pRet, 0, (size_t )nByte);
  } else {
    *pRc = 7;
  }
  return (pRet);
}
}
static void idxHashInit(IdxHash *pHash ) 
{ 


  {
  memset((void *)pHash, 0, sizeof(IdxHash ));
  return;
}
}
static void idxHashClear(IdxHash *pHash ) 
{ 
  int i ;
  IdxHashEntry *pEntry ;
  IdxHashEntry *pNext ;

  {
  i = 0;
  while (i < 1023) {
    pEntry = pHash->aHash[i];
    while (pEntry) {
      pNext = pEntry->pHashNext;
      sqlite3_free((void *)pEntry->zVal2);
      sqlite3_free((void *)pEntry);
      pEntry = pNext;
    }
    i ++;
  }
  memset((void *)pHash, 0, sizeof(IdxHash ));
  return;
}
}
static int idxHashString(char const   *z , int n ) 
{ 
  unsigned int ret ;
  int i ;

  {
  ret = 0U;
  i = 0;
  while (i < n) {
    ret += (ret << 3) + (unsigned int )((unsigned char )*(z + i));
    i ++;
  }
  return ((int )(ret % 1023U));
}
}
static int idxHashAdd(int *pRc , IdxHash *pHash , char const   *zKey , char const   *zVal ) 
{ 
  int nKey ;
  size_t tmp ;
  int iHash ;
  int tmp___0 ;
  int nVal ;
  size_t tmp___1 ;
  int tmp___2 ;
  IdxHashEntry *pEntry ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
  tmp = strlen(zKey);
  nKey = (int )tmp;
  tmp___0 = idxHashString(zKey, nKey);
  iHash = tmp___0;
  if (zVal) {
    tmp___1 = strlen(zVal);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 0;
  }
  nVal = tmp___2;
  if (! (iHash >= 0)) {
    __assert_fail("iHash>=0", "shell.c", 6909U, "idxHashAdd");
  }
  pEntry = pHash->aHash[iHash];
  while (pEntry) {
    tmp___4 = strlen((char const   *)pEntry->zKey);
    if ((int )tmp___4 == nKey) {
      tmp___5 = memcmp((void const   *)pEntry->zKey, (void const   *)zKey, (size_t )nKey);
      if (0 == tmp___5) {
        return (1);
      }
    }
    pEntry = pEntry->pHashNext;
  }
  tmp___6 = idxMalloc(pRc, (int )((((sizeof(IdxHashEntry ) + (unsigned long )nKey) + 1UL) + (unsigned long )nVal) + 1UL));
  pEntry = (IdxHashEntry *)tmp___6;
  if (pEntry) {
    pEntry->zKey = (char *)(pEntry + 1);
    memcpy((void * __restrict  )pEntry->zKey, (void const   * __restrict  )zKey, (size_t )nKey);
    if (zVal) {
      pEntry->zVal = pEntry->zKey + (nKey + 1);
      memcpy((void * __restrict  )pEntry->zVal, (void const   * __restrict  )zVal,
             (size_t )nVal);
    }
    pEntry->pHashNext = pHash->aHash[iHash];
    pHash->aHash[iHash] = pEntry;
    pEntry->pNext = pHash->pFirst;
    pHash->pFirst = pEntry;
  }
  return (0);
}
}
static IdxHashEntry *idxHashFind(IdxHash *pHash , char const   *zKey , int nKey ) 
{ 
  int iHash ;
  IdxHashEntry *pEntry ;
  size_t tmp ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  if (nKey < 0) {
    tmp = strlen(zKey);
    nKey = (int )tmp;
  }
  iHash = idxHashString(zKey, nKey);
  if (! (iHash >= 0)) {
    __assert_fail("iHash>=0", "shell.c", 6941U, "idxHashFind");
  }
  pEntry = pHash->aHash[iHash];
  while (pEntry) {
    tmp___1 = strlen((char const   *)pEntry->zKey);
    if ((int )tmp___1 == nKey) {
      tmp___2 = memcmp((void const   *)pEntry->zKey, (void const   *)zKey, (size_t )nKey);
      if (0 == tmp___2) {
        return (pEntry);
      }
    }
    pEntry = pEntry->pHashNext;
  }
  return ((IdxHashEntry *)0);
}
}
static char const   *idxHashSearch(IdxHash *pHash , char const   *zKey , int nKey ) 
{ 
  IdxHashEntry *pEntry ;
  IdxHashEntry *tmp ;

  {
  tmp = idxHashFind(pHash, zKey, nKey);
  pEntry = tmp;
  if (pEntry) {
    return ((char const   *)pEntry->zVal);
  }
  return ((char const   *)0);
}
}
static IdxConstraint *idxNewConstraint(int *pRc , char const   *zColl ) 
{ 
  IdxConstraint *pNew ;
  int nColl ;
  size_t tmp ;
  void *tmp___1 ;

  {
  tmp = strlen(zColl);
  nColl = (int )tmp;
  if (! (*pRc == 0)) {
    __assert_fail("*pRc==SQLITE_OK", "shell.c", 6970U, "idxNewConstraint");
  }
  tmp___1 = idxMalloc(pRc, (int )(sizeof(IdxConstraint ) * (unsigned long )nColl + 1UL));
  pNew = (IdxConstraint *)tmp___1;
  if (pNew) {
    pNew->zColl = (char *)(pNew + 1);
    memcpy((void * __restrict  )pNew->zColl, (void const   * __restrict  )zColl, (size_t )(nColl + 1));
  }
  return (pNew);
}
}
static void idxDatabaseError(sqlite3 *db , char **pzErrmsg ) 
{ 
  char const   *tmp ;

  {
  tmp = sqlite3_errmsg(db);
  *pzErrmsg = sqlite3_mprintf("%s", tmp);
  return;
}
}
static int idxPrepareStmt(sqlite3 *db , sqlite3_stmt **ppStmt , char **pzErrmsg ,
                          char const   *zSql ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_prepare_v2(db, zSql, -1, ppStmt, (char const   **)0);
  rc = tmp;
  if (rc != 0) {
    *ppStmt = (sqlite3_stmt *)0;
    idxDatabaseError(db, pzErrmsg);
  }
  return (rc);
}
}
static int idxPrintfPrepareStmt(sqlite3 *db , sqlite3_stmt **ppStmt , char **pzErrmsg ,
                                char const   *zFmt  , ...) 
{ 
  va_list ap ;
  int rc ;
  char *zSql ;

  {
  __builtin_va_start(ap, zFmt);
  zSql = sqlite3_vmprintf(zFmt, ap);
  if ((unsigned long )zSql == (unsigned long )((char *)0)) {
    rc = 7;
  } else {
    rc = idxPrepareStmt(db, ppStmt, pzErrmsg, (char const   *)zSql);
    sqlite3_free((void *)zSql);
  }
  __builtin_va_end(ap);
  return (rc);
}
}
static char *expertDequote(char const   *zIn ) 
{ 
  int n ;
  size_t tmp ;
  char *zRet ;
  void *tmp___0 ;
  int iOut ;
  int iIn ;
  int tmp___4 ;

  {
  tmp = strlen(zIn);
  n = (int )tmp;
  tmp___0 = sqlite3_malloc(n);
  zRet = (char *)tmp___0;
  if (! ((int const   )*(zIn + 0) == 39)) {
    __assert_fail("zIn[0]==\'\\\'\'", "shell.c", 7053U, "expertDequote");
  }
  if (! ((int const   )*(zIn + (n - 1)) == 39)) {
    __assert_fail("zIn[n-1]==\'\\\'\'", "shell.c", 7054U, "expertDequote");
  }
  if (zRet) {
    iOut = 0;
    iIn = 0;
    iIn = 1;
    while (iIn < n - 1) {
      if ((int const   )*(zIn + iIn) == 39) {
        if (! ((int const   )*(zIn + (iIn + 1)) == 39)) {
          __assert_fail("zIn[iIn+1]==\'\\\'\'", "shell.c", 7061U, "expertDequote");
        }
        iIn ++;
      }
      tmp___4 = iOut;
      iOut ++;
      *(zRet + tmp___4) = (char )*(zIn + iIn);
      iIn ++;
    }
    *(zRet + iOut) = (char )'\000';
  }
  return (zRet);
}
}
static int expertConnect(sqlite3 *db , void *pAux , int argc , char const   * const  *argv ,
                         sqlite3_vtab **ppVtab , char **pzErr ) 
{ 
  sqlite3expert *pExpert ;
  ExpertVtab *p ;
  int rc ;
  char *zCreateTable ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___4 ;

  {
  pExpert = (sqlite3expert *)pAux;
  p = (ExpertVtab *)0;
  if (argc != 4) {
    *pzErr = sqlite3_mprintf("internal error!");
    rc = 1;
  } else {
    tmp = expertDequote((char const   *)*(argv + 3));
    zCreateTable = tmp;
    if (zCreateTable) {
      rc = sqlite3_declare_vtab(db, (char const   *)zCreateTable);
      if (rc == 0) {
        tmp___0 = idxMalloc(& rc, (int )sizeof(ExpertVtab ));
        p = (ExpertVtab *)tmp___0;
      }
      if (rc == 0) {
        p->pExpert = pExpert;
        p->pTab = pExpert->pTable;
        tmp___4 = sqlite3_stricmp((char const   *)(p->pTab)->zName, (char const   *)*(argv + 2));
        if (! (tmp___4 == 0)) {
          __assert_fail("sqlite3_stricmp(p->pTab->zName, argv[2])==0", "shell.c",
                        7105U, "expertConnect");
        }
      }
      sqlite3_free((void *)zCreateTable);
    } else {
      rc = 7;
    }
  }
  *ppVtab = (sqlite3_vtab *)p;
  return (rc);
}
}
static int expertDisconnect(sqlite3_vtab *pVtab ) 
{ 
  ExpertVtab *p ;

  {
  p = (ExpertVtab *)pVtab;
  sqlite3_free((void *)p);
  return (0);
}
}
static int expertBestIndex(sqlite3_vtab *pVtab , sqlite3_index_info *pIdxInfo ) 
{ 
  ExpertVtab *p ;
  int rc ;
  int n ;
  IdxScan *pScan ;
  int opmask ;
  void *tmp ;
  int i ;
  struct sqlite3_index_constraint *pCons ;
  IdxConstraint *pNew ;
  char const   *zColl ;
  char const   *tmp___0 ;
  int iCol ;
  IdxConstraint *pNew___0 ;
  IdxConstraint *tmp___1 ;

  {
  p = (ExpertVtab *)pVtab;
  rc = 0;
  n = 0;
  opmask = 62;
  tmp = idxMalloc(& rc, (int )sizeof(IdxScan ));
  pScan = (IdxScan *)tmp;
  if (pScan) {
    pScan->pTab = p->pTab;
    pScan->pNextScan = (p->pExpert)->pScan;
    (p->pExpert)->pScan = pScan;
    i = 0;
    while (i < pIdxInfo->nConstraint) {
      pCons = pIdxInfo->aConstraint + i;
      if (pCons->usable) {
        if (pCons->iColumn >= 0) {
          if (((p->pTab)->aCol + pCons->iColumn)->iPk == 0) {
            if ((int )pCons->op & opmask) {
              tmp___0 = sqlite3_vtab_collation(pIdxInfo, i);
              zColl = tmp___0;
              pNew = idxNewConstraint(& rc, zColl);
              if (pNew) {
                pNew->iCol = pCons->iColumn;
                if ((int )pCons->op == 2) {
                  pNew->pNext = pScan->pEq;
                  pScan->pEq = pNew;
                } else {
                  pNew->bRange = 1;
                  pNew->pNext = pScan->pRange;
                  pScan->pRange = pNew;
                }
              }
              n ++;
              (pIdxInfo->aConstraintUsage + i)->argvIndex = n;
            }
          }
        }
      }
      i ++;
    }
    i = pIdxInfo->nOrderBy - 1;
    while (i >= 0) {
      iCol = (pIdxInfo->aOrderBy + i)->iColumn;
      if (iCol >= 0) {
        tmp___1 = idxNewConstraint(& rc, (char const   *)((p->pTab)->aCol + iCol)->zColl);
        pNew___0 = tmp___1;
        if (pNew___0) {
          pNew___0->iCol = iCol;
          pNew___0->bDesc = (int )(pIdxInfo->aOrderBy + i)->desc;
          pNew___0->pNext = pScan->pOrder;
          pNew___0->pLink = pScan->pOrder;
          pScan->pOrder = pNew___0;
          n ++;
        }
      }
      i --;
    }
  }
  pIdxInfo->estimatedCost = 1000000.0 / (double )(n + 1);
  return (rc);
}
}
static int expertUpdate(sqlite3_vtab *pVtab , int nData , sqlite3_value **azData ,
                        sqlite_int64 *pRowid ) 
{ 


  {
  return (0);
}
}
static int expertOpen(sqlite3_vtab *pVTab , sqlite3_vtab_cursor **ppCursor ) 
{ 
  int rc ;
  ExpertCsr *pCsr ;
  void *tmp ;

  {
  rc = 0;
  tmp = idxMalloc(& rc, (int )sizeof(ExpertCsr ));
  pCsr = (ExpertCsr *)tmp;
  *ppCursor = (sqlite3_vtab_cursor *)pCsr;
  return (rc);
}
}
static int expertClose(sqlite3_vtab_cursor *cur ) 
{ 
  ExpertCsr *pCsr ;

  {
  pCsr = (ExpertCsr *)cur;
  sqlite3_finalize(pCsr->pData);
  sqlite3_free((void *)pCsr);
  return (0);
}
}
static int expertEof(sqlite3_vtab_cursor *cur ) 
{ 
  ExpertCsr *pCsr ;

  {
  pCsr = (ExpertCsr *)cur;
  return ((unsigned long )pCsr->pData == (unsigned long )((sqlite3_stmt *)0));
}
}
static int expertNext(sqlite3_vtab_cursor *cur ) 
{ 
  ExpertCsr *pCsr ;
  int rc ;

  {
  pCsr = (ExpertCsr *)cur;
  rc = 0;
  if (! pCsr->pData) {
    __assert_fail("pCsr->pData", "shell.c", 7243U, "expertNext");
  }
  rc = sqlite3_step(pCsr->pData);
  if (rc != 100) {
    rc = sqlite3_finalize(pCsr->pData);
    pCsr->pData = (sqlite3_stmt *)0;
  } else {
    rc = 0;
  }
  return (rc);
}
}
static int expertRowid(sqlite3_vtab_cursor *cur , sqlite_int64 *pRowid ) 
{ 


  {
  *pRowid = (sqlite_int64 )0;
  return (0);
}
}
static int expertColumn(sqlite3_vtab_cursor *cur , sqlite3_context *ctx , int i ) 
{ 
  ExpertCsr *pCsr ;
  sqlite3_value *pVal ;

  {
  pCsr = (ExpertCsr *)cur;
  pVal = sqlite3_column_value(pCsr->pData, i);
  if (pVal) {
    sqlite3_result_value(ctx, pVal);
  }
  return (0);
}
}
static int expertFilter(sqlite3_vtab_cursor *cur , int idxNum , char const   *idxStr ,
                        int argc , sqlite3_value **argv ) 
{ 
  ExpertCsr *pCsr ;
  ExpertVtab *pVtab ;
  sqlite3expert *pExpert ;
  int rc ;

  {
  pCsr = (ExpertCsr *)cur;
  pVtab = (ExpertVtab *)cur->pVtab;
  pExpert = pVtab->pExpert;
  rc = sqlite3_finalize(pCsr->pData);
  pCsr->pData = (sqlite3_stmt *)0;
  if (rc == 0) {
    rc = idxPrintfPrepareStmt(pExpert->db, & pCsr->pData, & pVtab->base.zErrMsg, "SELECT * FROM main.%Q WHERE sample()",
                              (pVtab->pTab)->zName);
  }
  if (rc == 0) {
    rc = expertNext(cur);
  }
  return (rc);
}
}
static int idxRegisterVtab(sqlite3expert *p ) ;
static sqlite3_module expertModule  = 
     {2, & expertConnect, & expertConnect, & expertBestIndex, & expertDisconnect, & expertDisconnect,
    & expertOpen, & expertClose, & expertFilter, & expertNext, & expertEof, & expertColumn,
    & expertRowid, & expertUpdate, (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0,
    (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVTab ))0, (int (*)(sqlite3_vtab *pVtab ,
                                                                                 int nArg ,
                                                                                 char const   *zName ,
                                                                                 void (**pxFunc)(sqlite3_context * ,
                                                                                                 int  ,
                                                                                                 sqlite3_value ** ) ,
                                                                                 void **ppArg ))0,
    (int (*)(sqlite3_vtab *pVtab , char const   *zNew ))0, (int (*)(sqlite3_vtab *pVTab ,
                                                                    int  ))0, (int (*)(sqlite3_vtab *pVTab ,
                                                                                       int  ))0,
    (int (*)(sqlite3_vtab *pVTab , int  ))0, (int (*)(char const   * ))0};
static int idxRegisterVtab(sqlite3expert *p ) 
{ 
  int tmp ;

  {
  tmp = sqlite3_create_module(p->dbv, "expert", (sqlite3_module const   *)(& expertModule),
                              (void *)p);
  return (tmp);
}
}
static void idxFinalize(int *pRc , sqlite3_stmt *pStmt ) 
{ 
  int rc ;
  int tmp ;

  {
  tmp = sqlite3_finalize(pStmt);
  rc = tmp;
  if (*pRc == 0) {
    *pRc = rc;
  }
  return;
}
}
static int idxGetTableInfo(sqlite3 *db , char const   *zTab , IdxTable **ppOut , char **pzErrmsg ) 
{ 
  sqlite3_stmt *p1 ;
  int nCol ;
  int nTab ;
  size_t tmp ;
  int nByte ;
  IdxTable *pNew ;
  int rc ;
  int rc2 ;
  char *pCsr ;
  char const   *zCol ;
  unsigned char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char const   *zCol___0 ;
  unsigned char const   *tmp___5 ;
  int nCopy ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  p1 = (sqlite3_stmt *)0;
  nCol = 0;
  tmp = strlen(zTab);
  nTab = (int )tmp;
  nByte = (int )((sizeof(IdxTable ) + (unsigned long )nTab) + 1UL);
  pNew = (IdxTable *)0;
  pCsr = (char *)0;
  rc = idxPrintfPrepareStmt(db, & p1, pzErrmsg, "PRAGMA table_info=%Q", zTab);
  while (1) {
    if (rc == 0) {
      tmp___3 = sqlite3_step(p1);
      if (! (100 == tmp___3)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = sqlite3_column_text(p1, 1);
    zCol = (char const   *)tmp___0;
    tmp___1 = strlen(zCol);
    nByte += 1 + (int )tmp___1;
    rc = sqlite3_table_column_metadata(db, "main", zTab, zCol, (char const   **)0,
                                       & zCol, (int *)0, (int *)0, (int *)0);
    tmp___2 = strlen(zCol);
    nByte += 1 + (int )tmp___2;
    nCol ++;
  }
  rc2 = sqlite3_reset(p1);
  if (rc == 0) {
    rc = rc2;
  }
  nByte = (int )((unsigned long )nByte + sizeof(IdxColumn ) * (unsigned long )nCol);
  if (rc == 0) {
    tmp___4 = idxMalloc(& rc, nByte);
    pNew = (IdxTable *)tmp___4;
  }
  if (rc == 0) {
    pNew->aCol = (IdxColumn *)(pNew + 1);
    pNew->nCol = nCol;
    pCsr = (char *)(pNew->aCol + nCol);
  }
  nCol = 0;
  while (1) {
    if (rc == 0) {
      tmp___8 = sqlite3_step(p1);
      if (! (100 == tmp___8)) {
        break;
      }
    } else {
      break;
    }
    tmp___5 = sqlite3_column_text(p1, 1);
    zCol___0 = (char const   *)tmp___5;
    tmp___6 = strlen(zCol___0);
    nCopy = (int )tmp___6 + 1;
    (pNew->aCol + nCol)->zName = pCsr;
    (pNew->aCol + nCol)->iPk = sqlite3_column_int(p1, 5);
    memcpy((void * __restrict  )pCsr, (void const   * __restrict  )zCol___0, (size_t )nCopy);
    pCsr += nCopy;
    rc = sqlite3_table_column_metadata(db, "main", zTab, zCol___0, (char const   **)0,
                                       & zCol___0, (int *)0, (int *)0, (int *)0);
    if (rc == 0) {
      tmp___7 = strlen(zCol___0);
      nCopy = (int )tmp___7 + 1;
      (pNew->aCol + nCol)->zColl = pCsr;
      memcpy((void * __restrict  )pCsr, (void const   * __restrict  )zCol___0, (size_t )nCopy);
      pCsr += nCopy;
    }
    nCol ++;
  }
  idxFinalize(& rc, p1);
  if (rc != 0) {
    sqlite3_free((void *)pNew);
    pNew = (IdxTable *)0;
  } else {
    pNew->zName = pCsr;
    memcpy((void * __restrict  )pNew->zName, (void const   * __restrict  )zTab, (size_t )(nTab + 1));
  }
  *ppOut = pNew;
  return (rc);
}
}
static char *idxAppendText(int *pRc , char *zIn , char const   *zFmt  , ...) 
{ 
  va_list ap ;
  char *zAppend ;
  char *zRet ;
  int nIn ;
  size_t tmp ;
  int tmp___0 ;
  int nAppend ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  zAppend = (char *)0;
  zRet = (char *)0;
  if (zIn) {
    tmp = strlen((char const   *)zIn);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 0;
  }
  nIn = tmp___0;
  nAppend = 0;
  __builtin_va_start(ap, zFmt);
  if (*pRc == 0) {
    zAppend = sqlite3_vmprintf(zFmt, ap);
    if (zAppend) {
      tmp___1 = strlen((char const   *)zAppend);
      nAppend = (int )tmp___1;
      tmp___2 = sqlite3_malloc((nIn + nAppend) + 1);
      zRet = (char *)tmp___2;
    }
    if (zAppend) {
      if (zRet) {
        if (nIn) {
          memcpy((void * __restrict  )zRet, (void const   * __restrict  )zIn, (size_t )nIn);
        }
        memcpy((void * __restrict  )(zRet + nIn), (void const   * __restrict  )zAppend,
               (size_t )(nAppend + 1));
      } else {
        sqlite3_free((void *)zRet);
        zRet = (char *)0;
        *pRc = 7;
      }
    } else {
      sqlite3_free((void *)zRet);
      zRet = (char *)0;
      *pRc = 7;
    }
    sqlite3_free((void *)zAppend);
    sqlite3_free((void *)zIn);
  }
  __builtin_va_end(ap);
  return (zRet);
}
}
static int idxIdentifierRequiresQuotes(char const   *zId ) 
{ 
  int i ;

  {
  i = 0;
  while (*(zId + i)) {
    if (! ((int const   )*(zId + i) == 95)) {
      if ((int const   )*(zId + i) >= 48) {
        if (! ((int const   )*(zId + i) <= 57)) {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if ((int const   )*(zId + i) >= 97) {
        if (! ((int const   )*(zId + i) <= 122)) {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((int const   )*(zId + i) >= 65) {
        if (! ((int const   )*(zId + i) <= 90)) {
          return (1);
        }
      } else {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static char *idxAppendColDefn(int *pRc , char *zIn , IdxTable *pTab , IdxConstraint *pCons ) 
{ 
  char *zRet ;
  IdxColumn *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  zRet = zIn;
  p = pTab->aCol + pCons->iCol;
  if (zRet) {
    zRet = idxAppendText(pRc, zRet, ", ");
  }
  tmp = idxIdentifierRequiresQuotes((char const   *)p->zName);
  if (tmp) {
    zRet = idxAppendText(pRc, zRet, "%Q", p->zName);
  } else {
    zRet = idxAppendText(pRc, zRet, "%s", p->zName);
  }
  tmp___1 = sqlite3_stricmp((char const   *)p->zColl, (char const   *)pCons->zColl);
  if (tmp___1) {
    tmp___0 = idxIdentifierRequiresQuotes((char const   *)pCons->zColl);
    if (tmp___0) {
      zRet = idxAppendText(pRc, zRet, " COLLATE %Q", pCons->zColl);
    } else {
      zRet = idxAppendText(pRc, zRet, " COLLATE %s", pCons->zColl);
    }
  }
  if (pCons->bDesc) {
    zRet = idxAppendText(pRc, zRet, " DESC");
  }
  return (zRet);
}
}
static int idxFindCompatible(int *pRc , sqlite3 *dbm , IdxScan *pScan , IdxConstraint *pEq ,
                             IdxConstraint *pTail ) 
{ 
  char const   *zTbl ;
  sqlite3_stmt *pIdxList ;
  IdxConstraint *pIter ;
  int nEq ;
  int rc ;
  int bMatch ;
  IdxConstraint *pT ;
  sqlite3_stmt *pInfo ;
  char const   *zIdx ;
  unsigned char const   *tmp ;
  int iIdx ;
  int tmp___0 ;
  int iCol ;
  int tmp___1 ;
  char const   *zColl ;
  unsigned char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  zTbl = (char const   *)(pScan->pTab)->zName;
  pIdxList = (sqlite3_stmt *)0;
  nEq = 0;
  pIter = pEq;
  while (pIter) {
    nEq ++;
    pIter = pIter->pLink;
  }
  rc = idxPrintfPrepareStmt(dbm, & pIdxList, (char **)0, "PRAGMA index_list=%Q", zTbl);
  while (1) {
    if (rc == 0) {
      tmp___6 = sqlite3_step(pIdxList);
      if (! (tmp___6 == 100)) {
        break;
      }
    } else {
      break;
    }
    bMatch = 1;
    pT = pTail;
    pInfo = (sqlite3_stmt *)0;
    tmp = sqlite3_column_text(pIdxList, 1);
    zIdx = (char const   *)tmp;
    pIter = pEq;
    while (pIter) {
      pIter->bFlag = 0;
      pIter = pIter->pLink;
    }
    rc = idxPrintfPrepareStmt(dbm, & pInfo, (char **)0, "PRAGMA index_xInfo=%Q", zIdx);
    while (1) {
      if (rc == 0) {
        tmp___5 = sqlite3_step(pInfo);
        if (! (tmp___5 == 100)) {
          break;
        }
      } else {
        break;
      }
      tmp___0 = sqlite3_column_int(pInfo, 0);
      iIdx = tmp___0;
      tmp___1 = sqlite3_column_int(pInfo, 1);
      iCol = tmp___1;
      tmp___2 = sqlite3_column_text(pInfo, 4);
      zColl = (char const   *)tmp___2;
      if (iIdx < nEq) {
        pIter = pEq;
        while (pIter) {
          if (pIter->bFlag) {
            goto __Cont;
          }
          if (pIter->iCol != iCol) {
            goto __Cont;
          }
          tmp___3 = sqlite3_stricmp((char const   *)pIter->zColl, zColl);
          if (tmp___3) {
            goto __Cont;
          }
          pIter->bFlag = 1;
          break;
          __Cont: /* CIL Label */ 
          pIter = pIter->pLink;
        }
        if ((unsigned long )pIter == (unsigned long )((IdxConstraint *)0)) {
          bMatch = 0;
          break;
        }
      } else
      if (pT) {
        if (pT->iCol != iCol) {
          bMatch = 0;
          break;
        } else {
          tmp___4 = sqlite3_stricmp((char const   *)pT->zColl, zColl);
          if (tmp___4) {
            bMatch = 0;
            break;
          }
        }
        pT = pT->pLink;
      }
    }
    idxFinalize(& rc, pInfo);
    if (rc == 0) {
      if (bMatch) {
        sqlite3_finalize(pIdxList);
        return (1);
      }
    }
  }
  idxFinalize(& rc, pIdxList);
  *pRc = rc;
  return (0);
}
}
static int idxCreateFromCons(sqlite3expert *p , IdxScan *pScan , IdxConstraint *pEq ,
                             IdxConstraint *pTail ) 
{ 
  sqlite3 *dbm ;
  int rc ;
  IdxTable *pTab ;
  char *zCols ;
  char *zIdx ;
  IdxConstraint *pCons ;
  unsigned int h ;
  char const   *zFmt ;
  char const   *zTable ;
  char *zName ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  dbm = p->dbm;
  rc = 0;
  if (pEq) {
    goto _L;
  } else
  if (pTail) {
    _L: /* CIL Label */ 
    tmp___0 = idxFindCompatible(& rc, dbm, pScan, pEq, pTail);
    if (0 == tmp___0) {
      pTab = pScan->pTab;
      zCols = (char *)0;
      zIdx = (char *)0;
      h = 0U;
      pCons = pEq;
      while (pCons) {
        zCols = idxAppendColDefn(& rc, zCols, pTab, pCons);
        pCons = pCons->pLink;
      }
      pCons = pTail;
      while (pCons) {
        zCols = idxAppendColDefn(& rc, zCols, pTab, pCons);
        pCons = pCons->pLink;
      }
      if (rc == 0) {
        zTable = (char const   *)(pScan->pTab)->zName;
        i = 0;
        while (*(zCols + i)) {
          h += (h << 3) + (unsigned int )*(zCols + i);
          i ++;
        }
        zName = sqlite3_mprintf("%s_idx_%08x", zTable, h);
        if ((unsigned long )zName == (unsigned long )((char *)0)) {
          rc = 7;
        } else {
          tmp = idxIdentifierRequiresQuotes(zTable);
          if (tmp) {
            zFmt = "CREATE INDEX \'%q\' ON %Q(%s)";
          } else {
            zFmt = "CREATE INDEX %s ON %s(%s)";
          }
          zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
          if (! zIdx) {
            rc = 7;
          } else {
            rc = sqlite3_exec(dbm, (char const   *)zIdx, (int (*)(void * , int  ,
                                                                  char ** , char ** ))0,
                              (void *)0, p->pzErrmsg);
            idxHashAdd(& rc, & p->hIdx, (char const   *)zName, (char const   *)zIdx);
          }
          sqlite3_free((void *)zName);
          sqlite3_free((void *)zIdx);
        }
      }
      sqlite3_free((void *)zCols);
    }
  }
  return (rc);
}
}
static int idxFindConstraint(IdxConstraint *pList , IdxConstraint *p ) 
{ 
  IdxConstraint *pCmp ;

  {
  pCmp = pList;
  while (pCmp) {
    if (p->iCol == pCmp->iCol) {
      return (1);
    }
    pCmp = pCmp->pLink;
  }
  return (0);
}
}
static int idxCreateFromWhere(sqlite3expert *p , IdxScan *pScan , IdxConstraint *pTail ) 
{ 
  IdxConstraint *p1 ;
  IdxConstraint *pCon ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  p1 = (IdxConstraint *)0;
  pCon = pScan->pEq;
  while (pCon) {
    tmp = idxFindConstraint(p1, pCon);
    if (! tmp) {
      tmp___0 = idxFindConstraint(pTail, pCon);
      if (! tmp___0) {
        pCon->pLink = p1;
        p1 = pCon;
      }
    }
    pCon = pCon->pNext;
  }
  rc = idxCreateFromCons(p, pScan, p1, pTail);
  if ((unsigned long )pTail == (unsigned long )((IdxConstraint *)0)) {
    pCon = pScan->pRange;
    while (1) {
      if (rc == 0) {
        if (! pCon) {
          break;
        }
      } else {
        break;
      }
      if (! ((unsigned long )pCon->pLink == (unsigned long )((IdxConstraint *)0))) {
        __assert_fail("pCon->pLink==0", "shell.c", 7691U, "idxCreateFromWhere");
      }
      tmp___2 = idxFindConstraint(p1, pCon);
      if (! tmp___2) {
        tmp___3 = idxFindConstraint(pTail, pCon);
        if (! tmp___3) {
          rc = idxCreateFromCons(p, pScan, p1, pCon);
        }
      }
      pCon = pCon->pNext;
    }
  }
  return (rc);
}
}
static int idxCreateCandidates(sqlite3expert *p ) 
{ 
  int rc ;
  IdxScan *pIter ;

  {
  rc = 0;
  pIter = p->pScan;
  while (1) {
    if (pIter) {
      if (! (rc == 0)) {
        break;
      }
    } else {
      break;
    }
    rc = idxCreateFromWhere(p, pIter, (IdxConstraint *)0);
    if (rc == 0) {
      if (pIter->pOrder) {
        rc = idxCreateFromWhere(p, pIter, pIter->pOrder);
      }
    }
    pIter = pIter->pNextScan;
  }
  return (rc);
}
}
static void idxConstraintFree(IdxConstraint *pConstraint ) 
{ 
  IdxConstraint *pNext ;
  IdxConstraint *p ;

  {
  p = pConstraint;
  while (p) {
    pNext = p->pNext;
    sqlite3_free((void *)p);
    p = pNext;
  }
  return;
}
}
static void idxScanFree(IdxScan *pScan , IdxScan *pLast ) 
{ 
  IdxScan *p ;
  IdxScan *pNext ;

  {
  p = pScan;
  while ((unsigned long )p != (unsigned long )pLast) {
    pNext = p->pNextScan;
    idxConstraintFree(p->pOrder);
    idxConstraintFree(p->pEq);
    idxConstraintFree(p->pRange);
    sqlite3_free((void *)p);
    p = pNext;
  }
  return;
}
}
static void idxStatementFree(IdxStatement *pStatement , IdxStatement *pLast ) 
{ 
  IdxStatement *p ;
  IdxStatement *pNext ;

  {
  p = pStatement;
  while ((unsigned long )p != (unsigned long )pLast) {
    pNext = p->pNext;
    sqlite3_free((void *)p->zEQP);
    sqlite3_free((void *)p->zIdx);
    sqlite3_free((void *)p);
    p = pNext;
  }
  return;
}
}
static void idxTableFree(IdxTable *pTab ) 
{ 
  IdxTable *pIter ;
  IdxTable *pNext ;

  {
  pIter = pTab;
  while (pIter) {
    pNext = pIter->pNext;
    sqlite3_free((void *)pIter);
    pIter = pNext;
  }
  return;
}
}
static void idxWriteFree(IdxWrite *pTab ) 
{ 
  IdxWrite *pIter ;
  IdxWrite *pNext ;

  {
  pIter = pTab;
  while (pIter) {
    pNext = pIter->pNext;
    sqlite3_free((void *)pIter);
    pIter = pNext;
  }
  return;
}
}
int idxFindIndexes(sqlite3expert *p , char **pzErr ) 
{ 
  IdxStatement *pStmt ;
  sqlite3 *dbm ;
  int rc ;
  IdxHash hIdx ;
  IdxHashEntry *pEntry ;
  sqlite3_stmt *pExplain ;
  char const   *zDetail ;
  unsigned char const   *tmp ;
  int nDetail ;
  size_t tmp___0 ;
  int i ;
  char const   *zIdx ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *zSql ;
  int nIdx ;
  int tmp___3 ;

  {
  dbm = p->dbm;
  rc = 0;
  idxHashInit(& hIdx);
  pStmt = p->pStatement;
  while (1) {
    if (rc == 0) {
      if (! pStmt) {
        break;
      }
    } else {
      break;
    }
    pExplain = (sqlite3_stmt *)0;
    idxHashClear(& hIdx);
    rc = idxPrintfPrepareStmt(dbm, & pExplain, pzErr, "EXPLAIN QUERY PLAN %s", pStmt->zSql);
    while (1) {
      if (rc == 0) {
        tmp___3 = sqlite3_step(pExplain);
        if (! (tmp___3 == 100)) {
          break;
        }
      } else {
        break;
      }
      tmp = sqlite3_column_text(pExplain, 3);
      zDetail = (char const   *)tmp;
      tmp___0 = strlen(zDetail);
      nDetail = (int )tmp___0;
      i = 0;
      while (i < nDetail) {
        zIdx = (char const   *)0;
        tmp___2 = memcmp((void const   *)(zDetail + i), (void const   *)" USING INDEX ",
                         (size_t )13);
        if (tmp___2 == 0) {
          zIdx = zDetail + (i + 13);
        } else {
          tmp___1 = memcmp((void const   *)(zDetail + i), (void const   *)" USING COVERING INDEX ",
                           (size_t )22);
          if (tmp___1 == 0) {
            zIdx = zDetail + (i + 22);
          }
        }
        if (zIdx) {
          nIdx = 0;
          while (1) {
            if ((int const   )*(zIdx + nIdx) != 0) {
              if (! ((int const   )*(zIdx + nIdx) != 32)) {
                if (! ((int const   )*(zIdx + (nIdx + 1)) != 40)) {
                  break;
                }
              }
            } else {
              break;
            }
            nIdx ++;
          }
          zSql = idxHashSearch(& p->hIdx, zIdx, nIdx);
          if (zSql) {
            idxHashAdd(& rc, & hIdx, zSql, (char const   *)0);
            if (rc) {
              goto find_indexes_out;
            }
          }
          break;
        }
        i ++;
      }
      if ((int const   )*(zDetail + 0) != 45) {
        pStmt->zEQP = idxAppendText(& rc, pStmt->zEQP, "%s\n", zDetail);
      }
    }
    pEntry = hIdx.pFirst;
    while (pEntry) {
      pStmt->zIdx = idxAppendText(& rc, pStmt->zIdx, "%s;\n", pEntry->zKey);
      pEntry = pEntry->pNext;
    }
    idxFinalize(& rc, pExplain);
    pStmt = pStmt->pNext;
  }
  find_indexes_out: 
  idxHashClear(& hIdx);
  return (rc);
}
}
static int idxAuthCallback(void *pCtx , int eOp , char const   *z3 , char const   *z4 ,
                           char const   *zDb , char const   *zTrigger ) 
{ 
  int rc ;
  sqlite3expert *p ;
  IdxTable *pTab ;
  int tmp ;
  IdxWrite *pWrite ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  rc = 0;
  if (eOp == 18) {
    goto _L;
  } else
  if (eOp == 23) {
    goto _L;
  } else
  if (eOp == 9) {
    _L: /* CIL Label */ 
    tmp___1 = sqlite3_stricmp(zDb, "main");
    if (tmp___1 == 0) {
      p = (sqlite3expert *)pCtx;
      pTab = p->pTable;
      while (pTab) {
        tmp = sqlite3_stricmp(z3, (char const   *)pTab->zName);
        if (0 == tmp) {
          break;
        }
        pTab = pTab->pNext;
      }
      if (pTab) {
        pWrite = p->pWrite;
        while (pWrite) {
          if ((unsigned long )pWrite->pTab == (unsigned long )pTab) {
            if (pWrite->eOp == eOp) {
              break;
            }
          }
          pWrite = pWrite->pNext;
        }
        if ((unsigned long )pWrite == (unsigned long )((IdxWrite *)0)) {
          tmp___0 = idxMalloc(& rc, (int )sizeof(IdxWrite ));
          pWrite = (IdxWrite *)tmp___0;
          if (rc == 0) {
            pWrite->pTab = pTab;
            pWrite->eOp = eOp;
            pWrite->pNext = p->pWrite;
            p->pWrite = pWrite;
          }
        }
      }
    }
  }
  return (rc);
}
}
static int idxProcessOneTrigger(sqlite3expert *p , IdxWrite *pWrite , char **pzErr ) ;
static char const   *zInt  =    "t592690916721053953805701627921227776";
static char const   *zDrop  =    "DROP TABLE t592690916721053953805701627921227776";
static int idxProcessOneTrigger(sqlite3expert *p , IdxWrite *pWrite , char **pzErr ) 
{ 
  IdxTable *pTab ;
  char const   *zTab ;
  char const   *zSql ;
  sqlite3_stmt *pSelect ;
  int rc ;
  char *zWrite ;
  char const   *zCreate ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  char *z ;
  char *tmp___1 ;
  int i ;
  char const   *tmp___2 ;
  int i___0 ;
  char const   *tmp___3 ;
  sqlite3_stmt *pX ;

  {
  pTab = pWrite->pTab;
  zTab = (char const   *)pTab->zName;
  zSql = "SELECT \'CREATE TEMP\' || substr(sql, 7) FROM sqlite_master WHERE tbl_name = %Q AND type IN (\'table\', \'trigger\') ORDER BY type;";
  pSelect = (sqlite3_stmt *)0;
  rc = 0;
  zWrite = (char *)0;
  rc = idxPrintfPrepareStmt(p->db, & pSelect, pzErr, zSql, zTab, zTab);
  while (1) {
    if (rc == 0) {
      tmp___0 = sqlite3_step(pSelect);
      if (! (100 == tmp___0)) {
        break;
      }
    } else {
      break;
    }
    tmp = sqlite3_column_text(pSelect, 0);
    zCreate = (char const   *)tmp;
    rc = sqlite3_exec(p->dbv, zCreate, (int (*)(void * , int  , char ** , char ** ))0,
                      (void *)0, pzErr);
  }
  idxFinalize(& rc, pSelect);
  if (rc == 0) {
    tmp___1 = sqlite3_mprintf("ALTER TABLE temp.%Q RENAME TO %Q", zTab, zInt);
    z = tmp___1;
    if ((unsigned long )z == (unsigned long )((char *)0)) {
      rc = 7;
    } else {
      rc = sqlite3_exec(p->dbv, (char const   *)z, (int (*)(void * , int  , char ** ,
                                                            char ** ))0, (void *)0,
                        pzErr);
      sqlite3_free((void *)z);
    }
  }
  switch (pWrite->eOp) {
  case 18: 
  zWrite = idxAppendText(& rc, zWrite, "INSERT INTO %Q VALUES(", zInt);
  i = 0;
  while (i < pTab->nCol) {
    if (i == 0) {
      tmp___2 = "";
    } else {
      tmp___2 = ", ";
    }
    zWrite = idxAppendText(& rc, zWrite, "%s?", tmp___2);
    i ++;
  }
  zWrite = idxAppendText(& rc, zWrite, ")");
  break;
  case 23: 
  zWrite = idxAppendText(& rc, zWrite, "UPDATE %Q SET ", zInt);
  i___0 = 0;
  while (i___0 < pTab->nCol) {
    if (i___0 == 0) {
      tmp___3 = "";
    } else {
      tmp___3 = ", ";
    }
    zWrite = idxAppendText(& rc, zWrite, "%s%Q=?", tmp___3, (pTab->aCol + i___0)->zName);
    i___0 ++;
  }
  break;
  default: 
  if (! (pWrite->eOp == 9)) {
    __assert_fail("pWrite->eOp==SQLITE_DELETE", "shell.c", 7954U, "idxProcessOneTrigger");
  }
  if (rc == 0) {
    zWrite = sqlite3_mprintf("DELETE FROM %Q", zInt);
    if ((unsigned long )zWrite == (unsigned long )((char *)0)) {
      rc = 7;
    }
  }
  }
  if (rc == 0) {
    pX = (sqlite3_stmt *)0;
    rc = sqlite3_prepare_v2(p->dbv, (char const   *)zWrite, -1, & pX, (char const   **)0);
    idxFinalize(& rc, pX);
    if (rc != 0) {
      idxDatabaseError(p->dbv, pzErr);
    }
  }
  sqlite3_free((void *)zWrite);
  if (rc == 0) {
    rc = sqlite3_exec(p->dbv, zDrop, (int (*)(void * , int  , char ** , char ** ))0,
                      (void *)0, pzErr);
  }
  return (rc);
}
}
static int idxProcessTriggers(sqlite3expert *p , char **pzErr ) 
{ 
  int rc ;
  IdxWrite *pEnd ;
  IdxWrite *pFirst ;
  IdxWrite *pIter ;

  {
  rc = 0;
  pEnd = (IdxWrite *)0;
  pFirst = p->pWrite;
  while (1) {
    if (rc == 0) {
      if (! ((unsigned long )pFirst != (unsigned long )pEnd)) {
        break;
      }
    } else {
      break;
    }
    pIter = pFirst;
    while (1) {
      if (rc == 0) {
        if (! ((unsigned long )pIter != (unsigned long )pEnd)) {
          break;
        }
      } else {
        break;
      }
      rc = idxProcessOneTrigger(p, pIter, pzErr);
      pIter = pIter->pNext;
    }
    pEnd = pFirst;
    pFirst = p->pWrite;
  }
  return (rc);
}
}
static int idxCreateVtabSchema(sqlite3expert *p , char **pzErrmsg ) 
{ 
  int rc ;
  int tmp ;
  sqlite3_stmt *pSchema ;
  char const   *zType ;
  unsigned char const   *tmp___0 ;
  char const   *zName ;
  unsigned char const   *tmp___1 ;
  char const   *zSql ;
  unsigned char const   *tmp___2 ;
  IdxTable *pTab ;
  int i ;
  char *zInner ;
  char *zOuter ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  tmp = idxRegisterVtab(p);
  rc = tmp;
  pSchema = (sqlite3_stmt *)0;
  rc = idxPrepareStmt(p->db, & pSchema, pzErrmsg, "SELECT type, name, sql, 1 FROM sqlite_master WHERE type IN (\'table\',\'view\') AND name NOT LIKE \'sqlite_%%\'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_master WHERE type = \'trigger\'  AND tbl_name IN(SELECT name FROM sqlite_master WHERE type = \'view\') ORDER BY 4, 1");
  while (1) {
    if (rc == 0) {
      tmp___4 = sqlite3_step(pSchema);
      if (! (100 == tmp___4)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = sqlite3_column_text(pSchema, 0);
    zType = (char const   *)tmp___0;
    tmp___1 = sqlite3_column_text(pSchema, 1);
    zName = (char const   *)tmp___1;
    tmp___2 = sqlite3_column_text(pSchema, 2);
    zSql = (char const   *)tmp___2;
    if ((int const   )*(zType + 0) == 118) {
      rc = sqlite3_exec(p->dbv, zSql, (int (*)(void * , int  , char ** , char ** ))0,
                        (void *)0, pzErrmsg);
    } else
    if ((int const   )*(zType + 1) == 114) {
      rc = sqlite3_exec(p->dbv, zSql, (int (*)(void * , int  , char ** , char ** ))0,
                        (void *)0, pzErrmsg);
    } else {
      rc = idxGetTableInfo(p->db, zName, & pTab, pzErrmsg);
      if (rc == 0) {
        zInner = (char *)0;
        zOuter = (char *)0;
        pTab->pNext = p->pTable;
        p->pTable = pTab;
        zInner = idxAppendText(& rc, (char *)0, "CREATE TABLE x(");
        i = 0;
        while (i < pTab->nCol) {
          if (i == 0) {
            tmp___3 = "";
          } else {
            tmp___3 = ", ";
          }
          zInner = idxAppendText(& rc, zInner, "%s%Q COLLATE %s", tmp___3, (pTab->aCol + i)->zName,
                                 (pTab->aCol + i)->zColl);
          i ++;
        }
        zInner = idxAppendText(& rc, zInner, ")");
        zOuter = idxAppendText(& rc, (char *)0, "CREATE VIRTUAL TABLE %Q USING expert(%Q)",
                               zName, zInner);
        if (rc == 0) {
          rc = sqlite3_exec(p->dbv, (char const   *)zOuter, (int (*)(void * , int  ,
                                                                     char ** , char ** ))0,
                            (void *)0, pzErrmsg);
        }
        sqlite3_free((void *)zInner);
        sqlite3_free((void *)zOuter);
      }
    }
  }
  idxFinalize(& rc, pSchema);
  return (rc);
}
}
static void idxSampleFunc(sqlite3_context *pCtx , int argc , sqlite3_value **argv ) 
{ 
  struct IdxSampleCtx *p ;
  void *tmp ;
  int bRet ;
  unsigned short rnd ;

  {
  tmp = sqlite3_user_data(pCtx);
  p = (struct IdxSampleCtx *)tmp;
  if (! (argc == 0)) {
    __assert_fail("argc==0", "shell.c", 8073U, "idxSampleFunc");
  }
  if (p->nRow == 0.0) {
    bRet = 1;
  } else {
    bRet = p->nRet / p->nRow <= p->target;
    if (bRet == 0) {
      sqlite3_randomness(2, (void *)(& rnd));
      bRet = (int )rnd % 100 <= p->iTarget;
    }
  }
  sqlite3_result_int(pCtx, bRet);
  p->nRow += 1.0;
  p->nRet += (double )bRet;
  return;
}
}
static void idxRemFunc(sqlite3_context *pCtx , int argc , sqlite3_value **argv ) 
{ 
  struct IdxRemCtx *p ;
  void *tmp ;
  struct IdxRemSlot *pSlot ;
  int iSlot ;
  int nByte ;
  int tmp___2 ;
  char *zNew ;
  void *tmp___3 ;
  void const   *tmp___4 ;
  unsigned char const   *tmp___5 ;

  {
  tmp = sqlite3_user_data(pCtx);
  p = (struct IdxRemCtx *)tmp;
  if (! (argc == 2)) {
    __assert_fail("argc==2", "shell.c", 8113U, "idxRemFunc");
  }
  iSlot = sqlite3_value_int(*(argv + 0));
  if (! (iSlot <= p->nSlot)) {
    __assert_fail("iSlot<=p->nSlot", "shell.c", 8116U, "idxRemFunc");
  }
  pSlot = & p->aSlot[iSlot];
  switch (pSlot->eType) {
  case 5: 
  break;
  case 1: 
  sqlite3_result_int64(pCtx, pSlot->iVal);
  break;
  case 2: 
  sqlite3_result_double(pCtx, pSlot->rVal);
  break;
  case 4: 
  sqlite3_result_blob(pCtx, (void const   *)pSlot->z, pSlot->n, (void (*)(void * ))-1);
  break;
  case 3: 
  sqlite3_result_text(pCtx, (char const   *)pSlot->z, pSlot->n, (void (*)(void * ))-1);
  break;
  }
  pSlot->eType = sqlite3_value_type(*(argv + 1));
  switch (pSlot->eType) {
  case 5: 
  break;
  case 1: 
  pSlot->iVal = sqlite3_value_int64(*(argv + 1));
  break;
  case 2: 
  pSlot->rVal = sqlite3_value_double(*(argv + 1));
  break;
  case 3: 
  case 4: 
  tmp___2 = sqlite3_value_bytes(*(argv + 1));
  nByte = tmp___2;
  if (nByte > pSlot->nByte) {
    tmp___3 = sqlite3_realloc((void *)pSlot->z, nByte * 2);
    zNew = (char *)tmp___3;
    if ((unsigned long )zNew == (unsigned long )((char *)0)) {
      sqlite3_result_error_nomem(pCtx);
      return;
    }
    pSlot->nByte = nByte * 2;
    pSlot->z = zNew;
  }
  pSlot->n = nByte;
  if (pSlot->eType == 4) {
    tmp___4 = sqlite3_value_blob(*(argv + 1));
    memcpy((void * __restrict  )pSlot->z, (void const   * __restrict  )tmp___4, (size_t )nByte);
  } else {
    tmp___5 = sqlite3_value_text(*(argv + 1));
    memcpy((void * __restrict  )pSlot->z, (void const   * __restrict  )tmp___5, (size_t )nByte);
  }
  break;
  }
  return;
}
}
static int idxLargestIndex(sqlite3 *db , int *pnMax , char **pzErr ) 
{ 
  int rc ;
  char const   *zMax ;
  sqlite3_stmt *pMax ;
  int tmp ;
  int tmp___0 ;

  {
  rc = 0;
  zMax = "SELECT max(i.seqno) FROM   sqlite_master AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = \'table\'";
  pMax = (sqlite3_stmt *)0;
  *pnMax = 0;
  rc = idxPrepareStmt(db, & pMax, pzErr, zMax);
  if (rc == 0) {
    tmp___0 = sqlite3_step(pMax);
    if (100 == tmp___0) {
      tmp = sqlite3_column_int(pMax, 0);
      *pnMax = tmp + 1;
    }
  }
  idxFinalize(& rc, pMax);
  return (rc);
}
}
static int idxPopulateOneStat1(sqlite3expert *p , sqlite3_stmt *pIndexXInfo , sqlite3_stmt *pWriteStat ,
                               char const   *zTab , char const   *zIdx , char **pzErr ) 
{ 
  char *zCols ;
  char *zOrder ;
  char *zQuery ;
  int nCol ;
  int i ;
  sqlite3_stmt *pQuery ;
  int *aStat ;
  int rc ;
  char const   *zComma ;
  char const   *tmp___0 ;
  char const   *zName ;
  unsigned char const   *tmp___1 ;
  char const   *zColl ;
  unsigned char const   *tmp___2 ;
  int tmp___3 ;
  sqlite3 *dbrem ;
  sqlite3 *tmp___4 ;
  void *tmp___5 ;
  IdxHashEntry *pEntry ;
  char *zStat ;
  int tmp___6 ;
  int tmp___7 ;
  int s0 ;
  size_t tmp___8 ;
  int tmp___10 ;

  {
  zCols = (char *)0;
  zOrder = (char *)0;
  zQuery = (char *)0;
  nCol = 0;
  pQuery = (sqlite3_stmt *)0;
  aStat = (int *)0;
  rc = 0;
  if (! (p->iSample > 0)) {
    __assert_fail("p->iSample>0", "shell.c", 8215U, "idxPopulateOneStat1");
  }
  sqlite3_bind_text(pIndexXInfo, 1, zIdx, -1, (void (*)(void * ))0);
  while (1) {
    if (0 == rc) {
      tmp___3 = sqlite3_step(pIndexXInfo);
      if (! (100 == tmp___3)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned long )zCols == (unsigned long )((char *)0)) {
      tmp___0 = "";
    } else {
      tmp___0 = ", ";
    }
    zComma = tmp___0;
    tmp___1 = sqlite3_column_text(pIndexXInfo, 0);
    zName = (char const   *)tmp___1;
    tmp___2 = sqlite3_column_text(pIndexXInfo, 1);
    zColl = (char const   *)tmp___2;
    zCols = idxAppendText(& rc, zCols, "%sx.%Q IS rem(%d, x.%Q) COLLATE %s", zComma,
                          zName, nCol, zName, zColl);
    nCol ++;
    zOrder = idxAppendText(& rc, zOrder, "%s%d", zComma, nCol);
  }
  sqlite3_reset(pIndexXInfo);
  if (rc == 0) {
    if (p->iSample == 100) {
      zQuery = sqlite3_mprintf("SELECT %s FROM %Q x ORDER BY %s", zCols, zTab, zOrder);
    } else {
      zQuery = sqlite3_mprintf("SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s",
                               zCols, zOrder);
    }
  }
  sqlite3_free((void *)zCols);
  sqlite3_free((void *)zOrder);
  if (rc == 0) {
    if (p->iSample == 100) {
      tmp___4 = p->db;
    } else {
      tmp___4 = p->dbv;
    }
    dbrem = tmp___4;
    rc = idxPrepareStmt(dbrem, & pQuery, pzErr, (char const   *)zQuery);
  }
  sqlite3_free((void *)zQuery);
  if (rc == 0) {
    tmp___5 = idxMalloc(& rc, (int )(sizeof(int ) * (unsigned long )(nCol + 1)));
    aStat = (int *)tmp___5;
  }
  if (rc == 0) {
    tmp___10 = sqlite3_step(pQuery);
    if (100 == tmp___10) {
      zStat = (char *)0;
      i = 0;
      while (i <= nCol) {
        *(aStat + i) = 1;
        i ++;
      }
      while (1) {
        if (rc == 0) {
          tmp___7 = sqlite3_step(pQuery);
          if (! (100 == tmp___7)) {
            break;
          }
        } else {
          break;
        }
        (*(aStat + 0)) ++;
        i = 0;
        while (i < nCol) {
          tmp___6 = sqlite3_column_int(pQuery, i);
          if (tmp___6 == 0) {
            break;
          }
          i ++;
        }
        while (i < nCol) {
          (*(aStat + (i + 1))) ++;
          i ++;
        }
      }
      if (rc == 0) {
        s0 = *(aStat + 0);
        zStat = sqlite3_mprintf("%d", s0);
        if ((unsigned long )zStat == (unsigned long )((char *)0)) {
          rc = 7;
        }
        i = 1;
        while (1) {
          if (rc == 0) {
            if (! (i <= nCol)) {
              break;
            }
          } else {
            break;
          }
          zStat = idxAppendText(& rc, zStat, " %d", (s0 + *(aStat + i) / 2) / *(aStat + i));
          i ++;
        }
      }
      if (rc == 0) {
        sqlite3_bind_text(pWriteStat, 1, zTab, -1, (void (*)(void * ))0);
        sqlite3_bind_text(pWriteStat, 2, zIdx, -1, (void (*)(void * ))0);
        sqlite3_bind_text(pWriteStat, 3, (char const   *)zStat, -1, (void (*)(void * ))0);
        sqlite3_step(pWriteStat);
        rc = sqlite3_reset(pWriteStat);
      }
      tmp___8 = strlen(zIdx);
      pEntry = idxHashFind(& p->hIdx, zIdx, (int )tmp___8);
      if (pEntry) {
        if (! ((unsigned long )pEntry->zVal2 == (unsigned long )((char *)0))) {
          __assert_fail("pEntry->zVal2==0", "shell.c", 8286U, "idxPopulateOneStat1");
        }
        pEntry->zVal2 = zStat;
      } else {
        sqlite3_free((void *)zStat);
      }
    }
  }
  sqlite3_free((void *)aStat);
  idxFinalize(& rc, pQuery);
  return (rc);
}
}
static int idxBuildSampleTable(sqlite3expert *p , char const   *zTab ) 
{ 
  int rc ;
  char *zSql ;

  {
  rc = sqlite3_exec(p->dbv, "DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776",
                    (int (*)(void * , int  , char ** , char ** ))0, (void *)0, (char **)0);
  if (rc != 0) {
    return (rc);
  }
  zSql = sqlite3_mprintf("CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q",
                         zTab);
  if ((unsigned long )zSql == (unsigned long )((char *)0)) {
    return (7);
  }
  rc = sqlite3_exec(p->dbv, (char const   *)zSql, (int (*)(void * , int  , char ** ,
                                                           char ** ))0, (void *)0,
                    (char **)0);
  sqlite3_free((void *)zSql);
  return (rc);
}
}
static int idxPopulateStat1(sqlite3expert *p , char **pzErr ) 
{ 
  int rc ;
  int nMax ;
  struct IdxRemCtx *pCtx ;
  struct IdxSampleCtx samplectx ;
  int i ;
  i64 iPrev ;
  sqlite3_stmt *pAllIndex ;
  sqlite3_stmt *pIndexXInfo ;
  sqlite3_stmt *pWrite ;
  char const   *zAllIndex ;
  char const   *zIndexXInfo ;
  char const   *zWrite ;
  int nByte ;
  void *tmp ;
  sqlite3 *dbrem ;
  sqlite3 *tmp___0 ;
  i64 iRowid ;
  sqlite_int64 tmp___1 ;
  char const   *zTab ;
  unsigned char const   *tmp___2 ;
  char const   *zIdx ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;

  {
  rc = 0;
  nMax = 0;
  pCtx = (struct IdxRemCtx *)0;
  iPrev = (i64 )-100000;
  pAllIndex = (sqlite3_stmt *)0;
  pIndexXInfo = (sqlite3_stmt *)0;
  pWrite = (sqlite3_stmt *)0;
  zAllIndex = "SELECT s.rowid, s.name, l.name FROM   sqlite_master AS s,   pragma_index_list(s.name) AS l WHERE s.type = \'table\'";
  zIndexXInfo = "SELECT name, coll FROM pragma_index_xinfo(?) WHERE key";
  zWrite = "INSERT INTO sqlite_stat1 VALUES(?, ?, ?)";
  if (p->iSample == 0) {
    return (0);
  }
  rc = idxLargestIndex(p->dbm, & nMax, pzErr);
  if (nMax <= 0) {
    return (rc);
  } else
  if (rc != 0) {
    return (rc);
  }
  rc = sqlite3_exec(p->dbm, "ANALYZE; PRAGMA writable_schema=1", (int (*)(void * ,
                                                                          int  , char ** ,
                                                                          char ** ))0,
                    (void *)0, (char **)0);
  if (rc == 0) {
    nByte = (int )(sizeof(struct IdxRemCtx ) + sizeof(struct IdxRemSlot ) * (unsigned long )nMax);
    tmp = idxMalloc(& rc, nByte);
    pCtx = (struct IdxRemCtx *)tmp;
  }
  if (rc == 0) {
    if (p->iSample == 100) {
      tmp___0 = p->db;
    } else {
      tmp___0 = p->dbv;
    }
    dbrem = tmp___0;
    rc = sqlite3_create_function(dbrem, "rem", 2, 1, (void *)pCtx, & idxRemFunc, (void (*)(sqlite3_context * ,
                                                                                           int  ,
                                                                                           sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  if (rc == 0) {
    rc = sqlite3_create_function(p->db, "sample", 0, 1, (void *)(& samplectx), & idxSampleFunc,
                                 (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                                 (void (*)(sqlite3_context * ))0);
  }
  if (rc == 0) {
    pCtx->nSlot = nMax + 1;
    rc = idxPrepareStmt(p->dbm, & pAllIndex, pzErr, zAllIndex);
  }
  if (rc == 0) {
    rc = idxPrepareStmt(p->dbm, & pIndexXInfo, pzErr, zIndexXInfo);
  }
  if (rc == 0) {
    rc = idxPrepareStmt(p->dbm, & pWrite, pzErr, zWrite);
  }
  while (1) {
    if (rc == 0) {
      tmp___4 = sqlite3_step(pAllIndex);
      if (! (100 == tmp___4)) {
        break;
      }
    } else {
      break;
    }
    tmp___1 = sqlite3_column_int64(pAllIndex, 0);
    iRowid = tmp___1;
    tmp___2 = sqlite3_column_text(pAllIndex, 1);
    zTab = (char const   *)tmp___2;
    tmp___3 = sqlite3_column_text(pAllIndex, 2);
    zIdx = (char const   *)tmp___3;
    if (p->iSample < 100) {
      if (iPrev != iRowid) {
        samplectx.target = (double )p->iSample / 100.0;
        samplectx.iTarget = p->iSample;
        samplectx.nRow = 0.0;
        samplectx.nRet = 0.0;
        rc = idxBuildSampleTable(p, zTab);
        if (rc != 0) {
          break;
        }
      }
    }
    rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
    iPrev = iRowid;
  }
  if (rc == 0) {
    if (p->iSample < 100) {
      rc = sqlite3_exec(p->dbv, "DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776",
                        (int (*)(void * , int  , char ** , char ** ))0, (void *)0,
                        (char **)0);
    }
  }
  idxFinalize(& rc, pAllIndex);
  idxFinalize(& rc, pIndexXInfo);
  idxFinalize(& rc, pWrite);
  i = 0;
  while (i < pCtx->nSlot) {
    sqlite3_free((void *)pCtx->aSlot[i].z);
    i ++;
  }
  sqlite3_free((void *)pCtx);
  if (rc == 0) {
    rc = sqlite3_exec(p->dbm, "ANALYZE sqlite_master", (int (*)(void * , int  , char ** ,
                                                                char ** ))0, (void *)0,
                      (char **)0);
  }
  sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776",
               (int (*)(void * , int  , char ** , char ** ))0, (void *)0, (char **)0);
  return (rc);
}
}
sqlite3expert *sqlite3_expert_new(sqlite3 *db , char **pzErrmsg ) 
{ 
  int rc ;
  sqlite3expert *pNew ;
  void *tmp ;
  sqlite3_stmt *pSql ;
  char const   *zSql ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;

  {
  rc = 0;
  tmp = idxMalloc(& rc, (int )sizeof(sqlite3expert ));
  pNew = (sqlite3expert *)tmp;
  if (rc == 0) {
    pNew->db = db;
    pNew->iSample = 100;
    rc = sqlite3_open(":memory:", & pNew->dbv);
  }
  if (rc == 0) {
    rc = sqlite3_open(":memory:", & pNew->dbm);
    if (rc == 0) {
      sqlite3_db_config(pNew->dbm, 1008, 1, (int *)0);
    }
  }
  if (rc == 0) {
    rc = idxPrintfPrepareStmt(pNew->db, & pSql, pzErrmsg, "SELECT sql FROM sqlite_master WHERE name NOT LIKE \'sqlite_%%\' AND sql NOT LIKE \'CREATE VIRTUAL %%\'");
    while (1) {
      if (rc == 0) {
        tmp___1 = sqlite3_step(pSql);
        if (! (100 == tmp___1)) {
          break;
        }
      } else {
        break;
      }
      tmp___0 = sqlite3_column_text(pSql, 0);
      zSql = (char const   *)tmp___0;
      rc = sqlite3_exec(pNew->dbm, zSql, (int (*)(void * , int  , char ** , char ** ))0,
                        (void *)0, pzErrmsg);
    }
    idxFinalize(& rc, pSql);
  }
  if (rc == 0) {
    rc = idxCreateVtabSchema(pNew, pzErrmsg);
  }
  if (rc == 0) {
    sqlite3_set_authorizer(pNew->dbv, & idxAuthCallback, (void *)pNew);
  }
  if (rc != 0) {
    sqlite3_expert_destroy(pNew);
    pNew = (sqlite3expert *)0;
  }
  return (pNew);
}
}
int sqlite3_expert_config(sqlite3expert *p , int op  , ...) 
{ 
  int rc ;
  va_list ap ;
  int iVal ;
  int tmp___0 ;

  {
  rc = 0;
  __builtin_va_start(ap, op);
  switch (op) {
  case 1: 
  tmp___0 = __builtin_va_arg(ap, int );
  iVal = tmp___0;
  if (iVal < 0) {
    iVal = 0;
  }
  if (iVal > 100) {
    iVal = 100;
  }
  p->iSample = iVal;
  break;
  default: 
  rc = 12;
  break;
  }
  __builtin_va_end(ap);
  return (rc);
}
}
int sqlite3_expert_sql(sqlite3expert *p , char const   *zSql , char **pzErr ) 
{ 
  IdxScan *pScanOrig ;
  IdxStatement *pStmtOrig ;
  int rc ;
  char const   *zStmt ;
  sqlite3_stmt *pStmt ;
  IdxStatement *pNew ;
  char const   *z ;
  char const   *tmp ;
  int n ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  pScanOrig = p->pScan;
  pStmtOrig = p->pStatement;
  rc = 0;
  zStmt = zSql;
  if (p->bRun) {
    return (21);
  }
  while (1) {
    if (rc == 0) {
      if (zStmt) {
        if (! *(zStmt + 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    pStmt = (sqlite3_stmt *)0;
    rc = sqlite3_prepare_v2(p->dbv, zStmt, -1, & pStmt, & zStmt);
    if (rc == 0) {
      if (pStmt) {
        tmp = sqlite3_sql(pStmt);
        z = tmp;
        tmp___0 = strlen(z);
        n = (int )tmp___0;
        tmp___1 = idxMalloc(& rc, (int )((sizeof(IdxStatement ) + (unsigned long )n) + 1UL));
        pNew = (IdxStatement *)tmp___1;
        if (rc == 0) {
          pNew->zSql = (char *)(pNew + 1);
          memcpy((void * __restrict  )pNew->zSql, (void const   * __restrict  )z,
                 (size_t )(n + 1));
          pNew->pNext = p->pStatement;
          if (p->pStatement) {
            pNew->iId = (p->pStatement)->iId + 1;
          }
          p->pStatement = pNew;
        }
        sqlite3_finalize(pStmt);
      }
    } else {
      idxDatabaseError(p->dbv, pzErr);
    }
  }
  if (rc != 0) {
    idxScanFree(p->pScan, pScanOrig);
    idxStatementFree(p->pStatement, pStmtOrig);
    p->pScan = pScanOrig;
    p->pStatement = pStmtOrig;
  }
  return (rc);
}
}
int sqlite3_expert_analyze(sqlite3expert *p , char **pzErr ) 
{ 
  int rc ;
  IdxHashEntry *pEntry ;
  char const   *tmp ;

  {
  rc = idxProcessTriggers(p, pzErr);
  if (rc == 0) {
    rc = idxCreateCandidates(p);
  }
  if (rc == 0) {
    rc = idxPopulateStat1(p, pzErr);
  }
  pEntry = p->hIdx.pFirst;
  while (pEntry) {
    if (pEntry->zVal2) {
      tmp = " -- stat1: ";
    } else {
      tmp = "";
    }
    p->zCandidates = idxAppendText(& rc, p->zCandidates, "%s;%s%s\n", pEntry->zVal,
                                   tmp, pEntry->zVal2);
    pEntry = pEntry->pNext;
  }
  if (rc == 0) {
    rc = idxFindIndexes(p, pzErr);
  }
  if (rc == 0) {
    p->bRun = 1;
  }
  return (rc);
}
}
int sqlite3_expert_count(sqlite3expert *p ) 
{ 
  int nRet ;

  {
  nRet = 0;
  if (p->pStatement) {
    nRet = (p->pStatement)->iId + 1;
  }
  return (nRet);
}
}
char const   *sqlite3_expert_report(sqlite3expert *p , int iStmt , int eReport ) 
{ 
  char const   *zRet ;
  IdxStatement *pStmt ;

  {
  zRet = (char const   *)0;
  if (p->bRun == 0) {
    return ((char const   *)0);
  }
  pStmt = p->pStatement;
  while (1) {
    if (pStmt) {
      if (! (pStmt->iId != iStmt)) {
        break;
      }
    } else {
      break;
    }
    pStmt = pStmt->pNext;
  }
  switch (eReport) {
  case 1: 
  if (pStmt) {
    zRet = (char const   *)pStmt->zSql;
  }
  break;
  case 2: 
  if (pStmt) {
    zRet = (char const   *)pStmt->zIdx;
  }
  break;
  case 3: 
  if (pStmt) {
    zRet = (char const   *)pStmt->zEQP;
  }
  break;
  case 4: 
  zRet = (char const   *)p->zCandidates;
  break;
  }
  return (zRet);
}
}
void sqlite3_expert_destroy(sqlite3expert *p ) 
{ 


  {
  if (p) {
    sqlite3_close(p->dbm);
    sqlite3_close(p->dbv);
    idxScanFree(p->pScan, (IdxScan *)0);
    idxStatementFree(p->pStatement, (IdxStatement *)0);
    idxTableFree(p->pTable);
    idxWriteFree(p->pWrite);
    idxHashClear(& p->hIdx);
    sqlite3_free((void *)p->zCandidates);
    sqlite3_free((void *)p);
  }
  return;
}
}
static char const   *modeDescr[13]  = 
  {      "line",      "column",      "list",      "semi", 
        "html",      "insert",      "quote",      "tcl", 
        "csv",      "explain",      "ascii",      "prettyprint", 
        "eqp"};
static void shellLog(void *pArg , int iErrCode , char const   *zMsg ) 
{ 
  ShellState *p ;

  {
  p = (ShellState *)pArg;
  if ((unsigned long )p->pLog == (unsigned long )((FILE *)0)) {
    return;
  }
  fprintf((FILE * __restrict  )p->pLog, (char const   * __restrict  )"(%d) %s\n",
          iErrCode, zMsg);
  fflush(p->pLog);
  return;
}
}
static void shellPutsFunc(sqlite3_context *pCtx , int nVal , sqlite3_value **apVal ) 
{ 
  ShellState *p ;
  void *tmp ;
  unsigned char const   *tmp___0 ;

  {
  tmp = sqlite3_user_data(pCtx);
  p = (ShellState *)tmp;
  tmp___0 = sqlite3_value_text(*(apVal + 0));
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n", tmp___0);
  sqlite3_result_value(pCtx, *(apVal + 0));
  return;
}
}
static void editFunc(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zEditor ;
  char *zTempFile ;
  sqlite3 *db ;
  char *zCmd ;
  int bBin ;
  int rc ;
  int hasCRNL ;
  FILE *f ;
  sqlite_int64 sz ;
  sqlite_int64 x___0 ;
  unsigned char *p ;
  unsigned char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  sqlite_uint64 r ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void const   *tmp___5 ;
  size_t tmp___6 ;
  char const   *z ;
  unsigned char const   *tmp___7 ;
  char *tmp___8 ;
  unsigned char const   *tmp___9 ;
  size_t tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  sqlite_int64 i ;
  sqlite_int64 j ;
  sqlite_int64 tmp___14 ;

  {
  zTempFile = (char *)0;
  zCmd = (char *)0;
  hasCRNL = 0;
  f = (FILE *)0;
  p = (unsigned char *)0;
  if (argc == 2) {
    tmp = sqlite3_value_text(*(argv + 1));
    zEditor = (char const   *)tmp;
  } else {
    tmp___0 = getenv("VISUAL");
    zEditor = (char const   *)tmp___0;
  }
  if ((unsigned long )zEditor == (unsigned long )((char const   *)0)) {
    sqlite3_result_error(context, "no editor for edit()", -1);
    return;
  }
  tmp___1 = sqlite3_value_type(*(argv + 0));
  if (tmp___1 == 5) {
    sqlite3_result_error(context, "NULL input to edit()", -1);
    return;
  }
  db = sqlite3_context_db_handle(context);
  zTempFile = (char *)0;
  sqlite3_file_control(db, (char const   *)0, 16, (void *)(& zTempFile));
  if ((unsigned long )zTempFile == (unsigned long )((char *)0)) {
    r = (sqlite_uint64 )0;
    sqlite3_randomness((int )sizeof(r), (void *)(& r));
    zTempFile = sqlite3_mprintf("temp%llx", r);
    if ((unsigned long )zTempFile == (unsigned long )((char *)0)) {
      sqlite3_result_error_nomem(context);
      return;
    }
  }
  tmp___2 = sqlite3_value_type(*(argv + 0));
  bBin = tmp___2 == 4;
  if (bBin) {
    tmp___3 = "wb";
  } else {
    tmp___3 = "w";
  }
  f = fopen((char const   * __restrict  )zTempFile, (char const   * __restrict  )tmp___3);
  if ((unsigned long )f == (unsigned long )((FILE *)0)) {
    sqlite3_result_error(context, "edit() cannot open temp file", -1);
    goto edit_func_end;
  }
  tmp___4 = sqlite3_value_bytes(*(argv + 0));
  sz = (sqlite_int64 )tmp___4;
  if (bBin) {
    tmp___5 = sqlite3_value_blob(*(argv + 0));
    tmp___6 = fwrite((void const   * __restrict  )tmp___5, (size_t )1, (size_t )sz,
                     (FILE * __restrict  )f);
    x___0 = (sqlite_int64 )tmp___6;
  } else {
    tmp___7 = sqlite3_value_text(*(argv + 0));
    z = (char const   *)tmp___7;
    if (z) {
      tmp___8 = strstr(z, "\r\n");
      if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
        hasCRNL = 1;
      }
    }
    tmp___9 = sqlite3_value_text(*(argv + 0));
    tmp___10 = fwrite((void const   * __restrict  )tmp___9, (size_t )1, (size_t )sz,
                      (FILE * __restrict  )f);
    x___0 = (sqlite_int64 )tmp___10;
  }
  fclose(f);
  f = (FILE *)0;
  if (x___0 != sz) {
    sqlite3_result_error(context, "edit() could not write the whole file", -1);
    goto edit_func_end;
  }
  zCmd = sqlite3_mprintf("%s \"%s\"", zEditor, zTempFile);
  if ((unsigned long )zCmd == (unsigned long )((char *)0)) {
    sqlite3_result_error_nomem(context);
    goto edit_func_end;
  }
  rc = system((char const   *)zCmd);
  sqlite3_free((void *)zCmd);
  if (rc) {
    sqlite3_result_error(context, "EDITOR returned non-zero", -1);
    goto edit_func_end;
  }
  f = fopen((char const   * __restrict  )zTempFile, (char const   * __restrict  )"rb");
  if ((unsigned long )f == (unsigned long )((FILE *)0)) {
    sqlite3_result_error(context, "edit() cannot reopen temp file after edit", -1);
    goto edit_func_end;
  }
  fseek(f, 0L, 2);
  tmp___11 = ftell(f);
  sz = (sqlite_int64 )tmp___11;
  rewind(f);
  tmp___12 = sqlite3_malloc64((sqlite_uint64 )(sz + 1LL));
  p = (unsigned char *)tmp___12;
  if ((unsigned long )p == (unsigned long )((unsigned char *)0)) {
    sqlite3_result_error_nomem(context);
    goto edit_func_end;
  }
  tmp___13 = fread((void * __restrict  )p, (size_t )1, (size_t )sz, (FILE * __restrict  )f);
  x___0 = (sqlite_int64 )tmp___13;
  fclose(f);
  f = (FILE *)0;
  if (x___0 != sz) {
    sqlite3_result_error(context, "could not read back the whole file", -1);
    goto edit_func_end;
  }
  if (bBin) {
    sqlite3_result_blob64(context, (void const   *)p, (sqlite_uint64 )sz, & sqlite3_free);
  } else {
    if (hasCRNL) {
      j = sz;
    } else {
      j = (sqlite_int64 )0;
      i = j;
      while (i < sz) {
        if ((int )*(p + i) == 13) {
          if ((int )*(p + (i + 1LL)) == 10) {
            i ++;
          }
        }
        tmp___14 = j;
        j ++;
        *(p + tmp___14) = *(p + i);
        i ++;
      }
      sz = j;
      *(p + sz) = (unsigned char)0;
    }
    sqlite3_result_text64(context, (char const   *)p, (sqlite_uint64 )sz, & sqlite3_free,
                          (unsigned char)1);
  }
  p = (unsigned char *)0;
  edit_func_end: 
  if (f) {
    fclose(f);
  }
  unlink((char const   *)zTempFile);
  sqlite3_free((void *)zTempFile);
  sqlite3_free((void *)p);
  return;
}
}
static void outputModePush(ShellState *p ) 
{ 


  {
  p->modePrior = p->mode;
  memcpy((void * __restrict  )(p->colSepPrior), (void const   * __restrict  )(p->colSeparator),
         sizeof(p->colSeparator));
  memcpy((void * __restrict  )(p->rowSepPrior), (void const   * __restrict  )(p->rowSeparator),
         sizeof(p->rowSeparator));
  return;
}
}
static void outputModePop(ShellState *p ) 
{ 


  {
  p->mode = p->modePrior;
  memcpy((void * __restrict  )(p->colSeparator), (void const   * __restrict  )(p->colSepPrior),
         sizeof(p->colSeparator));
  memcpy((void * __restrict  )(p->rowSeparator), (void const   * __restrict  )(p->rowSepPrior),
         sizeof(p->rowSeparator));
  return;
}
}
static void output_hex_blob(FILE *out , void const   *pBlob , int nBlob ) 
{ 
  int i ;
  char *zBlob ;

  {
  zBlob = (char *)pBlob;
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"X\'");
  i = 0;
  while (i < nBlob) {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%02x", (int )*(zBlob + i) & 255);
    i ++;
  }
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
  return;
}
}
static char const   *unused_string(char const   *z , char const   *zA , char const   *zB ,
                                   char *zBuf ) 
{ 
  unsigned int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;

  {
  i = 0U;
  tmp = strstr(z, zA);
  if ((unsigned long )tmp == (unsigned long )((char *)0)) {
    return (zA);
  }
  tmp___0 = strstr(z, zB);
  if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
    return (zB);
  }
  while (1) {
    tmp___1 = i;
    i ++;
    sqlite3_snprintf(20, zBuf, "(%s%u)", zA, tmp___1);
    tmp___2 = strstr(z, (char const   *)zBuf);
    if (! ((unsigned long )tmp___2 != (unsigned long )((char *)0))) {
      break;
    }
  }
  return ((char const   *)zBuf);
}
}
static void output_quoted_string(FILE *out , char const   *z ) 
{ 
  int i ;
  char c ;

  {
  i = 0;
  while (1) {
    c = (char )*(z + i);
    if ((int )c != 0) {
      if (! ((int )c != 39)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if ((int )c == 0) {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'%s\'", z);
  } else {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
    while (*z) {
      i = 0;
      while (1) {
        c = (char )*(z + i);
        if ((int )c != 0) {
          if (! ((int )c != 39)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      if ((int )c == 39) {
        i ++;
      }
      if (i) {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%.*s", i,
                z);
        z += i;
      }
      if ((int )c == 39) {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
        continue;
      }
      if ((int )c == 0) {
        break;
      }
      z ++;
    }
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
  }
  return;
}
}
static void output_quoted_escaped_string(FILE *out , char const   *z ) 
{ 
  int i ;
  char c ;
  char const   *zNL ;
  char const   *zCR ;
  int nNL ;
  int nCR ;
  char zBuf1[20] ;
  char zBuf2[20] ;

  {
  i = 0;
  while (1) {
    c = (char )*(z + i);
    if ((int )c != 0) {
      if ((int )c != 39) {
        if ((int )c != 10) {
          if (! ((int )c != 13)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  if ((int )c == 0) {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'%s\'", z);
  } else {
    zNL = (char const   *)0;
    zCR = (char const   *)0;
    nNL = 0;
    nCR = 0;
    i = 0;
    while (*(z + i)) {
      if ((int const   )*(z + i) == 10) {
        nNL ++;
      }
      if ((int const   )*(z + i) == 13) {
        nCR ++;
      }
      i ++;
    }
    if (nNL) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"replace(");
      zNL = unused_string(z, "\\n", "\\012", zBuf1);
    }
    if (nCR) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"replace(");
      zCR = unused_string(z, "\\r", "\\015", zBuf2);
    }
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
    while (*z) {
      i = 0;
      while (1) {
        c = (char )*(z + i);
        if ((int )c != 0) {
          if ((int )c != 10) {
            if ((int )c != 13) {
              if (! ((int )c != 39)) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      if ((int )c == 39) {
        i ++;
      }
      if (i) {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%.*s", i,
                z);
        z += i;
      }
      if ((int )c == 39) {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
        continue;
      }
      if ((int )c == 0) {
        break;
      }
      z ++;
      if ((int )c == 10) {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s", zNL);
        continue;
      }
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s", zCR);
    }
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\'");
    if (nCR) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )",\'%s\',char(13))",
              zCR);
    }
    if (nNL) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )",\'%s\',char(10))",
              zNL);
    }
  }
  return;
}
}
static void output_c_string(FILE *out , char const   *z ) 
{ 
  unsigned int c ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;

  {
  fputc('\"', out);
  while (1) {
    tmp___0 = z;
    z ++;
    c = (unsigned int )*tmp___0;
    if (! (c != 0U)) {
      break;
    }
    if (c == 92U) {
      fputc((int )c, out);
      fputc((int )c, out);
    } else
    if (c == 34U) {
      fputc('\\', out);
      fputc('\"', out);
    } else
    if (c == 9U) {
      fputc('\\', out);
      fputc('t', out);
    } else
    if (c == 10U) {
      fputc('\\', out);
      fputc('n', out);
    } else
    if (c == 13U) {
      fputc('\\', out);
      fputc('r', out);
    } else {
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )(c & 255U)) & 16384) {
        fputc((int )c, out);
      } else {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\\%03o", c & 255U);
      }
    }
  }
  fputc('\"', out);
  return;
}
}
static void output_html_string(FILE *out , char const   *z ) 
{ 
  int i ;

  {
  if ((unsigned long )z == (unsigned long )((char const   *)0)) {
    z = "";
  }
  while (*z) {
    i = 0;
    while (1) {
      if (*(z + i)) {
        if ((int const   )*(z + i) != 60) {
          if ((int const   )*(z + i) != 38) {
            if ((int const   )*(z + i) != 62) {
              if ((int const   )*(z + i) != 34) {
                if (! ((int const   )*(z + i) != 39)) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    if (i > 0) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%.*s", i, z);
    }
    if ((int const   )*(z + i) == 60) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"&lt;");
    } else
    if ((int const   )*(z + i) == 38) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"&amp;");
    } else
    if ((int const   )*(z + i) == 62) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"&gt;");
    } else
    if ((int const   )*(z + i) == 34) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"&quot;");
    } else
    if ((int const   )*(z + i) == 39) {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"&#39;");
    } else {
      break;
    }
    z += i + 1;
  }
  return;
}
}
static char const   needCsvQuote[256]  = 
  {      (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )0,      (char const   )1,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1};
static void output_csv(ShellState *p , char const   *z , int bSep ) 
{ 
  FILE *out ;
  int i ;
  int nSep ;
  int tmp ;
  int tmp___0 ;
  char *zQuoted ;
  char *tmp___1 ;

  {
  out = p->out;
  if ((unsigned long )z == (unsigned long )((char const   *)0)) {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s", p->nullValue);
  } else {
    tmp = strlen30((char const   *)(p->colSeparator));
    nSep = tmp;
    i = 0;
    while (*(z + i)) {
      if (needCsvQuote[*((unsigned char *)z + i)]) {
        i = 0;
        break;
      } else
      if ((int const   )*(z + i) == (int const   )p->colSeparator[0]) {
        if (nSep == 1) {
          i = 0;
          break;
        } else {
          tmp___0 = memcmp((void const   *)z, (void const   *)(p->colSeparator), (size_t )nSep);
          if (tmp___0 == 0) {
            i = 0;
            break;
          }
        }
      }
      i ++;
    }
    if (i == 0) {
      tmp___1 = sqlite3_mprintf("\"%w\"", z);
      zQuoted = tmp___1;
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s", zQuoted);
      sqlite3_free((void *)zQuoted);
    } else {
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s", z);
    }
  }
  if (bSep) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->colSeparator);
  }
  return;
}
}
static void interrupt_handler(int NotUsed ) 
{ 


  {
  seenInterrupt += (int volatile   )1;
  if (seenInterrupt > (int volatile   )2) {
    exit(1);
  }
  if (globalDb) {
    sqlite3_interrupt(globalDb);
  }
  return;
}
}
static int shellAuth(void *pClientData , int op , char const   *zA1 , char const   *zA2 ,
                     char const   *zA3 , char const   *zA4 ) ;
static char const   *azAction[34]  = 
  {      (char const   *)0,      "CREATE_INDEX",      "CREATE_TABLE",      "CREATE_TEMP_INDEX", 
        "CREATE_TEMP_TABLE",      "CREATE_TEMP_TRIGGER",      "CREATE_TEMP_VIEW",      "CREATE_TRIGGER", 
        "CREATE_VIEW",      "DELETE",      "DROP_INDEX",      "DROP_TABLE", 
        "DROP_TEMP_INDEX",      "DROP_TEMP_TABLE",      "DROP_TEMP_TRIGGER",      "DROP_TEMP_VIEW", 
        "DROP_TRIGGER",      "DROP_VIEW",      "INSERT",      "PRAGMA", 
        "READ",      "SELECT",      "TRANSACTION",      "UPDATE", 
        "ATTACH",      "DETACH",      "ALTER_TABLE",      "REINDEX", 
        "ANALYZE",      "CREATE_VTABLE",      "DROP_VTABLE",      "FUNCTION", 
        "SAVEPOINT",      "RECURSIVE"};
static int shellAuth(void *pClientData , int op , char const   *zA1 , char const   *zA2 ,
                     char const   *zA3 , char const   *zA4 ) 
{ 
  ShellState *p ;
  int i ;
  char const   *az___0[4] ;

  {
  p = (ShellState *)pClientData;
  az___0[0] = zA1;
  az___0[1] = zA2;
  az___0[2] = zA3;
  az___0[3] = zA4;
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"authorizer: %s",
          azAction[op]);
  i = 0;
  while (i < 4) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )" ");
    if (az___0[i]) {
      output_c_string(p->out, az___0[i]);
    } else {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"NULL");
    }
    i ++;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
  return (0);
}
}
static void printSchemaLine(FILE *out , char const   *z , char const   *zTail ) 
{ 
  int tmp ;

  {
  if ((unsigned long )z == (unsigned long )((char const   *)0)) {
    return;
  }
  if ((unsigned long )zTail == (unsigned long )((char const   *)0)) {
    return;
  }
  tmp = sqlite3_strglob("CREATE TABLE [\'\"]*", z);
  if (tmp == 0) {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"CREATE TABLE IF NOT EXISTS %s%s",
            z + 13, zTail);
  } else {
    fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s%s", z, zTail);
  }
  return;
}
}
static void printSchemaLineN(FILE *out , char *z , int n , char const   *zTail ) 
{ 
  char c ;

  {
  c = *(z + n);
  *(z + n) = (char)0;
  printSchemaLine(out, (char const   *)z, zTail);
  *(z + n) = c;
  return;
}
}
static int wsToEol(char const   *z ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
  i = 0;
  while (*(z + i)) {
    if ((int const   )*(z + i) == 10) {
      return (1);
    }
    tmp = __ctype_b_loc();
    if ((int const   )*(*tmp + (int )((unsigned char )*(z + i))) & 8192) {
      goto __Cont;
    }
    if ((int const   )*(z + i) == 45) {
      if ((int const   )*(z + (i + 1)) == 45) {
        return (1);
      }
    }
    return (0);
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (1);
}
}
static void eqp_append(ShellState *p , int iEqpId , int p2 , char const   *zText___0 ) 
{ 
  EQPGraphRow *pNew ;
  int nText ;
  int tmp ;
  void *tmp___0 ;

  {
  tmp = strlen30(zText___0);
  nText = tmp;
  if (p->autoEQPtest) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d,%d,%s\n",
            iEqpId, p2, zText___0);
  }
  tmp___0 = sqlite3_malloc64((sqlite_uint64 )(sizeof(*pNew) + (unsigned long )nText));
  pNew = (EQPGraphRow *)tmp___0;
  if ((unsigned long )pNew == (unsigned long )((EQPGraphRow *)0)) {
    shell_out_of_memory();
  }
  pNew->iEqpId = iEqpId;
  pNew->iParentId = p2;
  memcpy((void * __restrict  )(pNew->zText), (void const   * __restrict  )zText___0,
         (size_t )(nText + 1));
  pNew->pNext = (EQPGraphRow *)0;
  if (p->sGraph.pLast) {
    (p->sGraph.pLast)->pNext = pNew;
  } else {
    p->sGraph.pRow = pNew;
  }
  p->sGraph.pLast = pNew;
  return;
}
}
static void eqp_reset(ShellState *p ) 
{ 
  EQPGraphRow *pRow ;
  EQPGraphRow *pNext ;

  {
  pRow = p->sGraph.pRow;
  while (pRow) {
    pNext = pRow->pNext;
    sqlite3_free((void *)pRow);
    pRow = pNext;
  }
  memset((void *)(& p->sGraph), 0, sizeof(p->sGraph));
  return;
}
}
static EQPGraphRow *eqp_next_row(ShellState *p , int iEqpId , EQPGraphRow *pOld ) 
{ 
  EQPGraphRow *pRow ;
  EQPGraphRow *tmp ;

  {
  if (pOld) {
    tmp = pOld->pNext;
  } else {
    tmp = p->sGraph.pRow;
  }
  pRow = tmp;
  while (1) {
    if (pRow) {
      if (! (pRow->iParentId != iEqpId)) {
        break;
      }
    } else {
      break;
    }
    pRow = pRow->pNext;
  }
  return (pRow);
}
}
static void eqp_render_level(ShellState *p , int iEqpId ) 
{ 
  EQPGraphRow *pRow ;
  EQPGraphRow *pNext ;
  int n ;
  int tmp ;
  char *z ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = strlen30((char const   *)(p->sGraph.zPrefix));
  n = tmp;
  pRow = eqp_next_row(p, iEqpId, (EQPGraphRow *)0);
  while (pRow) {
    pNext = eqp_next_row(p, iEqpId, pRow);
    z = pRow->zText;
    if (pNext) {
      tmp___0 = "|--";
    } else {
      tmp___0 = "`--";
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s%s%s\n",
            p->sGraph.zPrefix, tmp___0, z);
    if (n < (int )sizeof(p->sGraph.zPrefix) - 7) {
      if (pNext) {
        tmp___1 = "|  ";
      } else {
        tmp___1 = "   ";
      }
      memcpy((void * __restrict  )(& p->sGraph.zPrefix[n]), (void const   * __restrict  )tmp___1,
             (size_t )4);
      eqp_render_level(p, pRow->iEqpId);
      p->sGraph.zPrefix[n] = (char)0;
    }
    pRow = pNext;
  }
  return;
}
}
static void eqp_render(ShellState *p ) 
{ 
  EQPGraphRow *pRow ;

  {
  pRow = p->sGraph.pRow;
  if (pRow) {
    if ((int )pRow->zText[0] == 45) {
      if ((unsigned long )pRow->pNext == (unsigned long )((EQPGraphRow *)0)) {
        eqp_reset(p);
        return;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n", pRow->zText + 3);
      p->sGraph.pRow = pRow->pNext;
      sqlite3_free((void *)pRow);
    } else {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"QUERY PLAN\n");
    }
    p->sGraph.zPrefix[0] = (char)0;
    eqp_render_level(p, 0);
    eqp_reset(p);
  }
  return;
}
}
static int progress_handler(void *pClientData ) 
{ 
  ShellState *p ;

  {
  p = (ShellState *)pClientData;
  (p->nProgress) ++;
  if (p->nProgress >= p->mxProgress) {
    if (p->mxProgress > 0U) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Progress limit reached (%u)\n",
              p->nProgress);
      if (p->flgProgress & 2U) {
        p->nProgress = 0U;
      }
      if (p->flgProgress & 4U) {
        p->mxProgress = 0U;
      }
      return (1);
    }
  }
  if ((p->flgProgress & 1U) == 0U) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Progress %u\n",
            p->nProgress);
  }
  return (0);
}
}
static int shell_callback(void *pArg , int nArg , char **azArg , char **azCol , int *aiType ) ;
static int const   aExplainWidths[8]  = 
  {      (int const   )4,      (int const   )13,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )13,      (int const   )2,      (int const   )13};
static int shell_callback(void *pArg , int nArg , char **azArg , char **azCol , int *aiType ) 
{ 
  int i ;
  ShellState *p ;
  int w ;
  int len ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int const   *colWidth ;
  int showHdr ;
  char *rowSep ;
  int w___0 ;
  int n ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  int w___1 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int w___2 ;
  int tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *z ;
  int j ;
  int nParen ;
  char cEnd ;
  char c ;
  int nLine ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *z___0 ;
  int tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char *z___1 ;
  char *tmp___33 ;
  char tmp___34 ;
  char const   *tmp___35 ;
  char z___2[50] ;
  double r ;
  double tmp___36 ;
  sqlite_uint64 ur ;
  void const   *pBlob ;
  void const   *tmp___37 ;
  int nBlob ;
  int tmp___38 ;
  int tmp___39 ;
  char z___3[50] ;
  double r___0 ;
  double tmp___40 ;
  void const   *pBlob___0 ;
  void const   *tmp___41 ;
  int nBlob___0 ;
  int tmp___42 ;
  int tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;

  {
  p = (ShellState *)pArg;
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    return (0);
  }
  switch (p->cMode) {
  case 0: 
  w = 5;
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  i = 0;
  while (i < nArg) {
    if (*(azCol + i)) {
      tmp = (char const   *)*(azCol + i);
    } else {
      tmp = "";
    }
    tmp___0 = strlen30(tmp);
    len = tmp___0;
    if (len > w) {
      w = len;
    }
    i ++;
  }
  tmp___1 = p->cnt;
  (p->cnt) ++;
  if (tmp___1 > 0) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
  }
  i = 0;
  while (i < nArg) {
    if (*(azArg + i)) {
      tmp___2 = *(azArg + i);
    } else {
      tmp___2 = p->nullValue;
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%*s = %s%s",
            w, *(azCol + i), tmp___2, p->rowSeparator);
    i ++;
  }
  break;
  case 1: 
  case 9: 
  if (p->cMode == 1) {
    colWidth = (int const   *)(p->colWidth);
    showHdr = p->showHeader;
    rowSep = p->rowSeparator;
  } else {
    colWidth = aExplainWidths;
    showHdr = 1;
    rowSep = (char *)"\n";
  }
  tmp___7 = p->cnt;
  (p->cnt) ++;
  if (tmp___7 == 0) {
    i = 0;
    while (i < nArg) {
      if (i < (int )(sizeof(p->colWidth) / sizeof(p->colWidth[0]))) {
        w___0 = (int )*(colWidth + i);
      } else {
        w___0 = 0;
      }
      if (w___0 == 0) {
        if (*(azCol + i)) {
          tmp___3 = (char const   *)*(azCol + i);
        } else {
          tmp___3 = "";
        }
        w___0 = strlenChar(tmp___3);
        if (w___0 < 10) {
          w___0 = 10;
        }
        if (azArg) {
          if (*(azArg + i)) {
            tmp___4 = *(azArg + i);
          } else {
            tmp___4 = p->nullValue;
          }
        } else {
          tmp___4 = p->nullValue;
        }
        n = strlenChar((char const   *)tmp___4);
        if (w___0 < n) {
          w___0 = n;
        }
      }
      if (i < (int )(sizeof(p->actualWidth) / sizeof(p->actualWidth[0]))) {
        p->actualWidth[i] = w___0;
      }
      if (showHdr) {
        utf8_width_print(p->out, w___0, (char const   *)*(azCol + i));
        if (i == nArg - 1) {
          tmp___5 = (char const   *)rowSep;
        } else {
          tmp___5 = "  ";
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", tmp___5);
      }
      i ++;
    }
    if (showHdr) {
      i = 0;
      while (i < nArg) {
        if (i < (int )(sizeof(p->actualWidth) / sizeof(p->actualWidth[0]))) {
          w___1 = p->actualWidth[i];
          if (w___1 < 0) {
            w___1 = - w___1;
          }
        } else {
          w___1 = 10;
        }
        if (i == nArg - 1) {
          tmp___6 = (char const   *)rowSep;
        } else {
          tmp___6 = "  ";
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-*.*s%s",
                w___1, w___1, "--------------------------------------------------------------------------------------------------------------------",
                tmp___6);
        i ++;
      }
    }
  }
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  i = 0;
  while (i < nArg) {
    if (i < (int )(sizeof(p->actualWidth) / sizeof(p->actualWidth[0]))) {
      w___2 = p->actualWidth[i];
    } else {
      w___2 = 10;
    }
    if (p->cMode == 9) {
      if (*(azArg + i)) {
        tmp___8 = strlenChar((char const   *)*(azArg + i));
        if (tmp___8 > w___2) {
          w___2 = strlenChar((char const   *)*(azArg + i));
        }
      }
    }
    if (i == 1) {
      if (p->aiIndent) {
        if (p->pStmt) {
          if (p->iIndent < p->nIndent) {
            fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%*.s",
                    *(p->aiIndent + p->iIndent), "");
          }
          (p->iIndent) ++;
        }
      }
    }
    if (*(azArg + i)) {
      tmp___9 = *(azArg + i);
    } else {
      tmp___9 = p->nullValue;
    }
    utf8_width_print(p->out, w___2, (char const   *)tmp___9);
    if (i == nArg - 1) {
      tmp___10 = (char const   *)rowSep;
    } else {
      tmp___10 = "  ";
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", tmp___10);
    i ++;
  }
  break;
  case 3: 
  printSchemaLine(p->out, (char const   *)*(azArg + 0), ";\n");
  break;
  case 11: 
  nParen = 0;
  cEnd = (char)0;
  nLine = 0;
  if (! (nArg == 1)) {
    __assert_fail("nArg==1", "shell.c", 10483U, "shell_callback");
  }
  if ((unsigned long )*(azArg + 0) == (unsigned long )((char *)0)) {
    break;
  }
  tmp___12 = sqlite3_strlike("CREATE VIEW%", (char const   *)*(azArg + 0), 0U);
  if (tmp___12 == 0) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s;\n", *(azArg + 0));
    break;
  } else {
    tmp___13 = sqlite3_strlike("CREATE TRIG%", (char const   *)*(azArg + 0), 0U);
    if (tmp___13 == 0) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s;\n", *(azArg + 0));
      break;
    }
  }
  z = sqlite3_mprintf("%s", *(azArg + 0));
  j = 0;
  i = 0;
  while (1) {
    tmp___14 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___14 + (int )((unsigned char )*(z + i))) & 8192)) {
      break;
    }
    i ++;
  }
  while (1) {
    c = *(z + i);
    if (! ((int )c != 0)) {
      break;
    }
    tmp___17 = __ctype_b_loc();
    if ((int const   )*(*tmp___17 + (int )((unsigned char )c)) & 8192) {
      if ((int )*(z + (j - 1)) == 13) {
        *(z + (j - 1)) = (char )'\n';
      }
      tmp___15 = __ctype_b_loc();
      if ((int const   )*(*tmp___15 + (int )((unsigned char )*(z + (j - 1)))) & 8192) {
        goto __Cont;
      } else
      if ((int )*(z + (j - 1)) == 40) {
        goto __Cont;
      }
    } else
    if ((int )c == 40) {
      goto _L;
    } else
    if ((int )c == 41) {
      _L: /* CIL Label */ 
      if (j > 0) {
        tmp___16 = __ctype_b_loc();
        if ((int const   )*(*tmp___16 + (int )((unsigned char )*(z + (j - 1)))) & 8192) {
          j --;
        }
      }
    }
    tmp___18 = j;
    j ++;
    *(z + tmp___18) = c;
    __Cont: /* CIL Label */ 
    i ++;
  }
  while (1) {
    if (j > 0) {
      tmp___19 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___19 + (int )((unsigned char )*(z + (j - 1)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    j --;
  }
  *(z + j) = (char)0;
  tmp___23 = strlen30((char const   *)z);
  if (tmp___23 >= 79) {
    j = 0;
    i = j;
    while (1) {
      c = *(z + i);
      if (! ((int )c != 0)) {
        break;
      }
      if ((int )c == (int )cEnd) {
        cEnd = (char)0;
      } else
      if ((int )c == 34) {
        cEnd = c;
      } else
      if ((int )c == 39) {
        cEnd = c;
      } else
      if ((int )c == 96) {
        cEnd = c;
      } else
      if ((int )c == 91) {
        cEnd = (char )']';
      } else
      if ((int )c == 45) {
        if ((int )*(z + (i + 1)) == 45) {
          cEnd = (char )'\n';
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if ((int )c == 40) {
        nParen ++;
      } else
      if ((int )c == 41) {
        nParen --;
        if (nLine > 0) {
          if (nParen == 0) {
            if (j > 0) {
              printSchemaLineN(p->out, z, j, "\n");
              j = 0;
            }
          }
        }
      }
      tmp___20 = j;
      j ++;
      *(z + tmp___20) = c;
      if (nParen == 1) {
        if ((int )cEnd == 0) {
          if ((int )c == 40) {
            goto _L___1;
          } else
          if ((int )c == 10) {
            goto _L___1;
          } else
          if ((int )c == 44) {
            tmp___22 = wsToEol((char const   *)((z + i) + 1));
            if (! tmp___22) {
              _L___1: /* CIL Label */ 
              if ((int )c == 10) {
                j --;
              }
              printSchemaLineN(p->out, z, j, "\n  ");
              j = 0;
              nLine ++;
              while (1) {
                tmp___21 = __ctype_b_loc();
                if (! ((int const   )*(*tmp___21 + (int )((unsigned char )*(z + (i + 1)))) & 8192)) {
                  break;
                }
                i ++;
              }
            }
          }
        }
      }
      i ++;
    }
    *(z + j) = (char)0;
  }
  printSchemaLine(p->out, (char const   *)z, ";\n");
  sqlite3_free((void *)z);
  break;
  case 2: 
  tmp___25 = p->cnt;
  (p->cnt) ++;
  if (tmp___25 == 0) {
    if (p->showHeader) {
      i = 0;
      while (i < nArg) {
        if (i == nArg - 1) {
          tmp___24 = p->rowSeparator;
        } else {
          tmp___24 = p->colSeparator;
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s%s",
                *(azCol + i), tmp___24);
        i ++;
      }
    }
  }
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  i = 0;
  while (i < nArg) {
    z___0 = *(azArg + i);
    if ((unsigned long )z___0 == (unsigned long )((char *)0)) {
      z___0 = p->nullValue;
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", z___0);
    if (i < nArg - 1) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->colSeparator);
    } else {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
    }
    i ++;
  }
  break;
  case 4: 
  tmp___26 = p->cnt;
  (p->cnt) ++;
  if (tmp___26 == 0) {
    if (p->showHeader) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"<TR>");
      i = 0;
      while (i < nArg) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"<TH>");
        output_html_string(p->out, (char const   *)*(azCol + i));
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"</TH>\n");
        i ++;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"</TR>\n");
    }
  }
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"<TR>");
  i = 0;
  while (i < nArg) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"<TD>");
    if (*(azArg + i)) {
      tmp___27 = *(azArg + i);
    } else {
      tmp___27 = p->nullValue;
    }
    output_html_string(p->out, (char const   *)tmp___27);
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"</TD>\n");
    i ++;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"</TR>\n");
  break;
  case 7: 
  tmp___29 = p->cnt;
  (p->cnt) ++;
  if (tmp___29 == 0) {
    if (p->showHeader) {
      i = 0;
      while (i < nArg) {
        if (*(azCol + i)) {
          tmp___28 = (char const   *)*(azCol + i);
        } else {
          tmp___28 = "";
        }
        output_c_string(p->out, tmp___28);
        if (i < nArg - 1) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s",
                  p->colSeparator);
        }
        i ++;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
    }
  }
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  i = 0;
  while (i < nArg) {
    if (*(azArg + i)) {
      tmp___30 = *(azArg + i);
    } else {
      tmp___30 = p->nullValue;
    }
    output_c_string(p->out, (char const   *)tmp___30);
    if (i < nArg - 1) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->colSeparator);
    }
    i ++;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
  break;
  case 8: 
  tmp___32 = p->cnt;
  (p->cnt) ++;
  if (tmp___32 == 0) {
    if (p->showHeader) {
      i = 0;
      while (i < nArg) {
        if (*(azCol + i)) {
          tmp___31 = (char const   *)*(azCol + i);
        } else {
          tmp___31 = "";
        }
        output_csv(p, tmp___31, i < nArg - 1);
        i ++;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
    }
  }
  if (nArg > 0) {
    i = 0;
    while (i < nArg) {
      output_csv(p, (char const   *)*(azArg + i), i < nArg - 1);
      i ++;
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
  }
  break;
  case 5: 
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"INSERT INTO %s",
          p->zDestTable);
  if (p->showHeader) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"(");
    i = 0;
    while (i < nArg) {
      if (i > 0) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )",");
      }
      tmp___34 = quoteChar((char const   *)*(azCol + i));
      if (tmp___34) {
        tmp___33 = sqlite3_mprintf("\"%w\"", *(azCol + i));
        z___1 = tmp___33;
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", z___1);
        sqlite3_free((void *)z___1);
      } else {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", *(azCol + i));
      }
      i ++;
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )")");
  }
  (p->cnt) ++;
  i = 0;
  while (i < nArg) {
    if (i > 0) {
      tmp___35 = ",";
    } else {
      tmp___35 = " VALUES(";
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )tmp___35);
    if ((unsigned long )*(azArg + i) == (unsigned long )((char *)0)) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"NULL");
    } else
    if (aiType) {
      if (*(aiType + i) == 5) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"NULL");
      } else {
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 3) {
        if ((p->shellFlgs & 16U) != 0U) {
          output_quoted_string(p->out, (char const   *)*(azArg + i));
        } else {
          output_quoted_escaped_string(p->out, (char const   *)*(azArg + i));
        }
      } else {
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 1) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", *(azArg + i));
      } else {
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 2) {
        tmp___36 = sqlite3_column_double(p->pStmt, i);
        r = tmp___36;
        memcpy((void * __restrict  )(& ur), (void const   * __restrict  )(& r), sizeof(r));
        if (ur == 9218868437227405312ULL) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"1e999");
        } else
        if (ur == 0xfff0000000000000ULL) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"-1e999");
        } else {
          sqlite3_snprintf(50, z___2, "%!.20g", r);
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s",
                  z___2);
        }
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 4) {
        if (p->pStmt) {
          tmp___37 = sqlite3_column_blob(p->pStmt, i);
          pBlob = tmp___37;
          tmp___38 = sqlite3_column_bytes(p->pStmt, i);
          nBlob = tmp___38;
          output_hex_blob(p->out, pBlob, nBlob);
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      tmp___39 = isNumber((char const   *)*(azArg + i), (int *)0);
      if (tmp___39) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", *(azArg + i));
      } else
      if ((p->shellFlgs & 16U) != 0U) {
        output_quoted_string(p->out, (char const   *)*(azArg + i));
      } else {
        output_quoted_escaped_string(p->out, (char const   *)*(azArg + i));
      }
    }
    i ++;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )");\n");
  break;
  case 6: 
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  if (p->cnt == 0) {
    if (p->showHeader) {
      i = 0;
      while (i < nArg) {
        if (i > 0) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )",");
        }
        output_quoted_string(p->out, (char const   *)*(azCol + i));
        i ++;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
    }
  }
  (p->cnt) ++;
  i = 0;
  while (i < nArg) {
    if (i > 0) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )",");
    }
    if ((unsigned long )*(azArg + i) == (unsigned long )((char *)0)) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"NULL");
    } else
    if (aiType) {
      if (*(aiType + i) == 5) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"NULL");
      } else {
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 3) {
        output_quoted_string(p->out, (char const   *)*(azArg + i));
      } else {
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 1) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", *(azArg + i));
      } else {
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 2) {
        tmp___40 = sqlite3_column_double(p->pStmt, i);
        r___0 = tmp___40;
        sqlite3_snprintf(50, z___3, "%!.20g", r___0);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", z___3);
      } else {
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
    if (aiType) {
      if (*(aiType + i) == 4) {
        if (p->pStmt) {
          tmp___41 = sqlite3_column_blob(p->pStmt, i);
          pBlob___0 = tmp___41;
          tmp___42 = sqlite3_column_bytes(p->pStmt, i);
          nBlob___0 = tmp___42;
          output_hex_blob(p->out, pBlob___0, nBlob___0);
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ 
      tmp___43 = isNumber((char const   *)*(azArg + i), (int *)0);
      if (tmp___43) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", *(azArg + i));
      } else {
        output_quoted_string(p->out, (char const   *)*(azArg + i));
      }
    }
    i ++;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
  break;
  case 10: 
  tmp___45 = p->cnt;
  (p->cnt) ++;
  if (tmp___45 == 0) {
    if (p->showHeader) {
      i = 0;
      while (i < nArg) {
        if (i > 0) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s",
                  p->colSeparator);
        }
        if (*(azCol + i)) {
          tmp___44 = (char const   *)*(azCol + i);
        } else {
          tmp___44 = "";
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", tmp___44);
        i ++;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
    }
  }
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    break;
  }
  i = 0;
  while (i < nArg) {
    if (i > 0) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->colSeparator);
    }
    if (*(azArg + i)) {
      tmp___46 = *(azArg + i);
    } else {
      tmp___46 = p->nullValue;
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", tmp___46);
    i ++;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", p->rowSeparator);
  break;
  case 12: 
  tmp___47 = atoi((char const   *)*(azArg + 1));
  tmp___48 = atoi((char const   *)*(azArg + 0));
  eqp_append(p, tmp___48, tmp___47, (char const   *)*(azArg + 3));
  break;
  }
  return (0);
}
}
static int callback(void *pArg , int nArg , char **azArg , char **azCol ) 
{ 
  int tmp ;

  {
  tmp = shell_callback(pArg, nArg, azArg, azCol, (int *)((void *)0));
  return (tmp);
}
}
static int captureOutputCallback(void *pArg , int nArg , char **azArg , char **az___0 ) 
{ 
  ShellText *p ;
  int i ;

  {
  p = (ShellText *)pArg;
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    return (0);
  }
  if (p->n) {
    appendText(p, "|", (char)0);
  }
  i = 0;
  while (i < nArg) {
    if (i) {
      appendText(p, ",", (char)0);
    }
    if (*(azArg + i)) {
      appendText(p, (char const   *)*(azArg + i), (char)0);
    }
    i ++;
  }
  return (0);
}
}
static void createSelftestTable(ShellState *p ) 
{ 
  char *zErrMsg ;

  {
  zErrMsg = (char *)0;
  sqlite3_exec(p->db, "SAVEPOINT selftest_init;\nCREATE TABLE IF NOT EXISTS selftest(\n  tno INTEGER PRIMARY KEY,\n  op TEXT,\n  cmd TEXT,\n  ans TEXT\n);CREATE TEMP TABLE [_shell$self](op,cmd,ans);\nINSERT INTO [_shell$self](rowid,op,cmd)\n  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n         \'memo\',\'Tests generated by --init\');\nINSERT INTO [_shell$self]\n  SELECT \'run\',\n    \'SELECT hex(sha3_query(\'\'SELECT type,name,tbl_name,sql FROM sqlite_master ORDER BY 2\'\',224))\',\n    hex(sha3_query(\'SELECT type,name,tbl_name,sql FROM sqlite_master ORDER BY 2\',224));\nINSERT INTO [_shell$self]\n  SELECT \'run\',    \'SELECT hex(sha3_query(\'\'SELECT * FROM \"\' ||        printf(\'%w\',name) || \'\" NOT INDEXED\'\',224))\',\n    hex(sha3_query(printf(\'SELECT * FROM \"%w\" NOT INDEXED\',name),224))\n  FROM (\n    SELECT name FROM sqlite_master\n     WHERE type=\'table\'\n       AND name<>\'selftest\'\n       AND coalesce(rootpage,0)>0\n  )\n ORDER BY name;\nINSERT INTO [_shell$self]\n  VALUES(\'run\',\'PRAGMA integrity_check\',\'ok\');\nINSERT INTO selftest(tno,op,cmd,ans)  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\nDROP TABLE [_shell$self];",
               (int (*)(void * , int  , char ** , char ** ))0, (void *)0, & zErrMsg);
  if (zErrMsg) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SELFTEST initialization failure: %s\n",
            zErrMsg);
    sqlite3_free((void *)zErrMsg);
  }
  sqlite3_exec(p->db, "RELEASE selftest_init", (int (*)(void * , int  , char ** ,
                                                        char ** ))0, (void *)0, (char **)0);
  return;
}
}
static void set_table_name(ShellState *p , char const   *zName ) 
{ 
  int i ;
  int n ;
  char cQuote ;
  char *z ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (p->zDestTable) {
    free((void *)p->zDestTable);
    p->zDestTable = (char *)0;
  }
  if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
    return;
  }
  cQuote = quoteChar(zName);
  n = strlen30(zName);
  if (cQuote) {
    n += n + 2;
  }
  tmp___0 = malloc((size_t )(n + 1));
  tmp = (char *)tmp___0;
  p->zDestTable = tmp;
  z = tmp;
  if ((unsigned long )z == (unsigned long )((char *)0)) {
    shell_out_of_memory();
  }
  n = 0;
  if (cQuote) {
    tmp___1 = n;
    n ++;
    *(z + tmp___1) = cQuote;
  }
  i = 0;
  while (*(zName + i)) {
    tmp___2 = n;
    n ++;
    *(z + tmp___2) = (char )*(zName + i);
    if ((int const   )*(zName + i) == (int const   )cQuote) {
      tmp___3 = n;
      n ++;
      *(z + tmp___3) = cQuote;
    }
    i ++;
  }
  if (cQuote) {
    tmp___4 = n;
    n ++;
    *(z + tmp___4) = cQuote;
  }
  *(z + n) = (char)0;
  return;
}
}
static int run_table_dump_query(ShellState *p , char const   *zSelect , char const   *zFirstRow ) 
{ 
  sqlite3_stmt *pSelect ;
  int rc ;
  int nResult ;
  int i ;
  char const   *z ;
  char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  rc = sqlite3_prepare_v2(p->db, zSelect, -1, & pSelect, (char const   **)0);
  if (rc != 0) {
    goto _L;
  } else
  if (! pSelect) {
    _L: /* CIL Label */ 
    tmp = sqlite3_errmsg(p->db);
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/**** ERROR: (%d) %s *****/\n",
            rc, tmp);
    if ((rc & 255) != 11) {
      (p->nErr) ++;
    }
    return (rc);
  }
  rc = sqlite3_step(pSelect);
  nResult = sqlite3_column_count(pSelect);
  while (rc == 100) {
    if (zFirstRow) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", zFirstRow);
      zFirstRow = (char const   *)0;
    }
    tmp___0 = sqlite3_column_text(pSelect, 0);
    z = (char const   *)tmp___0;
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s", z);
    i = 1;
    while (i < nResult) {
      tmp___1 = sqlite3_column_text(pSelect, i);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )",%s", tmp___1);
      i ++;
    }
    if ((unsigned long )z == (unsigned long )((char const   *)0)) {
      z = "";
    }
    while (1) {
      if (*(z + 0)) {
        if (! ((int const   )*(z + 0) != 45)) {
          if (! ((int const   )*(z + 1) != 45)) {
            break;
          }
        }
      } else {
        break;
      }
      z ++;
    }
    if (*(z + 0)) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n;\n");
    } else {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )";\n");
    }
    rc = sqlite3_step(pSelect);
  }
  rc = sqlite3_finalize(pSelect);
  if (rc != 0) {
    tmp___2 = sqlite3_errmsg(p->db);
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/**** ERROR: (%d) %s *****/\n",
            rc, tmp___2);
    if ((rc & 255) != 11) {
      (p->nErr) ++;
    }
  }
  return (rc);
}
}
static char *save_err_msg(sqlite3 *db ) 
{ 
  int nErrMsg ;
  char const   *tmp ;
  int tmp___0 ;
  char *zErrMsg ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  tmp = sqlite3_errmsg(db);
  tmp___0 = strlen30(tmp);
  nErrMsg = 1 + tmp___0;
  tmp___1 = sqlite3_malloc64((sqlite_uint64 )nErrMsg);
  zErrMsg = (char *)tmp___1;
  if (zErrMsg) {
    tmp___2 = sqlite3_errmsg(db);
    memcpy((void * __restrict  )zErrMsg, (void const   * __restrict  )tmp___2, (size_t )nErrMsg);
  }
  return (zErrMsg);
}
}
static void displayLinuxIoStats(FILE *out ) ;
static struct __anonstruct_aTrans_527861670  const  aTrans[7]  = {      {"rchar: ", "Bytes received by read():"}, 
        {"wchar: ", "Bytes sent to write():"}, 
        {"syscr: ", "Read() system calls:"}, 
        {"syscw: ", "Write() system calls:"}, 
        {"read_bytes: ", "Bytes read from storage:"}, 
        {"write_bytes: ", "Bytes written to storage:"}, 
        {"cancelled_write_bytes: ", "Cancelled write bytes:"}};
static void displayLinuxIoStats(FILE *out ) 
{ 
  FILE *in ;
  char z[200] ;
  __pid_t tmp ;
  int i ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  tmp = getpid();
  sqlite3_snprintf((int )sizeof(z), z, "/proc/%d/io", tmp);
  in = fopen((char const   * __restrict  )(z), (char const   * __restrict  )"rb");
  if ((unsigned long )in == (unsigned long )((FILE *)0)) {
    return;
  }
  while (1) {
    tmp___2 = fgets((char * __restrict  )(z), (int )sizeof(z), (FILE * __restrict  )in);
    if (! ((unsigned long )tmp___2 != (unsigned long )((char *)0))) {
      break;
    }
    i = 0;
    while (i < (int )(sizeof(aTrans) / sizeof(aTrans[0]))) {
      tmp___0 = strlen30((char const   *)aTrans[i].zPattern);
      n = tmp___0;
      tmp___1 = strncmp((char const   *)aTrans[i].zPattern, (char const   *)(z), (size_t )n);
      if (tmp___1 == 0) {
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%-36s %s",
                aTrans[i].zDesc, & z[n]);
        break;
      }
      i ++;
    }
  }
  fclose(in);
  return;
}
}
static void displayStatLine(ShellState *p , char *zLabel , char *zFormat , int iStatusCtrl ,
                            int bReset ) 
{ 
  sqlite_int64 iCur ;
  sqlite_int64 iHiwtr ;
  int i ;
  int nPercent ;
  char zLine[200] ;

  {
  iCur = (sqlite_int64 )-1;
  iHiwtr = (sqlite_int64 )-1;
  sqlite3_status64(iStatusCtrl, & iCur, & iHiwtr, bReset);
  i = 0;
  nPercent = 0;
  while (*(zFormat + i)) {
    if ((int )*(zFormat + i) == 37) {
      nPercent ++;
    }
    i ++;
  }
  if (nPercent > 1) {
    sqlite3_snprintf((int )sizeof(zLine), zLine, (char const   *)zFormat, iCur, iHiwtr);
  } else {
    sqlite3_snprintf((int )sizeof(zLine), zLine, (char const   *)zFormat, iHiwtr);
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-36s %s\n",
          zLabel, zLine);
  return;
}
}
static int display_stats(sqlite3 *db , ShellState *pArg , int bReset ) 
{ 
  int iCur ;
  int iHiwtr ;
  FILE *out ;
  int nCol ;
  int i ;
  int x___0 ;
  sqlite3_stmt *pStmt ;
  char z[100] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((unsigned long )pArg == (unsigned long )((ShellState *)0)) {
    return (0);
  } else
  if ((unsigned long )pArg->out == (unsigned long )((FILE *)0)) {
    return (0);
  }
  out = pArg->out;
  if (pArg->pStmt) {
    if ((int )pArg->statsOn & 2) {
      pStmt = pArg->pStmt;
      nCol = sqlite3_column_count(pStmt);
      fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%-36s %d\n",
              "Number of output columns:", nCol);
      i = 0;
      while (i < nCol) {
        sqlite3_snprintf((int )sizeof(z), z, "Column %d %nname:", i, & x___0);
        tmp = sqlite3_column_name(pStmt, i);
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%-36s %s\n",
                z, tmp);
        sqlite3_snprintf(30, z + x___0, "declared type:");
        tmp___0 = sqlite3_column_decltype(pStmt, i);
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%-36s %s\n",
                z, tmp___0);
        i ++;
      }
    }
  }
  displayStatLine(pArg, (char *)"Memory Used:", (char *)"%lld (max %lld) bytes", 0,
                  bReset);
  displayStatLine(pArg, (char *)"Number of Outstanding Allocations:", (char *)"%lld (max %lld)",
                  9, bReset);
  if (pArg->shellFlgs & 1U) {
    displayStatLine(pArg, (char *)"Number of Pcache Pages Used:", (char *)"%lld (max %lld) pages",
                    1, bReset);
  }
  displayStatLine(pArg, (char *)"Number of Pcache Overflow Bytes:", (char *)"%lld (max %lld) bytes",
                  2, bReset);
  displayStatLine(pArg, (char *)"Largest Allocation:", (char *)"%lld bytes", 5, bReset);
  displayStatLine(pArg, (char *)"Largest Pcache Allocation:", (char *)"%lld bytes",
                  7, bReset);
  if (db) {
    if (pArg->shellFlgs & 2U) {
      iCur = -1;
      iHiwtr = iCur;
      sqlite3_db_status(db, 0, & iCur, & iHiwtr, bReset);
      fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Lookaside Slots Used:                %d (max %d)\n",
              iCur, iHiwtr);
      sqlite3_db_status(db, 4, & iCur, & iHiwtr, bReset);
      fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Successful lookaside attempts:       %d\n",
              iHiwtr);
      sqlite3_db_status(db, 5, & iCur, & iHiwtr, bReset);
      fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Lookaside failures due to size:      %d\n",
              iHiwtr);
      sqlite3_db_status(db, 6, & iCur, & iHiwtr, bReset);
      fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Lookaside failures due to OOM:       %d\n",
              iHiwtr);
    }
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 1, & iCur, & iHiwtr, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Pager Heap Usage:                    %d bytes\n",
            iCur);
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 7, & iCur, & iHiwtr, 1);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Page cache hits:                     %d\n",
            iCur);
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 8, & iCur, & iHiwtr, 1);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Page cache misses:                   %d\n",
            iCur);
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 9, & iCur, & iHiwtr, 1);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Page cache writes:                   %d\n",
            iCur);
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 12, & iCur, & iHiwtr, 1);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Page cache spills:                   %d\n",
            iCur);
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 2, & iCur, & iHiwtr, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Schema Heap Usage:                   %d bytes\n",
            iCur);
    iCur = -1;
    iHiwtr = iCur;
    sqlite3_db_status(db, 3, & iCur, & iHiwtr, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Statement Heap/Lookaside Usage:      %d bytes\n",
            iCur);
  }
  if (pArg->pStmt) {
    iCur = sqlite3_stmt_status(pArg->pStmt, 1, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Fullscan Steps:                      %d\n",
            iCur);
    iCur = sqlite3_stmt_status(pArg->pStmt, 2, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Sort Operations:                     %d\n",
            iCur);
    iCur = sqlite3_stmt_status(pArg->pStmt, 3, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Autoindex Inserts:                   %d\n",
            iCur);
    iCur = sqlite3_stmt_status(pArg->pStmt, 4, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Virtual Machine Steps:               %d\n",
            iCur);
    iCur = sqlite3_stmt_status(pArg->pStmt, 5, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Reprepare operations:                %d\n",
            iCur);
    iCur = sqlite3_stmt_status(pArg->pStmt, 6, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Number of times run:                 %d\n",
            iCur);
    iCur = sqlite3_stmt_status(pArg->pStmt, 99, bReset);
    fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"Memory used by prepared stmt:        %d\n",
            iCur);
  }
  displayLinuxIoStats(pArg->out);
  return (0);
}
}
static void display_scanstats(sqlite3 *db , ShellState *pArg ) 
{ 


  {
  return;
}
}
static int str_in_array(char const   *zStr , char const   **azArray ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (*(azArray + i)) {
    tmp = strcmp(zStr, *(azArray + i));
    if (0 == tmp) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static void explain_data_prepare(ShellState *p , sqlite3_stmt *pSql ) ;
static char const   *explainCols[8]  = 
  {      "addr",      "opcode",      "p1",      "p2", 
        "p3",      "p4",      "p5",      "comment"};
static void explain_data_prepare(ShellState *p , sqlite3_stmt *pSql ) 
{ 
  char const   *zSql ;
  char const   *z ;
  int *abYield ;
  int nAlloc ;
  int iOp ;
  char const   *azNext[6] ;
  char const   *azYield[6] ;
  char const   *azGoto[2] ;
  int tmp ;
  int tmp___0 ;
  int i ;
  int iAddr ;
  int tmp___1 ;
  char const   *zOp ;
  unsigned char const   *tmp___2 ;
  int p2 ;
  int tmp___3 ;
  int p2op ;
  int jj ;
  char const   *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  abYield = (int *)0;
  nAlloc = 0;
  azNext[0] = "Next";
  azNext[1] = "Prev";
  azNext[2] = "VPrev";
  azNext[3] = "VNext";
  azNext[4] = "SorterNext";
  azNext[5] = (char const   *)0;
  azYield[0] = "Yield";
  azYield[1] = "SeekLT";
  azYield[2] = "SeekGT";
  azYield[3] = "RowSetRead";
  azYield[4] = "Rewind";
  azYield[5] = (char const   *)0;
  azGoto[0] = "Goto";
  azGoto[1] = (char const   *)0;
  tmp = sqlite3_column_count(pSql);
  if (tmp != 8) {
    p->cMode = p->mode;
    return;
  }
  zSql = sqlite3_sql(pSql);
  if ((unsigned long )zSql == (unsigned long )((char const   *)0)) {
    return;
  }
  z = zSql;
  while (1) {
    if (! ((int const   )*z == 32)) {
      if (! ((int const   )*z == 9)) {
        if (! ((int const   )*z == 10)) {
          if (! ((int const   )*z == 12)) {
            if (! ((int const   )*z == 13)) {
              break;
            }
          }
        }
      }
    }
    z ++;
  }
  tmp___0 = sqlite3_strnicmp(z, "explain", 7);
  if (tmp___0) {
    p->cMode = p->mode;
    return;
  }
  iOp = 0;
  while (1) {
    tmp___11 = sqlite3_step(pSql);
    if (! (100 == tmp___11)) {
      break;
    }
    tmp___1 = sqlite3_column_int(pSql, 0);
    iAddr = tmp___1;
    tmp___2 = sqlite3_column_text(pSql, 1);
    zOp = (char const   *)tmp___2;
    tmp___3 = sqlite3_column_int(pSql, 3);
    p2 = tmp___3;
    p2op = p2 + (iOp - iAddr);
    if (iOp >= nAlloc) {
      if (iOp == 0) {
        jj = 0;
        while (jj < (int )(sizeof(explainCols) / sizeof(explainCols[0]))) {
          tmp___4 = sqlite3_column_name(pSql, jj);
          tmp___5 = strcmp(tmp___4, explainCols[jj]);
          if (tmp___5 != 0) {
            p->cMode = p->mode;
            sqlite3_reset(pSql);
            return;
          }
          jj ++;
        }
      }
      nAlloc += 100;
      tmp___6 = sqlite3_realloc64((void *)p->aiIndent, (sqlite_uint64 )((unsigned long )nAlloc * sizeof(int )));
      p->aiIndent = (int *)tmp___6;
      if ((unsigned long )p->aiIndent == (unsigned long )((int *)0)) {
        shell_out_of_memory();
      }
      tmp___7 = sqlite3_realloc64((void *)abYield, (sqlite_uint64 )((unsigned long )nAlloc * sizeof(int )));
      abYield = (int *)tmp___7;
      if ((unsigned long )abYield == (unsigned long )((int *)0)) {
        shell_out_of_memory();
      }
    }
    *(abYield + iOp) = str_in_array(zOp, azYield);
    *(p->aiIndent + iOp) = 0;
    p->nIndent = iOp + 1;
    tmp___8 = str_in_array(zOp, azNext);
    if (tmp___8) {
      i = p2op;
      while (i < iOp) {
        *(p->aiIndent + i) += 2;
        i ++;
      }
    }
    tmp___9 = str_in_array(zOp, azGoto);
    if (tmp___9) {
      if (p2op < p->nIndent) {
        if (*(abYield + p2op)) {
          goto _L;
        } else {
          tmp___10 = sqlite3_column_int(pSql, 2);
          if (tmp___10) {
            _L: /* CIL Label */ 
            i = p2op;
            while (i < iOp) {
              *(p->aiIndent + i) += 2;
              i ++;
            }
          }
        }
      }
    }
    iOp ++;
  }
  p->iIndent = 0;
  sqlite3_free((void *)abYield);
  sqlite3_reset(pSql);
  return;
}
}
static void explain_data_delete(ShellState *p ) 
{ 


  {
  sqlite3_free((void *)p->aiIndent);
  p->aiIndent = (int *)0;
  p->nIndent = 0;
  p->iIndent = 0;
  return;
}
}
static void disable_debug_trace_modes(void) 
{ 


  {
  return;
}
}
static void restore_debug_trace_modes(void) 
{ 


  {
  return;
}
}
static void bind_table_init(ShellState *p ) 
{ 
  int wrSchema ;

  {
  wrSchema = 0;
  sqlite3_db_config(p->db, 1011, -1, & wrSchema);
  sqlite3_db_config(p->db, 1011, 1, 0);
  sqlite3_exec(p->db, "CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n  key TEXT PRIMARY KEY,\n  value ANY\n) WITHOUT ROWID;",
               (int (*)(void * , int  , char ** , char ** ))0, (void *)0, (char **)0);
  sqlite3_db_config(p->db, 1011, wrSchema, 0);
  return;
}
}
static void bind_prepared_stmt(ShellState *pArg , sqlite3_stmt *pStmt ) 
{ 
  int nVar ;
  int i ;
  int rc ;
  sqlite3_stmt *pQ ;
  int tmp ;
  char zNum[30] ;
  char const   *zVar ;
  char const   *tmp___0 ;
  sqlite3_value *tmp___1 ;
  int tmp___2 ;

  {
  pQ = (sqlite3_stmt *)0;
  nVar = sqlite3_bind_parameter_count(pStmt);
  if (nVar == 0) {
    return;
  }
  tmp = sqlite3_table_column_metadata(pArg->db, "TEMP", "sqlite_parameters", "key",
                                      (char const   **)0, (char const   **)0, (int *)0,
                                      (int *)0, (int *)0);
  if (tmp != 0) {
    return;
  }
  rc = sqlite3_prepare_v2(pArg->db, "SELECT value FROM temp.sqlite_parameters WHERE key=?1",
                          -1, & pQ, (char const   **)0);
  if (rc) {
    return;
  } else
  if ((unsigned long )pQ == (unsigned long )((sqlite3_stmt *)0)) {
    return;
  }
  i = 1;
  while (i <= nVar) {
    tmp___0 = sqlite3_bind_parameter_name(pStmt, i);
    zVar = tmp___0;
    if ((unsigned long )zVar == (unsigned long )((char const   *)0)) {
      sqlite3_snprintf((int )sizeof(zNum), zNum, "?%d", i);
      zVar = (char const   *)(zNum);
    }
    sqlite3_bind_text(pQ, 1, zVar, -1, (void (*)(void * ))0);
    tmp___2 = sqlite3_step(pQ);
    if (tmp___2 == 100) {
      tmp___1 = sqlite3_column_value(pQ, 0);
      sqlite3_bind_value(pStmt, i, (sqlite3_value const   *)tmp___1);
    } else {
      sqlite3_bind_null(pStmt, i);
    }
    sqlite3_reset(pQ);
    i ++;
  }
  sqlite3_finalize(pQ);
  return;
}
}
static void exec_prepared_stmt(ShellState *pArg , sqlite3_stmt *pStmt ) 
{ 
  int rc ;
  int nCol ;
  int tmp ;
  void *pData ;
  void *tmp___0 ;
  char **azCols ;
  char **azVals ;
  int *aiTypes ;
  int i ;
  int x___0 ;
  char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;

  {
  rc = sqlite3_step(pStmt);
  if (100 == rc) {
    tmp = sqlite3_column_count(pStmt);
    nCol = tmp;
    tmp___0 = sqlite3_malloc64((sqlite_uint64 )((unsigned long )(3 * nCol) * sizeof(char const   *) + 1UL));
    pData = tmp___0;
    if (! pData) {
      rc = 7;
    } else {
      azCols = (char **)pData;
      azVals = azCols + nCol;
      aiTypes = (int *)(azVals + nCol);
      if (! (sizeof(int ) <= sizeof(char *))) {
        __assert_fail("sizeof(int) <= sizeof(char *)", "shell.c", 11387U, "exec_prepared_stmt");
      }
      i = 0;
      while (i < nCol) {
        tmp___2 = sqlite3_column_name(pStmt, i);
        *(azCols + i) = (char *)tmp___2;
        i ++;
      }
      while (1) {
        i = 0;
        while (i < nCol) {
          x___0 = sqlite3_column_type(pStmt, i);
          *(aiTypes + i) = x___0;
          if (x___0 == 4) {
            if (pArg) {
              if (pArg->cMode == 5) {
                *(azVals + i) = (char *)"";
              } else {
                tmp___3 = sqlite3_column_text(pStmt, i);
                *(azVals + i) = (char *)tmp___3;
              }
            } else {
              tmp___3 = sqlite3_column_text(pStmt, i);
              *(azVals + i) = (char *)tmp___3;
            }
          } else {
            tmp___3 = sqlite3_column_text(pStmt, i);
            *(azVals + i) = (char *)tmp___3;
          }
          if (! *(azVals + i)) {
            if (*(aiTypes + i) != 5) {
              rc = 7;
              break;
            }
          }
          i ++;
        }
        if (100 == rc) {
          tmp___4 = shell_callback((void *)pArg, nCol, azVals, azCols, aiTypes);
          if (tmp___4) {
            rc = 4;
          } else {
            rc = sqlite3_step(pStmt);
          }
        }
        if (! (100 == rc)) {
          break;
        }
      }
      sqlite3_free(pData);
    }
  }
  return;
}
}
static int expertHandleSQL(ShellState *pState , char const   *zSql , char **pzErr ) 
{ 
  int tmp___1 ;

  {
  if (! pState->expert.pExpert) {
    __assert_fail("pState->expert.pExpert", "shell.c", 11438U, "expertHandleSQL");
  }
  if (! ((unsigned long )pzErr == (unsigned long )((char **)0))) {
    if (! ((unsigned long )*pzErr == (unsigned long )((char *)0))) {
      __assert_fail("pzErr==0 || *pzErr==0", "shell.c", 11439U, "expertHandleSQL");
    }
  }
  tmp___1 = sqlite3_expert_sql(pState->expert.pExpert, zSql, pzErr);
  return (tmp___1);
}
}
static int expertFinish(ShellState *pState , int bCancel , char **pzErr ) 
{ 
  int rc ;
  sqlite3expert *p ;
  FILE *out ;
  int bVerbose ;
  int nQuery ;
  int tmp___1 ;
  int i ;
  char const   *zCand ;
  char const   *tmp___2 ;
  char const   *zSql ;
  char const   *tmp___3 ;
  char const   *zIdx ;
  char const   *tmp___4 ;
  char const   *zEQP ;
  char const   *tmp___5 ;

  {
  rc = 0;
  p = pState->expert.pExpert;
  if (! p) {
    __assert_fail("p", "shell.c", 11460U, "expertFinish");
  }
  if (! bCancel) {
    if (! ((unsigned long )pzErr == (unsigned long )((char **)0))) {
      if (! ((unsigned long )*pzErr == (unsigned long )((char *)0))) {
        __assert_fail("bCancel || pzErr==0 || *pzErr==0", "shell.c", 11461U, "expertFinish");
      }
    }
  }
  if (bCancel == 0) {
    out = pState->out;
    bVerbose = pState->expert.bVerbose;
    rc = sqlite3_expert_analyze(p, pzErr);
    if (rc == 0) {
      tmp___1 = sqlite3_expert_count(p);
      nQuery = tmp___1;
      if (bVerbose) {
        tmp___2 = sqlite3_expert_report(p, 0, 4);
        zCand = tmp___2;
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"-- Candidates -----------------------------\n");
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n", zCand);
      }
      i = 0;
      while (i < nQuery) {
        tmp___3 = sqlite3_expert_report(p, i, 1);
        zSql = tmp___3;
        tmp___4 = sqlite3_expert_report(p, i, 2);
        zIdx = tmp___4;
        tmp___5 = sqlite3_expert_report(p, i, 3);
        zEQP = tmp___5;
        if ((unsigned long )zIdx == (unsigned long )((char const   *)0)) {
          zIdx = "(no new indexes)\n";
        }
        if (bVerbose) {
          fprintf((FILE * __restrict  )out, (char const   * __restrict  )"-- Query %d --------------------------------\n",
                  i + 1);
          fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n\n",
                  zSql);
        }
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n", zIdx);
        fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n", zEQP);
        i ++;
      }
    }
  }
  sqlite3_expert_destroy(p);
  pState->expert.pExpert = (sqlite3expert *)0;
  return (rc);
}
}
static int expertDotCommand(ShellState *pState , char **azArg , int nArg ) 
{ 
  int rc ;
  char *zErr ;
  int i ;
  int iSample ;
  char *z ;
  int n ;
  sqlite_int64 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  rc = 0;
  zErr = (char *)0;
  iSample = 0;
  if (! ((unsigned long )pState->expert.pExpert == (unsigned long )((sqlite3expert *)0))) {
    __assert_fail("pState->expert.pExpert==0", "shell.c", 11508U, "expertDotCommand");
  }
  memset((void *)(& pState->expert), 0, sizeof(ExpertInfo ));
  i = 1;
  while (1) {
    if (rc == 0) {
      if (! (i < nArg)) {
        break;
      }
    } else {
      break;
    }
    z = *(azArg + i);
    if ((int )*(z + 0) == 45) {
      if ((int )*(z + 1) == 45) {
        z ++;
      }
    }
    n = strlen30((char const   *)z);
    if (n >= 2) {
      tmp___2 = strncmp((char const   *)z, "-verbose", (size_t )n);
      if (0 == tmp___2) {
        pState->expert.bVerbose = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (n >= 2) {
      tmp___1 = strncmp((char const   *)z, "-sample", (size_t )n);
      if (0 == tmp___1) {
        if (i == nArg - 1) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"option requires an argument: %s\n",
                  z);
          rc = 1;
        } else {
          i ++;
          tmp___0 = integerValue((char const   *)*(azArg + i));
          iSample = (int )tmp___0;
          if (iSample < 0) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"value out of range: %s\n",
                    *(azArg + i));
            rc = 1;
          } else
          if (iSample > 100) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"value out of range: %s\n",
                    *(azArg + i));
            rc = 1;
          }
        }
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown option: %s\n",
                z);
        rc = 1;
      }
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown option: %s\n",
              z);
      rc = 1;
    }
    i ++;
  }
  if (rc == 0) {
    pState->expert.pExpert = sqlite3_expert_new(pState->db, & zErr);
    if ((unsigned long )pState->expert.pExpert == (unsigned long )((sqlite3expert *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sqlite3_expert_new: %s\n",
              zErr);
      rc = 1;
    } else {
      sqlite3_expert_config(pState->expert.pExpert, 1, iSample);
    }
  }
  return (rc);
}
}
static char const   *zStmtSql  ;
static int shell_exec(ShellState *pArg , char const   *zSql , char **pzErrMsg ) 
{ 
  sqlite3_stmt *pStmt ;
  int rc ;
  int rc2 ;
  char const   *zLeftover ;
  sqlite3 *db ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  sqlite3_stmt *pExplain ;
  char *zEQP ;
  int triggerEQP ;
  char const   *zEQPLine ;
  unsigned char const   *tmp___3 ;
  int iEqpId ;
  int tmp___4 ;
  int iParentId ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  pStmt = (sqlite3_stmt *)((void *)0);
  rc = 0;
  db = pArg->db;
  if (pzErrMsg) {
    *pzErrMsg = (char *)((void *)0);
  }
  if (pArg->expert.pExpert) {
    rc = expertHandleSQL(pArg, zSql, pzErrMsg);
    tmp = expertFinish(pArg, rc != 0, pzErrMsg);
    return (tmp);
  }
  while (1) {
    if (*(zSql + 0)) {
      if (! (0 == rc)) {
        break;
      }
    } else {
      break;
    }
    rc = sqlite3_prepare_v2(db, zSql, -1, & pStmt, & zLeftover);
    if (0 != rc) {
      if (pzErrMsg) {
        *pzErrMsg = save_err_msg(db);
      }
    } else {
      if (! pStmt) {
        zSql = zLeftover;
        while (1) {
          tmp___0 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(zSql + 0))) & 8192)) {
            break;
          }
          zSql ++;
        }
        continue;
      }
      zStmtSql = sqlite3_sql(pStmt);
      if ((unsigned long )zStmtSql == (unsigned long )((char const   *)0)) {
        zStmtSql = "";
      }
      while (1) {
        tmp___1 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*(zStmtSql + 0))) & 8192)) {
          break;
        }
        zStmtSql ++;
      }
      if (pArg) {
        pArg->pStmt = pStmt;
        pArg->cnt = 0;
      }
      if (pArg) {
        if ((pArg->shellFlgs & 64U) != 0U) {
          if (zStmtSql) {
            tmp___2 = zStmtSql;
          } else {
            tmp___2 = zSql;
          }
          fprintf((FILE * __restrict  )pArg->out, (char const   * __restrict  )"%s\n",
                  tmp___2);
        }
      }
      if (pArg) {
        if (pArg->autoEQP) {
          tmp___7 = sqlite3_stmt_isexplain(pStmt);
          if (tmp___7 == 0) {
            triggerEQP = 0;
            disable_debug_trace_modes();
            sqlite3_db_config(db, 1008, -1, & triggerEQP);
            if ((int )pArg->autoEQP >= 2) {
              sqlite3_db_config(db, 1008, 1, 0);
            }
            zEQP = sqlite3_mprintf("EXPLAIN QUERY PLAN %s", zStmtSql);
            rc = sqlite3_prepare_v2(db, (char const   *)zEQP, -1, & pExplain, (char const   **)0);
            if (rc == 0) {
              while (1) {
                tmp___6 = sqlite3_step(pExplain);
                if (! (tmp___6 == 100)) {
                  break;
                }
                tmp___3 = sqlite3_column_text(pExplain, 3);
                zEQPLine = (char const   *)tmp___3;
                tmp___4 = sqlite3_column_int(pExplain, 0);
                iEqpId = tmp___4;
                tmp___5 = sqlite3_column_int(pExplain, 1);
                iParentId = tmp___5;
                if ((int const   )*(zEQPLine + 0) == 45) {
                  eqp_render(pArg);
                }
                eqp_append(pArg, iEqpId, iParentId, zEQPLine);
              }
              eqp_render(pArg);
            }
            sqlite3_finalize(pExplain);
            sqlite3_free((void *)zEQP);
            if ((int )pArg->autoEQP >= 3) {
              zEQP = sqlite3_mprintf("EXPLAIN %s", zStmtSql);
              rc = sqlite3_prepare_v2(db, (char const   *)zEQP, -1, & pExplain, (char const   **)0);
              if (rc == 0) {
                pArg->cMode = 9;
                explain_data_prepare(pArg, pExplain);
                exec_prepared_stmt(pArg, pExplain);
                explain_data_delete(pArg);
              }
              sqlite3_finalize(pExplain);
              sqlite3_free((void *)zEQP);
            }
            if ((int )pArg->autoEQP >= 2) {
              if (triggerEQP == 0) {
                sqlite3_db_config(db, 1008, 0, 0);
                sqlite3_finalize(pStmt);
                sqlite3_prepare_v2(db, zSql, -1, & pStmt, (char const   **)0);
                if (pArg) {
                  pArg->pStmt = pStmt;
                }
              }
            }
            restore_debug_trace_modes();
          }
        }
      }
      if (pArg) {
        pArg->cMode = pArg->mode;
        if (pArg->autoExplain) {
          tmp___8 = sqlite3_stmt_isexplain(pStmt);
          if (tmp___8 == 1) {
            pArg->cMode = 9;
          }
          tmp___9 = sqlite3_stmt_isexplain(pStmt);
          if (tmp___9 == 2) {
            pArg->cMode = 12;
          }
        }
        if (pArg->cMode == 9) {
          explain_data_prepare(pArg, pStmt);
        }
      }
      bind_prepared_stmt(pArg, pStmt);
      exec_prepared_stmt(pArg, pStmt);
      explain_data_delete(pArg);
      eqp_render(pArg);
      if (pArg) {
        if (pArg->statsOn) {
          display_stats(db, pArg, 0);
        }
      }
      if (pArg) {
        if (pArg->scanstatsOn) {
          display_scanstats(db, pArg);
        }
      }
      rc2 = sqlite3_finalize(pStmt);
      if (rc != 7) {
        rc = rc2;
      }
      if (rc == 0) {
        zSql = zLeftover;
        while (1) {
          tmp___10 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___10 + (int )((unsigned char )*(zSql + 0))) & 8192)) {
            break;
          }
          zSql ++;
        }
      } else
      if (pzErrMsg) {
        *pzErrMsg = save_err_msg(db);
      }
      if (pArg) {
        pArg->pStmt = (sqlite3_stmt *)((void *)0);
      }
    }
  }
  return (rc);
}
}
static void freeColumnList(char **azCol ) 
{ 
  int i ;

  {
  i = 1;
  while (*(azCol + i)) {
    sqlite3_free((void *)*(azCol + i));
    i ++;
  }
  sqlite3_free((void *)azCol);
  return;
}
}
static char **tableColumnList(ShellState *p , char const   *zTab ) ;
static char *azRowid[3]  = {      (char *)"rowid",      (char *)"_rowid_",      (char *)"oid"};
static char **tableColumnList(ShellState *p , char const   *zTab ) 
{ 
  char **azCol ;
  sqlite3_stmt *pStmt ;
  char *zSql ;
  int nCol ;
  int nAlloc ;
  int nPK ;
  int isIPK ;
  int preserveRowid ;
  int rc ;
  void *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int i ;
  int j ;
  int tmp___5 ;

  {
  azCol = (char **)0;
  nCol = 0;
  nAlloc = 0;
  nPK = 0;
  isIPK = 0;
  preserveRowid = (p->shellFlgs & 8U) != 0U;
  zSql = sqlite3_mprintf("PRAGMA table_info=%Q", zTab);
  rc = sqlite3_prepare_v2(p->db, (char const   *)zSql, -1, & pStmt, (char const   **)0);
  sqlite3_free((void *)zSql);
  if (rc) {
    return ((char **)0);
  }
  while (1) {
    tmp___4 = sqlite3_step(pStmt);
    if (! (tmp___4 == 100)) {
      break;
    }
    if (nCol >= nAlloc - 2) {
      nAlloc = (nAlloc * 2 + nCol) + 10;
      tmp = sqlite3_realloc((void *)azCol, (int )((unsigned long )nAlloc * sizeof(*(azCol + 0))));
      azCol = (char **)tmp;
      if ((unsigned long )azCol == (unsigned long )((char **)0)) {
        shell_out_of_memory();
      }
    }
    nCol ++;
    tmp___0 = sqlite3_column_text(pStmt, 1);
    *(azCol + nCol) = sqlite3_mprintf("%s", tmp___0);
    tmp___3 = sqlite3_column_int(pStmt, 5);
    if (tmp___3) {
      nPK ++;
      if (nPK == 1) {
        tmp___1 = sqlite3_column_text(pStmt, 2);
        tmp___2 = sqlite3_stricmp((char const   *)tmp___1, "INTEGER");
        if (tmp___2 == 0) {
          isIPK = 1;
        } else {
          isIPK = 0;
        }
      } else {
        isIPK = 0;
      }
    }
  }
  sqlite3_finalize(pStmt);
  if ((unsigned long )azCol == (unsigned long )((char **)0)) {
    return ((char **)0);
  }
  *(azCol + 0) = (char *)0;
  *(azCol + (nCol + 1)) = (char *)0;
  if (preserveRowid) {
    if (isIPK) {
      zSql = sqlite3_mprintf("SELECT 1 FROM pragma_index_list(%Q) WHERE origin=\'pk\'",
                             zTab);
      rc = sqlite3_prepare_v2(p->db, (char const   *)zSql, -1, & pStmt, (char const   **)0);
      sqlite3_free((void *)zSql);
      if (rc) {
        freeColumnList(azCol);
        return ((char **)0);
      }
      rc = sqlite3_step(pStmt);
      sqlite3_finalize(pStmt);
      preserveRowid = rc == 100;
    }
  }
  if (preserveRowid) {
    j = 0;
    while (j < 3) {
      i = 1;
      while (i <= nCol) {
        tmp___5 = sqlite3_stricmp((char const   *)azRowid[j], (char const   *)*(azCol + i));
        if (tmp___5 == 0) {
          break;
        }
        i ++;
      }
      if (i > nCol) {
        rc = sqlite3_table_column_metadata(p->db, (char const   *)0, zTab, (char const   *)azRowid[j],
                                           (char const   **)0, (char const   **)0,
                                           (int *)0, (int *)0, (int *)0);
        if (rc == 0) {
          *(azCol + 0) = azRowid[j];
        }
        break;
      }
      j ++;
    }
  }
  return (azCol);
}
}
static void toggleSelectOrder(sqlite3 *db ) 
{ 
  sqlite3_stmt *pStmt ;
  int iSetting ;
  char zStmt[100] ;
  int tmp ;

  {
  pStmt = (sqlite3_stmt *)0;
  iSetting = 0;
  sqlite3_prepare_v2(db, "PRAGMA reverse_unordered_selects", -1, & pStmt, (char const   **)0);
  tmp = sqlite3_step(pStmt);
  if (tmp == 100) {
    iSetting = sqlite3_column_int(pStmt, 0);
  }
  sqlite3_finalize(pStmt);
  sqlite3_snprintf((int )sizeof(zStmt), zStmt, "PRAGMA reverse_unordered_selects(%d)",
                   ! iSetting);
  sqlite3_exec(db, (char const   *)(zStmt), (int (*)(void * , int  , char ** , char ** ))0,
               (void *)0, (char **)0);
  return;
}
}
static int dump_callback(void *pArg , int nArg , char **azArg , char **azNotUsed ) 
{ 
  int rc ;
  char const   *zTable ;
  char const   *zType ;
  char const   *zSql ;
  ShellState *p ;
  char *zIns ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ShellText sSelect ;
  ShellText sTable ;
  char **azCol ;
  int i ;
  char *savedDestTable ;
  int savedMode ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  p = (ShellState *)pArg;
  if (nArg != 3) {
    return (0);
  } else
  if ((unsigned long )azArg == (unsigned long )((char **)0)) {
    return (0);
  }
  zTable = (char const   *)*(azArg + 0);
  zType = (char const   *)*(azArg + 1);
  zSql = (char const   *)*(azArg + 2);
  tmp___2 = strcmp(zTable, "sqlite_sequence");
  if (tmp___2 == 0) {
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"DELETE FROM sqlite_sequence;\n");
  } else {
    tmp___1 = sqlite3_strglob("sqlite_stat?", zTable);
    if (tmp___1 == 0) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"ANALYZE sqlite_master;\n");
    } else {
      tmp___0 = strncmp(zTable, "sqlite_", (size_t )7);
      if (tmp___0 == 0) {
        return (0);
      } else {
        tmp = strncmp(zSql, "CREATE VIRTUAL TABLE", (size_t )20);
        if (tmp == 0) {
          if (! p->writableSchema) {
            fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"PRAGMA writable_schema=ON;\n");
            p->writableSchema = 1;
          }
          zIns = sqlite3_mprintf("INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)VALUES(\'table\',\'%q\',\'%q\',0,\'%q\');",
                                 zTable, zTable, zSql);
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n",
                  zIns);
          sqlite3_free((void *)zIns);
          return (0);
        } else {
          printSchemaLine(p->out, zSql, ";\n");
        }
      }
    }
  }
  tmp___8 = strcmp(zType, "table");
  if (tmp___8 == 0) {
    azCol = tableColumnList(p, zTable);
    if ((unsigned long )azCol == (unsigned long )((char **)0)) {
      (p->nErr) ++;
      return (0);
    }
    initText(& sTable);
    tmp___3 = quoteChar(zTable);
    appendText(& sTable, zTable, tmp___3);
    if (*(azCol + 0)) {
      appendText(& sTable, "(", (char)0);
      appendText(& sTable, (char const   *)*(azCol + 0), (char)0);
      i = 1;
      while (*(azCol + i)) {
        appendText(& sTable, ",", (char)0);
        tmp___4 = quoteChar((char const   *)*(azCol + i));
        appendText(& sTable, (char const   *)*(azCol + i), tmp___4);
        i ++;
      }
      appendText(& sTable, ")", (char)0);
    }
    initText(& sSelect);
    appendText(& sSelect, "SELECT ", (char)0);
    if (*(azCol + 0)) {
      appendText(& sSelect, (char const   *)*(azCol + 0), (char)0);
      appendText(& sSelect, ",", (char)0);
    }
    i = 1;
    while (*(azCol + i)) {
      tmp___5 = quoteChar((char const   *)*(azCol + i));
      appendText(& sSelect, (char const   *)*(azCol + i), tmp___5);
      if (*(azCol + (i + 1))) {
        appendText(& sSelect, ",", (char)0);
      }
      i ++;
    }
    freeColumnList(azCol);
    appendText(& sSelect, " FROM ", (char)0);
    tmp___6 = quoteChar(zTable);
    appendText(& sSelect, zTable, tmp___6);
    savedDestTable = p->zDestTable;
    savedMode = p->mode;
    p->zDestTable = sTable.z;
    tmp___7 = 5;
    p->cMode = tmp___7;
    p->mode = tmp___7;
    rc = shell_exec(p, (char const   *)sSelect.z, (char **)0);
    if ((rc & 255) == 11) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/****** CORRUPTION ERROR *******/\n");
      toggleSelectOrder(p->db);
      shell_exec(p, (char const   *)sSelect.z, (char **)0);
      toggleSelectOrder(p->db);
    }
    p->zDestTable = savedDestTable;
    p->mode = savedMode;
    freeText(& sTable);
    freeText(& sSelect);
    if (rc) {
      (p->nErr) ++;
    }
  }
  return (0);
}
}
static int run_schema_dump_query(ShellState *p , char const   *zQuery ) 
{ 
  int rc ;
  char *zErr ;
  char *zQ2 ;
  int len ;
  int tmp ;
  void *tmp___0 ;

  {
  zErr = (char *)0;
  rc = sqlite3_exec(p->db, zQuery, & dump_callback, (void *)p, & zErr);
  if (rc == 11) {
    tmp = strlen30(zQuery);
    len = tmp;
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/****** CORRUPTION ERROR *******/\n");
    if (zErr) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/****** %s ******/\n",
              zErr);
      sqlite3_free((void *)zErr);
      zErr = (char *)0;
    }
    tmp___0 = malloc((size_t )(len + 100));
    zQ2 = (char *)tmp___0;
    if ((unsigned long )zQ2 == (unsigned long )((char *)0)) {
      return (rc);
    }
    sqlite3_snprintf(len + 100, zQ2, "%s ORDER BY rowid DESC", zQuery);
    rc = sqlite3_exec(p->db, (char const   *)zQ2, & dump_callback, (void *)p, & zErr);
    if (rc) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/****** ERROR: %s ******/\n",
              zErr);
    } else {
      rc = 11;
    }
    sqlite3_free((void *)zErr);
    free((void *)zQ2);
  }
  return (rc);
}
}
static char const   *azHelp[127]  = 
  {      ".auth ON|OFF             Show authorizer callbacks",      ".backup ?DB? FILE        Backup DB (default \"main\") to FILE",      "       --append            Use the appendvfs",      "       --async             Write to FILE without journal and fsync()", 
        ".bail on|off             Stop after hitting an error.  Default OFF",      ".binary on|off           Turn binary output on or off.  Default OFF",      ".cd DIRECTORY            Change the working directory to DIRECTORY",      ".changes on|off          Show number of rows changed by SQL", 
        ".check GLOB              Fail if output since .testcase does not match",      ".clone NEWDB             Clone data into NEWDB from the existing database",      ".databases               List names and files of attached databases",      ".dbconfig ?op? ?val?     List or change sqlite3_db_config() options", 
        ".dbinfo ?DB?             Show status information about the database",      ".dump ?TABLE? ...        Render all database content as SQL",      "   Options:",      "     --preserve-rowids      Include ROWID values in the output", 
        "     --newlines             Allow unescaped newline characters in output",      "   TABLE is a LIKE pattern for the tables to dump",      ".echo on|off             Turn command echo on or off",      ".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN", 
        "   Other Modes:",      "      trigger               Like \"full\" but also show trigger bytecode",      ".excel                   Display the output of next command in spreadsheet",      ".exit ?CODE?             Exit this program with return-code CODE", 
        ".expert                  EXPERIMENTAL. Suggest indexes for queries",      ".filectrl CMD ...        Run various sqlite3_file_control() operations",      "                           Run \".filectrl\" with no arguments for details",      ".fullschema ?--indent?   Show schema and the content of sqlite_stat tables", 
        ".headers on|off          Turn display of headers on or off",      ".help ?-all? ?PATTERN?   Show help text for PATTERN",      ".import FILE TABLE       Import data from FILE into TABLE",      ".imposter INDEX TABLE    Create imposter table TABLE on index INDEX", 
        ".indexes ?TABLE?         Show names of indexes",      "                           If TABLE is specified, only show indexes for",      "                           tables matching TABLE using the LIKE operator.",      ".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT", 
        ".lint OPTIONS            Report potential schema issues.",      "     Options:",      "        fkey-indexes     Find missing foreign key indexes",      ".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout", 
        ".mode MODE ?TABLE?       Set output mode",      "   MODE is one of:",      "     ascii    Columns/rows delimited by 0x1F and 0x1E",      "     csv      Comma-separated values", 
        "     column   Left-aligned columns.  (See .width)",      "     html     HTML <table> code",      "     insert   SQL insert statements for TABLE",      "     line     One value per line", 
        "     list     Values delimited by \"|\"",      "     quote    Escape answers as for SQL",      "     tabs     Tab-separated values",      "     tcl      TCL list elements", 
        ".nullvalue STRING        Use STRING in place of NULL values",      ".once (-e|-x|FILE)       Output for the next SQL command only to FILE",      "     If FILE begins with \'|\' then open as a pipe",      "     Other options:", 
        "       -e    Invoke system text editor",      "       -x    Open in a spreadsheet",      ".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE",      "     Options:", 
        "        --append        Use appendvfs to append database to the end of FILE",      "        --new           Initialize FILE to an empty database",      "        --readonly      Open FILE readonly",      "        --zip           FILE is a ZIP archive", 
        ".output ?FILE?           Send output to FILE or stdout if FILE is omitted",      "     If FILE begins with \'|\' then open it as a pipe.",      ".parameter CMD ...       Manage SQL parameter bindings",      "   clear                   Erase all bindings", 
        "   init                    Initialize the TEMP table that holds bindings",      "   list                    List the current parameter bindings",      "   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE",      "                           PARAMETER should start with one of: $ : @ ?", 
        "   unset PARAMETER         Remove PARAMETER from the binding table",      ".print STRING...         Print literal STRING",      ".progress N              Invoke progress handler after every N opcodes",      "   --limit N                 Interrupt after N progress callbacks", 
        "   --once                    Do no more than one progress interrupt",      "   --quiet|-q                No output except at interrupts",      "   --reset                   Reset the count for each input and interrupt",      ".prompt MAIN CONTINUE    Replace the standard prompts", 
        ".quit                    Exit this program",      ".read FILE               Read input from FILE",      ".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE",      ".save FILE               Write in-memory database into FILE", 
        ".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off",      ".schema ?PATTERN?        Show the CREATE statements matching PATTERN",      "     Options:",      "         --indent            Try to pretty-print the schema", 
        ".selftest ?OPTIONS?      Run tests defined in the SELFTEST table",      "    Options:",      "       --init               Create a new SELFTEST table",      "       -v                   Verbose output", 
        ".separator COL ?ROW?     Change the column and row separators",      ".sha3sum ...             Compute a SHA3 hash of database content",      "    Options:",      "      --schema              Also hash the sqlite_master table", 
        "      --sha3-224            Use the sha3-224 algorithm",      "      --sha3-256            Use the sha3-256 algorithm (default)",      "      --sha3-384            Use the sha3-384 algorithm",      "      --sha3-512            Use the sha3-512 algorithm", 
        "    Any other argument is a LIKE pattern for tables to hash",      ".shell CMD ARGS...       Run CMD ARGS... in a system shell",      ".show                    Show the current values for various settings",      ".stats ?on|off?          Show stats or turn stats on or off", 
        ".system CMD ARGS...      Run CMD ARGS... in a system shell",      ".tables ?TABLE?          List names of tables matching LIKE pattern TABLE",      ".testcase NAME           Begin redirecting output to \'testcase-out.txt\'",      ".testctrl CMD ...        Run various sqlite3_test_control() operations", 
        "                           Run \".testctrl\" with no arguments for details",      ".timeout MS              Try opening locked tables for MS milliseconds",      ".timer on|off            Turn SQL timer on or off",      ".trace ?OPTIONS?         Output each SQL statement as it is run", 
        "    FILE                    Send output to FILE",      "    stdout                  Send output to stdout",      "    stderr                  Send output to stderr",      "    off                     Disable tracing", 
        "    --expanded              Expand query parameters",      "    --plain                 Show SQL as it is input",      "    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)",      "    --profile               Profile statements (SQLITE_TRACE_PROFILE)", 
        "    --row                   Trace each row (SQLITE_TRACE_ROW)",      "    --close                 Trace connection close (SQLITE_TRACE_CLOSE)",      ".vfsinfo ?AUX?           Information about the top-level VFS",      ".vfslist                 List all available VFSes", 
        ".vfsname ?AUX?           Print the name of the VFS stack",      ".width NUM1 NUM2 ...     Set column widths for \"column\" mode",      "     Negative values right-justify"};
static int showHelp(FILE *out ,
                    char const   *zPattern ) 
{ 
  int i ;
  int j ;
  int n ;
  char *zPat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  i = 0;
  j = 0;
  n = 0;
  if ((unsigned long )zPattern == (unsigned long )((char const   *)0)) {
    goto _L;
  } else
  if ((int const   )*(zPattern + 0) == 48) {
    goto _L;
  } else {
    tmp___1 = strcmp(zPattern, "-a");
    if (tmp___1 == 0) {
      goto _L;
    } else {
      tmp___2 = strcmp(zPattern, "-all");
      if (tmp___2 == 0) {
        _L: /* CIL Label */ 
        if ((unsigned long )zPattern == (unsigned long )((char const   *)0)) {
          zPattern = "";
        }
        i = 0;
        while (i < (int )(sizeof(azHelp) / sizeof(azHelp[0]))) {
          if ((int const   )*(azHelp[i] + 0) == 46) {
            fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n",
                    azHelp[i]);
            n ++;
          } else
          if (*(zPattern + 0)) {
            fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n",
                    azHelp[i]);
            n ++;
          }
          i ++;
        }
      } else {
        zPat = sqlite3_mprintf(".%s*", zPattern);
        i = 0;
        while (i < (int )(sizeof(azHelp) / sizeof(azHelp[0]))) {
          tmp = sqlite3_strglob((char const   *)zPat, azHelp[i]);
          if (tmp == 0) {
            fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n",
                    azHelp[i]);
            j = i + 1;
            n ++;
          }
          i ++;
        }
        sqlite3_free((void *)zPat);
        if (n) {
          if (n == 1) {
            while (1) {
              if (j < (int )(sizeof(azHelp) / sizeof(azHelp[0])) - 1) {
                if (! ((int const   )*(azHelp[j] + 0) != 46)) {
                  break;
                }
              } else {
                break;
              }
              fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n",
                      azHelp[j]);
              j ++;
            }
          }
          return (n);
        }
        zPat = sqlite3_mprintf("%%%s%%", zPattern);
        i = 0;
        while (i < (int )(sizeof(azHelp) / sizeof(azHelp[0]))) {
          if ((int const   )*(azHelp[i] + 0) == 46) {
            j = i;
          }
          tmp___0 = sqlite3_strlike((char const   *)zPat, azHelp[i], 0U);
          if (tmp___0 == 0) {
            fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n",
                    azHelp[j]);
            while (1) {
              if (j < (int )(sizeof(azHelp) / sizeof(azHelp[0])) - 1) {
                if (! ((int const   )*(azHelp[j + 1] + 0) != 46)) {
                  break;
                }
              } else {
                break;
              }
              j ++;
              fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s\n",
                      azHelp[j]);
            }
            i = j;
            n ++;
          }
          i ++;
        }
        sqlite3_free((void *)zPat);
      }
    }
  }
  return (n);
}
}
static int process_input(ShellState *p ) ;
static char *readFile(char const   *zName , int *pnByte ) 
{ 
  FILE *in ;
  FILE *tmp ;
  long nIn ;
  size_t nRead ;
  char *pBuf ;
  void *tmp___0 ;

  {
  tmp = fopen((char const   * __restrict  )zName, (char const   * __restrict  )"rb");
  in = tmp;
  if ((unsigned long )in == (unsigned long )((FILE *)0)) {
    return ((char *)0);
  }
  fseek(in, 0L, 2);
  nIn = ftell(in);
  rewind(in);
  tmp___0 = sqlite3_malloc64((sqlite_uint64 )(nIn + 1L));
  pBuf = (char *)tmp___0;
  if ((unsigned long )pBuf == (unsigned long )((char *)0)) {
    fclose(in);
    return ((char *)0);
  }
  nRead = fread((void * __restrict  )pBuf, (size_t )nIn, (size_t )1, (FILE * __restrict  )in);
  fclose(in);
  if (nRead != 1UL) {
    sqlite3_free((void *)pBuf);
    return ((char *)0);
  }
  *(pBuf + nIn) = (char)0;
  if (pnByte) {
    *pnByte = (int )nIn;
  }
  return (pBuf);
}
}
int deduceDatabaseType(char const   *zName , int dfltZip ) 
{ 
  FILE *f ;
  FILE *tmp ;
  size_t n ;
  int rc ;
  char zBuf[100] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = fopen((char const   * __restrict  )zName, (char const   * __restrict  )"rb");
  f = tmp;
  rc = 0;
  if ((unsigned long )f == (unsigned long )((FILE *)0)) {
    if (dfltZip) {
      tmp___0 = sqlite3_strlike("%.zip", zName, 0U);
      if (tmp___0 == 0) {
        return (3);
      } else {
        return (1);
      }
    } else {
      return (1);
    }
  }
  n = fread((void * __restrict  )(zBuf), (size_t )16, (size_t )1, (FILE * __restrict  )f);
  if (n == 1UL) {
    tmp___1 = memcmp((void const   *)(zBuf), (void const   *)"SQLite format 3", (size_t )16);
    if (tmp___1 == 0) {
      fclose(f);
      return (1);
    }
  }
  fseek(f, -25L, 2);
  n = fread((void * __restrict  )(zBuf), (size_t )25, (size_t )1, (FILE * __restrict  )f);
  if (n == 1UL) {
    tmp___3 = memcmp((void const   *)(zBuf), (void const   *)"Start-Of-SQLite3-",
                     (size_t )17);
    if (tmp___3 == 0) {
      rc = 2;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    fseek(f, -22L, 2);
    n = fread((void * __restrict  )(zBuf), (size_t )22, (size_t )1, (FILE * __restrict  )f);
    if (n == 1UL) {
      if ((int )zBuf[0] == 80) {
        if ((int )zBuf[1] == 75) {
          if ((int )zBuf[2] == 5) {
            if ((int )zBuf[3] == 6) {
              rc = 3;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if (n == 0UL) {
      if (dfltZip) {
        tmp___2 = sqlite3_strlike("%.zip", zName, 0U);
        if (tmp___2 == 0) {
          rc = 3;
        }
      }
    }
  }
  fclose(f);
  return (rc);
}
}
static void shellInt32(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  unsigned char const   *pBlob ;
  int nBlob ;
  int iInt ;
  void const   *tmp ;
  unsigned char const   *a___0 ;
  sqlite_int64 iVal ;

  {
  nBlob = sqlite3_value_bytes(*(argv + 0));
  tmp = sqlite3_value_blob(*(argv + 0));
  pBlob = (unsigned char const   *)tmp;
  iInt = sqlite3_value_int(*(argv + 1));
  if (iInt >= 0) {
    if ((iInt + 1) * 4 <= nBlob) {
      a___0 = pBlob + iInt * 4;
      iVal = ((((sqlite_int64 )*(a___0 + 0) << 24) + ((sqlite_int64 )*(a___0 + 1) << 16)) + ((sqlite_int64 )*(a___0 + 2) << 8)) + (sqlite_int64 )*(a___0 + 3);
      sqlite3_result_int64(context, iVal);
    }
  }
  return;
}
}
static void shellIdQuote(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zName ;
  unsigned char const   *tmp ;
  char *z ;
  char *tmp___0 ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  zName = (char const   *)tmp;
  if (zName) {
    tmp___0 = sqlite3_mprintf("\"%w\"", zName);
    z = tmp___0;
    sqlite3_result_text(context, (char const   *)z, -1, & sqlite3_free);
  }
  return;
}
}
static void shellEscapeCrnl(sqlite3_context *context , int argc , sqlite3_value **argv ) 
{ 
  char const   *zText___0 ;
  unsigned char const   *tmp ;
  int nText ;
  int tmp___0 ;
  int i ;
  char zBuf1[20] ;
  char zBuf2[20] ;
  char const   *zNL ;
  char const   *zCR ;
  int nCR ;
  int nNL ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int iOut ;
  i64 nMax ;
  int tmp___3 ;
  i64 nAlloc ;
  char *zOut ;
  void *tmp___4 ;

  {
  tmp = sqlite3_value_text(*(argv + 0));
  zText___0 = (char const   *)tmp;
  if ((int const   )*(zText___0 + 0) == 39) {
    tmp___0 = sqlite3_value_bytes(*(argv + 0));
    nText = tmp___0;
    zNL = (char const   *)0;
    zCR = (char const   *)0;
    nCR = 0;
    nNL = 0;
    i = 0;
    while (*(zText___0 + i)) {
      if ((unsigned long )zNL == (unsigned long )((char const   *)0)) {
        if ((int const   )*(zText___0 + i) == 10) {
          zNL = unused_string(zText___0, "\\n", "\\012", zBuf1);
          tmp___1 = strlen(zNL);
          nNL = (int )tmp___1;
        }
      }
      if ((unsigned long )zCR == (unsigned long )((char const   *)0)) {
        if ((int const   )*(zText___0 + i) == 13) {
          zCR = unused_string(zText___0, "\\r", "\\015", zBuf2);
          tmp___2 = strlen(zCR);
          nCR = (int )tmp___2;
        }
      }
      i ++;
    }
    if (zNL) {
      goto _L;
    } else
    if (zCR) {
      _L: /* CIL Label */ 
      iOut = 0;
      if (nNL > nCR) {
        tmp___3 = nNL;
      } else {
        tmp___3 = nCR;
      }
      nMax = (i64 )tmp___3;
      nAlloc = nMax * (i64 )nText + (nMax + 64LL) * 2LL;
      tmp___4 = sqlite3_malloc64((sqlite_uint64 )nAlloc);
      zOut = (char *)tmp___4;
      if ((unsigned long )zOut == (unsigned long )((char *)0)) {
        sqlite3_result_error_nomem(context);
        return;
      }
      if (zNL) {
        if (zCR) {
          memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )"replace(replace(",
                 (size_t )16);
          iOut += 16;
        } else {
          memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )"replace(",
                 (size_t )8);
          iOut += 8;
        }
      } else {
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )"replace(",
               (size_t )8);
        iOut += 8;
      }
      i = 0;
      while (*(zText___0 + i)) {
        if ((int const   )*(zText___0 + i) == 10) {
          memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )zNL,
                 (size_t )nNL);
          iOut += nNL;
        } else
        if ((int const   )*(zText___0 + i) == 13) {
          memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )zCR,
                 (size_t )nCR);
          iOut += nCR;
        } else {
          *(zOut + iOut) = (char )*(zText___0 + i);
          iOut ++;
        }
        i ++;
      }
      if (zNL) {
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )",\'",
               (size_t )2);
        iOut += 2;
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )zNL,
               (size_t )nNL);
        iOut += nNL;
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )"\', char(10))",
               (size_t )12);
        iOut += 12;
      }
      if (zCR) {
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )",\'",
               (size_t )2);
        iOut += 2;
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )zCR,
               (size_t )nCR);
        iOut += nCR;
        memcpy((void * __restrict  )(zOut + iOut), (void const   * __restrict  )"\', char(13))",
               (size_t )12);
        iOut += 12;
      }
      sqlite3_result_text(context, (char const   *)zOut, iOut, (void (*)(void * ))-1);
      sqlite3_free((void *)zOut);
      return;
    }
  }
  sqlite3_result_value(context, *(argv + 0));
  return;
}
}
static void open_db(ShellState *p , int openFlags ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *zSql ;
  char *tmp___2 ;

  {
  if ((unsigned long )p->db == (unsigned long )((sqlite3 *)0)) {
    if ((int )p->openMode == 0) {
      if ((unsigned long )p->zDbFilename == (unsigned long )((char const   *)0)) {
        p->openMode = (u8 )1;
      } else
      if ((int const   )*(p->zDbFilename + 0) == 0) {
        p->openMode = (u8 )1;
      } else {
        tmp = deduceDatabaseType(p->zDbFilename, (openFlags & 2) != 0);
        p->openMode = (u8 )tmp;
      }
    }
    switch ((int )p->openMode) {
    case 2: 
    sqlite3_open_v2(p->zDbFilename, & p->db, 6, "apndvfs");
    break;
    case 5: 
    case 6: 
    sqlite3_open((char const   *)0, & p->db);
    break;
    case 3: 
    sqlite3_open(":memory:", & p->db);
    break;
    case 4: 
    sqlite3_open_v2(p->zDbFilename, & p->db, 1, (char const   *)0);
    break;
    case 1: 
    case 0: 
    sqlite3_open(p->zDbFilename, & p->db);
    break;
    }
    globalDb = p->db;
    if ((unsigned long )p->db == (unsigned long )((sqlite3 *)0)) {
      goto _L;
    } else {
      tmp___1 = sqlite3_errcode(p->db);
      if (0 != tmp___1) {
        _L: /* CIL Label */ 
        tmp___0 = sqlite3_errmsg(p->db);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unable to open database \"%s\": %s\n",
                p->zDbFilename, tmp___0);
        if (openFlags & 1) {
          sqlite3_open(":memory:", & p->db);
          return;
        }
        exit(1);
      }
    }
    sqlite3_fileio_init(p->db, (char **)0, (sqlite3_api_routines const   *)0);
    sqlite3_shathree_init(p->db, (char **)0, (sqlite3_api_routines const   *)0);
    sqlite3_completion_init(p->db, (char **)0, (sqlite3_api_routines const   *)0);
    sqlite3_create_function(p->db, "shell_add_schema", 3, 1, (void *)0, & shellAddSchemaName,
                            (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "shell_module_schema", 1, 1, (void *)0, & shellModuleSchema,
                            (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "shell_putsnl", 1, 1, (void *)p, & shellPutsFunc,
                            (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "shell_escape_crnl", 1, 1, (void *)0, & shellEscapeCrnl,
                            (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "shell_int32", 2, 1, (void *)0, & shellInt32, (void (*)(sqlite3_context * ,
                                                                                           int  ,
                                                                                           sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "shell_idquote", 1, 1, (void *)0, & shellIdQuote,
                            (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "edit", 1, 1, (void *)0, & editFunc, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    sqlite3_create_function(p->db, "edit", 2, 1, (void *)0, & editFunc, (void (*)(sqlite3_context * ,
                                                                                  int  ,
                                                                                  sqlite3_value ** ))0,
                            (void (*)(sqlite3_context * ))0);
    if ((int )p->openMode == 3) {
      tmp___2 = sqlite3_mprintf("CREATE VIRTUAL TABLE zip USING zipfile(%Q);", p->zDbFilename);
      zSql = tmp___2;
      sqlite3_exec(p->db, (char const   *)zSql, (int (*)(void * , int  , char ** ,
                                                         char ** ))0, (void *)0, (char **)0);
      sqlite3_free((void *)zSql);
    }
  }
  return;
}
}
void close_db(sqlite3 *db ) 
{ 
  int rc ;
  int tmp ;
  char const   *tmp___0 ;

  {
  tmp = sqlite3_close(db);
  rc = tmp;
  if (rc) {
    tmp___0 = sqlite3_errmsg(db);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: sqlite3_close() returns %d: %s\n",
            rc, tmp___0);
  }
  return;
}
}
static void resolve_backslashes(char *z ) 
{ 
  int i ;
  int j ;
  char c ;

  {
  while (1) {
    if (*z) {
      if (! ((int )*z != 92)) {
        break;
      }
    } else {
      break;
    }
    z ++;
  }
  j = 0;
  i = j;
  while (1) {
    c = *(z + i);
    if (! ((int )c != 0)) {
      break;
    }
    if ((int )c == 92) {
      if ((int )*(z + (i + 1)) != 0) {
        i ++;
        c = *(z + i);
        if ((int )c == 97) {
          c = (char )'\a';
        } else
        if ((int )c == 98) {
          c = (char )'\b';
        } else
        if ((int )c == 116) {
          c = (char )'\t';
        } else
        if ((int )c == 110) {
          c = (char )'\n';
        } else
        if ((int )c == 118) {
          c = (char )'\v';
        } else
        if ((int )c == 102) {
          c = (char )'\f';
        } else
        if ((int )c == 114) {
          c = (char )'\r';
        } else
        if ((int )c == 34) {
          c = (char )'\"';
        } else
        if ((int )c == 39) {
          c = (char )'\'';
        } else
        if ((int )c == 92) {
          c = (char )'\\';
        } else
        if ((int )c >= 48) {
          if ((int )c <= 55) {
            c = (char )((int )c - 48);
            if ((int )*(z + (i + 1)) >= 48) {
              if ((int )*(z + (i + 1)) <= 55) {
                i ++;
                c = (char )((((int )c << 3) + (int )*(z + i)) - 48);
                if ((int )*(z + (i + 1)) >= 48) {
                  if ((int )*(z + (i + 1)) <= 55) {
                    i ++;
                    c = (char )((((int )c << 3) + (int )*(z + i)) - 48);
                  }
                }
              }
            }
          }
        }
      }
    }
    *(z + j) = c;
    i ++;
    j ++;
  }
  if (j < i) {
    *(z + j) = (char)0;
  }
  return;
}
}
static int booleanValue(char const   *zArg ) 
{ 
  int i ;
  int tmp ;
  sqlite_int64 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((int const   )*(zArg + 0) == 48) {
    if ((int const   )*(zArg + 1) == 120) {
      i = 2;
      while (1) {
        tmp = hexDigitValue((char )*(zArg + i));
        if (! (tmp >= 0)) {
          break;
        }
        i ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    i = 0;
    while (1) {
      if ((int const   )*(zArg + i) >= 48) {
        if (! ((int const   )*(zArg + i) <= 57)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
  }
  if (i > 0) {
    if ((int const   )*(zArg + i) == 0) {
      tmp___0 = integerValue(zArg);
      return ((int )(tmp___0 & 4294967295LL));
    }
  }
  tmp___1 = sqlite3_stricmp(zArg, "on");
  if (tmp___1 == 0) {
    return (1);
  } else {
    tmp___2 = sqlite3_stricmp(zArg, "yes");
    if (tmp___2 == 0) {
      return (1);
    }
  }
  tmp___3 = sqlite3_stricmp(zArg, "off");
  if (tmp___3 == 0) {
    return (0);
  } else {
    tmp___4 = sqlite3_stricmp(zArg, "no");
    if (tmp___4 == 0) {
      return (0);
    }
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n",
          zArg);
  return (0);
}
}
static void setOrClearFlag(ShellState *p , unsigned int mFlag , char const   *zArg ) 
{ 
  int tmp ;

  {
  tmp = booleanValue(zArg);
  if (tmp) {
    p->shellFlgs |= mFlag;
  } else {
    p->shellFlgs &= ~ mFlag;
  }
  return;
}
}
static void output_file_close(FILE *f ) 
{ 


  {
  if (f) {
    if ((unsigned long )f != (unsigned long )stdout) {
      if ((unsigned long )f != (unsigned long )stderr) {
        fclose(f);
      }
    }
  }
  return;
}
}
static FILE *output_file_open(char const   *zFile , int bTextMode ) 
{ 
  FILE *f ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp___2 = strcmp(zFile, "stdout");
  if (tmp___2 == 0) {
    f = stdout;
  } else {
    tmp___1 = strcmp(zFile, "stderr");
    if (tmp___1 == 0) {
      f = stderr;
    } else {
      tmp___0 = strcmp(zFile, "off");
      if (tmp___0 == 0) {
        f = (FILE *)0;
      } else {
        if (bTextMode) {
          tmp = "w";
        } else {
          tmp = "wb";
        }
        f = fopen((char const   * __restrict  )zFile, (char const   * __restrict  )tmp);
        if ((unsigned long )f == (unsigned long )((FILE *)0)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \"%s\"\n",
                  zFile);
        }
      }
    }
  }
  return (f);
}
}
static int sql_trace_callback(unsigned int mType , void *pArg , void *pP , void *pX ) 
{ 
  ShellState *p ;
  sqlite3_stmt *pStmt ;
  char const   *zSql ;
  int nSql ;
  char *tmp ;
  sqlite_int64 nNanosec ;

  {
  p = (ShellState *)pArg;
  if ((unsigned long )p->traceOut == (unsigned long )((FILE *)0)) {
    return (0);
  }
  if (mType == 8U) {
    fprintf((FILE * __restrict  )p->traceOut, (char const   * __restrict  )"-- closing database connection\n");
    return (0);
  }
  if (mType != 4U) {
    if ((int const   )*((char const   *)pX + 0) == 45) {
      zSql = (char const   *)pX;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    pStmt = (sqlite3_stmt *)pP;
    switch ((int )p->eTraceType) {
    case 1: 
    tmp = sqlite3_expanded_sql(pStmt);
    zSql = (char const   *)tmp;
    break;
    default: 
    zSql = sqlite3_sql(pStmt);
    break;
    }
  }
  if ((unsigned long )zSql == (unsigned long )((char const   *)0)) {
    return (0);
  }
  nSql = strlen30(zSql);
  while (1) {
    if (nSql > 0) {
      if (! ((int const   )*(zSql + (nSql - 1)) == 59)) {
        break;
      }
    } else {
      break;
    }
    nSql --;
  }
  switch (mType) {
  case 1U: 
  case 4U: 
  fprintf((FILE * __restrict  )p->traceOut, (char const   * __restrict  )"%.*s;\n",
          nSql, zSql);
  break;
  case 2U: 
  nNanosec = *((sqlite_int64 *)pX);
  fprintf((FILE * __restrict  )p->traceOut, (char const   * __restrict  )"%.*s; -- %lld ns\n",
          nSql, zSql, nNanosec);
  break;
  }
  return (0);
}
}
static void test_breakpoint(void) ;
static int nCall  =    0;
static void test_breakpoint(void) 
{ 


  {
  nCall ++;
  return;
}
}
static void import_append_char(ImportCtx *p , int c ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  if (p->n + 1 >= p->nAlloc) {
    p->nAlloc += p->nAlloc + 100;
    tmp = sqlite3_realloc64((void *)p->z, (sqlite_uint64 )p->nAlloc);
    p->z = (char *)tmp;
    if ((unsigned long )p->z == (unsigned long )((char *)0)) {
      shell_out_of_memory();
    }
  }
  tmp___0 = p->n;
  (p->n) ++;
  *(p->z + tmp___0) = (char )c;
  return;
}
}
static char *csv_read_one_field(ImportCtx *p ) 
{ 
  int c ;
  int cSep ;
  int rSep ;
  int pc ;
  int ppc ;
  int startLine ;
  int cQuote ;
  char *tmp ;

  {
  cSep = p->cColSep;
  rSep = p->cRowSep;
  p->n = 0;
  c = fgetc(p->in);
  if (c == -1) {
    p->cTerm = -1;
    return ((char *)0);
  } else
  if (seenInterrupt) {
    p->cTerm = -1;
    return ((char *)0);
  }
  if (c == 34) {
    startLine = p->nLine;
    cQuote = c;
    ppc = 0;
    pc = ppc;
    while (1) {
      c = fgetc(p->in);
      if (c == rSep) {
        (p->nLine) ++;
      }
      if (c == cQuote) {
        if (pc == cQuote) {
          pc = 0;
          continue;
        }
      }
      if (c == cSep) {
        if (pc == cQuote) {
          goto _L;
        } else {
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
      if (c == rSep) {
        if (pc == cQuote) {
          goto _L;
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if (c == rSep) {
        if (pc == 13) {
          if (ppc == cQuote) {
            goto _L;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (c == -1) {
        if (pc == cQuote) {
          _L: /* CIL Label */ 
          while (1) {
            (p->n) --;
            if (! ((int )*(p->z + p->n) != cQuote)) {
              break;
            }
          }
          p->cTerm = c;
          break;
        }
      }
      if (pc == cQuote) {
        if (c != 13) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: unescaped %c character\n",
                  p->zFile, p->nLine, cQuote);
        }
      }
      if (c == -1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: unterminated %c-quoted field\n",
                p->zFile, startLine, cQuote);
        p->cTerm = c;
        break;
      }
      import_append_char(p, c);
      ppc = pc;
      pc = c;
    }
  } else {
    if ((c & 255) == 239) {
      if (p->bNotFirst == 0) {
        import_append_char(p, c);
        c = fgetc(p->in);
        if ((c & 255) == 187) {
          import_append_char(p, c);
          c = fgetc(p->in);
          if ((c & 255) == 191) {
            p->bNotFirst = 1;
            p->n = 0;
            tmp = csv_read_one_field(p);
            return (tmp);
          }
        }
      }
    }
    while (1) {
      if (c != -1) {
        if (c != cSep) {
          if (! (c != rSep)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      import_append_char(p, c);
      c = fgetc(p->in);
    }
    if (c == rSep) {
      (p->nLine) ++;
      if (p->n > 0) {
        if ((int )*(p->z + (p->n - 1)) == 13) {
          (p->n) --;
        }
      }
    }
    p->cTerm = c;
  }
  if (p->z) {
    *(p->z + p->n) = (char)0;
  }
  p->bNotFirst = 1;
  return (p->z);
}
}
static char *ascii_read_one_field(ImportCtx *p ) 
{ 
  int c ;
  int cSep ;
  int rSep ;

  {
  cSep = p->cColSep;
  rSep = p->cRowSep;
  p->n = 0;
  c = fgetc(p->in);
  if (c == -1) {
    p->cTerm = -1;
    return ((char *)0);
  } else
  if (seenInterrupt) {
    p->cTerm = -1;
    return ((char *)0);
  }
  while (1) {
    if (c != -1) {
      if (c != cSep) {
        if (! (c != rSep)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    import_append_char(p, c);
    c = fgetc(p->in);
  }
  if (c == rSep) {
    (p->nLine) ++;
  }
  p->cTerm = c;
  if (p->z) {
    *(p->z + p->n) = (char)0;
  }
  return (p->z);
}
}
static void tryToCloneData(ShellState *p , sqlite3 *newDb , char const   *zTable ) 
{ 
  sqlite3_stmt *pQuery ;
  sqlite3_stmt *pInsert ;
  char *zQuery ;
  char *zInsert ;
  int rc ;
  int i ;
  int j ;
  int n ;
  int nTable ;
  int tmp ;
  int k ;
  int cnt ;
  int spinRate ;
  char const   *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  sqlite_int64 tmp___6 ;
  double tmp___7 ;
  unsigned char const   *tmp___8 ;
  int tmp___9 ;
  void const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;

  {
  pQuery = (sqlite3_stmt *)0;
  pInsert = (sqlite3_stmt *)0;
  zQuery = (char *)0;
  zInsert = (char *)0;
  tmp = strlen30(zTable);
  nTable = tmp;
  k = 0;
  cnt = 0;
  spinRate = 10000;
  zQuery = sqlite3_mprintf("SELECT * FROM \"%w\"", zTable);
  rc = sqlite3_prepare_v2(p->db, (char const   *)zQuery, -1, & pQuery, (char const   **)0);
  if (rc) {
    tmp___0 = sqlite3_errmsg(p->db);
    tmp___1 = sqlite3_extended_errcode(p->db);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error %d: %s on [%s]\n",
            tmp___1, tmp___0, zQuery);
    goto end_data_xfer;
  }
  n = sqlite3_column_count(pQuery);
  tmp___2 = sqlite3_malloc64((sqlite_uint64 )((200 + nTable) + n * 3));
  zInsert = (char *)tmp___2;
  if ((unsigned long )zInsert == (unsigned long )((char *)0)) {
    shell_out_of_memory();
  }
  sqlite3_snprintf(200 + nTable, zInsert, "INSERT OR IGNORE INTO \"%s\" VALUES(?",
                   zTable);
  i = strlen30((char const   *)zInsert);
  j = 1;
  while (j < n) {
    memcpy((void * __restrict  )(zInsert + i), (void const   * __restrict  )",?",
           (size_t )2);
    i += 2;
    j ++;
  }
  memcpy((void * __restrict  )(zInsert + i), (void const   * __restrict  )");", (size_t )3);
  rc = sqlite3_prepare_v2(newDb, (char const   *)zInsert, -1, & pInsert, (char const   **)0);
  if (rc) {
    tmp___3 = sqlite3_errmsg(newDb);
    tmp___4 = sqlite3_extended_errcode(newDb);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error %d: %s on [%s]\n",
            tmp___4, tmp___3, zQuery);
    goto end_data_xfer;
  }
  k = 0;
  while (k < 2) {
    while (1) {
      rc = sqlite3_step(pQuery);
      if (! (rc == 100)) {
        break;
      }
      i = 0;
      while (i < n) {
        tmp___5 = sqlite3_column_type(pQuery, i);
        switch (tmp___5) {
        case 5: 
        sqlite3_bind_null(pInsert, i + 1);
        break;
        case 1: 
        tmp___6 = sqlite3_column_int64(pQuery, i);
        sqlite3_bind_int64(pInsert, i + 1, tmp___6);
        break;
        case 2: 
        tmp___7 = sqlite3_column_double(pQuery, i);
        sqlite3_bind_double(pInsert, i + 1, tmp___7);
        break;
        case 3: 
        tmp___8 = sqlite3_column_text(pQuery, i);
        sqlite3_bind_text(pInsert, i + 1, (char const   *)tmp___8, -1, (void (*)(void * ))0);
        break;
        case 4: 
        tmp___9 = sqlite3_column_bytes(pQuery, i);
        tmp___10 = sqlite3_column_blob(pQuery, i);
        sqlite3_bind_blob(pInsert, i + 1, tmp___10, tmp___9, (void (*)(void * ))0);
        break;
        }
        i ++;
      }
      rc = sqlite3_step(pInsert);
      if (rc != 0) {
        if (rc != 100) {
          if (rc != 101) {
            tmp___11 = sqlite3_errmsg(newDb);
            tmp___12 = sqlite3_extended_errcode(newDb);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error %d: %s\n",
                    tmp___12, tmp___11);
          }
        }
      }
      sqlite3_reset(pInsert);
      cnt ++;
      if (cnt % spinRate == 0) {
        printf((char const   * __restrict  )"%c\b", (int const   )*("|/-\\" + (cnt / spinRate) % 4));
        fflush(stdout);
      }
    }
    if (rc == 101) {
      break;
    }
    sqlite3_finalize(pQuery);
    sqlite3_free((void *)zQuery);
    zQuery = sqlite3_mprintf("SELECT * FROM \"%w\" ORDER BY rowid DESC;", zTable);
    rc = sqlite3_prepare_v2(p->db, (char const   *)zQuery, -1, & pQuery, (char const   **)0);
    if (rc) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: cannot step \"%s\" backwards",
              zTable);
      break;
    }
    k ++;
  }
  end_data_xfer: 
  sqlite3_finalize(pQuery);
  sqlite3_finalize(pInsert);
  sqlite3_free((void *)zQuery);
  sqlite3_free((void *)zInsert);
  return;
}
}
static void tryToCloneSchema(ShellState *p , sqlite3 *newDb , char const   *zWhere ,
                             void (*xForEach)(ShellState * , sqlite3 * , char const   * ) ) 
{ 
  sqlite3_stmt *pQuery ;
  char *zQuery ;
  int rc ;
  unsigned char const   *zName ;
  unsigned char const   *zSql ;
  char *zErrMsg ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  pQuery = (sqlite3_stmt *)0;
  zQuery = (char *)0;
  zErrMsg = (char *)0;
  zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_master WHERE %s", zWhere);
  rc = sqlite3_prepare_v2(p->db, (char const   *)zQuery, -1, & pQuery, (char const   **)0);
  if (rc) {
    tmp = sqlite3_errmsg(p->db);
    tmp___0 = sqlite3_extended_errcode(p->db);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: (%d) %s on [%s]\n",
            tmp___0, tmp, zQuery);
    goto end_schema_xfer;
  }
  while (1) {
    rc = sqlite3_step(pQuery);
    if (! (rc == 100)) {
      break;
    }
    zName = sqlite3_column_text(pQuery, 0);
    zSql = sqlite3_column_text(pQuery, 1);
    printf((char const   * __restrict  )"%s... ", zName);
    fflush(stdout);
    sqlite3_exec(newDb, (char const   *)zSql, (int (*)(void * , int  , char ** , char ** ))0,
                 (void *)0, & zErrMsg);
    if (zErrMsg) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\nSQL: [%s]\n",
              zErrMsg, zSql);
      sqlite3_free((void *)zErrMsg);
      zErrMsg = (char *)0;
    }
    if (xForEach) {
      (*xForEach)(p, newDb, (char const   *)zName);
    }
    printf((char const   * __restrict  )"done\n");
  }
  if (rc != 101) {
    sqlite3_finalize(pQuery);
    sqlite3_free((void *)zQuery);
    zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_master WHERE %s ORDER BY rowid DESC",
                             zWhere);
    rc = sqlite3_prepare_v2(p->db, (char const   *)zQuery, -1, & pQuery, (char const   **)0);
    if (rc) {
      tmp___1 = sqlite3_errmsg(p->db);
      tmp___2 = sqlite3_extended_errcode(p->db);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: (%d) %s on [%s]\n",
              tmp___2, tmp___1, zQuery);
      goto end_schema_xfer;
    }
    while (1) {
      rc = sqlite3_step(pQuery);
      if (! (rc == 100)) {
        break;
      }
      zName = sqlite3_column_text(pQuery, 0);
      zSql = sqlite3_column_text(pQuery, 1);
      printf((char const   * __restrict  )"%s... ", zName);
      fflush(stdout);
      sqlite3_exec(newDb, (char const   *)zSql, (int (*)(void * , int  , char ** ,
                                                         char ** ))0, (void *)0, & zErrMsg);
      if (zErrMsg) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\nSQL: [%s]\n",
                zErrMsg, zSql);
        sqlite3_free((void *)zErrMsg);
        zErrMsg = (char *)0;
      }
      if (xForEach) {
        (*xForEach)(p, newDb, (char const   *)zName);
      }
      printf((char const   * __restrict  )"done\n");
    }
  }
  end_schema_xfer: 
  sqlite3_finalize(pQuery);
  sqlite3_free((void *)zQuery);
  return;
}
}
static void tryToClone(ShellState *p , char const   *zNewDb ) 
{ 
  int rc ;
  sqlite3 *newDb ;
  int tmp ;
  char const   *tmp___0 ;

  {
  newDb = (sqlite3 *)0;
  tmp = access(zNewDb, 0);
  if (tmp == 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"File \"%s\" already exists.\n",
            zNewDb);
    return;
  }
  rc = sqlite3_open(zNewDb, & newDb);
  if (rc) {
    tmp___0 = sqlite3_errmsg(newDb);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cannot create output database: %s\n",
            tmp___0);
  } else {
    sqlite3_exec(p->db, "PRAGMA writable_schema=ON;", (int (*)(void * , int  , char ** ,
                                                               char ** ))0, (void *)0,
                 (char **)0);
    sqlite3_exec(newDb, "BEGIN EXCLUSIVE;", (int (*)(void * , int  , char ** , char ** ))0,
                 (void *)0, (char **)0);
    tryToCloneSchema(p, newDb, "type=\'table\'", & tryToCloneData);
    tryToCloneSchema(p, newDb, "type!=\'table\'", (void (*)(ShellState * , sqlite3 * ,
                                                            char const   * ))0);
    sqlite3_exec(newDb, "COMMIT;", (int (*)(void * , int  , char ** , char ** ))0,
                 (void *)0, (char **)0);
    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", (int (*)(void * , int  , char ** ,
                                                                char ** ))0, (void *)0,
                 (char **)0);
  }
  close_db(newDb);
  return;
}
}
static void output_reset(ShellState *p ) 
{ 
  char const   *zXdgOpenCmd ;
  char *zCmd ;
  int tmp ;

  {
  if ((int )p->outfile[0] == 124) {
    pclose(p->out);
  } else {
    output_file_close(p->out);
    if (p->doXdgOpen) {
      zXdgOpenCmd = "xdg-open";
      zCmd = sqlite3_mprintf("%s %s", zXdgOpenCmd, p->zTempFile);
      tmp = system((char const   *)zCmd);
      if (tmp) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed: [%s]\n",
                zCmd);
      }
      sqlite3_free((void *)zCmd);
      outputModePop(p);
      p->doXdgOpen = (u8 )0;
      sqlite3_sleep(100);
    }
  }
  p->outfile[0] = (char)0;
  p->out = stdout;
  return;
}
}
static int db_int(ShellState *p , char const   *zSql ) 
{ 
  sqlite3_stmt *pStmt ;
  int res ;
  int tmp ;

  {
  res = 0;
  sqlite3_prepare_v2(p->db, zSql, -1, & pStmt, (char const   **)0);
  if (pStmt) {
    tmp = sqlite3_step(pStmt);
    if (tmp == 100) {
      res = sqlite3_column_int(pStmt, 0);
    }
  }
  sqlite3_finalize(pStmt);
  return (res);
}
}
static unsigned int get2byteInt(unsigned char *a___0 ) 
{ 


  {
  return ((unsigned int )(((int )*(a___0 + 0) << 8) + (int )*(a___0 + 1)));
}
}
static unsigned int get4byteInt(unsigned char *a___0 ) 
{ 


  {
  return ((unsigned int )(((((int )*(a___0 + 0) << 24) + ((int )*(a___0 + 1) << 16)) + ((int )*(a___0 + 2) << 8)) + (int )*(a___0 + 3)));
}
}
static int shell_dbinfo_command(ShellState *p , int nArg , char **azArg ) ;
static struct __anonstruct_aField_713894858  const  aField[12]  = 
  {      {"file change counter:", 24}, 
        {"database page count:", 28}, 
        {"freelist page count:", 36}, 
        {"schema cookie:", 40}, 
        {"schema format:", 44}, 
        {"default cache size:", 48}, 
        {"autovacuum top root:", 52}, 
        {"incremental vacuum:", 64}, 
        {"text encoding:", 56}, 
        {"user version:", 60}, 
        {"application id:", 68}, 
        {"software version:", 96}};
static struct __anonstruct_aQuery_713894859  const  aQuery[5]  = {      {"number of tables:", "SELECT count(*) FROM %s WHERE type=\'table\'"}, 
        {"number of indexes:", "SELECT count(*) FROM %s WHERE type=\'index\'"}, 
        {"number of triggers:", "SELECT count(*) FROM %s WHERE type=\'trigger\'"}, 
        {"number of views:", "SELECT count(*) FROM %s WHERE type=\'view\'"}, 
        {"schema size:", "SELECT total(length(sql)) FROM %s"}};
static int shell_dbinfo_command(ShellState *p , int nArg , char **azArg ) 
{ 
  int i ;
  int rc ;
  unsigned int iDataVersion ;
  char *zSchemaTab ;
  char *zDb ;
  char const   *tmp ;
  sqlite3_stmt *pStmt ;
  unsigned char aHdr[100] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  void const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int ofst ;
  unsigned int val ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  char *zSql ;
  char *tmp___8 ;
  int val___0 ;
  int tmp___9 ;

  {
  if (nArg >= 2) {
    tmp = (char const   *)*(azArg + 1);
  } else {
    tmp = "main";
  }
  zDb = (char *)tmp;
  pStmt = (sqlite3_stmt *)0;
  open_db(p, 0);
  if ((unsigned long )p->db == (unsigned long )((sqlite3 *)0)) {
    return (1);
  }
  rc = sqlite3_prepare_v2(p->db, "SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1",
                          -1, & pStmt, (char const   **)0);
  if (rc) {
    tmp___1 = sqlite3_compileoption_used("ENABLE_DBPAGE_VTAB");
    if (tmp___1) {
      tmp___0 = sqlite3_errmsg(p->db);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: %s\n",
              tmp___0);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"the \".dbinfo\" command requires the -DSQLITE_ENABLE_DBPAGE_VTAB compile-time options\n");
    }
    sqlite3_finalize(pStmt);
    return (1);
  }
  sqlite3_bind_text(pStmt, 1, (char const   *)zDb, -1, (void (*)(void * ))0);
  tmp___3 = sqlite3_step(pStmt);
  if (tmp___3 == 100) {
    tmp___4 = sqlite3_column_bytes(pStmt, 0);
    if (tmp___4 > 100) {
      tmp___2 = sqlite3_column_blob(pStmt, 0);
      memcpy((void * __restrict  )(aHdr), (void const   * __restrict  )tmp___2, (size_t )100);
      sqlite3_finalize(pStmt);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to read database header\n");
      sqlite3_finalize(pStmt);
      return (1);
    }
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to read database header\n");
    sqlite3_finalize(pStmt);
    return (1);
  }
  tmp___5 = get2byteInt(aHdr + 16);
  i = (int )tmp___5;
  if (i == 1) {
    i = 65536;
  }
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %d\n",
          "database page size:", i);
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %d\n",
          "write format:", (int )aHdr[18]);
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %d\n",
          "read format:", (int )aHdr[19]);
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %d\n",
          "reserved bytes:", (int )aHdr[20]);
  i = 0;
  while (i < (int )(sizeof(aField) / sizeof(aField[0]))) {
    ofst = (int )aField[i].ofst;
    tmp___6 = get4byteInt(aHdr + ofst);
    val = tmp___6;
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %u",
            aField[i].zName, val);
    switch (ofst) {
    case 56: 
    if (val == 1U) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )" (utf8)");
    }
    if (val == 2U) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )" (utf16le)");
    }
    if (val == 3U) {
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )" (utf16be)");
    }
    }
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
    i ++;
  }
  if ((unsigned long )zDb == (unsigned long )((char *)0)) {
    zSchemaTab = sqlite3_mprintf("main.sqlite_master");
  } else {
    tmp___7 = strcmp((char const   *)zDb, "temp");
    if (tmp___7 == 0) {
      zSchemaTab = sqlite3_mprintf("%s", "sqlite_temp_master");
    } else {
      zSchemaTab = sqlite3_mprintf("\"%w\".sqlite_master", zDb);
    }
  }
  i = 0;
  while (i < (int )(sizeof(aQuery) / sizeof(aQuery[0]))) {
    tmp___8 = sqlite3_mprintf((char const   *)aQuery[i].zSql, zSchemaTab);
    zSql = tmp___8;
    tmp___9 = db_int(p, (char const   *)zSql);
    val___0 = tmp___9;
    sqlite3_free((void *)zSql);
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %d\n",
            aQuery[i].zName, val___0);
    i ++;
  }
  sqlite3_free((void *)zSchemaTab);
  sqlite3_file_control(p->db, (char const   *)zDb, 35, (void *)(& iDataVersion));
  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-20s %u\n",
          "data version", iDataVersion);
  return (0);
}
}
static int shellDatabaseError(sqlite3 *db ) 
{ 
  char const   *zErr ;
  char const   *tmp ;

  {
  tmp = sqlite3_errmsg(db);
  zErr = tmp;
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
          zErr);
  return (1);
}
}
static int testcase_glob(char const   *zGlob , char const   *z ) 
{ 
  int c ;
  int c2 ;
  int invert ;
  int seen ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int prior_c ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  char const   *tmp___18 ;
  unsigned short const   **tmp___19 ;
  char const   *tmp___20 ;
  unsigned short const   **tmp___21 ;

  {
  while (1) {
    tmp___20 = zGlob;
    zGlob ++;
    c = (int )*tmp___20;
    if (! (c != 0)) {
      break;
    }
    tmp___19 = __ctype_b_loc();
    if ((int const   )*(*tmp___19 + (int )((unsigned char )c)) & 8192) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )((unsigned char )*z)) & 8192)) {
        return (0);
      }
      while (1) {
        tmp___0 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*zGlob)) & 8192)) {
          break;
        }
        zGlob ++;
      }
      while (1) {
        tmp___1 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*z)) & 8192)) {
          break;
        }
        z ++;
      }
    } else
    if (c == 42) {
      while (1) {
        tmp___3 = zGlob;
        zGlob ++;
        c = (int )*tmp___3;
        if (! (c == 42)) {
          if (! (c == 63)) {
            break;
          }
        }
        if (c == 63) {
          tmp___2 = z;
          z ++;
          if ((int const   )*tmp___2 == 0) {
            return (0);
          }
        }
      }
      if (c == 0) {
        return (1);
      } else
      if (c == 91) {
        while (1) {
          if (*z) {
            tmp___4 = testcase_glob(zGlob - 1, z);
            if (! (tmp___4 == 0)) {
              break;
            }
          } else {
            break;
          }
          z ++;
        }
        return ((int const   )*z != 0);
      }
      while (1) {
        tmp___7 = z;
        z ++;
        c2 = (int )*tmp___7;
        if (! (c2 != 0)) {
          break;
        }
        while (c2 != c) {
          tmp___5 = z;
          z ++;
          c2 = (int )*tmp___5;
          if (c2 == 0) {
            return (0);
          }
        }
        tmp___6 = testcase_glob(zGlob, z);
        if (tmp___6) {
          return (1);
        }
      }
      return (0);
    } else
    if (c == 63) {
      tmp___8 = z;
      z ++;
      if ((int const   )*tmp___8 == 0) {
        return (0);
      }
    } else
    if (c == 91) {
      prior_c = 0;
      seen = 0;
      invert = 0;
      tmp___9 = z;
      z ++;
      c = (int )*tmp___9;
      if (c == 0) {
        return (0);
      }
      tmp___10 = zGlob;
      zGlob ++;
      c2 = (int )*tmp___10;
      if (c2 == 94) {
        invert = 1;
        tmp___11 = zGlob;
        zGlob ++;
        c2 = (int )*tmp___11;
      }
      if (c2 == 93) {
        if (c == 93) {
          seen = 1;
        }
        tmp___12 = zGlob;
        zGlob ++;
        c2 = (int )*tmp___12;
      }
      while (1) {
        if (c2) {
          if (! (c2 != 93)) {
            break;
          }
        } else {
          break;
        }
        if (c2 == 45) {
          if ((int const   )*(zGlob + 0) != 93) {
            if ((int const   )*(zGlob + 0) != 0) {
              if (prior_c > 0) {
                tmp___13 = zGlob;
                zGlob ++;
                c2 = (int )*tmp___13;
                if (c >= prior_c) {
                  if (c <= c2) {
                    seen = 1;
                  }
                }
                prior_c = 0;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          if (c == c2) {
            seen = 1;
          }
          prior_c = c2;
        }
        tmp___14 = zGlob;
        zGlob ++;
        c2 = (int )*tmp___14;
      }
      if (c2 == 0) {
        return (0);
      } else
      if ((seen ^ invert) == 0) {
        return (0);
      }
    } else
    if (c == 35) {
      if ((int const   )*(z + 0) == 45) {
        goto _L___2;
      } else
      if ((int const   )*(z + 0) == 43) {
        _L___2: /* CIL Label */ 
        tmp___15 = __ctype_b_loc();
        if ((int const   )*(*tmp___15 + (int )((unsigned char )*(z + 1))) & 2048) {
          z ++;
        }
      }
      tmp___16 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___16 + (int )((unsigned char )*(z + 0))) & 2048)) {
        return (0);
      }
      z ++;
      while (1) {
        tmp___17 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___17 + (int )((unsigned char )*(z + 0))) & 2048)) {
          break;
        }
        z ++;
      }
    } else {
      tmp___18 = z;
      z ++;
      if (c != (int )*tmp___18) {
        return (0);
      }
    }
  }
  while (1) {
    tmp___21 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___21 + (int )((unsigned char )*z)) & 8192)) {
      break;
    }
    z ++;
  }
  return ((int const   )*z == 0);
}
}
static int optionMatch(char const   *zStr , char const   *zOpt ) 
{ 
  int tmp ;

  {
  if ((int const   )*(zStr + 0) != 45) {
    return (0);
  }
  zStr ++;
  if ((int const   )*(zStr + 0) == 45) {
    zStr ++;
  }
  tmp = strcmp(zStr, zOpt);
  return (tmp == 0);
}
}
int shellDeleteFile(char const   *zFilename ) 
{ 
  int rc ;

  {
  rc = unlink(zFilename);
  return (rc);
}
}
static void clearTempFile(ShellState *p ) 
{ 
  int tmp ;

  {
  if ((unsigned long )p->zTempFile == (unsigned long )((char *)0)) {
    return;
  }
  if (p->doXdgOpen) {
    return;
  }
  tmp = shellDeleteFile((char const   *)p->zTempFile);
  if (tmp) {
    return;
  }
  sqlite3_free((void *)p->zTempFile);
  p->zTempFile = (char *)0;
  return;
}
}
static void newTempFile(ShellState *p , char const   *zSuffix ) 
{ 
  sqlite_uint64 r ;

  {
  clearTempFile(p);
  sqlite3_free((void *)p->zTempFile);
  p->zTempFile = (char *)0;
  if (p->db) {
    sqlite3_file_control(p->db, (char const   *)0, 16, (void *)(& p->zTempFile));
  }
  if ((unsigned long )p->zTempFile == (unsigned long )((char *)0)) {
    sqlite3_randomness((int )sizeof(r), (void *)(& r));
    p->zTempFile = sqlite3_mprintf("temp%llx.%s", r, zSuffix);
  } else {
    p->zTempFile = sqlite3_mprintf("%z.%s", p->zTempFile, zSuffix);
  }
  if ((unsigned long )p->zTempFile == (unsigned long )((char *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"out of memory\n");
    exit(1);
  }
  return;
}
}
static void shellFkeyCollateClause(sqlite3_context *pCtx , int nVal , sqlite3_value **apVal ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  char const   *zParent ;
  char const   *zParentCol ;
  char const   *zParentSeq ;
  char const   *zChild ;
  char const   *zChildCol ;
  char const   *zChildSeq ;
  int rc ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  char *z ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  tmp = sqlite3_context_db_handle(pCtx);
  db = tmp;
  zChildSeq = (char const   *)0;
  if (! (nVal == 4)) {
    __assert_fail("nVal==4", "shell.c", 13764U, "shellFkeyCollateClause");
  }
  tmp___1 = sqlite3_value_text(*(apVal + 0));
  zParent = (char const   *)tmp___1;
  tmp___2 = sqlite3_value_text(*(apVal + 1));
  zParentCol = (char const   *)tmp___2;
  tmp___3 = sqlite3_value_text(*(apVal + 2));
  zChild = (char const   *)tmp___3;
  tmp___4 = sqlite3_value_text(*(apVal + 3));
  zChildCol = (char const   *)tmp___4;
  sqlite3_result_text(pCtx, "", -1, (void (*)(void * ))0);
  rc = sqlite3_table_column_metadata(db, "main", zParent, zParentCol, (char const   **)0,
                                     & zParentSeq, (int *)0, (int *)0, (int *)0);
  if (rc == 0) {
    rc = sqlite3_table_column_metadata(db, "main", zChild, zChildCol, (char const   **)0,
                                       & zChildSeq, (int *)0, (int *)0, (int *)0);
  }
  if (rc == 0) {
    tmp___6 = sqlite3_stricmp(zParentSeq, zChildSeq);
    if (tmp___6) {
      tmp___5 = sqlite3_mprintf(" COLLATE %s", zParentSeq);
      z = tmp___5;
      sqlite3_result_text(pCtx, (char const   *)z, -1, (void (*)(void * ))-1);
      sqlite3_free((void *)z);
    }
  }
  return;
}
}
static int lintFkeyIndexes(ShellState *pState , char **azArg , int nArg ) 
{ 
  sqlite3 *db ;
  FILE *out ;
  int bVerbose ;
  int bGroupByParent ;
  int i ;
  char const   *zIndent ;
  int rc ;
  sqlite3_stmt *pSql ;
  char const   *zSql ;
  char const   *zGlobIPK ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int rc2 ;
  char *zPrev ;
  int res ;
  sqlite3_stmt *pExplain ;
  char const   *zEQP ;
  unsigned char const   *tmp___2 ;
  char const   *zGlob ;
  unsigned char const   *tmp___3 ;
  char const   *zFrom ;
  unsigned char const   *tmp___4 ;
  char const   *zTarget ;
  unsigned char const   *tmp___5 ;
  char const   *zCI ;
  unsigned char const   *tmp___6 ;
  char const   *zParent ;
  unsigned char const   *tmp___7 ;
  char const   *zPlan ;
  unsigned char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
  db = pState->db;
  out = pState->out;
  bVerbose = 0;
  bGroupByParent = 0;
  zIndent = "";
  pSql = (sqlite3_stmt *)0;
  zSql = "SELECT      \'EXPLAIN QUERY PLAN SELECT 1 FROM \' || quote(s.name) || \' WHERE \'  || group_concat(quote(s.name) || \'.\' || quote(f.[from]) || \'=?\'   || fkey_collate_clause(       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),\' AND \'),      \'SEARCH TABLE \' || s.name || \' USING COVERING INDEX*(\'  || group_concat(\'*=?\', \' AND \') || \')\',      s.name  || \'(\' || group_concat(f.[from],  \', \') || \')\',      f.[table] || \'(\' || group_concat(COALESCE(f.[to], p.[name])) || \')\',      \'CREATE INDEX \' || quote(s.name ||\'_\'|| group_concat(f.[from], \'_\'))  || \' ON \' || quote(s.name) || \'(\'  || group_concat(quote(f.[from]) ||        fkey_collate_clause(          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), \', \')  || \');\',      f.[table] FROM sqlite_master AS s, pragma_foreign_key_list(s.name) AS f LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) GROUP BY s.name, f.id ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)";
  zGlobIPK = "SEARCH TABLE * USING INTEGER PRIMARY KEY (rowid=?)";
  i = 2;
  while (i < nArg) {
    tmp = strlen30((char const   *)*(azArg + i));
    n = tmp;
    if (n > 1) {
      tmp___1 = sqlite3_strnicmp("-verbose", (char const   *)*(azArg + i), n);
      if (tmp___1 == 0) {
        bVerbose = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (n > 1) {
      tmp___0 = sqlite3_strnicmp("-groupbyparent", (char const   *)*(azArg + i), n);
      if (tmp___0 == 0) {
        bGroupByParent = 1;
        zIndent = "    ";
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s %s ?-verbose? ?-groupbyparent?\n",
                *(azArg + 0), *(azArg + 1));
        return (1);
      }
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s %s ?-verbose? ?-groupbyparent?\n",
              *(azArg + 0), *(azArg + 1));
      return (1);
    }
    i ++;
  }
  rc = sqlite3_create_function(db, "fkey_collate_clause", 4, 1, (void *)0, & shellFkeyCollateClause,
                               (void (*)(sqlite3_context * , int  , sqlite3_value ** ))0,
                               (void (*)(sqlite3_context * ))0);
  if (rc == 0) {
    rc = sqlite3_prepare_v2(db, zSql, -1, & pSql, (char const   **)0);
  }
  if (rc == 0) {
    sqlite3_bind_int(pSql, 1, bGroupByParent);
  }
  if (rc == 0) {
    zPrev = (char *)0;
    while (1) {
      tmp___14 = sqlite3_step(pSql);
      if (! (100 == tmp___14)) {
        break;
      }
      res = -1;
      pExplain = (sqlite3_stmt *)0;
      tmp___2 = sqlite3_column_text(pSql, 0);
      zEQP = (char const   *)tmp___2;
      tmp___3 = sqlite3_column_text(pSql, 1);
      zGlob = (char const   *)tmp___3;
      tmp___4 = sqlite3_column_text(pSql, 2);
      zFrom = (char const   *)tmp___4;
      tmp___5 = sqlite3_column_text(pSql, 3);
      zTarget = (char const   *)tmp___5;
      tmp___6 = sqlite3_column_text(pSql, 4);
      zCI = (char const   *)tmp___6;
      tmp___7 = sqlite3_column_text(pSql, 5);
      zParent = (char const   *)tmp___7;
      rc = sqlite3_prepare_v2(db, zEQP, -1, & pExplain, (char const   **)0);
      if (rc != 0) {
        break;
      }
      tmp___12 = sqlite3_step(pExplain);
      if (100 == tmp___12) {
        tmp___8 = sqlite3_column_text(pExplain, 3);
        zPlan = (char const   *)tmp___8;
        tmp___9 = sqlite3_strglob(zGlob, zPlan);
        if (0 == tmp___9) {
          tmp___11 = 1;
        } else {
          tmp___10 = sqlite3_strglob(zGlobIPK, zPlan);
          if (0 == tmp___10) {
            tmp___11 = 1;
          } else {
            tmp___11 = 0;
          }
        }
        res = tmp___11;
      }
      rc = sqlite3_finalize(pExplain);
      if (rc != 0) {
        break;
      }
      if (res < 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: internal error");
        break;
      } else {
        if (bGroupByParent) {
          if (bVerbose) {
            goto _L___0;
          } else
          if (res == 0) {
            _L___0: /* CIL Label */ 
            if ((unsigned long )zPrev == (unsigned long )((char *)0)) {
              fprintf((FILE * __restrict  )out, (char const   * __restrict  )"-- Parent table %s\n",
                      zParent);
              sqlite3_free((void *)zPrev);
              zPrev = sqlite3_mprintf("%s", zParent);
            } else {
              tmp___13 = sqlite3_stricmp(zParent, (char const   *)zPrev);
              if (tmp___13) {
                fprintf((FILE * __restrict  )out, (char const   * __restrict  )"-- Parent table %s\n",
                        zParent);
                sqlite3_free((void *)zPrev);
                zPrev = sqlite3_mprintf("%s", zParent);
              }
            }
          }
        }
        if (res == 0) {
          fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s%s --> %s\n",
                  zIndent, zCI, zTarget);
        } else
        if (bVerbose) {
          fprintf((FILE * __restrict  )out, (char const   * __restrict  )"%s/* no extra indexes required for %s -> %s */\n",
                  zIndent, zFrom, zTarget);
        }
      }
    }
    sqlite3_free((void *)zPrev);
    if (rc != 0) {
      tmp___15 = sqlite3_errmsg(db);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", tmp___15);
    }
    rc2 = sqlite3_finalize(pSql);
    if (rc == 0) {
      if (rc2 != 0) {
        rc = rc2;
        tmp___16 = sqlite3_errmsg(db);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n",
                tmp___16);
      }
    }
  } else {
    tmp___17 = sqlite3_errmsg(db);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", tmp___17);
  }
  return (rc);
}
}
static int lintDotCommand(ShellState *pState , char **azArg , int nArg ) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (nArg >= 2) {
    tmp = strlen30((char const   *)*(azArg + 1));
    n = tmp;
  } else {
    n = 0;
  }
  if (n < 1) {
    goto usage;
  } else {
    tmp___0 = sqlite3_strnicmp((char const   *)*(azArg + 1), "fkey-indexes", n);
    if (tmp___0) {
      goto usage;
    }
  }
  tmp___1 = lintFkeyIndexes(pState, azArg, nArg);
  return (tmp___1);
  usage: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage %s sub-command ?switches...?\n",
          *(azArg + 0));
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Where sub-commands are:\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"    fkey-indexes\n");
  return (1);
}
}
static void shellPrepare(sqlite3 *db , int *pRc , char const   *zSql , sqlite3_stmt **ppStmt ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  *ppStmt = (sqlite3_stmt *)0;
  if (*pRc == 0) {
    tmp = sqlite3_prepare_v2(db, zSql, -1, ppStmt, (char const   **)0);
    rc = tmp;
    if (rc != 0) {
      tmp___0 = sqlite3_errcode(db);
      tmp___1 = sqlite3_errmsg(db);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sql error: %s (%d)\n",
              tmp___1, tmp___0);
      *pRc = rc;
    }
  }
  return;
}
}
void shellPreparePrintf(sqlite3 *db , int *pRc , sqlite3_stmt **ppStmt , char const   *zFmt 
                        , ...) 
{ 
  va_list ap ;
  char *z ;

  {
  *ppStmt = (sqlite3_stmt *)0;
  if (*pRc == 0) {
    __builtin_va_start(ap, zFmt);
    z = sqlite3_vmprintf(zFmt, ap);
    __builtin_va_end(ap);
    if ((unsigned long )z == (unsigned long )((char *)0)) {
      *pRc = 7;
    } else {
      shellPrepare(db, pRc, (char const   *)z, ppStmt);
      sqlite3_free((void *)z);
    }
  }
  return;
}
}
void shellFinalize(int *pRc , sqlite3_stmt *pStmt ) 
{ 
  sqlite3 *db ;
  sqlite3 *tmp ;
  int rc ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  if (pStmt) {
    tmp = sqlite3_db_handle(pStmt);
    db = tmp;
    tmp___0 = sqlite3_finalize(pStmt);
    rc = tmp___0;
    if (*pRc == 0) {
      if (rc != 0) {
        tmp___1 = sqlite3_errmsg(db);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SQL error: %s\n",
                tmp___1);
      }
      *pRc = rc;
    }
  }
  return;
}
}
void shellReset(int *pRc , sqlite3_stmt *pStmt ) 
{ 
  int rc ;
  int tmp ;
  sqlite3 *db ;
  sqlite3 *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = sqlite3_reset(pStmt);
  rc = tmp;
  if (*pRc == 0) {
    if (rc != 0) {
      tmp___0 = sqlite3_db_handle(pStmt);
      db = tmp___0;
      tmp___1 = sqlite3_errmsg(db);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SQL error: %s\n",
              tmp___1);
    }
    *pRc = rc;
  }
  return;
}
}
static int do_meta_command(char *zLine , ShellState *p ) ;
static struct DbConfigChoices  const  aDbConfig[14]  = 
  {      {"enable_fkey", 1002}, 
        {"enable_trigger", 1003}, 
        {"enable_view", 1015}, 
        {"fts3_tokenizer", 1004}, 
        {"load_extension", 1005}, 
        {"no_ckpt_on_close", 1006}, 
        {"enable_qpsg", 1007}, 
        {"trigger_eqp", 1008}, 
        {"reset_database", 1009}, 
        {"defensive", 1010}, 
        {"writable_schema", 1011}, 
        {"legacy_alter_table", 1012}, 
        {"dqs_dml", 1013}, 
        {"dqs_ddl", 1014}};
static struct __anonstruct_aCtrl_942335853  const  aCtrl[7]  = {      {"size_limit", 36, "[LIMIT]"}, 
        {"chunk_size", 6, "SIZE"}, 
        {"persist_wal", 10, "[BOOLEAN]"}, 
        {"psow", 13, "[BOOLEAN]"}, 
        {"tempfilename", 16, ""}, 
        {"has_moved", 20, ""}, 
        {"lock_timeout", 34, "MILLISEC"}};
static struct __anonstruct_aLimit_942335854  const  aLimit[12]  = 
  {      {"length", 0}, 
        {"sql_length", 1}, 
        {"column", 2}, 
        {"expr_depth", 3}, 
        {"compound_select", 4}, 
        {"vdbe_op", 5}, 
        {"function_arg", 6}, 
        {"attached", 7}, 
        {"like_pattern_length", 8}, 
        {"variable_number", 9}, 
        {"trigger_depth", 10}, 
        {"worker_threads", 11}};
static char const   *azBool[4]  = {      "off",      "on",      "trigger",      "full"};
static struct __anonstruct_aCtrl_942335855  const  aCtrl___0[14]  = 
  {      {"always", 13, "BOOLEAN"}, 
        {"assert", 12, "BOOLEAN"}, 
        {"byteorder", 22, ""}, 
        {"extra_schema_checks", 29, "BOOLEAN"}, 
        {"imposter", 25, "SCHEMA ON/OFF ROOTPAGE"}, 
        {"internal_functions", 17, "BOOLEAN"}, 
        {"localtime_fault", 18, "BOOLEAN"}, 
        {"never_corrupt", 20, "BOOLEAN"}, 
        {"optimizations", 15, "DISABLE-MASK"}, 
        {"pending_byte", 11, "OFFSET  "}, 
        {"prng_restore", 6, ""}, 
        {"prng_save", 5, ""}, 
        {"prng_seed", 28, "SEED ?db?"}, 
        {"reserve", 14, "BYTES-OF-RESERVE"}};
static int do_meta_command(char *zLine , ShellState *p ) 
{ 
  int h ;
  int nArg ;
  int n ;
  int c ;
  int rc ;
  char *azArg[52] ;
  unsigned short const   **tmp ;
  int delim ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *zDestFile ;
  char const   *zDb ;
  sqlite3 *pDest ;
  sqlite3_backup *pBackup ;
  int j ;
  int bAsync ;
  char const   *zVfs ;
  char const   *z ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *zRes ;
  int tmp___11 ;
  ShellState data ;
  char *zErrMsg ;
  int ii ;
  int v ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char const   *zLike ;
  int i ;
  int savedShowHeader ;
  int savedShellFlags ;
  char const   *z___0 ;
  int tmp___15 ;
  int tmp___16 ;
  char *zSql ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  sqlite_int64 tmp___21 ;
  int val ;
  int tmp___22 ;
  int filectrl ;
  int iCtrl ;
  sqlite_int64 iRes ;
  int isOk ;
  int n2 ;
  int i___0 ;
  char const   *zCmd ;
  int tmp___23 ;
  int tmp___24 ;
  sqlite_int64 tmp___25 ;
  int x___0 ;
  sqlite_int64 tmp___26 ;
  int x___1 ;
  int tmp___27 ;
  int x___2 ;
  char *z___1 ;
  char zBuf[100] ;
  ShellState data___0 ;
  char *zErrMsg___0 ;
  int doStats ;
  int tmp___28 ;
  sqlite3_stmt *pStmt ;
  int tmp___29 ;
  char *zTable ;
  char *zFile ;
  sqlite3_stmt *pStmt___0 ;
  int nCol ;
  int nByte ;
  int i___1 ;
  int j___0 ;
  int needCommit ;
  int nSep ;
  char *zSql___0 ;
  ImportCtx sCtx ;
  char *(*xRead)(ImportCtx * ) ;
  int (*xCloser)(FILE * ) ;
  int tmp___30 ;
  char *zCreate ;
  char *tmp___31 ;
  char cSep ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  void *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  int startLine ;
  char *z___2 ;
  char *tmp___42 ;
  char const   *tmp___43 ;
  char *zSql___1 ;
  char *zCollist ;
  sqlite3_stmt *pStmt___1 ;
  int tnum ;
  int i___2 ;
  int tmp___44 ;
  int tmp___45 ;
  char zLabel[20] ;
  char const   *zCol ;
  unsigned char const   *tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  char const   *tmp___49 ;
  int i___3 ;
  int n2___0 ;
  int tmp___50 ;
  int iLimit ;
  int tmp___51 ;
  sqlite_int64 tmp___52 ;
  int tmp___53 ;
  char const   *zFile___0 ;
  char const   *zMode ;
  char const   *tmp___54 ;
  int n2___1 ;
  int tmp___55 ;
  int c2 ;
  char const   *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  char *zNewFilename ;
  int iName ;
  int newFlag ;
  char const   *z___3 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  char *tmp___70 ;
  char const   *zFile___1 ;
  char const   *tmp___71 ;
  int bTxtMode ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  sqlite3_stmt *pStmt___2 ;
  int rx ;
  int len ;
  int tmp___76 ;
  unsigned char const   *tmp___77 ;
  unsigned char const   *tmp___78 ;
  int tmp___79 ;
  int rx___0 ;
  char *zSql___2 ;
  sqlite3_stmt *pStmt___3 ;
  char const   *zKey ;
  char const   *zValue ;
  char const   *tmp___80 ;
  char *zSql___3 ;
  char *tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int i___4 ;
  int i___5 ;
  int nn ;
  char const   *z___4 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  sqlite_int64 tmp___91 ;
  int tmp___92 ;
  sqlite_int64 tmp___93 ;
  FILE *inSaved ;
  int savedLineno ;
  char const   *zSrcFile ;
  char const   *zDb___0 ;
  sqlite3 *pSrc ;
  sqlite3_backup *pBackup___0 ;
  int nTimeout ;
  char const   *tmp___94 ;
  int tmp___95 ;
  char const   *tmp___96 ;
  int tmp___97 ;
  ShellText sSelect ;
  ShellState data___1 ;
  char *zErrMsg___1 ;
  char const   *zDiv ;
  char const   *zName ;
  int iSchema ;
  int bDebug ;
  int ii___0 ;
  int tmp___98 ;
  int tmp___99 ;
  int isMaster ;
  int tmp___100 ;
  char *new_argv[2] ;
  char *new_colv[2] ;
  char const   *tmp___101 ;
  int tmp___102 ;
  sqlite3_stmt *pStmt___4 ;
  char const   *tmp___103 ;
  char const   *zDb___1 ;
  unsigned char const   *tmp___104 ;
  char zScNum[30] ;
  int tmp___105 ;
  char tmp___106 ;
  int tmp___107 ;
  char *zQarg ;
  char *tmp___108 ;
  int bGlob ;
  char *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  int tmp___112 ;
  char *tmp___113 ;
  char const   *tmp___114 ;
  int bIsInit ;
  int bVerbose ;
  int bSelftestExists ;
  int i___6 ;
  int k ;
  int nTest ;
  int nErr ;
  ShellText str ;
  sqlite3_stmt *pStmt___5 ;
  char const   *z___5 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tno ;
  int tmp___118 ;
  char const   *zOp ;
  unsigned char const   *tmp___119 ;
  char const   *zSql___4 ;
  unsigned char const   *tmp___120 ;
  char const   *zAns ;
  unsigned char const   *tmp___121 ;
  char *zQuote ;
  char *tmp___122 ;
  char *zErrMsg___2 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  char const   *zLike___0 ;
  int i___7 ;
  int bSchema ;
  int bSeparate ;
  int iSize ;
  int bDebug___0 ;
  sqlite3_stmt *pStmt___6 ;
  char *zSql___5 ;
  char *zSep ;
  ShellText sSql ;
  ShellText sQuery ;
  char const   *z___6 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  char const   *zTab ;
  unsigned char const   *tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  char *zCmd___0 ;
  int i___8 ;
  int x___3 ;
  char const   *tmp___143 ;
  char *tmp___144 ;
  char const   *tmp___146 ;
  char *tmp___147 ;
  int i___9 ;
  char const   *tmp___148 ;
  char const   *tmp___149 ;
  char const   *tmp___151 ;
  int tmp___152 ;
  char const   *tmp___153 ;
  int tmp___154 ;
  sqlite3_stmt *pStmt___7 ;
  char **azResult ;
  int nRow ;
  int nAlloc ;
  int ii___1 ;
  ShellText s ;
  int tmp___155 ;
  char const   *zDbName ;
  unsigned char const   *tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  char **azNew ;
  int n2___2 ;
  void *tmp___160 ;
  unsigned char const   *tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int len___0 ;
  int maxlen ;
  int i___10 ;
  int j___1 ;
  int nPrintCol ;
  int nPrintRow ;
  char *zSp ;
  char const   *tmp___164 ;
  char const   *tmp___165 ;
  int testctrl ;
  int iCtrl___0 ;
  int rc2 ;
  int isOk___0 ;
  int i___11 ;
  int n2___3 ;
  char const   *zCmd___1 ;
  int tmp___166 ;
  int tmp___167 ;
  int opt ;
  long tmp___168 ;
  unsigned int opt___0 ;
  sqlite_int64 tmp___169 ;
  int ii___2 ;
  sqlite_int64 tmp___170 ;
  sqlite3 *db ;
  int tmp___171 ;
  int opt___1 ;
  int tmp___172 ;
  int opt___2 ;
  int tmp___173 ;
  sqlite_int64 tmp___174 ;
  sqlite_int64 tmp___175 ;
  sqlite_int64 tmp___176 ;
  int tmp___177 ;
  int mType ;
  int jj ;
  char const   *z___7 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  char const   *tmp___184 ;
  char const   *tmp___185 ;
  char const   *zDbName___0 ;
  char const   *tmp___186 ;
  sqlite3_vfs *pVfs ;
  sqlite3_vfs *pVfs___0 ;
  sqlite3_vfs *pCurrent ;
  char const   *tmp___187 ;
  char const   *zDbName___1 ;
  char const   *tmp___188 ;
  char *zVfsName ;
  int j___2 ;
  sqlite_int64 tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  int tmp___199 ;
  int tmp___200 ;
  int tmp___201 ;
  int tmp___202 ;
  int tmp___203 ;
  int tmp___204 ;
  int tmp___205 ;
  int tmp___206 ;
  int tmp___207 ;
  int tmp___208 ;
  int tmp___209 ;
  int tmp___210 ;
  int tmp___211 ;
  int tmp___212 ;
  int tmp___213 ;
  int tmp___214 ;
  int tmp___215 ;
  int tmp___216 ;
  int tmp___217 ;
  int tmp___218 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___230 ;
  int tmp___231 ;
  int tmp___232 ;
  int tmp___233 ;
  int tmp___234 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___242 ;
  int tmp___243 ;
  int tmp___244 ;
  int tmp___245 ;
  int tmp___246 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___253 ;

  {
  h = 1;
  nArg = 0;
  rc = 0;
  if (p->expert.pExpert) {
    expertFinish(p, 1, (char **)0);
  }
  while (1) {
    if (*(zLine + h)) {
      if (! (nArg < (int )(sizeof(azArg) / sizeof(azArg[0])) - 1)) {
        break;
      }
    } else {
      break;
    }
    while (1) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(zLine + h))) & 8192)) {
        break;
      }
      h ++;
    }
    if ((int )*(zLine + h) == 0) {
      break;
    }
    if ((int )*(zLine + h) == 39) {
      goto _L;
    } else
    if ((int )*(zLine + h) == 34) {
      _L: /* CIL Label */ 
      tmp___0 = h;
      h ++;
      delim = (int )*(zLine + tmp___0);
      tmp___1 = nArg;
      nArg ++;
      azArg[tmp___1] = zLine + h;
      while (1) {
        if (*(zLine + h)) {
          if (! ((int )*(zLine + h) != delim)) {
            break;
          }
        } else {
          break;
        }
        if ((int )*(zLine + h) == 92) {
          if (delim == 34) {
            if ((int )*(zLine + (h + 1)) != 0) {
              h ++;
            }
          }
        }
        h ++;
      }
      if ((int )*(zLine + h) == delim) {
        tmp___2 = h;
        h ++;
        *(zLine + tmp___2) = (char)0;
      }
      if (delim == 34) {
        resolve_backslashes(azArg[nArg - 1]);
      }
    } else {
      tmp___3 = nArg;
      nArg ++;
      azArg[tmp___3] = zLine + h;
      while (1) {
        if (*(zLine + h)) {
          tmp___4 = __ctype_b_loc();
          if ((int const   )*(*tmp___4 + (int )((unsigned char )*(zLine + h))) & 8192) {
            break;
          }
        } else {
          break;
        }
        h ++;
      }
      if (*(zLine + h)) {
        tmp___5 = h;
        h ++;
        *(zLine + tmp___5) = (char)0;
      }
      resolve_backslashes(azArg[nArg - 1]);
    }
  }
  azArg[nArg] = (char *)0;
  if (nArg == 0) {
    return (0);
  }
  n = strlen30((char const   *)azArg[0]);
  c = (int )*(azArg[0] + 0);
  clearTempFile(p);
  if (c == 97) {
    tmp___253 = strncmp((char const   *)azArg[0], "auth", (size_t )n);
    if (tmp___253 == 0) {
      if (nArg != 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .auth ON|OFF\n");
        rc = 1;
        goto meta_command_exit;
      }
      open_db(p, 0);
      tmp___6 = booleanValue((char const   *)azArg[1]);
      if (tmp___6) {
        sqlite3_set_authorizer(p->db, & shellAuth, (void *)p);
      } else {
        sqlite3_set_authorizer(p->db, (int (*)(void * , int  , char const   * , char const   * ,
                                               char const   * , char const   * ))0,
                               (void *)0);
      }
    } else {
      goto _L___113;
    }
  } else
  _L___113: /* CIL Label */ 
  if (c == 98) {
    if (n >= 3) {
      tmp___251 = strncmp((char const   *)azArg[0], "backup", (size_t )n);
      if (tmp___251 == 0) {
        goto _L___108;
      } else {
        goto _L___112;
      }
    } else {
      goto _L___112;
    }
  } else
  _L___112: /* CIL Label */ 
  if (c == 115) {
    if (n >= 3) {
      tmp___252 = strncmp((char const   *)azArg[0], "save", (size_t )n);
      if (tmp___252 == 0) {
        _L___108: /* CIL Label */ 
        zDestFile = (char const   *)0;
        zDb = (char const   *)0;
        bAsync = 0;
        zVfs = (char const   *)0;
        j = 1;
        while (j < nArg) {
          z = (char const   *)azArg[j];
          if ((int const   )*(z + 0) == 45) {
            if ((int const   )*(z + 1) == 45) {
              z ++;
            }
            tmp___8 = strcmp(z, "-append");
            if (tmp___8 == 0) {
              zVfs = "apndvfs";
            } else {
              tmp___7 = strcmp(z, "-async");
              if (tmp___7 == 0) {
                bAsync = 1;
              } else {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown option: %s\n",
                        azArg[j]);
                return (1);
              }
            }
          } else
          if ((unsigned long )zDestFile == (unsigned long )((char const   *)0)) {
            zDestFile = (char const   *)azArg[j];
          } else
          if ((unsigned long )zDb == (unsigned long )((char const   *)0)) {
            zDb = zDestFile;
            zDestFile = (char const   *)azArg[j];
          } else {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .backup ?DB? ?OPTIONS? FILENAME\n");
            return (1);
          }
          j ++;
        }
        if ((unsigned long )zDestFile == (unsigned long )((char const   *)0)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"missing FILENAME argument on .backup\n");
          return (1);
        }
        if ((unsigned long )zDb == (unsigned long )((char const   *)0)) {
          zDb = "main";
        }
        rc = sqlite3_open_v2(zDestFile, & pDest, 6, zVfs);
        if (rc != 0) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \"%s\"\n",
                  zDestFile);
          close_db(pDest);
          return (1);
        }
        if (bAsync) {
          sqlite3_exec(pDest, "PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;",
                       (int (*)(void * , int  , char ** , char ** ))0, (void *)0,
                       (char **)0);
        }
        open_db(p, 0);
        pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);
        if ((unsigned long )pBackup == (unsigned long )((sqlite3_backup *)0)) {
          tmp___9 = sqlite3_errmsg(pDest);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  tmp___9);
          close_db(pDest);
          return (1);
        }
        while (1) {
          rc = sqlite3_backup_step(pBackup, 100);
          if (! (rc == 0)) {
            break;
          }
        }
        sqlite3_backup_finish(pBackup);
        if (rc == 101) {
          rc = 0;
        } else {
          tmp___10 = sqlite3_errmsg(pDest);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  tmp___10);
          rc = 1;
        }
        close_db(pDest);
      } else {
        goto _L___110;
      }
    } else {
      goto _L___110;
    }
  } else
  _L___110: /* CIL Label */ 
  if (c == 98) {
    if (n >= 3) {
      tmp___250 = strncmp((char const   *)azArg[0], "bail", (size_t )n);
      if (tmp___250 == 0) {
        if (nArg == 2) {
          bail_on_error = booleanValue((char const   *)azArg[1]);
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .bail on|off\n");
          rc = 1;
        }
      } else {
        goto _L___107;
      }
    } else {
      goto _L___107;
    }
  } else
  _L___107: /* CIL Label */ 
  if (c == 98) {
    if (n >= 3) {
      tmp___249 = strncmp((char const   *)azArg[0], "binary", (size_t )n);
      if (tmp___249 == 0) {
        if (nArg == 2) {
          booleanValue((char const   *)azArg[1]);
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .binary on|off\n");
          rc = 1;
        }
      } else {
        goto _L___105;
      }
    } else {
      goto _L___105;
    }
  } else
  _L___105: /* CIL Label */ 
  if (c == 99) {
    tmp___248 = strcmp((char const   *)azArg[0], "cd");
    if (tmp___248 == 0) {
      if (nArg == 2) {
        rc = chdir((char const   *)azArg[1]);
        if (rc) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cannot change to directory \"%s\"\n",
                  azArg[1]);
          rc = 1;
        }
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .cd DIRECTORY\n");
        rc = 1;
      }
    } else {
      goto _L___103;
    }
  } else
  _L___103: /* CIL Label */ 
  if (c == 98) {
    if (n >= 3) {
      tmp___247 = strncmp((char const   *)azArg[0], "breakpoint", (size_t )n);
      if (tmp___247 == 0) {
        test_breakpoint();
      } else {
        goto _L___102;
      }
    } else {
      goto _L___102;
    }
  } else
  _L___102: /* CIL Label */ 
  if (c == 99) {
    if (n >= 3) {
      tmp___246 = strncmp((char const   *)azArg[0], "changes", (size_t )n);
      if (tmp___246 == 0) {
        if (nArg == 2) {
          setOrClearFlag(p, 32U, (char const   *)azArg[1]);
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .changes on|off\n");
          rc = 1;
        }
      } else {
        goto _L___100;
      }
    } else {
      goto _L___100;
    }
  } else
  _L___100: /* CIL Label */ 
  if (c == 99) {
    if (n >= 3) {
      tmp___245 = strncmp((char const   *)azArg[0], "check", (size_t )n);
      if (tmp___245 == 0) {
        zRes = (char *)0;
        output_reset(p);
        if (nArg != 2) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .check GLOB-PATTERN\n");
          rc = 2;
        } else {
          zRes = readFile("testcase-out.txt", (int *)0);
          if ((unsigned long )zRes == (unsigned long )((char *)0)) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot read \'testcase-out.txt\'\n");
            rc = 2;
          } else {
            tmp___11 = testcase_glob((char const   *)azArg[1], (char const   *)zRes);
            if (tmp___11 == 0) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n",
                      p->zTestcase, azArg[1], zRes);
              rc = 1;
            } else {
              fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"testcase-%s ok\n",
                      p->zTestcase);
              (p->nCheck) ++;
            }
          }
        }
        sqlite3_free((void *)zRes);
      } else {
        goto _L___98;
      }
    } else {
      goto _L___98;
    }
  } else
  _L___98: /* CIL Label */ 
  if (c == 99) {
    tmp___244 = strncmp((char const   *)azArg[0], "clone", (size_t )n);
    if (tmp___244 == 0) {
      if (nArg == 2) {
        tryToClone(p, (char const   *)azArg[1]);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .clone FILENAME\n");
        rc = 1;
      }
    } else {
      goto _L___96;
    }
  } else
  _L___96: /* CIL Label */ 
  if (c == 100) {
    if (n > 1) {
      tmp___243 = strncmp((char const   *)azArg[0], "databases", (size_t )n);
      if (tmp___243 == 0) {
        zErrMsg = (char *)0;
        open_db(p, 0);
        memcpy((void * __restrict  )(& data), (void const   * __restrict  )p, sizeof(data));
        data.showHeader = 0;
        data.mode = 2;
        data.cMode = data.mode;
        sqlite3_snprintf((int )sizeof(data.colSeparator), data.colSeparator, ": ");
        data.cnt = 0;
        sqlite3_exec(p->db, "SELECT name, file FROM pragma_database_list", & callback,
                     (void *)(& data), & zErrMsg);
        if (zErrMsg) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  zErrMsg);
          sqlite3_free((void *)zErrMsg);
          rc = 1;
        }
      } else {
        goto _L___95;
      }
    } else {
      goto _L___95;
    }
  } else
  _L___95: /* CIL Label */ 
  if (c == 100) {
    if (n >= 3) {
      tmp___242 = strncmp((char const   *)azArg[0], "dbconfig", (size_t )n);
      if (tmp___242 == 0) {
        open_db(p, 0);
        ii = 0;
        while (ii < (int )(sizeof(aDbConfig) / sizeof(aDbConfig[0]))) {
          if (nArg > 1) {
            tmp___12 = strcmp((char const   *)azArg[1], (char const   *)aDbConfig[ii].zName);
            if (tmp___12 != 0) {
              goto __Cont;
            }
          }
          if (nArg >= 3) {
            tmp___13 = booleanValue((char const   *)azArg[2]);
            sqlite3_db_config(p->db, (int )aDbConfig[ii].op, tmp___13, 0);
          }
          sqlite3_db_config(p->db, (int )aDbConfig[ii].op, -1, & v);
          if (v) {
            tmp___14 = "on";
          } else {
            tmp___14 = "off";
          }
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%18s %s\n",
                  aDbConfig[ii].zName, tmp___14);
          if (nArg > 1) {
            break;
          }
          __Cont: /* CIL Label */ 
          ii ++;
        }
        if (nArg > 1) {
          if (ii == (int )(sizeof(aDbConfig) / sizeof(aDbConfig[0]))) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unknown dbconfig \"%s\"\n",
                    azArg[1]);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Enter \".dbconfig\" with no arguments for a list\n");
          }
        }
      } else {
        goto _L___93;
      }
    } else {
      goto _L___93;
    }
  } else
  _L___93: /* CIL Label */ 
  if (c == 100) {
    if (n >= 3) {
      tmp___241 = strncmp((char const   *)azArg[0], "dbinfo", (size_t )n);
      if (tmp___241 == 0) {
        rc = shell_dbinfo_command(p, nArg, azArg);
      } else {
        goto _L___91;
      }
    } else {
      goto _L___91;
    }
  } else
  _L___91: /* CIL Label */ 
  if (c == 100) {
    tmp___240 = strncmp((char const   *)azArg[0], "dump", (size_t )n);
    if (tmp___240 == 0) {
      zLike = (char const   *)0;
      savedShowHeader = p->showHeader;
      savedShellFlags = (int )p->shellFlgs;
      p->shellFlgs &= 4294967207U;
      i = 1;
      while (i < nArg) {
        if ((int )*(azArg[i] + 0) == 45) {
          z___0 = (char const   *)(azArg[i] + 1);
          if ((int const   )*(z___0 + 0) == 45) {
            z___0 ++;
          }
          tmp___16 = strcmp(z___0, "preserve-rowids");
          if (tmp___16 == 0) {
            p->shellFlgs |= 8U;
          } else {
            tmp___15 = strcmp(z___0, "newlines");
            if (tmp___15 == 0) {
              p->shellFlgs |= 16U;
            } else {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown option \"%s\" on \".dump\"\n",
                      azArg[i]);
              rc = 1;
              goto meta_command_exit;
            }
          }
        } else
        if (zLike) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .dump ?--preserve-rowids? ?--newlines? ?LIKE-PATTERN?\n");
          rc = 1;
          goto meta_command_exit;
        } else {
          zLike = (char const   *)azArg[i];
        }
        i ++;
      }
      open_db(p, 0);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"PRAGMA foreign_keys=OFF;\n");
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"BEGIN TRANSACTION;\n");
      p->writableSchema = 0;
      p->showHeader = 0;
      sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", (int (*)(void * ,
                                                                                int  ,
                                                                                char ** ,
                                                                                char ** ))0,
                   (void *)0, (char **)0);
      p->nErr = 0;
      if ((unsigned long )zLike == (unsigned long )((char const   *)0)) {
        run_schema_dump_query(p, "SELECT name, type, sql FROM sqlite_master WHERE sql NOT NULL AND type==\'table\' AND name!=\'sqlite_sequence\'");
        run_schema_dump_query(p, "SELECT name, type, sql FROM sqlite_master WHERE name==\'sqlite_sequence\'");
        run_table_dump_query(p, "SELECT sql FROM sqlite_master WHERE sql NOT NULL AND type IN (\'index\',\'trigger\',\'view\')",
                             (char const   *)0);
      } else {
        zSql = sqlite3_mprintf("SELECT name, type, sql FROM sqlite_master WHERE tbl_name LIKE %Q AND type==\'table\'  AND sql NOT NULL",
                               zLike);
        run_schema_dump_query(p, (char const   *)zSql);
        sqlite3_free((void *)zSql);
        zSql = sqlite3_mprintf("SELECT sql FROM sqlite_master WHERE sql NOT NULL  AND type IN (\'index\',\'trigger\',\'view\')  AND tbl_name LIKE %Q",
                               zLike);
        run_table_dump_query(p, (char const   *)zSql, (char const   *)0);
        sqlite3_free((void *)zSql);
      }
      if (p->writableSchema) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"PRAGMA writable_schema=OFF;\n");
        p->writableSchema = 0;
      }
      sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", (int (*)(void * , int  ,
                                                                  char ** , char ** ))0,
                   (void *)0, (char **)0);
      sqlite3_exec(p->db, "RELEASE dump;", (int (*)(void * , int  , char ** , char ** ))0,
                   (void *)0, (char **)0);
      if (p->nErr) {
        tmp___17 = "ROLLBACK; -- due to errors\n";
      } else {
        tmp___17 = "COMMIT;\n";
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )tmp___17);
      p->showHeader = savedShowHeader;
      p->shellFlgs = (unsigned int )savedShellFlags;
    } else {
      goto _L___89;
    }
  } else
  _L___89: /* CIL Label */ 
  if (c == 101) {
    tmp___239 = strncmp((char const   *)azArg[0], "echo", (size_t )n);
    if (tmp___239 == 0) {
      if (nArg == 2) {
        setOrClearFlag(p, 64U, (char const   *)azArg[1]);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .echo on|off\n");
        rc = 1;
      }
    } else {
      goto _L___88;
    }
  } else
  _L___88: /* CIL Label */ 
  if (c == 101) {
    tmp___238 = strncmp((char const   *)azArg[0], "eqp", (size_t )n);
    if (tmp___238 == 0) {
      if (nArg == 2) {
        p->autoEQPtest = (u8 )0;
        if (p->autoEQPtrace) {
          if (p->db) {
            sqlite3_exec(p->db, "PRAGMA vdbe_trace=OFF;", (int (*)(void * , int  ,
                                                                   char ** , char ** ))0,
                         (void *)0, (char **)0);
          }
          p->autoEQPtrace = (u8 )0;
        }
        tmp___20 = strcmp((char const   *)azArg[1], "full");
        if (tmp___20 == 0) {
          p->autoEQP = (u8 )3;
        } else {
          tmp___19 = strcmp((char const   *)azArg[1], "trigger");
          if (tmp___19 == 0) {
            p->autoEQP = (u8 )2;
          } else {
            tmp___18 = booleanValue((char const   *)azArg[1]);
            p->autoEQP = (u8 )tmp___18;
          }
        }
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .eqp off|on|trace|trigger|full\n");
        rc = 1;
      }
    } else {
      goto _L___87;
    }
  } else
  _L___87: /* CIL Label */ 
  if (c == 101) {
    tmp___237 = strncmp((char const   *)azArg[0], "exit", (size_t )n);
    if (tmp___237 == 0) {
      if (nArg > 1) {
        tmp___21 = integerValue((char const   *)azArg[1]);
        rc = (int )tmp___21;
        if (rc != 0) {
          exit(rc);
        }
      }
      rc = 2;
    } else {
      goto _L___86;
    }
  } else
  _L___86: /* CIL Label */ 
  if (c == 101) {
    tmp___236 = strncmp((char const   *)azArg[0], "explain", (size_t )n);
    if (tmp___236 == 0) {
      val = 1;
      if (nArg >= 2) {
        tmp___22 = strcmp((char const   *)azArg[1], "auto");
        if (tmp___22 == 0) {
          val = 99;
        } else {
          val = booleanValue((char const   *)azArg[1]);
        }
      }
      if (val == 1) {
        if (p->mode != 9) {
          p->normalMode = p->mode;
          p->mode = 9;
          p->autoExplain = (u8 )0;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (val == 0) {
        if (p->mode == 9) {
          p->mode = p->normalMode;
        }
        p->autoExplain = (u8 )0;
      } else
      if (val == 99) {
        if (p->mode == 9) {
          p->mode = p->normalMode;
        }
        p->autoExplain = (u8 )1;
      }
    } else {
      goto _L___85;
    }
  } else
  _L___85: /* CIL Label */ 
  if (c == 101) {
    tmp___235 = strncmp((char const   *)azArg[0], "expert", (size_t )n);
    if (tmp___235 == 0) {
      open_db(p, 0);
      expertDotCommand(p, azArg, nArg);
    } else {
      goto _L___84;
    }
  } else
  _L___84: /* CIL Label */ 
  if (c == 102) {
    tmp___234 = strncmp((char const   *)azArg[0], "filectrl", (size_t )n);
    if (tmp___234 == 0) {
      filectrl = -1;
      iCtrl = -1;
      iRes = (sqlite_int64 )0;
      isOk = 0;
      zCmd = (char const   *)0;
      open_db(p, 0);
      if (nArg >= 2) {
        zCmd = (char const   *)azArg[1];
      } else {
        zCmd = "help";
      }
      if ((int const   )*(zCmd + 0) == 45) {
        if (*(zCmd + 1)) {
          zCmd ++;
          if ((int const   )*(zCmd + 0) == 45) {
            if (*(zCmd + 1)) {
              zCmd ++;
            }
          }
        }
      }
      tmp___23 = strcmp(zCmd, "help");
      if (tmp___23 == 0) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Available file-controls:\n");
        i___0 = 0;
        while (i___0 < (int )(sizeof(aCtrl) / sizeof(aCtrl[0]))) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"  .filectrl %s %s\n",
                  aCtrl[i___0].zCtrlName, aCtrl[i___0].zUsage);
          i___0 ++;
        }
        rc = 1;
        goto meta_command_exit;
      }
      n2 = strlen30(zCmd);
      i___0 = 0;
      while (i___0 < (int )(sizeof(aCtrl) / sizeof(aCtrl[0]))) {
        tmp___24 = strncmp(zCmd, (char const   *)aCtrl[i___0].zCtrlName, (size_t )n2);
        if (tmp___24 == 0) {
          if (filectrl < 0) {
            filectrl = (int )aCtrl[i___0].ctrlCode;
            iCtrl = i___0;
          } else {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: ambiguous file-control: \"%s\"\nUse \".filectrl --help\" for help\n",
                    zCmd);
            rc = 1;
            goto meta_command_exit;
          }
        }
        i___0 ++;
      }
      if (filectrl < 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unknown file-control: %s\nUse \".filectrl --help\" for help\n",
                zCmd);
      } else {
        switch (filectrl) {
        case 36: 
        if (nArg != 2) {
          if (nArg != 3) {
            break;
          }
        }
        if (nArg == 3) {
          tmp___25 = integerValue((char const   *)azArg[2]);
          iRes = tmp___25;
        } else {
          iRes = (sqlite_int64 )-1;
        }
        sqlite3_file_control(p->db, (char const   *)0, 36, (void *)(& iRes));
        isOk = 1;
        break;
        case 6: 
        case 34: 
        if (nArg != 3) {
          break;
        }
        tmp___26 = integerValue((char const   *)azArg[2]);
        x___0 = (int )tmp___26;
        sqlite3_file_control(p->db, (char const   *)0, filectrl, (void *)(& x___0));
        isOk = 2;
        break;
        case 13: 
        case 10: 
        if (nArg != 2) {
          if (nArg != 3) {
            break;
          }
        }
        if (nArg == 3) {
          tmp___27 = booleanValue((char const   *)azArg[2]);
          x___1 = tmp___27;
        } else {
          x___1 = -1;
        }
        sqlite3_file_control(p->db, (char const   *)0, filectrl, (void *)(& x___1));
        iRes = (sqlite_int64 )x___1;
        isOk = 1;
        break;
        case 20: 
        if (nArg != 2) {
          break;
        }
        sqlite3_file_control(p->db, (char const   *)0, filectrl, (void *)(& x___2));
        iRes = (sqlite_int64 )x___2;
        isOk = 1;
        break;
        case 16: 
        z___1 = (char *)0;
        if (nArg != 2) {
          break;
        }
        sqlite3_file_control(p->db, (char const   *)0, filectrl, (void *)(& z___1));
        if (z___1) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n",
                  z___1);
          sqlite3_free((void *)z___1);
        }
        isOk = 2;
        break;
        }
      }
      if (isOk == 0) {
        if (iCtrl >= 0) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Usage: .filectrl %s %s\n",
                  zCmd, aCtrl[iCtrl].zUsage);
          rc = 1;
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (isOk == 1) {
        sqlite3_snprintf((int )sizeof(zBuf), zBuf, "%lld", iRes);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n",
                zBuf);
      }
    } else {
      goto _L___83;
    }
  } else
  _L___83: /* CIL Label */ 
  if (c == 102) {
    tmp___233 = strncmp((char const   *)azArg[0], "fullschema", (size_t )n);
    if (tmp___233 == 0) {
      zErrMsg___0 = (char *)0;
      doStats = 0;
      memcpy((void * __restrict  )(& data___0), (void const   * __restrict  )p, sizeof(data___0));
      data___0.showHeader = 0;
      data___0.mode = 3;
      data___0.cMode = data___0.mode;
      if (nArg == 2) {
        tmp___28 = optionMatch((char const   *)azArg[1], "indent");
        if (tmp___28) {
          data___0.mode = 11;
          data___0.cMode = data___0.mode;
          nArg = 1;
        }
      }
      if (nArg != 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .fullschema ?--indent?\n");
        rc = 1;
        goto meta_command_exit;
      }
      open_db(p, 0);
      rc = sqlite3_exec(p->db, "SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_master UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) WHERE type!=\'meta\' AND sql NOTNULL AND name NOT LIKE \'sqlite_%\' ORDER BY rowid",
                        & callback, (void *)(& data___0), & zErrMsg___0);
      if (rc == 0) {
        rc = sqlite3_prepare_v2(p->db, "SELECT rowid FROM sqlite_master WHERE name GLOB \'sqlite_stat[134]\'",
                                -1, & pStmt, (char const   **)0);
        tmp___29 = sqlite3_step(pStmt);
        doStats = tmp___29 == 100;
        sqlite3_finalize(pStmt);
      }
      if (doStats == 0) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"/* No STAT tables available */\n");
      } else {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"ANALYZE sqlite_master;\n");
        sqlite3_exec(p->db, "SELECT \'ANALYZE sqlite_master\'", & callback, (void *)(& data___0),
                     & zErrMsg___0);
        data___0.mode = 5;
        data___0.cMode = data___0.mode;
        data___0.zDestTable = (char *)"sqlite_stat1";
        shell_exec(& data___0, "SELECT * FROM sqlite_stat1", & zErrMsg___0);
        data___0.zDestTable = (char *)"sqlite_stat4";
        shell_exec(& data___0, "SELECT * FROM sqlite_stat4", & zErrMsg___0);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"ANALYZE sqlite_master;\n");
      }
    } else {
      goto _L___82;
    }
  } else
  _L___82: /* CIL Label */ 
  if (c == 104) {
    tmp___232 = strncmp((char const   *)azArg[0], "headers", (size_t )n);
    if (tmp___232 == 0) {
      if (nArg == 2) {
        p->showHeader = booleanValue((char const   *)azArg[1]);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .headers on|off\n");
        rc = 1;
      }
    } else {
      goto _L___81;
    }
  } else
  _L___81: /* CIL Label */ 
  if (c == 104) {
    tmp___231 = strncmp((char const   *)azArg[0], "help", (size_t )n);
    if (tmp___231 == 0) {
      if (nArg >= 2) {
        n = showHelp(p->out, (char const   *)azArg[1]);
        if (n == 0) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Nothing matches \'%s\'\n",
                  azArg[1]);
        }
      } else {
        showHelp(p->out, (char const   *)0);
      }
    } else {
      goto _L___80;
    }
  } else
  _L___80: /* CIL Label */ 
  if (c == 105) {
    tmp___230 = strncmp((char const   *)azArg[0], "import", (size_t )n);
    if (tmp___230 == 0) {
      pStmt___0 = (sqlite3_stmt *)((void *)0);
      if (nArg != 3) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .import FILE TABLE\n");
        goto meta_command_exit;
      }
      zFile = azArg[1];
      zTable = azArg[2];
      seenInterrupt = (int volatile   )0;
      memset((void *)(& sCtx), 0, sizeof(sCtx));
      open_db(p, 0);
      nSep = strlen30((char const   *)(p->colSeparator));
      if (nSep == 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: non-null column separator required for import\n");
        return (1);
      }
      if (nSep > 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: multi-character column separators not allowed for import\n");
        return (1);
      }
      nSep = strlen30((char const   *)(p->rowSeparator));
      if (nSep == 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: non-null row separator required for import\n");
        return (1);
      }
      if (nSep == 2) {
        if (p->mode == 8) {
          tmp___30 = strcmp((char const   *)(p->rowSeparator), "\r\n");
          if (tmp___30 == 0) {
            sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\n");
            nSep = strlen30((char const   *)(p->rowSeparator));
          }
        }
      }
      if (nSep > 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: multi-character row separators not allowed for import\n");
        return (1);
      }
      sCtx.zFile = (char const   *)zFile;
      sCtx.nLine = 1;
      if ((int const   )*(sCtx.zFile + 0) == 124) {
        sCtx.in = popen(sCtx.zFile + 1, "r");
        sCtx.zFile = "<pipe>";
        xCloser = & pclose;
      } else {
        sCtx.in = fopen((char const   * __restrict  )sCtx.zFile, (char const   * __restrict  )"rb");
        xCloser = & fclose;
      }
      if (p->mode == 10) {
        xRead = & ascii_read_one_field;
      } else {
        xRead = & csv_read_one_field;
      }
      if ((unsigned long )sCtx.in == (unsigned long )((FILE *)0)) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \"%s\"\n",
                zFile);
        return (1);
      }
      sCtx.cColSep = (int )p->colSeparator[0];
      sCtx.cRowSep = (int )p->rowSeparator[0];
      zSql___0 = sqlite3_mprintf("SELECT * FROM %s", zTable);
      if ((unsigned long )zSql___0 == (unsigned long )((char *)0)) {
        (*xCloser)(sCtx.in);
        shell_out_of_memory();
      }
      nByte = strlen30((char const   *)zSql___0);
      rc = sqlite3_prepare_v2(p->db, (char const   *)zSql___0, -1, & pStmt___0, (char const   **)0);
      import_append_char(& sCtx, 0);
      if (rc) {
        tmp___34 = sqlite3_errmsg(p->db);
        tmp___35 = sqlite3_strglob("no such table: *", tmp___34);
        if (tmp___35 == 0) {
          tmp___31 = sqlite3_mprintf("CREATE TABLE %s", zTable);
          zCreate = tmp___31;
          cSep = (char )'(';
          while (1) {
            tmp___32 = (*xRead)(& sCtx);
            if (! tmp___32) {
              break;
            }
            zCreate = sqlite3_mprintf("%z%c\n  \"%w\" TEXT", zCreate, (int )cSep,
                                      sCtx.z);
            cSep = (char )',';
            if (sCtx.cTerm != sCtx.cColSep) {
              break;
            }
          }
          if ((int )cSep == 40) {
            sqlite3_free((void *)zCreate);
            sqlite3_free((void *)sCtx.z);
            (*xCloser)(sCtx.in);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: empty file\n",
                    sCtx.zFile);
            return (1);
          }
          zCreate = sqlite3_mprintf("%z\n)", zCreate);
          rc = sqlite3_exec(p->db, (char const   *)zCreate, (int (*)(void * , int  ,
                                                                     char ** , char ** ))0,
                            (void *)0, (char **)0);
          sqlite3_free((void *)zCreate);
          if (rc) {
            tmp___33 = sqlite3_errmsg(p->db);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CREATE TABLE %s(...) failed: %s\n",
                    zTable, tmp___33);
            sqlite3_free((void *)sCtx.z);
            (*xCloser)(sCtx.in);
            return (1);
          }
          rc = sqlite3_prepare_v2(p->db, (char const   *)zSql___0, -1, & pStmt___0,
                                  (char const   **)0);
        }
      }
      sqlite3_free((void *)zSql___0);
      if (rc) {
        if (pStmt___0) {
          sqlite3_finalize(pStmt___0);
        }
        tmp___36 = sqlite3_errmsg(p->db);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                tmp___36);
        (*xCloser)(sCtx.in);
        return (1);
      }
      nCol = sqlite3_column_count(pStmt___0);
      sqlite3_finalize(pStmt___0);
      pStmt___0 = (sqlite3_stmt *)0;
      if (nCol == 0) {
        return (0);
      }
      tmp___37 = sqlite3_malloc64((sqlite_uint64 )((nByte * 2 + 20) + nCol * 2));
      zSql___0 = (char *)tmp___37;
      if ((unsigned long )zSql___0 == (unsigned long )((char *)0)) {
        (*xCloser)(sCtx.in);
        shell_out_of_memory();
      }
      sqlite3_snprintf(nByte + 20, zSql___0, "INSERT INTO \"%w\" VALUES(?", zTable);
      j___0 = strlen30((char const   *)zSql___0);
      i___1 = 1;
      while (i___1 < nCol) {
        tmp___38 = j___0;
        j___0 ++;
        *(zSql___0 + tmp___38) = (char )',';
        tmp___39 = j___0;
        j___0 ++;
        *(zSql___0 + tmp___39) = (char )'?';
        i___1 ++;
      }
      tmp___40 = j___0;
      j___0 ++;
      *(zSql___0 + tmp___40) = (char )')';
      *(zSql___0 + j___0) = (char)0;
      rc = sqlite3_prepare_v2(p->db, (char const   *)zSql___0, -1, & pStmt___0, (char const   **)0);
      sqlite3_free((void *)zSql___0);
      if (rc) {
        tmp___41 = sqlite3_errmsg(p->db);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                tmp___41);
        if (pStmt___0) {
          sqlite3_finalize(pStmt___0);
        }
        (*xCloser)(sCtx.in);
        return (1);
      }
      needCommit = sqlite3_get_autocommit(p->db);
      if (needCommit) {
        sqlite3_exec(p->db, "BEGIN", (int (*)(void * , int  , char ** , char ** ))0,
                     (void *)0, (char **)0);
      }
      while (1) {
        startLine = sCtx.nLine;
        i___1 = 0;
        while (i___1 < nCol) {
          tmp___42 = (*xRead)(& sCtx);
          z___2 = tmp___42;
          if ((unsigned long )z___2 == (unsigned long )((char *)0)) {
            if (i___1 == 0) {
              break;
            }
          }
          if (p->mode == 10) {
            if ((unsigned long )z___2 == (unsigned long )((char *)0)) {
              goto _L___2;
            } else
            if ((int )*(z___2 + 0) == 0) {
              _L___2: /* CIL Label */ 
              if (i___1 == 0) {
                break;
              }
            }
          }
          sqlite3_bind_text(pStmt___0, i___1 + 1, (char const   *)z___2, -1, (void (*)(void * ))-1);
          if (i___1 < nCol - 1) {
            if (sCtx.cTerm != sCtx.cColSep) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: expected %d columns but found %d - filling the rest with NULL\n",
                      sCtx.zFile, startLine, nCol, i___1 + 1);
              i___1 += 2;
              while (i___1 <= nCol) {
                sqlite3_bind_null(pStmt___0, i___1);
                i___1 ++;
              }
            }
          }
          i___1 ++;
        }
        if (sCtx.cTerm == sCtx.cColSep) {
          while (1) {
            (*xRead)(& sCtx);
            i___1 ++;
            if (! (sCtx.cTerm == sCtx.cColSep)) {
              break;
            }
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: expected %d columns but found %d - extras ignored\n",
                  sCtx.zFile, startLine, nCol, i___1);
        }
        if (i___1 >= nCol) {
          sqlite3_step(pStmt___0);
          rc = sqlite3_reset(pStmt___0);
          if (rc != 0) {
            tmp___43 = sqlite3_errmsg(p->db);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: INSERT failed: %s\n",
                    sCtx.zFile, startLine, tmp___43);
          }
        }
        if (! (sCtx.cTerm != -1)) {
          break;
        }
      }
      (*xCloser)(sCtx.in);
      sqlite3_free((void *)sCtx.z);
      sqlite3_finalize(pStmt___0);
      if (needCommit) {
        sqlite3_exec(p->db, "COMMIT", (int (*)(void * , int  , char ** , char ** ))0,
                     (void *)0, (char **)0);
      }
    } else {
      goto _L___79;
    }
  } else
  _L___79: /* CIL Label */ 
  if (c == 105) {
    tmp___229 = strncmp((char const   *)azArg[0], "imposter", (size_t )n);
    if (tmp___229 == 0) {
      zCollist = (char *)0;
      tnum = 0;
      if (! (nArg == 3)) {
        if (nArg == 2) {
          tmp___44 = sqlite3_stricmp((char const   *)azArg[1], "off");
          if (! (tmp___44 == 0)) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .imposter INDEX IMPOSTER\n       .imposter off\n");
            rc = 1;
            goto meta_command_exit;
          }
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .imposter INDEX IMPOSTER\n       .imposter off\n");
          rc = 1;
          goto meta_command_exit;
        }
      }
      open_db(p, 0);
      if (nArg == 2) {
        sqlite3_test_control(25, p->db, "main", 0, 1);
        goto meta_command_exit;
      }
      zSql___1 = sqlite3_mprintf("SELECT rootpage FROM sqlite_master WHERE name=\'%q\' AND type=\'index\'",
                                 azArg[1]);
      sqlite3_prepare_v2(p->db, (char const   *)zSql___1, -1, & pStmt___1, (char const   **)0);
      sqlite3_free((void *)zSql___1);
      tmp___45 = sqlite3_step(pStmt___1);
      if (tmp___45 == 100) {
        tnum = sqlite3_column_int(pStmt___1, 0);
      }
      sqlite3_finalize(pStmt___1);
      if (tnum == 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"no such index: \"%s\"\n",
                azArg[1]);
        rc = 1;
        goto meta_command_exit;
      }
      zSql___1 = sqlite3_mprintf("PRAGMA index_xinfo=\'%q\'", azArg[1]);
      rc = sqlite3_prepare_v2(p->db, (char const   *)zSql___1, -1, & pStmt___1, (char const   **)0);
      sqlite3_free((void *)zSql___1);
      i___2 = 0;
      while (1) {
        tmp___48 = sqlite3_step(pStmt___1);
        if (! (tmp___48 == 100)) {
          break;
        }
        tmp___46 = sqlite3_column_text(pStmt___1, 2);
        zCol = (char const   *)tmp___46;
        i___2 ++;
        if ((unsigned long )zCol == (unsigned long )((char const   *)0)) {
          tmp___47 = sqlite3_column_int(pStmt___1, 1);
          if (tmp___47 == -1) {
            zCol = "_ROWID_";
          } else {
            sqlite3_snprintf((int )sizeof(zLabel), zLabel, "expr%d", i___2);
            zCol = (char const   *)(zLabel);
          }
        }
        if ((unsigned long )zCollist == (unsigned long )((char *)0)) {
          zCollist = sqlite3_mprintf("\"%w\"", zCol);
        } else {
          zCollist = sqlite3_mprintf("%z,\"%w\"", zCollist, zCol);
        }
      }
      sqlite3_finalize(pStmt___1);
      zSql___1 = sqlite3_mprintf("CREATE TABLE \"%w\"(%s,PRIMARY KEY(%s))WITHOUT ROWID",
                                 azArg[2], zCollist, zCollist);
      sqlite3_free((void *)zCollist);
      rc = sqlite3_test_control(25, p->db, "main", 1, tnum);
      if (rc == 0) {
        rc = sqlite3_exec(p->db, (char const   *)zSql___1, (int (*)(void * , int  ,
                                                                    char ** , char ** ))0,
                          (void *)0, (char **)0);
        sqlite3_test_control(25, p->db, "main", 0, 0);
        if (rc) {
          tmp___49 = sqlite3_errmsg(p->db);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error in [%s]: %s\n",
                  zSql___1, tmp___49);
        } else {
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s;\n",
                  zSql___1);
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"WARNING: writing to an imposter table will corrupt the index!\n");
        }
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SQLITE_TESTCTRL_IMPOSTER returns %d\n",
                rc);
        rc = 1;
      }
      sqlite3_free((void *)zSql___1);
    } else {
      goto _L___78;
    }
  } else
  _L___78: /* CIL Label */ 
  if (c == 108) {
    if (n >= 5) {
      tmp___228 = strncmp((char const   *)azArg[0], "limits", (size_t )n);
      if (tmp___228 == 0) {
        open_db(p, 0);
        if (nArg == 1) {
          i___3 = 0;
          while (i___3 < (int )(sizeof(aLimit) / sizeof(aLimit[0]))) {
            tmp___50 = sqlite3_limit(p->db, (int )aLimit[i___3].limitCode, -1);
            printf((char const   * __restrict  )"%20s %d\n", aLimit[i___3].zLimitName,
                   tmp___50);
            i___3 ++;
          }
        } else
        if (nArg > 3) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .limit NAME ?NEW-VALUE?\n");
          rc = 1;
          goto meta_command_exit;
        } else {
          iLimit = -1;
          n2___0 = strlen30((char const   *)azArg[1]);
          i___3 = 0;
          while (i___3 < (int )(sizeof(aLimit) / sizeof(aLimit[0]))) {
            tmp___51 = sqlite3_strnicmp((char const   *)aLimit[i___3].zLimitName,
                                        (char const   *)azArg[1], n2___0);
            if (tmp___51 == 0) {
              if (iLimit < 0) {
                iLimit = i___3;
              } else {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ambiguous limit: \"%s\"\n",
                        azArg[1]);
                rc = 1;
                goto meta_command_exit;
              }
            }
            i___3 ++;
          }
          if (iLimit < 0) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown limit: \"%s\"\nenter \".limits\" with no arguments for a list.\n",
                    azArg[1]);
            rc = 1;
            goto meta_command_exit;
          }
          if (nArg == 3) {
            tmp___52 = integerValue((char const   *)azArg[2]);
            sqlite3_limit(p->db, (int )aLimit[iLimit].limitCode, (int )tmp___52);
          }
          tmp___53 = sqlite3_limit(p->db, (int )aLimit[iLimit].limitCode, -1);
          printf((char const   * __restrict  )"%20s %d\n", aLimit[iLimit].zLimitName,
                 tmp___53);
        }
      } else {
        goto _L___77;
      }
    } else {
      goto _L___77;
    }
  } else
  _L___77: /* CIL Label */ 
  if (c == 108) {
    if (n > 2) {
      tmp___227 = strncmp((char const   *)azArg[0], "lint", (size_t )n);
      if (tmp___227 == 0) {
        open_db(p, 0);
        lintDotCommand(p, azArg, nArg);
      } else {
        goto _L___75;
      }
    } else {
      goto _L___75;
    }
  } else
  _L___75: /* CIL Label */ 
  if (c == 108) {
    tmp___226 = strncmp((char const   *)azArg[0], "log", (size_t )n);
    if (tmp___226 == 0) {
      if (nArg != 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .log FILENAME\n");
        rc = 1;
      } else {
        zFile___0 = (char const   *)azArg[1];
        output_file_close(p->pLog);
        p->pLog = output_file_open(zFile___0, 0);
      }
    } else {
      goto _L___73;
    }
  } else
  _L___73: /* CIL Label */ 
  if (c == 109) {
    tmp___225 = strncmp((char const   *)azArg[0], "mode", (size_t )n);
    if (tmp___225 == 0) {
      if (nArg >= 2) {
        tmp___54 = (char const   *)azArg[1];
      } else {
        tmp___54 = "";
      }
      zMode = tmp___54;
      tmp___55 = strlen30(zMode);
      n2___1 = tmp___55;
      c2 = (int )*(zMode + 0);
      if (c2 == 108) {
        if (n2___1 > 2) {
          tmp___66 = strncmp((char const   *)azArg[1], "lines", (size_t )n2___1);
          if (tmp___66 == 0) {
            p->mode = 0;
            sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\n");
          } else {
            goto _L___14;
          }
        } else {
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
      if (c2 == 99) {
        tmp___65 = strncmp((char const   *)azArg[1], "columns", (size_t )n2___1);
        if (tmp___65 == 0) {
          p->mode = 1;
          sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\n");
        } else {
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
      if (c2 == 108) {
        if (n2___1 > 2) {
          tmp___64 = strncmp((char const   *)azArg[1], "list", (size_t )n2___1);
          if (tmp___64 == 0) {
            p->mode = 2;
            sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, "|");
            sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\n");
          } else {
            goto _L___11;
          }
        } else {
          goto _L___11;
        }
      } else
      _L___11: /* CIL Label */ 
      if (c2 == 104) {
        tmp___63 = strncmp((char const   *)azArg[1], "html", (size_t )n2___1);
        if (tmp___63 == 0) {
          p->mode = 4;
        } else {
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
      if (c2 == 116) {
        tmp___62 = strncmp((char const   *)azArg[1], "tcl", (size_t )n2___1);
        if (tmp___62 == 0) {
          p->mode = 7;
          sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, " ");
          sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\n");
        } else {
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
      if (c2 == 99) {
        tmp___61 = strncmp((char const   *)azArg[1], "csv", (size_t )n2___1);
        if (tmp___61 == 0) {
          p->mode = 8;
          sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, ",");
          sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\r\n");
        } else {
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
      if (c2 == 116) {
        tmp___60 = strncmp((char const   *)azArg[1], "tabs", (size_t )n2___1);
        if (tmp___60 == 0) {
          p->mode = 2;
          sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, "\t");
        } else {
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
      if (c2 == 105) {
        tmp___59 = strncmp((char const   *)azArg[1], "insert", (size_t )n2___1);
        if (tmp___59 == 0) {
          p->mode = 5;
          if (nArg >= 3) {
            tmp___56 = (char const   *)azArg[2];
          } else {
            tmp___56 = "table";
          }
          set_table_name(p, tmp___56);
        } else {
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
      if (c2 == 113) {
        tmp___58 = strncmp((char const   *)azArg[1], "quote", (size_t )n2___1);
        if (tmp___58 == 0) {
          p->mode = 6;
        } else {
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
      if (c2 == 97) {
        tmp___57 = strncmp((char const   *)azArg[1], "ascii", (size_t )n2___1);
        if (tmp___57 == 0) {
          p->mode = 10;
          sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, "\037");
          sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\036");
        } else {
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
      if (nArg == 1) {
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"current output mode: %s\n",
                modeDescr[p->mode]);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: mode should be one of: ascii column csv html insert line list quote tabs tcl\n");
        rc = 1;
      }
      p->cMode = p->mode;
    } else {
      goto _L___72;
    }
  } else
  _L___72: /* CIL Label */ 
  if (c == 110) {
    tmp___224 = strncmp((char const   *)azArg[0], "nullvalue", (size_t )n);
    if (tmp___224 == 0) {
      if (nArg == 2) {
        sqlite3_snprintf((int )sizeof(p->nullValue), p->nullValue, "%.*s", (int )(sizeof(p->nullValue) / sizeof(p->nullValue[0])) - 1,
                         azArg[1]);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .nullvalue STRING\n");
        rc = 1;
      }
    } else {
      goto _L___71;
    }
  } else
  _L___71: /* CIL Label */ 
  if (c == 111) {
    tmp___223 = strncmp((char const   *)azArg[0], "open", (size_t )n);
    if (tmp___223 == 0) {
      if (n >= 2) {
        iName = 1;
        newFlag = 0;
        close_db(p->db);
        p->db = (sqlite3 *)0;
        p->zDbFilename = (char const   *)0;
        sqlite3_free((void *)p->zFreeOnClose);
        p->zFreeOnClose = (char *)0;
        p->openMode = (u8 )0;
        p->szMax = (sqlite_int64 )0;
        iName = 1;
        while (1) {
          if (iName < nArg) {
            if (! ((int )*(azArg[iName] + 0) == 45)) {
              break;
            }
          } else {
            break;
          }
          z___3 = (char const   *)azArg[iName];
          tmp___69 = optionMatch(z___3, "new");
          if (tmp___69) {
            newFlag = 1;
          } else {
            tmp___68 = optionMatch(z___3, "append");
            if (tmp___68) {
              p->openMode = (u8 )2;
            } else {
              tmp___67 = optionMatch(z___3, "readonly");
              if (tmp___67) {
                p->openMode = (u8 )4;
              } else
              if ((int const   )*(z___3 + 0) == 45) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown option: %s\n",
                        z___3);
                rc = 1;
                goto meta_command_exit;
              }
            }
          }
          iName ++;
        }
        if (nArg > iName) {
          tmp___70 = sqlite3_mprintf("%s", azArg[iName]);
          zNewFilename = tmp___70;
        } else {
          zNewFilename = (char *)0;
        }
        if (zNewFilename) {
          goto _L___15;
        } else
        if ((int )p->openMode == 6) {
          _L___15: /* CIL Label */ 
          if (newFlag) {
            shellDeleteFile((char const   *)zNewFilename);
          }
          p->zDbFilename = (char const   *)zNewFilename;
          open_db(p, 1);
          if ((unsigned long )p->db == (unsigned long )((sqlite3 *)0)) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \'%s\'\n",
                    zNewFilename);
            sqlite3_free((void *)zNewFilename);
          } else {
            p->zFreeOnClose = zNewFilename;
          }
        }
        if ((unsigned long )p->db == (unsigned long )((sqlite3 *)0)) {
          p->zDbFilename = (char const   *)0;
          open_db(p, 0);
        }
      } else {
        goto _L___70;
      }
    } else {
      goto _L___70;
    }
  } else
  _L___70: /* CIL Label */ 
  if (c == 111) {
    tmp___220 = strncmp((char const   *)azArg[0], "output", (size_t )n);
    if (tmp___220 == 0) {
      goto _L___65;
    } else {
      tmp___221 = strncmp((char const   *)azArg[0], "once", (size_t )n);
      if (tmp___221 == 0) {
        goto _L___65;
      } else {
        goto _L___68;
      }
    }
  } else
  _L___68: /* CIL Label */ 
  if (c == 101) {
    if (n == 5) {
      tmp___222 = strcmp((char const   *)azArg[0], "excel");
      if (tmp___222 == 0) {
        _L___65: /* CIL Label */ 
        if (nArg >= 2) {
          tmp___71 = (char const   *)azArg[1];
        } else {
          tmp___71 = "stdout";
        }
        zFile___1 = tmp___71;
        bTxtMode = 0;
        if ((int )*(azArg[0] + 0) == 101) {
          nArg = 2;
          azArg[0] = (char *)"once";
          azArg[1] = (char *)"-x";
          zFile___1 = (char const   *)azArg[1];
          n = 4;
        }
        if (nArg > 2) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .%s [-e|-x|FILE]\n",
                  azArg[0]);
          rc = 1;
          goto meta_command_exit;
        }
        if (n > 1) {
          tmp___72 = strncmp((char const   *)azArg[0], "once", (size_t )n);
          if (tmp___72 == 0) {
            if (nArg < 2) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .once (-e|-x|FILE)\n");
              rc = 1;
              goto meta_command_exit;
            }
            p->outCount = 2;
          } else {
            p->outCount = 0;
          }
        } else {
          p->outCount = 0;
        }
        output_reset(p);
        if ((int const   )*(zFile___1 + 0) == 45) {
          if ((int const   )*(zFile___1 + 1) == 45) {
            zFile___1 ++;
          }
        }
        tmp___73 = strcmp(zFile___1, "-e");
        if (tmp___73 == 0) {
          goto _L___16;
        } else {
          tmp___74 = strcmp(zFile___1, "-x");
          if (tmp___74 == 0) {
            _L___16: /* CIL Label */ 
            p->doXdgOpen = (u8 )1;
            outputModePush(p);
            if ((int const   )*(zFile___1 + 1) == 120) {
              newTempFile(p, "csv");
              p->mode = 8;
              sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, ",");
              sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "\r\n");
            } else {
              newTempFile(p, "txt");
              bTxtMode = 1;
            }
            zFile___1 = (char const   *)p->zTempFile;
          }
        }
        if ((int const   )*(zFile___1 + 0) == 124) {
          p->out = popen(zFile___1 + 1, "w");
          if ((unsigned long )p->out == (unsigned long )((FILE *)0)) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open pipe \"%s\"\n",
                    zFile___1 + 1);
            p->out = stdout;
            rc = 1;
          } else {
            sqlite3_snprintf((int )sizeof(p->outfile), p->outfile, "%s", zFile___1);
          }
        } else {
          p->out = output_file_open(zFile___1, bTxtMode);
          if ((unsigned long )p->out == (unsigned long )((FILE *)0)) {
            tmp___75 = strcmp(zFile___1, "off");
            if (tmp___75 != 0) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot write to \"%s\"\n",
                      zFile___1);
            }
            p->out = stdout;
            rc = 1;
          } else {
            sqlite3_snprintf((int )sizeof(p->outfile), p->outfile, "%s", zFile___1);
          }
        }
      } else {
        goto _L___67;
      }
    } else {
      goto _L___67;
    }
  } else
  _L___67: /* CIL Label */ 
  if (c == 112) {
    if (n >= 3) {
      tmp___219 = strncmp((char const   *)azArg[0], "parameter", (size_t )n);
      if (tmp___219 == 0) {
        open_db(p, 0);
        if (nArg <= 1) {
          goto parameter_syntax_error;
        }
        if (nArg == 2) {
          tmp___86 = strcmp((char const   *)azArg[1], "clear");
          if (tmp___86 == 0) {
            sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp.sqlite_parameters;", (int (*)(void * ,
                                                                                         int  ,
                                                                                         char ** ,
                                                                                         char ** ))0,
                         (void *)0, (char **)0);
          } else {
            goto _L___21;
          }
        } else
        _L___21: /* CIL Label */ 
        if (nArg == 2) {
          tmp___85 = strcmp((char const   *)azArg[1], "list");
          if (tmp___85 == 0) {
            pStmt___2 = (sqlite3_stmt *)0;
            len = 0;
            rx = sqlite3_prepare_v2(p->db, "SELECT max(length(key)) FROM temp.sqlite_parameters;",
                                    -1, & pStmt___2, (char const   **)0);
            if (rx == 0) {
              tmp___76 = sqlite3_step(pStmt___2);
              if (tmp___76 == 100) {
                len = sqlite3_column_int(pStmt___2, 0);
                if (len > 40) {
                  len = 40;
                }
              }
            }
            sqlite3_finalize(pStmt___2);
            pStmt___2 = (sqlite3_stmt *)0;
            if (len) {
              rx = sqlite3_prepare_v2(p->db, "SELECT key, quote(value) FROM temp.sqlite_parameters;",
                                      -1, & pStmt___2, (char const   **)0);
              while (1) {
                tmp___79 = sqlite3_step(pStmt___2);
                if (! (tmp___79 == 100)) {
                  break;
                }
                tmp___77 = sqlite3_column_text(pStmt___2, 1);
                tmp___78 = sqlite3_column_text(pStmt___2, 0);
                fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%-*s %s\n",
                        len, tmp___78, tmp___77);
              }
              sqlite3_finalize(pStmt___2);
            }
          } else {
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
        if (nArg == 2) {
          tmp___84 = strcmp((char const   *)azArg[1], "init");
          if (tmp___84 == 0) {
            bind_table_init(p);
          } else {
            goto _L___19;
          }
        } else
        _L___19: /* CIL Label */ 
        if (nArg == 4) {
          tmp___83 = strcmp((char const   *)azArg[1], "set");
          if (tmp___83 == 0) {
            zKey = (char const   *)azArg[2];
            zValue = (char const   *)azArg[3];
            bind_table_init(p);
            zSql___2 = sqlite3_mprintf("REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);",
                                       zKey, zValue);
            if ((unsigned long )zSql___2 == (unsigned long )((char *)0)) {
              shell_out_of_memory();
            }
            pStmt___3 = (sqlite3_stmt *)0;
            rx___0 = sqlite3_prepare_v2(p->db, (char const   *)zSql___2, -1, & pStmt___3,
                                        (char const   **)0);
            sqlite3_free((void *)zSql___2);
            if (rx___0 != 0) {
              sqlite3_finalize(pStmt___3);
              pStmt___3 = (sqlite3_stmt *)0;
              zSql___2 = sqlite3_mprintf("REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);",
                                         zKey, zValue);
              if ((unsigned long )zSql___2 == (unsigned long )((char *)0)) {
                shell_out_of_memory();
              }
              rx___0 = sqlite3_prepare_v2(p->db, (char const   *)zSql___2, -1, & pStmt___3,
                                          (char const   **)0);
              sqlite3_free((void *)zSql___2);
              if (rx___0 != 0) {
                tmp___80 = sqlite3_errmsg(p->db);
                fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Error: %s\n",
                        tmp___80);
                sqlite3_finalize(pStmt___3);
                pStmt___3 = (sqlite3_stmt *)0;
                rc = 1;
              }
            }
            sqlite3_step(pStmt___3);
            sqlite3_finalize(pStmt___3);
          } else {
            goto _L___18;
          }
        } else
        _L___18: /* CIL Label */ 
        if (nArg == 3) {
          tmp___82 = strcmp((char const   *)azArg[1], "unset");
          if (tmp___82 == 0) {
            tmp___81 = sqlite3_mprintf("DELETE FROM temp.sqlite_parameters WHERE key=%Q",
                                       azArg[2]);
            zSql___3 = tmp___81;
            if ((unsigned long )zSql___3 == (unsigned long )((char *)0)) {
              shell_out_of_memory();
            }
            sqlite3_exec(p->db, (char const   *)zSql___3, (int (*)(void * , int  ,
                                                                   char ** , char ** ))0,
                         (void *)0, (char **)0);
            sqlite3_free((void *)zSql___3);
          } else {
            goto parameter_syntax_error;
          }
        } else {
          parameter_syntax_error: 
          showHelp(p->out, "parameter");
        }
      } else {
        goto _L___64;
      }
    } else {
      goto _L___64;
    }
  } else
  _L___64: /* CIL Label */ 
  if (c == 112) {
    if (n >= 3) {
      tmp___218 = strncmp((char const   *)azArg[0], "print", (size_t )n);
      if (tmp___218 == 0) {
        i___4 = 1;
        while (i___4 < nArg) {
          if (i___4 > 1) {
            fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )" ");
          }
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s",
                  azArg[i___4]);
          i___4 ++;
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
      } else {
        goto _L___62;
      }
    } else {
      goto _L___62;
    }
  } else
  _L___62: /* CIL Label */ 
  if (c == 112) {
    if (n >= 3) {
      tmp___217 = strncmp((char const   *)azArg[0], "progress", (size_t )n);
      if (tmp___217 == 0) {
        nn = 0;
        p->flgProgress = 0U;
        p->mxProgress = 0U;
        p->nProgress = 0U;
        i___5 = 1;
        while (i___5 < nArg) {
          z___4 = (char const   *)azArg[i___5];
          if ((int const   )*(z___4 + 0) == 45) {
            z___4 ++;
            if ((int const   )*(z___4 + 0) == 45) {
              z___4 ++;
            }
            tmp___87 = strcmp(z___4, "quiet");
            if (tmp___87 == 0) {
              p->flgProgress |= 1U;
              goto __Cont___0;
            } else {
              tmp___88 = strcmp(z___4, "q");
              if (tmp___88 == 0) {
                p->flgProgress |= 1U;
                goto __Cont___0;
              }
            }
            tmp___89 = strcmp(z___4, "reset");
            if (tmp___89 == 0) {
              p->flgProgress |= 2U;
              goto __Cont___0;
            }
            tmp___90 = strcmp(z___4, "once");
            if (tmp___90 == 0) {
              p->flgProgress |= 4U;
              goto __Cont___0;
            }
            tmp___92 = strcmp(z___4, "limit");
            if (tmp___92 == 0) {
              if (i___5 + 1 >= nArg) {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: missing argument on --limit\n");
                rc = 1;
                goto meta_command_exit;
              } else {
                i___5 ++;
                tmp___91 = integerValue((char const   *)azArg[i___5]);
                p->mxProgress = (unsigned int )((int )tmp___91);
              }
              goto __Cont___0;
            }
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unknown option: \"%s\"\n",
                    azArg[i___5]);
            rc = 1;
            goto meta_command_exit;
          } else {
            tmp___93 = integerValue(z___4);
            nn = (int )tmp___93;
          }
          __Cont___0: /* CIL Label */ 
          i___5 ++;
        }
        open_db(p, 0);
        sqlite3_progress_handler(p->db, nn, & progress_handler, (void *)p);
      } else {
        goto _L___60;
      }
    } else {
      goto _L___60;
    }
  } else
  _L___60: /* CIL Label */ 
  if (c == 112) {
    tmp___216 = strncmp((char const   *)azArg[0], "prompt", (size_t )n);
    if (tmp___216 == 0) {
      if (nArg >= 2) {
        strncpy((char * __restrict  )(mainPrompt), (char const   * __restrict  )azArg[1],
                (size_t )((int )(sizeof(mainPrompt) / sizeof(mainPrompt[0])) - 1));
      }
      if (nArg >= 3) {
        strncpy((char * __restrict  )(continuePrompt), (char const   * __restrict  )azArg[2],
                (size_t )((int )(sizeof(continuePrompt) / sizeof(continuePrompt[0])) - 1));
      }
    } else {
      goto _L___58;
    }
  } else
  _L___58: /* CIL Label */ 
  if (c == 113) {
    tmp___215 = strncmp((char const   *)azArg[0], "quit", (size_t )n);
    if (tmp___215 == 0) {
      rc = 2;
    } else {
      goto _L___57;
    }
  } else
  _L___57: /* CIL Label */ 
  if (c == 114) {
    if (n >= 3) {
      tmp___214 = strncmp((char const   *)azArg[0], "read", (size_t )n);
      if (tmp___214 == 0) {
        inSaved = p->in;
        savedLineno = p->lineno;
        if (nArg != 2) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .read FILE\n");
          rc = 1;
          goto meta_command_exit;
        }
        p->in = fopen((char const   * __restrict  )azArg[1], (char const   * __restrict  )"rb");
        if ((unsigned long )p->in == (unsigned long )((FILE *)0)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \"%s\"\n",
                  azArg[1]);
          rc = 1;
        } else {
          rc = process_input(p);
          fclose(p->in);
        }
        p->in = inSaved;
        p->lineno = savedLineno;
      } else {
        goto _L___56;
      }
    } else {
      goto _L___56;
    }
  } else
  _L___56: /* CIL Label */ 
  if (c == 114) {
    if (n >= 3) {
      tmp___213 = strncmp((char const   *)azArg[0], "restore", (size_t )n);
      if (tmp___213 == 0) {
        nTimeout = 0;
        if (nArg == 2) {
          zSrcFile = (char const   *)azArg[1];
          zDb___0 = "main";
        } else
        if (nArg == 3) {
          zSrcFile = (char const   *)azArg[2];
          zDb___0 = (char const   *)azArg[1];
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .restore ?DB? FILE\n");
          rc = 1;
          goto meta_command_exit;
        }
        rc = sqlite3_open(zSrcFile, & pSrc);
        if (rc != 0) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \"%s\"\n",
                  zSrcFile);
          close_db(pSrc);
          return (1);
        }
        open_db(p, 0);
        pBackup___0 = sqlite3_backup_init(p->db, zDb___0, pSrc, "main");
        if ((unsigned long )pBackup___0 == (unsigned long )((sqlite3_backup *)0)) {
          tmp___94 = sqlite3_errmsg(p->db);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  tmp___94);
          close_db(pSrc);
          return (1);
        }
        while (1) {
          rc = sqlite3_backup_step(pBackup___0, 100);
          if (! (rc == 0)) {
            if (! (rc == 5)) {
              break;
            }
          }
          if (rc == 5) {
            tmp___95 = nTimeout;
            nTimeout ++;
            if (tmp___95 >= 3) {
              break;
            }
            sqlite3_sleep(100);
          }
        }
        sqlite3_backup_finish(pBackup___0);
        if (rc == 101) {
          rc = 0;
        } else
        if (rc == 5) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: source database is busy\n");
          rc = 1;
        } else
        if (rc == 6) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: source database is busy\n");
          rc = 1;
        } else {
          tmp___96 = sqlite3_errmsg(p->db);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  tmp___96);
          rc = 1;
        }
        close_db(pSrc);
      } else {
        goto _L___54;
      }
    } else {
      goto _L___54;
    }
  } else
  _L___54: /* CIL Label */ 
  if (c == 115) {
    tmp___212 = strncmp((char const   *)azArg[0], "scanstats", (size_t )n);
    if (tmp___212 == 0) {
      if (nArg == 2) {
        tmp___97 = booleanValue((char const   *)azArg[1]);
        p->scanstatsOn = (u8 )tmp___97;
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: .scanstats not available in this build.\n");
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .scanstats on|off\n");
        rc = 1;
      }
    } else {
      goto _L___52;
    }
  } else
  _L___52: /* CIL Label */ 
  if (c == 115) {
    tmp___211 = strncmp((char const   *)azArg[0], "schema", (size_t )n);
    if (tmp___211 == 0) {
      zErrMsg___1 = (char *)0;
      zDiv = "(";
      zName = (char const   *)0;
      iSchema = 0;
      bDebug = 0;
      open_db(p, 0);
      memcpy((void * __restrict  )(& data___1), (void const   * __restrict  )p, sizeof(data___1));
      data___1.showHeader = 0;
      data___1.mode = 3;
      data___1.cMode = data___1.mode;
      initText(& sSelect);
      ii___0 = 1;
      while (ii___0 < nArg) {
        tmp___99 = optionMatch((char const   *)azArg[ii___0], "indent");
        if (tmp___99) {
          data___1.mode = 11;
          data___1.cMode = data___1.mode;
        } else {
          tmp___98 = optionMatch((char const   *)azArg[ii___0], "debug");
          if (tmp___98) {
            bDebug = 1;
          } else
          if ((unsigned long )zName == (unsigned long )((char const   *)0)) {
            zName = (char const   *)azArg[ii___0];
          } else {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .schema ?--indent? ?LIKE-PATTERN?\n");
            rc = 1;
            goto meta_command_exit;
          }
        }
        ii___0 ++;
      }
      if ((unsigned long )zName != (unsigned long )((char const   *)0)) {
        tmp___100 = sqlite3_strlike(zName, "sqlite_master", (unsigned int )'\\');
        isMaster = tmp___100 == 0;
        if (isMaster) {
          goto _L___22;
        } else {
          tmp___102 = sqlite3_strlike(zName, "sqlite_temp_master", (unsigned int )'\\');
          if (tmp___102 == 0) {
            _L___22: /* CIL Label */ 
            if (isMaster) {
              tmp___101 = "sqlite_master";
            } else {
              tmp___101 = "sqlite_temp_master";
            }
            new_argv[0] = sqlite3_mprintf("CREATE TABLE %s (\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)",
                                          tmp___101);
            new_argv[1] = (char *)0;
            new_colv[0] = (char *)"sql";
            new_colv[1] = (char *)0;
            callback((void *)(& data___1), 1, new_argv, new_colv);
            sqlite3_free((void *)new_argv[0]);
          }
        }
      }
      if (zDiv) {
        pStmt___4 = (sqlite3_stmt *)0;
        rc = sqlite3_prepare_v2(p->db, "SELECT name FROM pragma_database_list", -1,
                                & pStmt___4, (char const   **)0);
        if (rc) {
          tmp___103 = sqlite3_errmsg(p->db);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  tmp___103);
          sqlite3_finalize(pStmt___4);
          rc = 1;
          goto meta_command_exit;
        }
        appendText(& sSelect, "SELECT sql FROM", (char)0);
        iSchema = 0;
        while (1) {
          tmp___107 = sqlite3_step(pStmt___4);
          if (! (tmp___107 == 100)) {
            break;
          }
          tmp___104 = sqlite3_column_text(pStmt___4, 0);
          zDb___1 = (char const   *)tmp___104;
          iSchema ++;
          sqlite3_snprintf((int )sizeof(zScNum), zScNum, "%d", iSchema);
          appendText(& sSelect, zDiv, (char)0);
          zDiv = " UNION ALL ";
          appendText(& sSelect, "SELECT shell_add_schema(sql,", (char)0);
          tmp___105 = sqlite3_stricmp(zDb___1, "main");
          if (tmp___105 != 0) {
            appendText(& sSelect, zDb___1, (char )'\'');
          } else {
            appendText(& sSelect, "NULL", (char)0);
          }
          appendText(& sSelect, ",name) AS sql, type, tbl_name, name, rowid,", (char)0);
          appendText(& sSelect, (char const   *)(zScNum), (char)0);
          appendText(& sSelect, " AS snum, ", (char)0);
          appendText(& sSelect, zDb___1, (char )'\'');
          appendText(& sSelect, " AS sname FROM ", (char)0);
          tmp___106 = quoteChar(zDb___1);
          appendText(& sSelect, zDb___1, tmp___106);
          appendText(& sSelect, ".sqlite_master", (char)0);
        }
        sqlite3_finalize(pStmt___4);
        if (zName) {
          appendText(& sSelect, " UNION ALL SELECT shell_module_schema(name), \'table\', name, name, name, 9e+99, \'main\' FROM pragma_module_list",
                     (char)0);
        }
        appendText(& sSelect, ") WHERE ", (char)0);
        if (zName) {
          tmp___108 = sqlite3_mprintf("%Q", zName);
          zQarg = tmp___108;
          tmp___109 = strchr(zName, '*');
          if ((unsigned long )tmp___109 != (unsigned long )((char *)0)) {
            tmp___112 = 1;
          } else {
            tmp___110 = strchr(zName, '?');
            if ((unsigned long )tmp___110 != (unsigned long )((char *)0)) {
              tmp___112 = 1;
            } else {
              tmp___111 = strchr(zName, '[');
              if ((unsigned long )tmp___111 != (unsigned long )((char *)0)) {
                tmp___112 = 1;
              } else {
                tmp___112 = 0;
              }
            }
          }
          bGlob = tmp___112;
          tmp___113 = strchr(zName, '.');
          if (tmp___113) {
            appendText(& sSelect, "lower(printf(\'%s.%s\',sname,tbl_name))", (char)0);
          } else {
            appendText(& sSelect, "lower(tbl_name)", (char)0);
          }
          if (bGlob) {
            tmp___114 = " GLOB ";
          } else {
            tmp___114 = " LIKE ";
          }
          appendText(& sSelect, tmp___114, (char)0);
          appendText(& sSelect, (char const   *)zQarg, (char)0);
          if (! bGlob) {
            appendText(& sSelect, " ESCAPE \'\\\' ", (char)0);
          }
          appendText(& sSelect, " AND ", (char)0);
          sqlite3_free((void *)zQarg);
        }
        appendText(& sSelect, "type!=\'meta\' AND sql IS NOT NULL ORDER BY snum, rowid",
                   (char)0);
        if (bDebug) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"SQL: %s;\n",
                  sSelect.z);
        } else {
          rc = sqlite3_exec(p->db, (char const   *)sSelect.z, & callback, (void *)(& data___1),
                            & zErrMsg___1);
        }
        freeText(& sSelect);
      }
      if (zErrMsg___1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                zErrMsg___1);
        sqlite3_free((void *)zErrMsg___1);
        rc = 1;
      } else
      if (rc != 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: querying schema information\n");
        rc = 1;
      } else {
        rc = 0;
      }
    } else {
      goto _L___51;
    }
  } else
  _L___51: /* CIL Label */ 
  if (c == 115) {
    if (n >= 4) {
      tmp___210 = strncmp((char const   *)azArg[0], "selftest", (size_t )n);
      if (tmp___210 == 0) {
        bIsInit = 0;
        bVerbose = 0;
        nTest = 0;
        nErr = 0;
        pStmt___5 = (sqlite3_stmt *)0;
        open_db(p, 0);
        i___6 = 1;
        while (i___6 < nArg) {
          z___5 = (char const   *)azArg[i___6];
          if ((int const   )*(z___5 + 0) == 45) {
            if ((int const   )*(z___5 + 1) == 45) {
              z___5 ++;
            }
          }
          tmp___116 = strcmp(z___5, "-init");
          if (tmp___116 == 0) {
            bIsInit = 1;
          } else {
            tmp___115 = strcmp(z___5, "-v");
            if (tmp___115 == 0) {
              bVerbose ++;
            } else {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown option \"%s\" on \"%s\"\n",
                      azArg[i___6], azArg[0]);
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Should be one of: --init -v\n");
              rc = 1;
              goto meta_command_exit;
            }
          }
          i___6 ++;
        }
        tmp___117 = sqlite3_table_column_metadata(p->db, "main", "selftest", (char const   *)0,
                                                  (char const   **)0, (char const   **)0,
                                                  (int *)0, (int *)0, (int *)0);
        if (tmp___117 != 0) {
          bSelftestExists = 0;
        } else {
          bSelftestExists = 1;
        }
        if (bIsInit) {
          createSelftestTable(p);
          bSelftestExists = 1;
        }
        initText(& str);
        appendText(& str, "x", (char)0);
        k = bSelftestExists;
        while (k >= 0) {
          if (k == 1) {
            rc = sqlite3_prepare_v2(p->db, "SELECT tno,op,cmd,ans FROM selftest ORDER BY tno",
                                    -1, & pStmt___5, (char const   **)0);
          } else {
            rc = sqlite3_prepare_v2(p->db, "VALUES(0,\'memo\',\'Missing SELFTEST table - default checks only\',\'\'),      (1,\'run\',\'PRAGMA integrity_check\',\'ok\')",
                                    -1, & pStmt___5, (char const   **)0);
          }
          if (rc) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error querying the selftest table\n");
            rc = 1;
            sqlite3_finalize(pStmt___5);
            goto meta_command_exit;
          }
          i___6 = 1;
          while (1) {
            tmp___126 = sqlite3_step(pStmt___5);
            if (! (tmp___126 == 100)) {
              break;
            }
            tmp___118 = sqlite3_column_int(pStmt___5, 0);
            tno = tmp___118;
            tmp___119 = sqlite3_column_text(pStmt___5, 1);
            zOp = (char const   *)tmp___119;
            tmp___120 = sqlite3_column_text(pStmt___5, 2);
            zSql___4 = (char const   *)tmp___120;
            tmp___121 = sqlite3_column_text(pStmt___5, 3);
            zAns = (char const   *)tmp___121;
            k = 0;
            if (bVerbose > 0) {
              tmp___122 = sqlite3_mprintf("%q", zSql___4);
              zQuote = tmp___122;
              printf((char const   * __restrict  )"%d: %s %s\n", tno, zOp, zSql___4);
              sqlite3_free((void *)zQuote);
            }
            tmp___125 = strcmp(zOp, "memo");
            if (tmp___125 == 0) {
              fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n",
                      zSql___4);
            } else {
              tmp___124 = strcmp(zOp, "run");
              if (tmp___124 == 0) {
                zErrMsg___2 = (char *)0;
                str.n = 0;
                *(str.z + 0) = (char)0;
                rc = sqlite3_exec(p->db, zSql___4, & captureOutputCallback, (void *)(& str),
                                  & zErrMsg___2);
                nTest ++;
                if (bVerbose) {
                  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Result: %s\n",
                          str.z);
                }
                if (rc) {
                  nErr ++;
                  rc = 1;
                  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d: error-code-%d: %s\n",
                          tno, rc, zErrMsg___2);
                  sqlite3_free((void *)zErrMsg___2);
                } else
                if (zErrMsg___2) {
                  nErr ++;
                  rc = 1;
                  fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d: error-code-%d: %s\n",
                          tno, rc, zErrMsg___2);
                  sqlite3_free((void *)zErrMsg___2);
                } else {
                  tmp___123 = strcmp(zAns, (char const   *)str.z);
                  if (tmp___123 != 0) {
                    nErr ++;
                    rc = 1;
                    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d: Expected: [%s]\n",
                            tno, zAns);
                    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d:      Got: [%s]\n",
                            tno, str.z);
                  }
                }
              } else {
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown operation \"%s\" on selftest line %d\n",
                        zOp, tno);
                rc = 1;
                break;
              }
            }
            i___6 ++;
          }
          sqlite3_finalize(pStmt___5);
          k --;
        }
        freeText(& str);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d errors out of %d tests\n",
                nErr, nTest);
      } else {
        goto _L___50;
      }
    } else {
      goto _L___50;
    }
  } else
  _L___50: /* CIL Label */ 
  if (c == 115) {
    tmp___209 = strncmp((char const   *)azArg[0], "separator", (size_t )n);
    if (tmp___209 == 0) {
      if (nArg < 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .separator COL ?ROW?\n");
        rc = 1;
      } else
      if (nArg > 3) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .separator COL ?ROW?\n");
        rc = 1;
      }
      if (nArg >= 2) {
        sqlite3_snprintf((int )sizeof(p->colSeparator), p->colSeparator, "%.*s", (int )(sizeof(p->colSeparator) / sizeof(p->colSeparator[0])) - 1,
                         azArg[1]);
      }
      if (nArg >= 3) {
        sqlite3_snprintf((int )sizeof(p->rowSeparator), p->rowSeparator, "%.*s", (int )(sizeof(p->rowSeparator) / sizeof(p->rowSeparator[0])) - 1,
                         azArg[2]);
      }
    } else {
      goto _L___48;
    }
  } else
  _L___48: /* CIL Label */ 
  if (c == 115) {
    if (n >= 4) {
      tmp___208 = strncmp((char const   *)azArg[0], "sha3sum", (size_t )n);
      if (tmp___208 == 0) {
        zLike___0 = (char const   *)0;
        bSchema = 0;
        bSeparate = 0;
        iSize = 224;
        bDebug___0 = 0;
        open_db(p, 0);
        i___7 = 1;
        while (i___7 < nArg) {
          z___6 = (char const   *)azArg[i___7];
          if ((int const   )*(z___6 + 0) == 45) {
            z___6 ++;
            if ((int const   )*(z___6 + 0) == 45) {
              z___6 ++;
            }
            tmp___132 = strcmp(z___6, "schema");
            if (tmp___132 == 0) {
              bSchema = 1;
            } else {
              tmp___128 = strcmp(z___6, "sha3-224");
              if (tmp___128 == 0) {
                iSize = atoi(z___6 + 5);
              } else {
                tmp___129 = strcmp(z___6, "sha3-256");
                if (tmp___129 == 0) {
                  iSize = atoi(z___6 + 5);
                } else {
                  tmp___130 = strcmp(z___6, "sha3-384");
                  if (tmp___130 == 0) {
                    iSize = atoi(z___6 + 5);
                  } else {
                    tmp___131 = strcmp(z___6, "sha3-512");
                    if (tmp___131 == 0) {
                      iSize = atoi(z___6 + 5);
                    } else {
                      tmp___127 = strcmp(z___6, "debug");
                      if (tmp___127 == 0) {
                        bDebug___0 = 1;
                      } else {
                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown option \"%s\" on \"%s\"\n",
                                azArg[i___7], azArg[0]);
                        showHelp(p->out, (char const   *)azArg[0]);
                        rc = 1;
                        goto meta_command_exit;
                      }
                    }
                  }
                }
              }
            }
          } else
          if (zLike___0) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n");
            rc = 1;
            goto meta_command_exit;
          } else {
            zLike___0 = z___6;
            bSeparate = 1;
            tmp___133 = sqlite3_strlike("sqlite\\_%", zLike___0, (unsigned int )'\\');
            if (tmp___133 == 0) {
              bSchema = 1;
            }
          }
          i___7 ++;
        }
        if (bSchema) {
          zSql___5 = (char *)"SELECT lower(name) FROM sqlite_master WHERE type=\'table\' AND coalesce(rootpage,0)>1 UNION ALL SELECT \'sqlite_master\' ORDER BY 1 collate nocase";
        } else {
          zSql___5 = (char *)"SELECT lower(name) FROM sqlite_master WHERE type=\'table\' AND coalesce(rootpage,0)>1 AND name NOT LIKE \'sqlite_%\' ORDER BY 1 collate nocase";
        }
        sqlite3_prepare_v2(p->db, (char const   *)zSql___5, -1, & pStmt___6, (char const   **)0);
        initText(& sQuery);
        initText(& sSql);
        appendText(& sSql, "WITH [sha3sum$query](a,b) AS(", (char)0);
        zSep = (char *)"VALUES(";
        while (1) {
          tmp___141 = sqlite3_step(pStmt___6);
          if (! (100 == tmp___141)) {
            break;
          }
          tmp___134 = sqlite3_column_text(pStmt___6, 0);
          zTab = (char const   *)tmp___134;
          if (zLike___0) {
            tmp___135 = sqlite3_strlike(zLike___0, zTab, 0U);
            if (tmp___135 != 0) {
              continue;
            }
          }
          tmp___140 = strncmp(zTab, "sqlite_", (size_t )7);
          if (tmp___140 != 0) {
            appendText(& sQuery, "SELECT * FROM ", (char)0);
            appendText(& sQuery, zTab, (char )'\"');
            appendText(& sQuery, " NOT INDEXED;", (char)0);
          } else {
            tmp___139 = strcmp(zTab, "sqlite_master");
            if (tmp___139 == 0) {
              appendText(& sQuery, "SELECT type,name,tbl_name,sql FROM sqlite_master ORDER BY name;",
                         (char)0);
            } else {
              tmp___138 = strcmp(zTab, "sqlite_sequence");
              if (tmp___138 == 0) {
                appendText(& sQuery, "SELECT name,seq FROM sqlite_sequence ORDER BY name;",
                           (char)0);
              } else {
                tmp___137 = strcmp(zTab, "sqlite_stat1");
                if (tmp___137 == 0) {
                  appendText(& sQuery, "SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;",
                             (char)0);
                } else {
                  tmp___136 = strcmp(zTab, "sqlite_stat4");
                  if (tmp___136 == 0) {
                    appendText(& sQuery, "SELECT * FROM ", (char)0);
                    appendText(& sQuery, zTab, (char)0);
                    appendText(& sQuery, " ORDER BY tbl, idx, rowid;\n", (char)0);
                  }
                }
              }
            }
          }
          appendText(& sSql, (char const   *)zSep, (char)0);
          appendText(& sSql, (char const   *)sQuery.z, (char )'\'');
          sQuery.n = 0;
          appendText(& sSql, ",", (char)0);
          appendText(& sSql, zTab, (char )'\'');
          zSep = (char *)"),(";
        }
        sqlite3_finalize(pStmt___6);
        if (bSeparate) {
          zSql___5 = sqlite3_mprintf("%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]",
                                     sSql.z, iSize);
        } else {
          zSql___5 = sqlite3_mprintf("%s)) SELECT lower(hex(sha3_query(group_concat(a,\'\'),%d))) AS hash   FROM [sha3sum$query]",
                                     sSql.z, iSize);
        }
        freeText(& sQuery);
        freeText(& sSql);
        if (bDebug___0) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n",
                  zSql___5);
        } else {
          shell_exec(p, (char const   *)zSql___5, (char **)0);
        }
        sqlite3_free((void *)zSql___5);
      } else {
        goto _L___47;
      }
    } else {
      goto _L___47;
    }
  } else
  _L___47: /* CIL Label */ 
  if (c == 115) {
    tmp___206 = strncmp((char const   *)azArg[0], "shell", (size_t )n);
    if (tmp___206 == 0) {
      goto _L___45;
    } else {
      tmp___207 = strncmp((char const   *)azArg[0], "system", (size_t )n);
      if (tmp___207 == 0) {
        _L___45: /* CIL Label */ 
        if (nArg < 2) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .system COMMAND\n");
          rc = 1;
          goto meta_command_exit;
        }
        tmp___144 = strchr((char const   *)azArg[1], ' ');
        if ((unsigned long )tmp___144 == (unsigned long )((char *)0)) {
          tmp___143 = "%s";
        } else {
          tmp___143 = "\"%s\"";
        }
        zCmd___0 = sqlite3_mprintf(tmp___143, azArg[1]);
        i___8 = 2;
        while (i___8 < nArg) {
          tmp___147 = strchr((char const   *)azArg[i___8], ' ');
          if ((unsigned long )tmp___147 == (unsigned long )((char *)0)) {
            tmp___146 = "%z %s";
          } else {
            tmp___146 = "%z \"%s\"";
          }
          zCmd___0 = sqlite3_mprintf(tmp___146, zCmd___0, azArg[i___8]);
          i___8 ++;
        }
        x___3 = system((char const   *)zCmd___0);
        sqlite3_free((void *)zCmd___0);
        if (x___3) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"System command returns %d\n",
                  x___3);
        }
      } else {
        goto _L___44;
      }
    }
  } else
  _L___44: /* CIL Label */ 
  if (c == 115) {
    tmp___205 = strncmp((char const   *)azArg[0], "show", (size_t )n);
    if (tmp___205 == 0) {
      if (nArg != 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .show\n");
        rc = 1;
        goto meta_command_exit;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "echo", azBool[(p->shellFlgs & 64U) != 0U]);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "eqp", azBool[(int )p->autoEQP & 3]);
      if (p->mode == 9) {
        tmp___149 = "on";
      } else {
        if (p->autoExplain) {
          tmp___148 = "auto";
        } else {
          tmp___148 = "off";
        }
        tmp___149 = tmp___148;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "explain", tmp___149);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "headers", azBool[p->showHeader != 0]);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "mode", modeDescr[p->mode]);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: ",
              "nullvalue");
      output_c_string(p->out, (char const   *)(p->nullValue));
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
      tmp___152 = strlen30((char const   *)(p->outfile));
      if (tmp___152) {
        tmp___151 = (char const   *)(p->outfile);
      } else {
        tmp___151 = "stdout";
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "output", tmp___151);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: ",
              "colseparator");
      output_c_string(p->out, (char const   *)(p->colSeparator));
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: ",
              "rowseparator");
      output_c_string(p->out, (char const   *)(p->rowSeparator));
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "stats", azBool[(int )p->statsOn != 0]);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: ",
              "width");
      i___9 = 0;
      while (1) {
        if (i___9 < (int )(sizeof(p->colWidth) / sizeof(p->colWidth[0]))) {
          if (! (p->colWidth[i___9] != 0)) {
            break;
          }
        } else {
          break;
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d ", p->colWidth[i___9]);
        i___9 ++;
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
      if (p->zDbFilename) {
        tmp___153 = p->zDbFilename;
      } else {
        tmp___153 = "";
      }
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%12.12s: %s\n",
              "filename", tmp___153);
    } else {
      goto _L___43;
    }
  } else
  _L___43: /* CIL Label */ 
  if (c == 115) {
    tmp___204 = strncmp((char const   *)azArg[0], "stats", (size_t )n);
    if (tmp___204 == 0) {
      if (nArg == 2) {
        tmp___154 = booleanValue((char const   *)azArg[1]);
        p->statsOn = (u8 )tmp___154;
      } else
      if (nArg == 1) {
        display_stats(p->db, p, 0);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .stats ?on|off?\n");
        rc = 1;
      }
    } else {
      goto _L___42;
    }
  } else
  _L___42: /* CIL Label */ 
  if (c == 116) {
    if (n > 1) {
      tmp___201 = strncmp((char const   *)azArg[0], "tables", (size_t )n);
      if (tmp___201 == 0) {
        goto _L___39;
      } else {
        goto _L___41;
      }
    } else {
      goto _L___41;
    }
  } else
  _L___41: /* CIL Label */ 
  if (c == 105) {
    tmp___202 = strncmp((char const   *)azArg[0], "indices", (size_t )n);
    if (tmp___202 == 0) {
      goto _L___39;
    } else {
      tmp___203 = strncmp((char const   *)azArg[0], "indexes", (size_t )n);
      if (tmp___203 == 0) {
        _L___39: /* CIL Label */ 
        initText(& s);
        open_db(p, 0);
        rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, & pStmt___7, (char const   **)0);
        if (rc) {
          sqlite3_finalize(pStmt___7);
          tmp___155 = shellDatabaseError(p->db);
          return (tmp___155);
        }
        if (nArg > 2) {
          if (c == 105) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .indexes ?LIKE-PATTERN?\n");
            rc = 1;
            sqlite3_finalize(pStmt___7);
            goto meta_command_exit;
          }
        }
        ii___1 = 0;
        while (1) {
          tmp___158 = sqlite3_step(pStmt___7);
          if (! (tmp___158 == 100)) {
            break;
          }
          tmp___156 = sqlite3_column_text(pStmt___7, 1);
          zDbName = (char const   *)tmp___156;
          if ((unsigned long )zDbName == (unsigned long )((char const   *)0)) {
            goto __Cont___1;
          }
          if (s.z) {
            if (*(s.z + 0)) {
              appendText(& s, " UNION ALL ", (char)0);
            }
          }
          tmp___157 = sqlite3_stricmp(zDbName, "main");
          if (tmp___157 == 0) {
            appendText(& s, "SELECT name FROM ", (char)0);
          } else {
            appendText(& s, "SELECT ", (char)0);
            appendText(& s, zDbName, (char )'\'');
            appendText(& s, "||\'.\'||name FROM ", (char)0);
          }
          appendText(& s, zDbName, (char )'\"');
          appendText(& s, ".sqlite_master ", (char)0);
          if (c == 116) {
            appendText(& s, " WHERE type IN (\'table\',\'view\')   AND name NOT LIKE \'sqlite_%\'   AND name LIKE ?1",
                       (char)0);
          } else {
            appendText(& s, " WHERE type=\'index\'   AND tbl_name LIKE ?1", (char)0);
          }
          __Cont___1: /* CIL Label */ 
          ii___1 ++;
        }
        rc = sqlite3_finalize(pStmt___7);
        appendText(& s, " ORDER BY 1", (char)0);
        rc = sqlite3_prepare_v2(p->db, (char const   *)s.z, -1, & pStmt___7, (char const   **)0);
        freeText(& s);
        if (rc) {
          tmp___159 = shellDatabaseError(p->db);
          return (tmp___159);
        }
        nAlloc = 0;
        nRow = nAlloc;
        azResult = (char **)0;
        if (nArg > 1) {
          sqlite3_bind_text(pStmt___7, 1, (char const   *)azArg[1], -1, (void (*)(void * ))-1);
        } else {
          sqlite3_bind_text(pStmt___7, 1, "%", -1, (void (*)(void * ))0);
        }
        while (1) {
          tmp___162 = sqlite3_step(pStmt___7);
          if (! (tmp___162 == 100)) {
            break;
          }
          if (nRow >= nAlloc) {
            n2___2 = nAlloc * 2 + 10;
            tmp___160 = sqlite3_realloc64((void *)azResult, (sqlite_uint64 )(sizeof(*(azResult + 0)) * (unsigned long )n2___2));
            azNew = (char **)tmp___160;
            if ((unsigned long )azNew == (unsigned long )((char **)0)) {
              shell_out_of_memory();
            }
            nAlloc = n2___2;
            azResult = azNew;
          }
          tmp___161 = sqlite3_column_text(pStmt___7, 0);
          *(azResult + nRow) = sqlite3_mprintf("%s", tmp___161);
          if ((unsigned long )((char *)0) == (unsigned long )*(azResult + nRow)) {
            shell_out_of_memory();
          }
          nRow ++;
        }
        tmp___163 = sqlite3_finalize(pStmt___7);
        if (tmp___163 != 0) {
          rc = shellDatabaseError(p->db);
        }
        if (rc == 0) {
          if (nRow > 0) {
            maxlen = 0;
            i___10 = 0;
            while (i___10 < nRow) {
              len___0 = strlen30((char const   *)*(azResult + i___10));
              if (len___0 > maxlen) {
                maxlen = len___0;
              }
              i___10 ++;
            }
            nPrintCol = 80 / (maxlen + 2);
            if (nPrintCol < 1) {
              nPrintCol = 1;
            }
            nPrintRow = ((nRow + nPrintCol) - 1) / nPrintCol;
            i___10 = 0;
            while (i___10 < nPrintRow) {
              j___1 = i___10;
              while (j___1 < nRow) {
                if (j___1 < nPrintRow) {
                  tmp___164 = "";
                } else {
                  tmp___164 = "  ";
                }
                zSp = (char *)tmp___164;
                if (*(azResult + j___1)) {
                  tmp___165 = (char const   *)*(azResult + j___1);
                } else {
                  tmp___165 = "";
                }
                fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s%-*s",
                        zSp, maxlen, tmp___165);
                j___1 += nPrintRow;
              }
              fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"\n");
              i___10 ++;
            }
          }
        }
        ii___1 = 0;
        while (ii___1 < nRow) {
          sqlite3_free((void *)*(azResult + ii___1));
          ii___1 ++;
        }
        sqlite3_free((void *)azResult);
      } else {
        goto _L___38;
      }
    }
  } else
  _L___38: /* CIL Label */ 
  if (c == 116) {
    tmp___200 = strcmp((char const   *)azArg[0], "testcase");
    if (tmp___200 == 0) {
      output_reset(p);
      p->out = output_file_open("testcase-out.txt", 0);
      if ((unsigned long )p->out == (unsigned long )((FILE *)0)) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: cannot open \'testcase-out.txt\'\n");
      }
      if (nArg >= 2) {
        sqlite3_snprintf((int )sizeof(p->zTestcase), p->zTestcase, "%s", azArg[1]);
      } else {
        sqlite3_snprintf((int )sizeof(p->zTestcase), p->zTestcase, "?");
      }
    } else {
      goto _L___36;
    }
  } else
  _L___36: /* CIL Label */ 
  if (c == 116) {
    if (n >= 8) {
      tmp___199 = strncmp((char const   *)azArg[0], "testctrl", (size_t )n);
      if (tmp___199 == 0) {
        testctrl = -1;
        iCtrl___0 = -1;
        rc2 = 0;
        isOk___0 = 0;
        zCmd___1 = (char const   *)0;
        open_db(p, 0);
        if (nArg >= 2) {
          zCmd___1 = (char const   *)azArg[1];
        } else {
          zCmd___1 = "help";
        }
        if ((int const   )*(zCmd___1 + 0) == 45) {
          if (*(zCmd___1 + 1)) {
            zCmd___1 ++;
            if ((int const   )*(zCmd___1 + 0) == 45) {
              if (*(zCmd___1 + 1)) {
                zCmd___1 ++;
              }
            }
          }
        }
        tmp___166 = strcmp(zCmd___1, "help");
        if (tmp___166 == 0) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Available test-controls:\n");
          i___11 = 0;
          while (i___11 < (int )(sizeof(aCtrl___0) / sizeof(aCtrl___0[0]))) {
            fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"  .testctrl %s %s\n",
                    aCtrl___0[i___11].zCtrlName, aCtrl___0[i___11].zUsage);
            i___11 ++;
          }
          rc = 1;
          goto meta_command_exit;
        }
        n2___3 = strlen30(zCmd___1);
        i___11 = 0;
        while (i___11 < (int )(sizeof(aCtrl___0) / sizeof(aCtrl___0[0]))) {
          tmp___167 = strncmp(zCmd___1, (char const   *)aCtrl___0[i___11].zCtrlName,
                              (size_t )n2___3);
          if (tmp___167 == 0) {
            if (testctrl < 0) {
              testctrl = (int )aCtrl___0[i___11].ctrlCode;
              iCtrl___0 = i___11;
            } else {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: ambiguous test-control: \"%s\"\nUse \".testctrl --help\" for help\n",
                      zCmd___1);
              rc = 1;
              goto meta_command_exit;
            }
          }
          i___11 ++;
        }
        if (testctrl < 0) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unknown test-control: %s\nUse \".testctrl --help\" for help\n",
                  zCmd___1);
        } else {
          switch (testctrl) {
          case 14: 
          case 15: 
          if (nArg == 3) {
            tmp___168 = strtol((char const   * __restrict  )azArg[2], (char ** __restrict  )0,
                               0);
            opt = (int )tmp___168;
            rc2 = sqlite3_test_control(testctrl, p->db, opt);
            isOk___0 = 3;
          }
          break;
          case 22: 
          case 7: 
          case 6: 
          case 5: 
          if (nArg == 2) {
            rc2 = sqlite3_test_control(testctrl);
            if (testctrl == 22) {
              isOk___0 = 1;
            } else {
              isOk___0 = 3;
            }
          }
          break;
          case 11: 
          if (nArg == 3) {
            tmp___169 = integerValue((char const   *)azArg[2]);
            opt___0 = (unsigned int )tmp___169;
            rc2 = sqlite3_test_control(testctrl, opt___0);
            isOk___0 = 3;
          }
          break;
          case 28: 
          if (nArg == 3) {
            goto _L___23;
          } else
          if (nArg == 4) {
            _L___23: /* CIL Label */ 
            tmp___170 = integerValue((char const   *)azArg[2]);
            ii___2 = (int )tmp___170;
            if (ii___2 == 0) {
              tmp___171 = strcmp((char const   *)azArg[2], "random");
              if (tmp___171 == 0) {
                sqlite3_randomness((int )sizeof(ii___2), (void *)(& ii___2));
                printf((char const   * __restrict  )"-- random seed: %d\n", ii___2);
              }
            }
            if (nArg == 3) {
              db = (sqlite3 *)0;
            } else {
              db = p->db;
              sqlite3_table_column_metadata(db, (char const   *)0, "x", (char const   *)0,
                                            (char const   **)0, (char const   **)0,
                                            (int *)0, (int *)0, (int *)0);
            }
            rc2 = sqlite3_test_control(testctrl, ii___2, db);
            isOk___0 = 3;
          }
          break;
          case 17: 
          case 13: 
          case 12: 
          if (nArg == 3) {
            tmp___172 = booleanValue((char const   *)azArg[2]);
            opt___1 = tmp___172;
            rc2 = sqlite3_test_control(testctrl, opt___1);
            isOk___0 = 1;
          }
          break;
          case 20: 
          case 18: 
          if (nArg == 3) {
            tmp___173 = booleanValue((char const   *)azArg[2]);
            opt___2 = tmp___173;
            rc2 = sqlite3_test_control(testctrl, opt___2);
            isOk___0 = 3;
          }
          break;
          case 25: 
          if (nArg == 5) {
            tmp___174 = integerValue((char const   *)azArg[4]);
            tmp___175 = integerValue((char const   *)azArg[3]);
            rc2 = sqlite3_test_control(testctrl, p->db, azArg[2], tmp___175, tmp___174);
            isOk___0 = 3;
          }
          break;
          }
        }
        if (isOk___0 == 0) {
          if (iCtrl___0 >= 0) {
            fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"Usage: .testctrl %s %s\n",
                    zCmd___1, aCtrl___0[iCtrl___0].zUsage);
            rc = 1;
          } else {
            goto _L___24;
          }
        } else
        _L___24: /* CIL Label */ 
        if (isOk___0 == 1) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%d\n",
                  rc2);
        } else
        if (isOk___0 == 2) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"0x%08x\n",
                  rc2);
        }
      } else {
        goto _L___35;
      }
    } else {
      goto _L___35;
    }
  } else
  _L___35: /* CIL Label */ 
  if (c == 116) {
    if (n > 4) {
      tmp___198 = strncmp((char const   *)azArg[0], "timeout", (size_t )n);
      if (tmp___198 == 0) {
        open_db(p, 0);
        if (nArg >= 2) {
          tmp___176 = integerValue((char const   *)azArg[1]);
          tmp___177 = (int )tmp___176;
        } else {
          tmp___177 = 0;
        }
        sqlite3_busy_timeout(p->db, tmp___177);
      } else {
        goto _L___33;
      }
    } else {
      goto _L___33;
    }
  } else
  _L___33: /* CIL Label */ 
  if (c == 116) {
    if (n >= 5) {
      tmp___197 = strncmp((char const   *)azArg[0], "timer", (size_t )n);
      if (tmp___197 == 0) {
        if (nArg == 2) {
          enableTimer = booleanValue((char const   *)azArg[1]);
          if (enableTimer) {

          }
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: .timer on|off\n");
          rc = 1;
        }
      } else {
        goto _L___31;
      }
    } else {
      goto _L___31;
    }
  } else
  _L___31: /* CIL Label */ 
  if (c == 116) {
    tmp___196 = strncmp((char const   *)azArg[0], "trace", (size_t )n);
    if (tmp___196 == 0) {
      mType = 0;
      open_db(p, 0);
      jj = 1;
      while (jj < nArg) {
        z___7 = (char const   *)azArg[jj];
        if ((int const   )*(z___7 + 0) == 45) {
          tmp___183 = optionMatch(z___7, "expanded");
          if (tmp___183) {
            p->eTraceType = (u8 )1;
          } else {
            tmp___182 = optionMatch(z___7, "plain");
            if (tmp___182) {
              p->eTraceType = (u8 )0;
            } else {
              tmp___181 = optionMatch(z___7, "profile");
              if (tmp___181) {
                mType |= 2;
              } else {
                tmp___180 = optionMatch(z___7, "row");
                if (tmp___180) {
                  mType |= 4;
                } else {
                  tmp___179 = optionMatch(z___7, "stmt");
                  if (tmp___179) {
                    mType |= 1;
                  } else {
                    tmp___178 = optionMatch(z___7, "close");
                    if (tmp___178) {
                      mType |= 8;
                    } else {
                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unknown option \"%s\" on \".trace\"\n",
                              z___7);
                      rc = 1;
                      goto meta_command_exit;
                    }
                  }
                }
              }
            }
          }
        } else {
          output_file_close(p->traceOut);
          p->traceOut = output_file_open((char const   *)azArg[1], 0);
        }
        jj ++;
      }
      if ((unsigned long )p->traceOut == (unsigned long )((FILE *)0)) {
        sqlite3_trace_v2(p->db, 0U, (int (*)(unsigned int  , void * , void * , void * ))0,
                         (void *)0);
      } else {
        if (mType == 0) {
          mType = 1;
        }
        sqlite3_trace_v2(p->db, (unsigned int )mType, & sql_trace_callback, (void *)p);
      }
    } else {
      goto _L___29;
    }
  } else
  _L___29: /* CIL Label */ 
  if (c == 118) {
    tmp___195 = strncmp((char const   *)azArg[0], "version", (size_t )n);
    if (tmp___195 == 0) {
      tmp___184 = sqlite3_sourceid();
      tmp___185 = sqlite3_libversion();
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"SQLite %s %s\n",
              tmp___185, tmp___184);
      fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"gcc-8.3.0\n");
    } else {
      goto _L___28;
    }
  } else
  _L___28: /* CIL Label */ 
  if (c == 118) {
    tmp___194 = strncmp((char const   *)azArg[0], "vfsinfo", (size_t )n);
    if (tmp___194 == 0) {
      if (nArg == 2) {
        tmp___186 = (char const   *)azArg[1];
      } else {
        tmp___186 = "main";
      }
      zDbName___0 = tmp___186;
      pVfs = (sqlite3_vfs *)0;
      if (p->db) {
        sqlite3_file_control(p->db, zDbName___0, 27, (void *)(& pVfs));
        if (pVfs) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.zName      = \"%s\"\n",
                  pVfs->zName);
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.iVersion   = %d\n",
                  pVfs->iVersion);
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.szOsFile   = %d\n",
                  pVfs->szOsFile);
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.mxPathname = %d\n",
                  pVfs->mxPathname);
        }
      }
    } else {
      goto _L___27;
    }
  } else
  _L___27: /* CIL Label */ 
  if (c == 118) {
    tmp___193 = strncmp((char const   *)azArg[0], "vfslist", (size_t )n);
    if (tmp___193 == 0) {
      pCurrent = (sqlite3_vfs *)0;
      if (p->db) {
        sqlite3_file_control(p->db, "main", 27, (void *)(& pCurrent));
      }
      pVfs___0 = sqlite3_vfs_find((char const   *)0);
      while (pVfs___0) {
        if ((unsigned long )pVfs___0 == (unsigned long )pCurrent) {
          tmp___187 = "  <--- CURRENT";
        } else {
          tmp___187 = "";
        }
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.zName      = \"%s\"%s\n",
                pVfs___0->zName, tmp___187);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.iVersion   = %d\n",
                pVfs___0->iVersion);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.szOsFile   = %d\n",
                pVfs___0->szOsFile);
        fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"vfs.mxPathname = %d\n",
                pVfs___0->mxPathname);
        if (pVfs___0->pNext) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"-----------------------------------\n");
        }
        pVfs___0 = pVfs___0->pNext;
      }
    } else {
      goto _L___26;
    }
  } else
  _L___26: /* CIL Label */ 
  if (c == 118) {
    tmp___192 = strncmp((char const   *)azArg[0], "vfsname", (size_t )n);
    if (tmp___192 == 0) {
      if (nArg == 2) {
        tmp___188 = (char const   *)azArg[1];
      } else {
        tmp___188 = "main";
      }
      zDbName___1 = tmp___188;
      zVfsName = (char *)0;
      if (p->db) {
        sqlite3_file_control(p->db, zDbName___1, 12, (void *)(& zVfsName));
        if (zVfsName) {
          fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"%s\n",
                  zVfsName);
          sqlite3_free((void *)zVfsName);
        }
      }
    } else {
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
  if (c == 119) {
    tmp___191 = strncmp((char const   *)azArg[0], "width", (size_t )n);
    if (tmp___191 == 0) {
      if (! (nArg <= (int )(sizeof(azArg) / sizeof(azArg[0])))) {
        __assert_fail("nArg<=ArraySize(azArg)", "shell.c", 18126U, "do_meta_command");
      }
      j___2 = 1;
      while (1) {
        if (j___2 < nArg) {
          if (! (j___2 < (int )(sizeof(p->colWidth) / sizeof(p->colWidth[0])))) {
            break;
          }
        } else {
          break;
        }
        tmp___190 = integerValue((char const   *)azArg[j___2]);
        p->colWidth[j___2 - 1] = (int )tmp___190;
        j___2 ++;
      }
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unknown command or invalid arguments:  \"%s\". Enter \".help\" for help\n",
              azArg[0]);
      rc = 1;
    }
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unknown command or invalid arguments:  \"%s\". Enter \".help\" for help\n",
            azArg[0]);
    rc = 1;
  }
  meta_command_exit: 
  if (p->outCount) {
    (p->outCount) --;
    if (p->outCount == 0) {
      output_reset(p);
    }
  }
  return (rc);
}
}
static int line_contains_semicolon(char const   *z , int N ) 
{ 
  int i ;

  {
  i = 0;
  while (i < N) {
    if ((int const   )*(z + i) == 59) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static int _all_whitespace(char const   *z ) 
{ 
  unsigned short const   **tmp ;

  {
  while (*z) {
    tmp = __ctype_b_loc();
    if ((int const   )*(*tmp + (int )((unsigned char )*(z + 0))) & 8192) {
      goto __Cont;
    }
    if ((int const   )*z == 47) {
      if ((int const   )*(z + 1) == 42) {
        z += 2;
        while (1) {
          if (*z) {
            if (! ((int const   )*z != 42)) {
              if (! ((int const   )*(z + 1) != 47)) {
                break;
              }
            }
          } else {
            break;
          }
          z ++;
        }
        if ((int const   )*z == 0) {
          return (0);
        }
        z ++;
        goto __Cont;
      }
    }
    if ((int const   )*z == 45) {
      if ((int const   )*(z + 1) == 45) {
        z += 2;
        while (1) {
          if (*z) {
            if (! ((int const   )*z != 10)) {
              break;
            }
          } else {
            break;
          }
          z ++;
        }
        if ((int const   )*z == 0) {
          return (1);
        }
        goto __Cont;
      }
    }
    return (0);
    __Cont: /* CIL Label */ 
    z ++;
  }
  return (1);
}
}
static int line_is_command_terminator(char const   *zLine ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(zLine + 0))) & 8192)) {
      break;
    }
    zLine ++;
  }
  if ((int const   )*(zLine + 0) == 47) {
    tmp___0 = _all_whitespace(zLine + 1);
    if (tmp___0) {
      return (1);
    }
  }
  tmp___1 = tolower((int )((unsigned char )*(zLine + 0)));
  if ((int )((char )tmp___1) == 103) {
    tmp___2 = tolower((int )((unsigned char )*(zLine + 1)));
    if ((int )((char )tmp___2) == 111) {
      tmp___3 = _all_whitespace(zLine + 2);
      if (tmp___3) {
        return (1);
      }
    }
  }
  return (0);
}
}
static int line_is_complete(char *zSql , int nSql ) 
{ 
  int rc ;

  {
  if ((unsigned long )zSql == (unsigned long )((char *)0)) {
    return (1);
  }
  *(zSql + nSql) = (char )';';
  *(zSql + (nSql + 1)) = (char)0;
  rc = sqlite3_complete((char const   *)zSql);
  *(zSql + nSql) = (char)0;
  return (rc);
}
}
static int runOneSqlLine(ShellState *p , char *zSql , FILE *in , int startline ) 
{ 
  int rc ;
  char *zErrMsg ;
  char zPrefix[100] ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  zErrMsg = (char *)0;
  open_db(p, 0);
  if ((p->shellFlgs & 4U) != 0U) {
    resolve_backslashes(zSql);
  }
  if (p->flgProgress & 2U) {
    p->nProgress = 0U;
  }
  beginTimer();
  rc = shell_exec(p, (char const   *)zSql, & zErrMsg);
  endTimer();
  if (rc) {
    goto _L;
  } else
  if (zErrMsg) {
    _L: /* CIL Label */ 
    if ((unsigned long )in != (unsigned long )((FILE *)0)) {
      sqlite3_snprintf((int )sizeof(zPrefix), zPrefix, "Error: near line %d:", startline);
    } else
    if (! stdin_is_interactive) {
      sqlite3_snprintf((int )sizeof(zPrefix), zPrefix, "Error: near line %d:", startline);
    } else {
      sqlite3_snprintf((int )sizeof(zPrefix), zPrefix, "Error:");
    }
    if ((unsigned long )zErrMsg != (unsigned long )((char *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s\n",
              zPrefix, zErrMsg);
      sqlite3_free((void *)zErrMsg);
      zErrMsg = (char *)0;
    } else {
      tmp = sqlite3_errmsg(p->db);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s %s\n",
              zPrefix, tmp);
    }
    return (1);
  } else
  if ((p->shellFlgs & 32U) != 0U) {
    tmp___0 = sqlite3_total_changes(p->db);
    tmp___1 = sqlite3_changes(p->db);
    fprintf((FILE * __restrict  )p->out, (char const   * __restrict  )"changes: %3d   total_changes: %d\n",
            tmp___1, tmp___0);
  }
  return (0);
}
}
static int process_input(ShellState *p ) 
{ 
  char *zLine ;
  char *zSql ;
  int nLine ;
  int nSql ;
  int nAlloc ;
  int nSqlPrior ;
  int rc ;
  int errCnt ;
  int startline ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  unsigned short const   **tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  zLine = (char *)0;
  zSql = (char *)0;
  nSql = 0;
  nAlloc = 0;
  nSqlPrior = 0;
  errCnt = 0;
  startline = 0;
  p->lineno = 0;
  while (1) {
    if (! (errCnt == 0)) {
      if (! (! bail_on_error)) {
        if ((unsigned long )p->in == (unsigned long )((FILE *)0)) {
          if (! stdin_is_interactive) {
            break;
          }
        } else {
          break;
        }
      }
    }
    fflush(p->out);
    zLine = one_input_line(p->in, zLine, nSql > 0);
    if ((unsigned long )zLine == (unsigned long )((char *)0)) {
      if ((unsigned long )p->in == (unsigned long )((FILE *)0)) {
        if (stdin_is_interactive) {
          printf((char const   * __restrict  )"\n");
        }
      }
      break;
    }
    if (seenInterrupt) {
      if ((unsigned long )p->in != (unsigned long )((FILE *)0)) {
        break;
      }
      seenInterrupt = (int volatile   )0;
    }
    (p->lineno) ++;
    if (nSql == 0) {
      tmp = _all_whitespace((char const   *)zLine);
      if (tmp) {
        if ((p->shellFlgs & 64U) != 0U) {
          printf((char const   * __restrict  )"%s\n", zLine);
        }
        continue;
      }
    }
    if (zLine) {
      if ((int )*(zLine + 0) == 46) {
        goto _L;
      } else
      if ((int )*(zLine + 0) == 35) {
        _L: /* CIL Label */ 
        if (nSql == 0) {
          if ((p->shellFlgs & 64U) != 0U) {
            printf((char const   * __restrict  )"%s\n", zLine);
          }
          if ((int )*(zLine + 0) == 46) {
            rc = do_meta_command(zLine, p);
            if (rc == 2) {
              break;
            } else
            if (rc) {
              errCnt ++;
            }
          }
          continue;
        }
      }
    }
    tmp___0 = line_is_command_terminator((char const   *)zLine);
    if (tmp___0) {
      tmp___1 = line_is_complete(zSql, nSql);
      if (tmp___1) {
        memcpy((void * __restrict  )zLine, (void const   * __restrict  )";", (size_t )2);
      }
    }
    nLine = strlen30((char const   *)zLine);
    if ((nSql + nLine) + 2 >= nAlloc) {
      nAlloc = (nSql + nLine) + 100;
      tmp___2 = realloc((void *)zSql, (size_t )nAlloc);
      zSql = (char *)tmp___2;
      if ((unsigned long )zSql == (unsigned long )((char *)0)) {
        shell_out_of_memory();
      }
    }
    nSqlPrior = nSql;
    if (nSql == 0) {
      i = 0;
      while (1) {
        if (*(zLine + i)) {
          tmp___3 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*(zLine + i))) & 8192)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      if (nAlloc > 0) {
        if (! ((unsigned long )zSql != (unsigned long )((char *)0))) {
          __assert_fail("nAlloc>0 && zSql!=0", "shell.c", 18321U, "process_input");
        }
      } else {
        __assert_fail("nAlloc>0 && zSql!=0", "shell.c", 18321U, "process_input");
      }
      memcpy((void * __restrict  )zSql, (void const   * __restrict  )(zLine + i),
             (size_t )((nLine + 1) - i));
      startline = p->lineno;
      nSql = nLine - i;
    } else {
      tmp___5 = nSql;
      nSql ++;
      *(zSql + tmp___5) = (char )'\n';
      memcpy((void * __restrict  )(zSql + nSql), (void const   * __restrict  )zLine,
             (size_t )(nLine + 1));
      nSql += nLine;
    }
    if (nSql) {
      tmp___8 = line_contains_semicolon((char const   *)(zSql + nSqlPrior), nSql - nSqlPrior);
      if (tmp___8) {
        tmp___9 = sqlite3_complete((char const   *)zSql);
        if (tmp___9) {
          tmp___6 = runOneSqlLine(p, zSql, p->in, startline);
          errCnt += tmp___6;
          nSql = 0;
          if (p->outCount) {
            output_reset(p);
            p->outCount = 0;
          } else {
            clearTempFile(p);
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (nSql) {
      tmp___7 = _all_whitespace((char const   *)zSql);
      if (tmp___7) {
        if ((p->shellFlgs & 64U) != 0U) {
          printf((char const   * __restrict  )"%s\n", zSql);
        }
        nSql = 0;
      }
    }
  }
  if (nSql) {
    tmp___11 = _all_whitespace((char const   *)zSql);
    if (! tmp___11) {
      tmp___10 = runOneSqlLine(p, zSql, p->in, startline);
      errCnt += tmp___10;
    }
  }
  free((void *)zSql);
  free((void *)zLine);
  return (errCnt > 0);
}
}
static char *find_home_dir(int clearFlag ) ;
static char *home_dir  =    (char *)((void *)0);
static char *find_home_dir(int clearFlag ) 
{ 
  struct passwd *pwent ;
  uid_t uid ;
  __uid_t tmp ;
  int n ;
  int tmp___0 ;
  char *z ;
  void *tmp___1 ;

  {
  if (clearFlag) {
    free((void *)home_dir);
    home_dir = (char *)0;
    return ((char *)0);
  }
  if (home_dir) {
    return (home_dir);
  }
  tmp = getuid();
  uid = tmp;
  pwent = getpwuid(uid);
  if ((unsigned long )pwent != (unsigned long )((void *)0)) {
    home_dir = pwent->pw_dir;
  }
  if (! home_dir) {
    home_dir = getenv("HOME");
  }
  if (home_dir) {
    tmp___0 = strlen30((char const   *)home_dir);
    n = tmp___0 + 1;
    tmp___1 = malloc((size_t )n);
    z = (char *)tmp___1;
    if (z) {
      memcpy((void * __restrict  )z, (void const   * __restrict  )home_dir, (size_t )n);
    }
    home_dir = z;
  }
  return (home_dir);
}
}
static void process_sqliterc(ShellState *p , char const   *sqliterc_override ) 
{ 
  char *home_dir___0 ;
  char const   *sqliterc ;
  char *zBuf ;
  FILE *inSaved ;
  int savedLineno ;

  {
  home_dir___0 = (char *)((void *)0);
  sqliterc = sqliterc_override;
  zBuf = (char *)0;
  inSaved = p->in;
  savedLineno = p->lineno;
  if ((unsigned long )sqliterc == (unsigned long )((void *)0)) {
    home_dir___0 = find_home_dir(0);
    if ((unsigned long )home_dir___0 == (unsigned long )((char *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"-- warning: cannot find home directory; cannot read ~/.sqliterc\n");
      return;
    }
    zBuf = sqlite3_mprintf("%s/.sqliterc", home_dir___0);
    sqliterc = (char const   *)zBuf;
  }
  p->in = fopen((char const   * __restrict  )sqliterc, (char const   * __restrict  )"rb");
  if (p->in) {
    if (stdin_is_interactive) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"-- Loading resources from %s\n",
              sqliterc);
    }
    process_input(p);
    fclose(p->in);
  }
  p->in = inSaved;
  p->lineno = savedLineno;
  sqlite3_free((void *)zBuf);
  return;
}
}
static char const   zOptions[1487]  = 
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'a',      (char const   )'p',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'a',      (char const   )'p',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'a',      (char const   )'b', 
        (char const   )'a',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'a', 
        (char const   )'s',      (char const   )'c',      (char const   )'i',      (char const   )'i', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'\'',      (char const   )'a', 
        (char const   )'s',      (char const   )'c',      (char const   )'i',      (char const   )'i', 
        (char const   )'\'',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'b',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'o',      (char const   )'p',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'h',      (char const   )'i',      (char const   )'t', 
        (char const   )'t',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'b',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'I',      (char const   )'/', 
        (char const   )'O',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'c',      (char const   )'o', 
        (char const   )'l',      (char const   )'u',      (char const   )'m',      (char const   )'n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'p',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'\'',      (char const   )'c',      (char const   )'o', 
        (char const   )'l',      (char const   )'u',      (char const   )'m',      (char const   )'n', 
        (char const   )'\'',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'c',      (char const   )'m', 
        (char const   )'d',      (char const   )' ',      (char const   )'C',      (char const   )'O', 
        (char const   )'M',      (char const   )'M',      (char const   )'A',      (char const   )'N', 
        (char const   )'D',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'r',      (char const   )'u', 
        (char const   )'n',      (char const   )' ',      (char const   )'\"',      (char const   )'C', 
        (char const   )'O',      (char const   )'M',      (char const   )'M',      (char const   )'A', 
        (char const   )'N',      (char const   )'D',      (char const   )'\"',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'a',      (char const   )'d',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'d',      (char const   )'i',      (char const   )'n', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'c',      (char const   )'s',      (char const   )'v', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'\'',      (char const   )'c',      (char const   )'s',      (char const   )'v', 
        (char const   )'\'',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'e',      (char const   )'c', 
        (char const   )'h',      (char const   )'o',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'s', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'e',      (char const   )'c', 
        (char const   )'u',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'i',      (char const   )'n', 
        (char const   )'i',      (char const   )'t',      (char const   )' ',      (char const   )'F', 
        (char const   )'I',      (char const   )'L',      (char const   )'E',      (char const   )'N', 
        (char const   )'A',      (char const   )'M',      (char const   )'E',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'d',      (char const   )'/',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'c',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'n', 
        (char const   )'a',      (char const   )'m',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'[',      (char const   )'n', 
        (char const   )'o',      (char const   )']',      (char const   )'h',      (char const   )'e', 
        (char const   )'a',      (char const   )'d',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'t',      (char const   )'u', 
        (char const   )'r',      (char const   )'n',      (char const   )' ',      (char const   )'h', 
        (char const   )'e',      (char const   )'a',      (char const   )'d',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )'f', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'h',      (char const   )'e',      (char const   )'l', 
        (char const   )'p',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'w',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'m', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'h', 
        (char const   )'t',      (char const   )'m',      (char const   )'l',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'H',      (char const   )'T', 
        (char const   )'M',      (char const   )'L',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'c',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )' ',      (char const   )'I',      (char const   )'/',      (char const   )'O', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'\'',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'\'',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'l', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'\'',      (char const   )'l', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'\'', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'l',      (char const   )'o',      (char const   )'o', 
        (char const   )'k',      (char const   )'a',      (char const   )'s',      (char const   )'i', 
        (char const   )'d',      (char const   )'e',      (char const   )' ',      (char const   )'S', 
        (char const   )'I',      (char const   )'Z',      (char const   )'E',      (char const   )' ', 
        (char const   )'N',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'N',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'S',      (char const   )'Z', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )'t', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'o',      (char const   )'k',      (char const   )'a', 
        (char const   )'s',      (char const   )'i',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'m',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'m',      (char const   )'e',      (char const   )'m',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'m',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'a', 
        (char const   )'l',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )' ', 
        (char const   )'N',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )' ',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )' ', 
        (char const   )'s',      (char const   )'i',      (char const   )'z',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'N',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'n',      (char const   )'e', 
        (char const   )'w',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )' ',      (char const   )'S',      (char const   )'E', 
        (char const   )'P',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'p',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'r',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'.',      (char const   )' ', 
        (char const   )'D',      (char const   )'e',      (char const   )'f',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )':', 
        (char const   )' ',      (char const   )'\'',      (char const   )'\\',      (char const   )'n', 
        (char const   )'\'',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'n',      (char const   )'u', 
        (char const   )'l',      (char const   )'l',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'u',      (char const   )'e',      (char const   )' ', 
        (char const   )'T',      (char const   )'E',      (char const   )'X',      (char const   )'T', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'e', 
        (char const   )'x',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'N',      (char const   )'U', 
        (char const   )'L',      (char const   )'L',      (char const   )' ',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'u',      (char const   )'e', 
        (char const   )'s',      (char const   )'.',      (char const   )' ',      (char const   )'D', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )' ',      (char const   )'\'', 
        (char const   )'\'',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'p',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )'c',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'S',      (char const   )'I',      (char const   )'Z',      (char const   )'E', 
        (char const   )' ',      (char const   )'N',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'N',      (char const   )' ', 
        (char const   )'s',      (char const   )'l',      (char const   )'o',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'S',      (char const   )'Z',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'e',      (char const   )'a', 
        (char const   )'c',      (char const   )'h',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'m',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )'q',      (char const   )'u',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'m',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'\'',      (char const   )'q',      (char const   )'u',      (char const   )'o', 
        (char const   )'t',      (char const   )'e',      (char const   )'\'',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'r',      (char const   )'e',      (char const   )'a',      (char const   )'d', 
        (char const   )'o',      (char const   )'n',      (char const   )'l',      (char const   )'y', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'e',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'a',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'d',      (char const   )'-',      (char const   )'o', 
        (char const   )'n',      (char const   )'l',      (char const   )'y',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'s',      (char const   )'e',      (char const   )'p',      (char const   )'a', 
        (char const   )'r',      (char const   )'a',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'S',      (char const   )'E', 
        (char const   )'P',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'u',      (char const   )'t',      (char const   )'p', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'l',      (char const   )'u',      (char const   )'m', 
        (char const   )'n',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'.', 
        (char const   )' ',      (char const   )'D',      (char const   )'e',      (char const   )'f', 
        (char const   )'a',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )':',      (char const   )' ',      (char const   )'\'',      (char const   )'|', 
        (char const   )'\'',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'s',      (char const   )'t', 
        (char const   )'a',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'m',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'a',      (char const   )'t',      (char const   )'s', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'e',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'n', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'s',      (char const   )'h', 
        (char const   )'o',      (char const   )'w',      (char const   )' ',      (char const   )'S', 
        (char const   )'Q',      (char const   )'L',      (char const   )'i',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'v',      (char const   )'f', 
        (char const   )'s',      (char const   )' ',      (char const   )'N',      (char const   )'A', 
        (char const   )'M',      (char const   )'E',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'N',      (char const   )'A', 
        (char const   )'M',      (char const   )'E',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'f',      (char const   )'a',      (char const   )'u',      (char const   )'l', 
        (char const   )'t',      (char const   )' ',      (char const   )'V',      (char const   )'F', 
        (char const   )'S',      (char const   )'\n',      (char const   )'\000'};
static void usage(int showDetail ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [OPTIONS] FILENAME [SQL]\nFILENAME is the name of an SQLite database. A new database is created\nif the file does not previously exist.\n",
          Argv0);
  if (showDetail) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"OPTIONS include:\n%s",
            zOptions);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Use the -help option for additional information\n");
  }
  exit(1);
}
}
static void verify_uninitialized(void) 
{ 
  int tmp ;

  {
  tmp = sqlite3_config(-1);
  if (tmp == 21) {
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"WARNING: attempt to configure SQLite after initialization.\n");
  }
  return;
}
}
static void main_init(ShellState *data ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  memset((void *)data, 0, sizeof(*data));
  tmp___0 = 2;
  data->mode = tmp___0;
  tmp = tmp___0;
  data->cMode = tmp;
  data->normalMode = tmp;
  data->autoExplain = (u8 )1;
  memcpy((void * __restrict  )(data->colSeparator), (void const   * __restrict  )"|",
         (size_t )2);
  memcpy((void * __restrict  )(data->rowSeparator), (void const   * __restrict  )"\n",
         (size_t )2);
  data->showHeader = 0;
  data->shellFlgs = 2U;
  verify_uninitialized();
  sqlite3_config(17, 1);
  sqlite3_config(16, & shellLog, data);
  sqlite3_config(2);
  sqlite3_snprintf((int )sizeof(mainPrompt), mainPrompt, "sqlite> ");
  sqlite3_snprintf((int )sizeof(continuePrompt), continuePrompt, "   ...> ");
  return;
}
}
static void printBold(char const   *zText___0 ) 
{ 


  {
  printf((char const   * __restrict  )"\033[1m%s\033[0m", zText___0);
  return;
}
}
static char *cmdline_option_value(int argc , char **argv , int i ) 
{ 


  {
  if (i == argc) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: Error: missing argument to %s\n",
            *(argv + 0), *(argv + (argc - 1)));
    exit(1);
  }
  return (*(argv + i));
}
}
int wrapped_main(int argc , char **argv ) 
{ 
  char *zErrMsg ;
  ShellState data ;
  char const   *zInitFile ;
  int i ;
  int rc ;
  int warnInmemoryDb ;
  int readStdin ;
  int nCmd ;
  char **azCmd ;
  char const   *zVfs ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *z ;
  void *tmp___7 ;
  char *tmp___8 ;
  int n ;
  int sz ;
  char *tmp___9 ;
  sqlite_int64 tmp___10 ;
  char *tmp___11 ;
  sqlite_int64 tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int n___0 ;
  int sz___0 ;
  char *tmp___15 ;
  sqlite_int64 tmp___16 ;
  char *tmp___17 ;
  sqlite_int64 tmp___18 ;
  sqlite_int64 sz___1 ;
  char *tmp___19 ;
  sqlite_int64 tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  sqlite3_vfs *pVfs ;
  sqlite3_vfs *tmp___36 ;
  int tmp___37 ;
  char *z___0 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  char *zHome ;
  char *zHistory ;
  int nHistory ;
  char const   *tmp___80 ;
  char const   *tmp___81 ;
  int tmp___82 ;
  void *tmp___83 ;

  {
  zErrMsg = (char *)0;
  zInitFile = (char const   *)0;
  rc = 0;
  warnInmemoryDb = 0;
  readStdin = 1;
  nCmd = 0;
  azCmd = (char **)0;
  zVfs = (char const   *)0;
  setvbuf((FILE * __restrict  )stderr, (char * __restrict  )0, 2, (size_t )0);
  stdin_is_interactive = isatty(0);
  stdout_is_console = isatty(1);
  tmp___2 = getenv("SQLITE_DEBUG_BREAK");
  if (tmp___2) {
    tmp___0 = isatty(0);
    if (tmp___0) {
      tmp___1 = isatty(2);
      if (tmp___1) {
        tmp = getpid();
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"attach debugger to process %d and press any key to continue.\n",
                tmp);
        fgetc(stdin);
      } else {
        raise(5);
      }
    } else {
      raise(5);
    }
  }
  tmp___4 = sqlite3_sourceid();
  tmp___5 = strncmp(tmp___4, "2019-10-04 15:03:17 c20a35336432025445f9f7e289d0cc3e4003fb17f45a4ce74c6269c407c6e09f",
                    (size_t )60);
  if (tmp___5 != 0) {
    tmp___3 = sqlite3_sourceid();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SQLite header and source version mismatch\n%s\n%s\n",
            tmp___3, "2019-10-04 15:03:17 c20a35336432025445f9f7e289d0cc3e4003fb17f45a4ce74c6269c407c6e09f");
    exit(1);
  }
  main_init(& data);
  if (argc >= 1) {
    if (argv) {
      if (! *(argv + 0)) {
        __assert_fail("argc>=1 && argv && argv[0]", "shell.c", 18679U, "wrapped_main");
      }
    } else {
      __assert_fail("argc>=1 && argv && argv[0]", "shell.c", 18679U, "wrapped_main");
    }
  } else {
    __assert_fail("argc>=1 && argv && argv[0]", "shell.c", 18679U, "wrapped_main");
  }
  Argv0 = *(argv + 0);
  signal(2, & interrupt_handler);
  verify_uninitialized();
  i = 1;
  while (i < argc) {
    z = *(argv + i);
    if ((int )*(z + 0) != 45) {
      if ((unsigned long )data.zDbFilename == (unsigned long )((char const   *)0)) {
        data.zDbFilename = (char const   *)z;
      } else {
        readStdin = 0;
        nCmd ++;
        tmp___7 = realloc((void *)azCmd, sizeof(*(azCmd + 0)) * (unsigned long )nCmd);
        azCmd = (char **)tmp___7;
        if ((unsigned long )azCmd == (unsigned long )((char **)0)) {
          shell_out_of_memory();
        }
        *(azCmd + (nCmd - 1)) = z;
      }
    }
    if ((int )*(z + 1) == 45) {
      z ++;
    }
    tmp___32 = strcmp((char const   *)z, "-separator");
    if (tmp___32 == 0) {
      i ++;
      cmdline_option_value(argc, argv, i);
    } else {
      tmp___33 = strcmp((char const   *)z, "-nullvalue");
      if (tmp___33 == 0) {
        i ++;
        cmdline_option_value(argc, argv, i);
      } else {
        tmp___34 = strcmp((char const   *)z, "-newline");
        if (tmp___34 == 0) {
          i ++;
          cmdline_option_value(argc, argv, i);
        } else {
          tmp___35 = strcmp((char const   *)z, "-cmd");
          if (tmp___35 == 0) {
            i ++;
            cmdline_option_value(argc, argv, i);
          } else {
            tmp___31 = strcmp((char const   *)z, "-init");
            if (tmp___31 == 0) {
              i ++;
              tmp___8 = cmdline_option_value(argc, argv, i);
              zInitFile = (char const   *)tmp___8;
            } else {
              tmp___30 = strcmp((char const   *)z, "-batch");
              if (tmp___30 == 0) {
                stdin_is_interactive = 0;
              } else {
                tmp___29 = strcmp((char const   *)z, "-heap");
                if (tmp___29 == 0) {
                  i ++;
                  cmdline_option_value(argc, argv, i);
                } else {
                  tmp___28 = strcmp((char const   *)z, "-pagecache");
                  if (tmp___28 == 0) {
                    i ++;
                    tmp___9 = cmdline_option_value(argc, argv, i);
                    tmp___10 = integerValue((char const   *)tmp___9);
                    sz = (int )tmp___10;
                    if (sz > 70000) {
                      sz = 70000;
                    }
                    if (sz < 0) {
                      sz = 0;
                    }
                    i ++;
                    tmp___11 = cmdline_option_value(argc, argv, i);
                    tmp___12 = integerValue((char const   *)tmp___11);
                    n = (int )tmp___12;
                    if (n > 0) {
                      if (sz > 0) {
                        tmp___13 = malloc((size_t )(n * sz));
                        tmp___14 = tmp___13;
                      } else {
                        tmp___14 = (void *)0;
                      }
                    } else {
                      tmp___14 = (void *)0;
                    }
                    sqlite3_config(7, tmp___14, sz, n);
                    data.shellFlgs |= 1U;
                  } else {
                    tmp___27 = strcmp((char const   *)z, "-lookaside");
                    if (tmp___27 == 0) {
                      i ++;
                      tmp___15 = cmdline_option_value(argc, argv, i);
                      tmp___16 = integerValue((char const   *)tmp___15);
                      sz___0 = (int )tmp___16;
                      if (sz___0 < 0) {
                        sz___0 = 0;
                      }
                      i ++;
                      tmp___17 = cmdline_option_value(argc, argv, i);
                      tmp___18 = integerValue((char const   *)tmp___17);
                      n___0 = (int )tmp___18;
                      if (n___0 < 0) {
                        n___0 = 0;
                      }
                      sqlite3_config(13, sz___0, n___0);
                      if (sz___0 * n___0 == 0) {
                        data.shellFlgs &= 4294967293U;
                      }
                    } else {
                      tmp___26 = strcmp((char const   *)z, "-mmap");
                      if (tmp___26 == 0) {
                        i ++;
                        tmp___19 = cmdline_option_value(argc, argv, i);
                        tmp___20 = integerValue((char const   *)tmp___19);
                        sz___1 = tmp___20;
                        sqlite3_config(22, sz___1, sz___1);
                      } else {
                        tmp___25 = strcmp((char const   *)z, "-vfs");
                        if (tmp___25 == 0) {
                          i ++;
                          tmp___21 = cmdline_option_value(argc, argv, i);
                          zVfs = (char const   *)tmp___21;
                        } else {
                          tmp___24 = strcmp((char const   *)z, "-append");
                          if (tmp___24 == 0) {
                            data.openMode = (u8 )2;
                          } else {
                            tmp___23 = strcmp((char const   *)z, "-readonly");
                            if (tmp___23 == 0) {
                              data.openMode = (u8 )4;
                            } else {
                              tmp___22 = strcmp((char const   *)z, "-memtrace");
                              if (tmp___22 == 0) {
                                sqlite3MemTraceActivate(stderr);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    i ++;
  }
  verify_uninitialized();
  sqlite3_initialize();
  if (zVfs) {
    tmp___36 = sqlite3_vfs_find(zVfs);
    pVfs = tmp___36;
    if (pVfs) {
      sqlite3_vfs_register(pVfs, 1);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"no such VFS: \"%s\"\n",
              *(argv + i));
      exit(1);
    }
  }
  if ((unsigned long )data.zDbFilename == (unsigned long )((char const   *)0)) {
    data.zDbFilename = ":memory:";
    warnInmemoryDb = argc == 1;
  }
  data.out = stdout;
  sqlite3_appendvfs_init((sqlite3 *)0, (char **)0, (sqlite3_api_routines const   *)0);
  tmp___37 = access(data.zDbFilename, 0);
  if (tmp___37 == 0) {
    open_db(& data, 0);
  }
  process_sqliterc(& data, zInitFile);
  i = 1;
  while (i < argc) {
    z___0 = *(argv + i);
    if ((int )*(z___0 + 0) != 45) {
      goto __Cont;
    }
    if ((int )*(z___0 + 1) == 45) {
      z___0 ++;
    }
    tmp___77 = strcmp((char const   *)z___0, "-init");
    if (tmp___77 == 0) {
      i ++;
    } else {
      tmp___76 = strcmp((char const   *)z___0, "-html");
      if (tmp___76 == 0) {
        data.mode = 4;
      } else {
        tmp___75 = strcmp((char const   *)z___0, "-list");
        if (tmp___75 == 0) {
          data.mode = 2;
        } else {
          tmp___74 = strcmp((char const   *)z___0, "-quote");
          if (tmp___74 == 0) {
            data.mode = 6;
          } else {
            tmp___73 = strcmp((char const   *)z___0, "-line");
            if (tmp___73 == 0) {
              data.mode = 0;
            } else {
              tmp___72 = strcmp((char const   *)z___0, "-column");
              if (tmp___72 == 0) {
                data.mode = 1;
              } else {
                tmp___71 = strcmp((char const   *)z___0, "-csv");
                if (tmp___71 == 0) {
                  data.mode = 8;
                  memcpy((void * __restrict  )(data.colSeparator), (void const   * __restrict  )",",
                         (size_t )2);
                } else {
                  tmp___70 = strcmp((char const   *)z___0, "-append");
                  if (tmp___70 == 0) {
                    data.openMode = (u8 )2;
                  } else {
                    tmp___69 = strcmp((char const   *)z___0, "-readonly");
                    if (tmp___69 == 0) {
                      data.openMode = (u8 )4;
                    } else {
                      tmp___68 = strcmp((char const   *)z___0, "-ascii");
                      if (tmp___68 == 0) {
                        data.mode = 10;
                        sqlite3_snprintf((int )sizeof(data.colSeparator), data.colSeparator,
                                         "\037");
                        sqlite3_snprintf((int )sizeof(data.rowSeparator), data.rowSeparator,
                                         "\036");
                      } else {
                        tmp___67 = strcmp((char const   *)z___0, "-separator");
                        if (tmp___67 == 0) {
                          i ++;
                          tmp___38 = cmdline_option_value(argc, argv, i);
                          sqlite3_snprintf((int )sizeof(data.colSeparator), data.colSeparator,
                                           "%s", tmp___38);
                        } else {
                          tmp___66 = strcmp((char const   *)z___0, "-newline");
                          if (tmp___66 == 0) {
                            i ++;
                            tmp___39 = cmdline_option_value(argc, argv, i);
                            sqlite3_snprintf((int )sizeof(data.rowSeparator), data.rowSeparator,
                                             "%s", tmp___39);
                          } else {
                            tmp___65 = strcmp((char const   *)z___0, "-nullvalue");
                            if (tmp___65 == 0) {
                              i ++;
                              tmp___40 = cmdline_option_value(argc, argv, i);
                              sqlite3_snprintf((int )sizeof(data.nullValue), data.nullValue,
                                               "%s", tmp___40);
                            } else {
                              tmp___64 = strcmp((char const   *)z___0, "-header");
                              if (tmp___64 == 0) {
                                data.showHeader = 1;
                              } else {
                                tmp___63 = strcmp((char const   *)z___0, "-noheader");
                                if (tmp___63 == 0) {
                                  data.showHeader = 0;
                                } else {
                                  tmp___62 = strcmp((char const   *)z___0, "-echo");
                                  if (tmp___62 == 0) {
                                    data.shellFlgs |= 64U;
                                  } else {
                                    tmp___61 = strcmp((char const   *)z___0, "-eqp");
                                    if (tmp___61 == 0) {
                                      data.autoEQP = (u8 )1;
                                    } else {
                                      tmp___60 = strcmp((char const   *)z___0, "-eqpfull");
                                      if (tmp___60 == 0) {
                                        data.autoEQP = (u8 )3;
                                      } else {
                                        tmp___59 = strcmp((char const   *)z___0, "-stats");
                                        if (tmp___59 == 0) {
                                          data.statsOn = (u8 )1;
                                        } else {
                                          tmp___58 = strcmp((char const   *)z___0,
                                                            "-scanstats");
                                          if (tmp___58 == 0) {
                                            data.scanstatsOn = (u8 )1;
                                          } else {
                                            tmp___57 = strcmp((char const   *)z___0,
                                                              "-backslash");
                                            if (tmp___57 == 0) {
                                              data.shellFlgs |= 4U;
                                            } else {
                                              tmp___56 = strcmp((char const   *)z___0,
                                                                "-bail");
                                              if (tmp___56 == 0) {
                                                bail_on_error = 1;
                                              } else {
                                                tmp___55 = strcmp((char const   *)z___0,
                                                                  "-version");
                                                if (tmp___55 == 0) {
                                                  tmp___41 = sqlite3_sourceid();
                                                  tmp___42 = sqlite3_libversion();
                                                  printf((char const   * __restrict  )"%s %s\n",
                                                         tmp___42, tmp___41);
                                                  return (0);
                                                } else {
                                                  tmp___54 = strcmp((char const   *)z___0,
                                                                    "-interactive");
                                                  if (tmp___54 == 0) {
                                                    stdin_is_interactive = 1;
                                                  } else {
                                                    tmp___53 = strcmp((char const   *)z___0,
                                                                      "-batch");
                                                    if (tmp___53 == 0) {
                                                      stdin_is_interactive = 0;
                                                    } else {
                                                      tmp___52 = strcmp((char const   *)z___0,
                                                                        "-heap");
                                                      if (tmp___52 == 0) {
                                                        i ++;
                                                      } else {
                                                        tmp___51 = strcmp((char const   *)z___0,
                                                                          "-pagecache");
                                                        if (tmp___51 == 0) {
                                                          i += 2;
                                                        } else {
                                                          tmp___50 = strcmp((char const   *)z___0,
                                                                            "-lookaside");
                                                          if (tmp___50 == 0) {
                                                            i += 2;
                                                          } else {
                                                            tmp___49 = strcmp((char const   *)z___0,
                                                                              "-mmap");
                                                            if (tmp___49 == 0) {
                                                              i ++;
                                                            } else {
                                                              tmp___48 = strcmp((char const   *)z___0,
                                                                                "-memtrace");
                                                              if (tmp___48 == 0) {
                                                                i ++;
                                                              } else {
                                                                tmp___47 = strcmp((char const   *)z___0,
                                                                                  "-vfs");
                                                                if (tmp___47 == 0) {
                                                                  i ++;
                                                                } else {
                                                                  tmp___46 = strcmp((char const   *)z___0,
                                                                                    "-help");
                                                                  if (tmp___46 == 0) {
                                                                    usage(1);
                                                                  } else {
                                                                    tmp___45 = strcmp((char const   *)z___0,
                                                                                      "-cmd");
                                                                    if (tmp___45 == 0) {
                                                                      if (i == argc - 1) {
                                                                        break;
                                                                      }
                                                                      i ++;
                                                                      z___0 = cmdline_option_value(argc,
                                                                                                   argv,
                                                                                                   i);
                                                                      if ((int )*(z___0 + 0) == 46) {
                                                                        rc = do_meta_command(z___0,
                                                                                             & data);
                                                                        if (rc) {
                                                                          if (bail_on_error) {
                                                                            if (rc == 2) {
                                                                              tmp___43 = 0;
                                                                            } else {
                                                                              tmp___43 = rc;
                                                                            }
                                                                            return (tmp___43);
                                                                          }
                                                                        }
                                                                      } else {
                                                                        open_db(& data,
                                                                                0);
                                                                        rc = shell_exec(& data,
                                                                                        (char const   *)z___0,
                                                                                        & zErrMsg);
                                                                        if ((unsigned long )zErrMsg != (unsigned long )((char *)0)) {
                                                                          fprintf((FILE * __restrict  )stderr,
                                                                                  (char const   * __restrict  )"Error: %s\n",
                                                                                  zErrMsg);
                                                                          if (bail_on_error) {
                                                                            if (rc != 0) {
                                                                              tmp___44 = rc;
                                                                            } else {
                                                                              tmp___44 = 1;
                                                                            }
                                                                            return (tmp___44);
                                                                          }
                                                                        } else
                                                                        if (rc != 0) {
                                                                          fprintf((FILE * __restrict  )stderr,
                                                                                  (char const   * __restrict  )"Error: unable to process SQL \"%s\"\n",
                                                                                  z___0);
                                                                          if (bail_on_error) {
                                                                            return (rc);
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      fprintf((FILE * __restrict  )stderr,
                                                                              (char const   * __restrict  )"%s: Error: unknown option: %s\n",
                                                                              Argv0,
                                                                              z___0);
                                                                      fprintf((FILE * __restrict  )stderr,
                                                                              (char const   * __restrict  )"Use -help for a list of options.\n");
                                                                      return (1);
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    data.cMode = data.mode;
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! readStdin) {
    i = 0;
    while (i < nCmd) {
      if ((int )*(*(azCmd + i) + 0) == 46) {
        rc = do_meta_command(*(azCmd + i), & data);
        if (rc) {
          if (rc == 2) {
            tmp___78 = 0;
          } else {
            tmp___78 = rc;
          }
          return (tmp___78);
        }
      } else {
        open_db(& data, 0);
        rc = shell_exec(& data, (char const   *)*(azCmd + i), & zErrMsg);
        if ((unsigned long )zErrMsg != (unsigned long )((char *)0)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: %s\n",
                  zErrMsg);
          if (rc != 0) {
            tmp___79 = rc;
          } else {
            tmp___79 = 1;
          }
          return (tmp___79);
        } else
        if (rc != 0) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: unable to process SQL: %s\n",
                  *(azCmd + i));
          return (rc);
        }
      }
      i ++;
    }
    free((void *)azCmd);
  } else
  if (stdin_is_interactive) {
    tmp___80 = sqlite3_sourceid();
    tmp___81 = sqlite3_libversion();
    printf((char const   * __restrict  )"SQLite version %s %.19s\nEnter \".help\" for usage hints.\n",
           tmp___81, tmp___80);
    if (warnInmemoryDb) {
      printf((char const   * __restrict  )"Connected to a ");
      printBold("transient in-memory database");
      printf((char const   * __restrict  )".\nUse \".open FILENAME\" to reopen on a persistent database.\n");
    }
    zHistory = getenv("SQLITE_HISTORY");
    if (zHistory) {
      zHistory = strdup((char const   *)zHistory);
    } else {
      zHome = find_home_dir(0);
      if ((unsigned long )zHome != (unsigned long )((char *)0)) {
        tmp___82 = strlen30((char const   *)zHome);
        nHistory = tmp___82 + 20;
        tmp___83 = malloc((size_t )nHistory);
        zHistory = (char *)tmp___83;
        if ((unsigned long )zHistory != (unsigned long )((char *)0)) {
          sqlite3_snprintf(nHistory, zHistory, "%s/.sqlite_history", zHome);
        }
      }
    }
    data.in = (FILE *)0;
    rc = process_input(& data);
    if (zHistory) {
      free((void *)zHistory);
    }
  } else {
    data.in = stdin;
    rc = process_input(& data);
  }
  set_table_name(& data, (char const   *)0);
  if (data.db) {
    close_db(data.db);
  }
  sqlite3_free((void *)data.zFreeOnClose);
  find_home_dir(1);
  output_reset(& data);
  data.doXdgOpen = (u8 )0;
  clearTempFile(& data);
  memset((void *)(& data), 0, sizeof(data));
  return (rc);
}
}
extern void abort(void);
void assume_abort_if_not(int cond) {
  if(!cond) {abort();}
}
extern char __VERIFIER_nondet_char(void) ;
extern int __VERIFIER_nondet_int(void) ;
int main(int argc , char **argv ) 
{ 
  int wrapped_argc ;
  int tmp ;
  int tmp___0 ;
  char **wrapped_argv ;
  void *tmp___1 ;
  int i ;
  void *tmp___2 ;
  int j ;
  int wrapped_rc ;
  int tmp___3 ;
  int i___0 ;

  {
  tmp = __VERIFIER_nondet_int();
  wrapped_argc = tmp;
  if (wrapped_argc >= 1) {
    if (wrapped_argc <= 20) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  assume_abort_if_not(tmp___0);
  tmp___1 = malloc(sizeof(*argv) * (unsigned long )wrapped_argc);
  wrapped_argv = (char **)tmp___1;
  i = 0;
  while (i < wrapped_argc) {
    tmp___2 = malloc(sizeof(*(*argv)) * 50UL);
    *(wrapped_argv + i) = (char *)tmp___2;
    j = 0;
    while (j < 50) {
      *(*(wrapped_argv + i) + j) = __VERIFIER_nondet_char();
      j ++;
    }
    i ++;
  }
  tmp___3 = wrapped_main(wrapped_argc, wrapped_argv);
  wrapped_rc = tmp___3;
  i___0 = 0;
  while (i___0 < wrapped_argc) {
    free((void *)*(wrapped_argv + i___0));
    i___0 ++;
  }
  free((void *)wrapped_argv);
  return (wrapped_rc);
}
}
